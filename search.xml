<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>框架原理</title>
      <link href="2020/10/15/hexo/%E6%A1%86%E6%9E%B6%E5%8E%9F%E7%90%86/"/>
      <url>2020/10/15/hexo/%E6%A1%86%E6%9E%B6%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h3 id="1-Okhttp"><a href="#1-Okhttp" class="headerlink" title="1.Okhttp"></a>1.Okhttp</h3><h4 id="一、特点"><a href="#一、特点" class="headerlink" title="一、特点"></a>一、特点</h4><p>支持HTTP2.0。</p><p>无缝支持GZIP来减少数据流量。</p><p>发送的数据和接受的收据在传递过程中都是经过gzip压缩的。</p><p>socket自动选择最好路线，并支持自动重连</p><p>缓存响应数据来减少重复的网络请求</p><h4 id="二、Okhttp的核心类有哪些？简单讲一下"><a href="#二、Okhttp的核心类有哪些？简单讲一下" class="headerlink" title="二、Okhttp的核心类有哪些？简单讲一下"></a>二、Okhttp的核心类有哪些？简单讲一下</h4><p>Dispatcher类：</p><p>Dispatcher 通过维护一个线程池，来维护、管理、执行OKHttp的请求。<br>Dispatcher 内部维护着三个队列：同步请求队列 runningSyncCalls、异步请求队列 runningAsyncCalls、异步缓存队列 readyAsyncCalls，和一个线程池 executorService。<br>Dispatcher类整体可以参照生产者消费者模式来理解：<br>Dispatcher是生产者，executorService是消费者池，runningSyncCalls、runningAsyncCalls和readyAsyncCalls是消费者，用来消费请求Call。</p><p>Interceptor类：</p><p>官网：拦截器是Okhttp中提供的一种强大机制，它可以实现网络监听、请求、以及响应重写、请求失败重试等功能。<br>RetryAndFollowUpInterceptor、BridgeIntercept、CacheIntercept、ConnectIntercept、CallServerIntercept</p><ul><li>RetryAndFollowUpInterceptor：重试和失败重定向拦截器 </li><li>BridgeInterceptor：桥接拦截器，处理一些必须的请求头信息的拦截器 </li><li>CacheInterceptor：缓存拦截器，用于处理缓存 </li><li>ConnectInterceptor：连接拦截器，建立可用的连接，是CallServerInterceptor的基本 </li><li>CallServerInterceptor：请求服务器拦截器将 http 请求写进 IO 流当中，并且从 IO 流中读取响应 Response</li></ul><h4 id="三-、-原理、设计模式："><a href="#三-、-原理、设计模式：" class="headerlink" title="三 、 原理、设计模式："></a>三 、 原理、设计模式：</h4><p>Builder、责任链</p><ul><li>（1）、当我们通过OkhttpClient创建一个Call，并发起同步或异步请求时；</li><li>（2）、okhttp会通过Dispatcher对我们所有的RealCall（Call的具体实现类）进行统一管理，并通过execute()及enqueue()方法对同步或异步请求进行处理；</li><li>（3）、execute()及enqueue()这两个方法会最终调用RealCall中的getResponseWithInterceptorChain()方法，从拦截器链中获取返回结果；</li><li>（4）、拦截器链中，依次通过RetryAndFollowUpInterceptor（重定向拦截器）、BridgeInterceptor（桥接拦截器）、CacheInterceptor（缓存拦截器）、ConnectInterceptor（连接拦截器）、CallServerInterceptor（网络拦截器）对请求依次处理，与服务的建立连接后，获取返回数据，再经过上述拦截器依次处理后，最后将结果返回给调用方。</li></ul><h3 id="2-Glide"><a href="#2-Glide" class="headerlink" title="2.Glide"></a>2.Glide</h3><h4 id="Q1：看过Glide源码吗，你印象最深的是什么？"><a href="#Q1：看过Glide源码吗，你印象最深的是什么？" class="headerlink" title="Q1：看过Glide源码吗，你印象最深的是什么？"></a>Q1：看过Glide源码吗，你印象最深的是什么？</h4><p>Glide缓存简介<br>Glide的缓存设计可以说是非常先进的，考虑的场景也很周全。在缓存这一功能上，Glide又将它分成了两个模块，一个是内存缓存，一个是硬盘缓存。</p><p>这两个缓存模块的作用各不相同，内存缓存的主要作用是防止应用重复将图片数据读取到内存当中，而硬盘缓存的主要作用是防止应用重复从网络或其他地方重复下载和读取数据。</p><p>内存缓存和硬盘缓存的相互结合才构成了Glide极佳的图片缓存效果，那么接下来我们就分别来分析一下这两种缓存的使用方法以及它们的实现原理。</p><h4 id="Q2：简单说一下Glide的三级缓存？"><a href="#Q2：简单说一下Glide的三级缓存？" class="headerlink" title="Q2：简单说一下Glide的三级缓存？"></a>Q2：简单说一下Glide的三级缓存？</h4><p>当我们的APP中想要加载某张图片时，先去LruCache中寻找图片，如果LruCache中有，则直接取出来使用，如果LruCache中没有，则去WeakReference中寻找，如果WeakReference中有，则从WeakReference中取出图片使用，同时将图片重新放回到LruCache中，如果WeakReference中也没有图片，则去文件系统中寻找，如果有则取出来使用，同时将图片添加到LruCache中，如果没有，则连接网络从网上下载图片。图片下载完成后，将图片保存到文件系统中，然后放到LruCache中。</p><h4 id="Q3：Glide加载一个一兆的图片（100100），是否会压缩后再加载，放到一个200200的view上会怎样，1000-1000呢，图片会很模糊，怎么处理？"><a href="#Q3：Glide加载一个一兆的图片（100100），是否会压缩后再加载，放到一个200200的view上会怎样，1000-1000呢，图片会很模糊，怎么处理？" class="headerlink" title="Q3：Glide加载一个一兆的图片（100100），是否会压缩后再加载，放到一个200200的view上会怎样，1000*1000呢，图片会很模糊，怎么处理？"></a>Q3：Glide加载一个一兆的图片（100<em>100），是否会压缩后再加载，放到一个200</em>200的view上会怎样，1000*1000呢，图片会很模糊，怎么处理？</h4><p>而使用Glide，我们就完全不用担心图片内存浪费，甚至是内存溢出的问题。因为Glide从来都不会直接将图片的完整尺寸全部加载到内存中，而是用多少加载多少。Glide会自动判断ImageView的大小，然后只将这么大的图片像素加载到内存当中，帮助我们节省内存开支。</p><p>ImageView默认的scaleType是FIT_CENTER</p><p>FitCenter的效果：会将图片按照原始的长宽比充满全屏</p><p>那么，Glide将图片压缩到什么程度呢？.</p><p><a href="https://blog.csdn.net/u011200604/article/details/53021685" target="_blank" rel="noopener">关于图片加载神器–Glide与Picasso的使用与比较</a></p><p><a href="https://inthecheesefactory.com/blog/get-to-know-glide-recommended-by-google/en" target="_blank" rel="noopener">https://inthecheesefactory.com/blog/get-to-know-glide-recommended-by-google/en</a></p><p>在默认情况下Picasso和Glide的外部缓存机制是非常不一样的，通过实验可以发现（1920x1080 像素的图片被加载到768x432像素的imageview中），Glide缓存的是768x432像素的图片，而Picasso缓存的是整张图片（1920x1080像素）。</p><p>当我们调整imageview的大小时，Picasso会不管imageview大小是什么，总是直接缓存整张图片，而Glide就不一样了，它会为每个不同尺寸的Imageview缓存一张图片，也就是说不管你的这张图片有没有加载过，只要imageview的尺寸不一样，那么Glide就会重新加载一次，这时候，它会在加载的imageview之前从网络上重新下载，然后再缓存。</p><p>防止各位不明白，再来举个例子，如果一个页面的imageview是200<em>200像素，而另一个页面中的imageview是100</em>100像素，这时候想要让两个imageview像是同一张图片，那么Glide需要下载两次图片，并且缓存两张图片。</p><h4 id="Q4：Glide-缓存原理，如何设计一个大图加载框架。"><a href="#Q4：Glide-缓存原理，如何设计一个大图加载框架。" class="headerlink" title="Q4：Glide 缓存原理，如何设计一个大图加载框架。"></a>Q4：Glide 缓存原理，如何设计一个大图加载框架。</h4><p><a href="https://www.jianshu.com/p/3df395d8a6bc" target="_blank" rel="noopener">如何实现一个图片加载框架</a></p><p>概括来说，图片加载包含封装，解析，下载，解码，变换，缓存，显示等操作。</p><p>流程图如下：</p><p><img src="https://img-blog.csdnimg.cn/2019102310370793.png" srcset="/img/loading.gif" alt="img"></p><h4 id="Q6：Glide-VS-Picasso"><a href="#Q6：Glide-VS-Picasso" class="headerlink" title="Q6：Glide VS Picasso"></a>Q6：Glide VS Picasso</h4><p>双胞胎兄弟之间的对比，使用方式相同，但 Glide 之所以胜出，不仅仅是 Google的推荐，更多应该归功于 GIF 的支持。 在没有 Glide 之前，常用的做法就是写了个自定义 view 然后 用一个 media 去播放。有了 Glide 之后几乎对于 GIF 无感知了的， 内部已经支持了的。可以像普通图片那样去加载并且显示出来动图。</p><p><a href="http://lib.csdn.net/base/android" target="_blank" rel="noopener">安卓</a>图片显示的质量配置主要分为四种:</p><ul><li>ARGB_8888 :32位图,带透明度,每个像素占4个字节</li><li>ARGB_4444 :16位图,带透明度,每个像素占2个字节</li><li>RGB_565 :16位图,不带透明度,每个像素占2个字节</li><li>ALPHA_8 :32位图,只有透明度,不带颜色,每个像素占4个字节</li></ul><p>(A代表透明度,RGB代表红绿蓝:即颜色)</p><p><a href="https://www.baidu.com/s?wd=Picasso&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd" target="_blank" rel="noopener">Picasso</a>的默认质量是 ARGB_8888<br>Glide的默认质量则为 RGB_565</p><p>加载一张4000 * 2000(一般<a href="https://www.baidu.com/s?wd=手机拍摄&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd" target="_blank" rel="noopener">手机拍摄</a>的都超过这个像素)的图片</p><p>Picasso需要占用的内存为: 32MB</p><p>4000 * 2000 * 4 / 1024 / 1024 = 30 (MB)</p><p>Glide需要占用的内存为: 16MB</p><p>4000 * 2000 * 2 / 1024 / 1024 = 15 (MB)</p><p>也就是说只要同时加载几张图片,你的应用就会OOM(内存溢出了),最恐怖的是就算你的ImageView的宽高只有10px,同样会占用那么多内存,这就是为什么需要做图片压缩的原因了</p><h4 id="Q7：Glide-VS-fresco"><a href="#Q7：Glide-VS-fresco" class="headerlink" title="Q7：Glide VS fresco"></a>Q7：Glide VS fresco</h4><p>两个都支持 GIF。所以 GIF 这一关pass掉。说到这里不得不提到一个头疼的OOM问题，fresco 之所以很快闯入大家的视线，大概就是因为 Facebook 说他们使用了 native 内存规避掉了 OutOfMemoryError 问题。而且官方还专门写了个demo，把几大流行的开源库都集成进去，为了说明自己的图片加载库加载同样的图片速度更快，内存占用更低。所以 fresco 相比较于 Glide 的（官方）优势就是这两点： 内存以及加载速度。但是我为什么依旧坚持抛弃了 fresco ?</p><ol><li>“ In Android 4.x and lower, Fresco puts images in a special region of Android memory. This lets your application run faster - and suffer the dreaded OutOfMemoryError much less often.” 官方的原话是这么说的，所以在高版本上面依旧使用的Java 内存，所以不可避免依旧会占用内存。</li><li>提到内存，不得不说到另外一个笑话，fresco 最大只支持图片文件大小为 2M 。记得有一次帮其他团队跟踪问题，看到了 fresco 源码中有一个 最大 size 2M 常量 。于是当场找了一个10M的图片作为测试。 Glide 正常显示， fresco显示黑屏。。。</li><li>使用方式上，fresco 推荐的是用他提供的 SimpleDraweeView . 这个方式意味着我们的迁移成本会非常的高，要改布局文件，其次还必须给定大小（或者比例）。 当然他也支持代码来加载图片，比如 DraweeHierarchy，但是写起来还是真心很费劲的，很不友好，改动成本居高。</li><li>fresco 更多是native实现。所以需要对NDK有所了解，但个人对NDK不太了解，相比较于 Glide， 同样遇到问题之后，修改源码的成本，Glide 成本更可控。前者可能就不太好下手了的。</li><li>Glide 各种 BitmapTransformation，比如圆形，圆角等，更让人喜欢。</li><li>这一点就当随意吐槽一下，当然也可以说心疼一下 Facebook。因为在没有 Android studio （gradle构建）的情况下，想必大家都用的是 eclipse 吧。那么就意味着 fresco 得提供 Jar 包. 这一点当时也是把很多人拒之门外了的，可笑的是当 Facebook 费了老大劲的搞出来 jar 包之后，大家早就纷纷转战 gradle 构建工程, 直接 maven 依赖啦。大写的尴尬。</li></ol><h3 id="3-socket"><a href="#3-socket" class="headerlink" title="3.socket"></a>3.socket</h3><p>图片中断是怎么处理的。</p><h3 id="4-listview与recyclerview"><a href="#4-listview与recyclerview" class="headerlink" title="4.listview与recyclerview"></a>4.listview与recyclerview</h3><h3 id="5-reentraint-lock"><a href="#5-reentraint-lock" class="headerlink" title="5.reentraint lock"></a>5.reentraint lock</h3><h3 id="优化："><a href="#优化：" class="headerlink" title="优化："></a>优化：</h3><h4 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h4><h4 id="卡顿优化"><a href="#卡顿优化" class="headerlink" title="卡顿优化"></a>卡顿优化</h4><p>可能会导致卡顿的原因有三大类：</p><p>1）事件本身太耗时。</p><p>2）事件本身并不耗时，但需要等待别的地方返回耗时。</p><p>3）UI线程本身已经拿不到CPU资源来执行事件。</p><p>下面根据这三大类来分别具体细聊。</p><p><strong>二. 耗时事件</strong></p><p>这个很容易理解，就是把一些耗时业务逻辑直接写在了UI线程中，比如计算密集型的复杂计算，庞大的MD5计算，非对称RSA解密等。一般情况下，开发人员都不会犯这种错误，因为能够直接意识到计算量很大，本身就有警醒的作用。</p><p><strong>三．耗时等待</strong></p><p>1）网络I/O 同步请求</p><p>2）磁盘I/O 文件，数据库</p><p>3）跨进程Binder同步等待返回数据</p><p><strong>四．CPU时间片</strong></p><p>1）其他应用发生抢占CPU资源的情况，导致本应用无法获得CPU执行时间片。</p><p>2）线程间发生死锁，UI线程无法获取锁，导致无法继续执行。</p><p>3）频繁GC，内存抖动。GC的次数越多，消耗在GC上的时间就越长，CPU花在界面绘制上的时间相应就越短。</p><p><strong>五. 分析</strong></p><p>对于卡顿的分析手段，有很多工具可以使用，下面介绍几种。</p><p>1）TraceView</p><p>相比之下，TraceView是分析卡顿的神兵利器，它不仅能看出每个方法消耗的时间、发生次数，并且可以进行排序，直接从最耗时的方法开始处优化。</p><p>3）AndroidPerformanceMonitor</p><p>AndroidPerformanceMonitor 是国人开发的一个检测卡顿的开源库，原名是BlockCanary，可以设置卡顿检测时间，debug模式下检测到的卡顿可以通知展示(基本和LeakCanary一样)，这个在开发自测时很有用。</p><p>其基本原理稍有不同，它并没有采用新开线程自己往UI线程里扔runnable的这种普通思想。而是利用系统在loop()方法里取出message前后进行了log打印这一特点，来重写Printer的println(String)方法，根据message处理前后的时间差，来判断是否发生了卡顿。</p><p><a href="https://blog.csdn.net/qingtiantianqing/article/details/100066873" target="_blank" rel="noopener">https://blog.csdn.net/qingtiantianqing/article/details/100066873</a></p><h4 id="绘制优化"><a href="#绘制优化" class="headerlink" title="绘制优化"></a>绘制优化</h4><p>solid原则</p><p>图片缩小策略。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法/排序</title>
      <link href="2020/10/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"/>
      <url>2020/10/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><pre class=" language-hljs java"><span class="hljs-comment"><code class="language-hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">     * 冒泡排序</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> arr</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bubbleSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span></span>&#123;        <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length <= <span class="hljs-number">1</span>)&#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">int</span> len = arr.length;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i < len; i++) &#123;            <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">true</span>;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j < len - i; j++) &#123;                <span class="hljs-keyword">if</span> (arr[j] < arr[j-<span class="hljs-number">1</span>])&#123;                  swap(arr,j,j-<span class="hljs-number">1</span>);                  flag = <span class="hljs-keyword">false</span>;                &#125;            &#125;            <span class="hljs-keyword">if</span> (flag)&#123;                <span class="hljs-keyword">break</span>;            &#125;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr,<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span>&#123;        <span class="hljs-keyword">int</span> temp = arr[a];        arr[a] = arr[b];        arr[b] = temp;    &#125;</code></pre><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><pre class=" language-hljs java"><span class="hljs-comment"><code class="language-hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">    * 插入排序</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> arr</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertionSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span></span>&#123;       <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length <= <span class="hljs-number">1</span>)&#123;           <span class="hljs-keyword">return</span>;       &#125;       <span class="hljs-keyword">int</span> len = arr.length;       <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i < len; i++) &#123;           <span class="hljs-keyword">int</span> temp = arr[i];           <span class="hljs-keyword">for</span> ( j = i; j > <span class="hljs-number">0</span> && temp < arr[j-<span class="hljs-number">1</span>]; j--) &#123;               arr[j] = arr[j - <span class="hljs-number">1</span>];           &#125;           arr[j] = temp;       &#125;   &#125;</code></pre><p>最好情况：时间复杂度O(n);</p><p>平均情况：时间复杂度O(n^2^)</p><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>i从0开始，每1轮找出待排数组中最小元素的位置，然后和i交换，i++。也就是每一轮选出一个最小的元素放在待排数组的第一个位置。</p><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertionSort</span><span class="hljs-params">(<span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertionSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span></span>&#123;        <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length <= <span class="hljs-number">1</span>)&#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">int</span> len = arr.length;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i < len; i++) &#123;            <span class="hljs-keyword">int</span> minIndex = i;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = i + <span class="hljs-number">1</span>; k < len; k++) &#123;                minIndex = arr[k] < arr[minIndex] ? k : minIndex;            &#125;            swap(arr,minIndex,i);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr,<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span>&#123;        <span class="hljs-keyword">int</span> temp = arr[a];        arr[a] = arr[b];        arr[b] = temp;    &#125;</code></pre><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>堆排序是对选择排序的一种改进，堆用完全二叉树(数组)实现，堆排序的步骤：</p><p>①建堆： $O(n)$</p><p>建最大堆，从倒数第一个有孩子的结点开始，把以它为根节点的树调整为堆，一次往前直到根节点。</p><p>②堆排序: $O(logn)$</p><p>对最大堆，堆顶元素和最后一个元素交换，然后调整；然后堆顶和倒第二个元素交换，调整，依次下去…</p><p>定理：堆排序处理n个不同元素的随机排列的平均比较次数是$2nlogn - O(nloglogn)$</p><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>算法思想：采用分治的策略，选取中间位置，将数组划分为2，然后合并，递归的处理左边，递归的处理右边。</p><p> 合并是合并2个有序子数组，要1个辅助数组。</p><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(<span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;<span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length < <span class="hljs-number">2</span>) &#123;<span class="hljs-keyword">return</span>;&#125;mergeSort(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<span class="hljs-keyword">if</span> (l == r) &#123;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">int</span> mid = l + ((r - l) >> <span class="hljs-number">1</span>);mergeSort(arr, l, mid);mergeSort(arr, mid + <span class="hljs-number">1</span>, r);merge(arr, l, mid, r);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<span class="hljs-keyword">int</span>[] help = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[r - l + <span class="hljs-number">1</span>];<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> p1 = l;<span class="hljs-keyword">int</span> p2 = m + <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (p1 <= m && p2 <= r) &#123;help[i++] = arr[p1] < arr[p2] ? arr[p1++] : arr[p2++];&#125;<span class="hljs-keyword">while</span> (p1 <= m) &#123;help[i++] = arr[p1++];&#125;<span class="hljs-keyword">while</span> (p2 <= r) &#123;help[i++] = arr[p2++];&#125;<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i < help.length; i++) &#123;arr[l + i] = help[i];&#125;&#125;</code></pre><p>快排和归并都是用分治的策略。</p><p>归并排序时间复杂度：O(nlogn),空间复杂度O(n)</p><h3 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h3><ul><li>选主元<ul><li>经典快排：选数组最后一个元素</li><li>将数组第一个，中间位置，最后1个位置三个数交换达到排序的目的，将中间位置的和最后一个位置的交换</li><li>随机函数选择1个与最后一个位置的交换</li></ul></li><li>划分子集<ul><li>int i = left - 1, j = right</li><li>++i,–j . 2个指针左指针和右指针，和主元比较，相向行驶。2个while循环</li><li>i &lt; j 时 交换（交换时的arr[i] &gt;= 主元，交换时的arr[j] &lt;= 主元）,否则退出循环</li><li>i+1的位置即是本轮主元的最终位置</li></ul></li></ul><pre class=" language-hljs java"> <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">partition2</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] array, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword"><code class="language-hljs java"> <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">partition2</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] array, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;       <span class="hljs-comment">//选主元</span>        <span class="hljs-keyword">int</span> privot = array[<span class="hljs-number">9</span>];       <span class="hljs-comment">//划分子集</span>        <span class="hljs-keyword">int</span> i = left - <span class="hljs-number">1</span>,j = right;        <span class="hljs-keyword">for</span> (;;)&#123;            <span class="hljs-comment">//大于等于的放右边</span>            <span class="hljs-keyword">while</span> (array[++i] < privot)&#123;&#125;<span class="hljs-comment">//红色警报</span>            <span class="hljs-keyword">while</span> (array[j--] > privot)&#123;&#125;<span class="hljs-comment">//红色警报</span>            <span class="hljs-comment">//和主元相等的时候也交换</span>            <span class="hljs-keyword">if</span> (i < j)&#123;                swap(array,i,j);            &#125;<span class="hljs-keyword">else</span>&#123;                <span class="hljs-keyword">break</span>;            &#125;        &#125;        swap(array,i,right);        <span class="hljs-keyword">return</span> i ;    &#125; <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[],<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> right)</span></span>&#123;        <span class="hljs-keyword">if</span> (left < right)&#123;            <span class="hljs-keyword">int</span> q = partition2(a,left,right);            quickSort(a,left,q-<span class="hljs-number">1</span>);            quickSort(a,q +<span class="hljs-number">1</span> ,right);        &#125;    &#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr,<span class="hljs-keyword">int</span> length)</span></span>&#123;        quickSort(arr,<span class="hljs-number">0</span>,length - <span class="hljs-number">1</span>);    &#125;</code></pre><p>平均情况下时间复杂度： O(nlogn),空间复杂度O(logn)</p><p>最快情况下时间复杂度: O(n^2^) ,空间复杂度O(n)</p><blockquote><p>注 :数组中元素全部相同时，不交换的情况下一轮就是O(n) ,整体就是O(n^2^)</p></blockquote><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java/Android</title>
      <link href="2020/10/13/Java/Android/"/>
      <url>2020/10/13/Java/Android/</url>
      
        <content type="html"><![CDATA[<h1 id="Android基础"><a href="#Android基础" class="headerlink" title="Android基础"></a>Android基础</h1><h3 id="apk打包流程？"><a href="#apk打包流程？" class="headerlink" title="apk打包流程？"></a>apk打包流程？</h3><h3 id="事件分发机制"><a href="#事件分发机制" class="headerlink" title="事件分发机制"></a>事件分发机制</h3><ul><li><p>Android事件分发机制的本质是要解决：</p><p>点击事件由哪个对象发出，经过哪些对象，最终达到哪个对象并最终得到处理。</p><blockquote><p>这里的对象是指Activity、ViewGroup、View</p></blockquote></li><li><p>Android中事件分发顺序：<strong>Activity（Window） -&gt; ViewGroup -&gt; View</strong></p></li><li><p>事件分发过程由dispatchTouchEvent() 、onInterceptTouchEvent()和onTouchEvent()三个方法协助完成</p></li></ul><h4 id="三者关系"><a href="#三者关系" class="headerlink" title="三者关系"></a>三者关系</h4><p>下面将用一段伪代码来阐述上述三个方法的关系和点击事件传递规则</p><pre class=" language-hljs java"><span class="hljs-comment"><code class="language-hljs java"><span class="hljs-comment">// 点击事件产生后，会直接调用dispatchTouchEvent（）方法</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">dispatchTouchEvent</span><span class="hljs-params">(MotionEvent ev)</span> </span>&#123;    <span class="hljs-comment">//代表是否消耗事件</span>    <span class="hljs-keyword">boolean</span> consume = <span class="hljs-keyword">false</span>;    <span class="hljs-keyword">if</span> (onInterceptTouchEvent(ev)) &#123;    <span class="hljs-comment">//如果onInterceptTouchEvent()返回true则代表当前View拦截了点击事件</span>    <span class="hljs-comment">//则该点击事件则会交给当前View进行处理</span>    <span class="hljs-comment">//即调用onTouchEvent (）方法去处理点击事件</span>      consume = onTouchEvent (ev) ;    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-comment">//如果onInterceptTouchEvent()返回false则代表当前View不拦截点击事件</span>      <span class="hljs-comment">//则该点击事件则会继续传递给它的子元素</span>      <span class="hljs-comment">//子元素的dispatchTouchEvent（）就会被调用，重复上述过程</span>      <span class="hljs-comment">//直到点击事件被最终处理为止</span>      consume = child.dispatchTouchEvent (ev) ;    &#125;    <span class="hljs-keyword">return</span> consume;   &#125;Copy</code></pre><h4 id="场景介绍"><a href="#场景介绍" class="headerlink" title="场景介绍"></a>场景介绍</h4><h4 id="源码理解"><a href="#源码理解" class="headerlink" title="源码理解"></a>源码理解</h4><p>其中：</p><ul><li>super：调用父类方法</li><li>true：消费事件，即事件不继续往下传递</li><li>false：不消费事件，事件继续往下传递 / 交由给父控件onTouchEvent（）处理</li></ul><p><strong>所以，要想充分理解Android分发机制，本质上是要理解：</strong></p><ul><li>Activity对点击事件的分发机制</li><li>ViewGroup对点击事件的分发机制</li><li>View对点击事件的分发机制</li></ul><p>接下来，我将通过源码分析详细介绍Activity、View和ViewGroup的事件分发机制</p><h4 id="4-1-Activity的事件分发机制"><a href="#4-1-Activity的事件分发机制" class="headerlink" title="4.1 Activity的事件分发机制"></a>4.1 Activity的事件分发机制</h4><ul><li>当一个点击事件发生时，事件最先传到Activity的dispatchTouchEvent()进行事件分发，最终是调用了ViewGroup的dispatchTouchEvent()方法</li><li>这样事件就从 Activity 传递到了 ViewGroup</li><li>dispatchTouchEvent返回false ，则调用activity的onTouchEvent处理，之后结束。</li></ul><h4 id="4-2-ViewGroup事件的分发机制"><a href="#4-2-ViewGroup事件的分发机制" class="headerlink" title="4.2 ViewGroup事件的分发机制"></a>4.2 ViewGroup事件的分发机制</h4><p>什么时候判断拦截？</p><ul><li><p>如果当前事件是MotionEvent.ACTION_DOWN 或者不是DOWN事件且之前的DOWN事件有子view处理过(mFirstTouchTarget != null)，判断是否拦截。</p></li><li><p>如果是MOVE、UP等非DOWN事件，且之前没有孩子处理，开始持续拦截触摸（intercepted = true）</p></li></ul><ul><li>当ViewGroup不拦截事件的时候，事件会向下分发交由它的子View或ViewGroup(触摸位置在child的区域内)进行处理。</li></ul><p>总结</p><ul><li><p>Android事件分发是先传递到ViewGroup，再由ViewGroup传递到View</p></li><li><p>在ViewGroup中通过onInterceptTouchEvent()对事件传递进行拦截</p><blockquote><ol><li>onInterceptTouchEvent方法返回true代表拦截事件，即不允许事件继续向子View传递；</li><li>返回false代表不拦截事件，即允许事件继续向子View传递；（默认返回false）</li><li>子View中如果将传递的事件消费掉，ViewGroup中将无法接收到任何事件。</li></ol></blockquote></li></ul><p>特别注意：</p><ul><li>如果ViewGroup A 拦截了一个半路的事件（如MOVE），这个事件将会被系统变成一个CANCEL事件并传递给之前处理该事件的子View；</li><li>该事件不会再传递给ViewGroup A的onTouchEvent()</li><li>只有再到来的事件才会传递到ViewGroup A的onTouchEvent()</li></ul><h4 id="4-3-View事件的分发机制"><a href="#4-3-View事件的分发机制" class="headerlink" title="4.3 View事件的分发机制"></a>4.3 View事件的分发机制</h4><ol><li><p>onTouch（）的执行高于onClick（）</p></li><li><p>每当控件被点击时：</p><ul><li><p>如果在回调onTouch()里返回false，就会让dispatchTouchEvent方法返回false，那么就会执行onTouchEvent()；如果回调了setOnClickListener()来给控件注册点击事件的话，最后会在performClick()方法里回调onClick()。</p><blockquote><p>onTouch()返回false（该事件没被onTouch()消费掉） = 执行onTouchEvent() = 执行OnClick()</p></blockquote></li><li><p>如果在回调onTouch()里返回true，就会让dispatchTouchEvent方法返回true，那么将不会执行onTouchEvent()，即onClick()也不会执行；</p><blockquote><p>onTouch()返回true（该事件被onTouch()消费掉） = dispatchTouchEvent()返回true（不会再继续向下传递） = 不会执行onTouchEvent() = 不会执行OnClick()</p></blockquote></li></ul></li></ol><h5 id="onTouch-和onTouchEvent-的区别"><a href="#onTouch-和onTouchEvent-的区别" class="headerlink" title="onTouch()和onTouchEvent()的区别"></a>onTouch()和onTouchEvent()的区别</h5><ul><li><p>这两个方法都是在View的dispatchTouchEvent中调用，但onTouch优先于onTouchEvent执行。</p></li><li><p>如果在onTouch方法中返回true将事件消费掉，onTouchEvent()将不会再执行。</p></li><li><p><font color = red>如果该控件是可以点击的，就一定会返回true ;如果该控件是不可以点击的，就一定会返回false</font></p></li></ul><p><strong>给出ACTION_MOVE和ACTION_UP事件的传递结论</strong>：</p><ul><li>如果在某个对象（Activity、ViewGroup、View）的dispatchTouchEvent()消费事件（返回true），那么收到ACTION_DOWN的函数也能收到ACTION_MOVE和ACTION_UP</li></ul><ul><li>如果在某个对象（Activity、ViewGroup、View）的onTouchEvent()消费事件（返回true），那么ACTION_MOVE和ACTION_UP的事件从上往下传到这个View后就不再往下传递了，而直接传给自己的onTouchEvent()并结束本次事件传递过程。</li></ul><h4 id="滑动冲突处理？"><a href="#滑动冲突处理？" class="headerlink" title="滑动冲突处理？"></a>滑动冲突处理？</h4><h1 id="Android进阶"><a href="#Android进阶" class="headerlink" title="Android进阶"></a>Android进阶</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>网络/https</title>
      <link href="2020/10/12/%E7%BD%91%E7%BB%9C/https/"/>
      <url>2020/10/12/%E7%BD%91%E7%BB%9C/https/</url>
      
        <content type="html"><![CDATA[<h2 id="通信过程"><a href="#通信过程" class="headerlink" title="通信过程"></a>通信过程</h2><ol><li>建立TCP连接（往服务端端口号443）</li><li>SSL握手<ol><li>client-&gt;server     Handshake Protocol: Client Hello</li><li>server-&gt;client     Handshake Protocol: Server Hello</li><li>server-&gt;client     Handshake Protocol: Certificate、Server Key Exchange、Server Hello Done</li><li>client-&gt;server     Client Key Exchange、Change Cipher Spec、Encrypted Handshake Message</li><li>server-&gt;client  New Session Ticket、Change Cipher Spec、Encrypted Handshake Message</li><li>密钥加密传输。Application Data</li></ol></li><li>报文加密传输</li><li>TCP释放连接</li></ol><p>SSL握手：</p><ul><li>交换协议版本号</li><li>选择一个两端都了解的加密算法</li><li>对两端身份进行认证</li><li>生成临时的会话密钥，以便加密信道</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java基础</title>
      <link href="2020/10/06/Java/Java%E5%9F%BA%E7%A1%80/"/>
      <url>2020/10/06/Java/Java%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-语言"><a href="#Java-语言" class="headerlink" title="Java 语言"></a>Java 语言</h1><h2 id="1-程序设计基础"><a href="#1-程序设计基础" class="headerlink" title="1.程序设计基础"></a>1.程序设计基础</h2><h5 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h5><p>final 属性：属性不可修改。</p><p>static final 修饰的成员不可在初始化块和构造器中初始化。</p><p>final 方法：方法不可被覆盖.</p><p>final 类： 类不能被继承。一个类不能被abstract final 同时修饰。</p><h5 id="为什么说Java是平台独立型语言？"><a href="#为什么说Java是平台独立型语言？" class="headerlink" title="为什么说Java是平台独立型语言？"></a>为什么说Java是平台独立型语言？</h5><p>java源代码编译后都是.class，是一种中间码，不同的硬件平台有不同的JVM，由JVM来把.class翻译为特定硬件平台能执行的代码。</p><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><h2 id="2-Java基础"><a href="#2-Java基础" class="headerlink" title="2. Java基础"></a>2. Java基础</h2><h3 id="2-1-面向对象"><a href="#2-1-面向对象" class="headerlink" title="2.1 面向对象"></a>2.1 面向对象</h3><p><strong>面向对象与面向过程</strong>：</p><p>面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了；面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。</p><p>可以拿生活中的实例来理解面向过程与面向对象，例如五子棋，面向过程的设计思路就是首先分析问题的步骤：<strong>1、开始游戏，2、黑子先走，3、绘制画面，4、判断输赢，5、轮到白子，6、绘制画面，7、判断输赢，8、返回步骤2，9、输出最后结果。把上面每个步骤用不同的方法来实现。</strong></p><p>如果是面向对象的设计思想来解决问题。面向对象的设计则是从另外的思路来解决问题。整个五子棋可以分为1、<strong>黑白双方</strong>，这两方的行为是一模一样的，2、<strong>棋盘系统</strong>，负责绘制画面，3、<strong>规则系统</strong>，负责判定诸如犯规、输赢等。第一类对象（玩家对象）负责接受用户输入，并告知第二类对象（棋盘对象）棋子布局的变化，棋盘对象接收到了棋子的变化就要负责在屏幕上面显示出这种变化，同时利用第三类对象（规则系统）来对棋局进行判定。</p><p>可以明显地看出，面向对象是以功能来划分问题，而不是步骤。同样是绘制棋局，这样的行为在面向过程的设计中分散在了多个步骤中，很可能出现不同的绘制版本，因为通常设计人员会考虑到实际情况进行各种各样的简化。而面向对象的设计中，绘图只可能在棋盘对象中出现，从而保证了绘图的统一。</p><p><strong>面向过程</strong></p><blockquote><p>优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、 Linux/Unix等一般采用面向过程开发，性能是最重要的因素。<br>缺点：没有面向对象易维护、易复用、易扩展</p></blockquote><p><strong>面向对象</strong></p><blockquote><p>优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统 更加灵活、更加易于维护<br>缺点：性能比面向过程低</p></blockquote><h4 id="2-1-1对象和类-内部类"><a href="#2-1-1对象和类-内部类" class="headerlink" title="2.1.1对象和类(内部类)"></a>2.1.1对象和类(内部类)</h4><h5 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a><strong>访问修饰符</strong></h5><table><thead><tr><th></th><th>类内部</th><th>同一个包</th><th>不同包的子类</th><th>不同包的非子类</th></tr></thead><tbody><tr><td>public</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>protected</td><td>√</td><td>√</td><td>√</td><td></td></tr><tr><td>不加</td><td>√</td><td>√</td><td></td><td></td></tr><tr><td>private</td><td>√</td><td></td><td></td><td></td></tr></tbody></table><p>没有访问修饰符的部分(类、方法、变量)可以被同一个包中的所有方法访问；</p><p>标记为private的部分只能被定义它们的类使用；</p><p>标记为Public的部分可以被任意的类使用。</p><p>类可以以两种方式使用：创建实例；扩展创建它的子类。</p><p>如果不想从类的外部使用的类的成员，就把成员声明成private;</p><p>如果想让该类的用户都能使用该类的成员，就把成员声明成public;</p><p>如果想让该类的扩展者使用该类的成员，而不想让该类的用户使用，就把成员声明为protected.</p><p>一个没有修饰符中的类是不能被其他包中的类访问。</p><ul><li><p>静态方法只能访问静态成员(变量和静态方法)。</p></li><li><p>实例方法可以访问实例方法和实例成员，也可以访问静态成员。</p></li></ul><h5 id="初始化顺序"><a href="#初始化顺序" class="headerlink" title="初始化顺序"></a><strong>初始化顺序</strong></h5><ol><li><p>初始化父类中的静态成员变量和静态代码块 ； </p></li><li><p>初始化子类中的静态成员变量和静态代码块 ； </p></li><li><p>初始化父类的普通成员变量和代码块，再执行父类的构造方法；</p></li><li><p>初始化子类的普通成员变量和代码块，再执行子类的构造方法； </p></li></ol><h5 id="内部类？？"><a href="#内部类？？" class="headerlink" title="内部类？？"></a>内部类？？</h5><h4 id="2-1-2继承和多态"><a href="#2-1-2继承和多态" class="headerlink" title="2.1.2继承和多态"></a>2.1.2继承和多态</h4><h5 id="继承继承了什么？"><a href="#继承继承了什么？" class="headerlink" title="继承继承了什么？"></a><strong>继承继承了什么？</strong></h5><ul><li>子类继承了父类中所有可访问的属性和方法，不包括构造方法。</li><li>super()和super(arguments)必须出现在子类构造方法的第一行。 </li></ul><p>多态（Polymorphism）：使用父类对象的地方都可以使用子类对象，这就是多态。简单来说，多态意味着父类型的变量可以引用子类型的对象。</p><p>java中当子类拥有和父类同样的函数，当通过这个父类对象的引用调用这个函数的时候，调用到的是子类中的函数。</p><p>多态也称动态绑定，运行时绑定。</p><h5 id="多态的优点"><a href="#多态的优点" class="headerlink" title="多态的优点"></a><strong>多态的优点</strong></h5><ol><li><p>改善代码的组织结构和可读性。</p></li><li><p>消除类型之间的耦合关系</p></li></ol><p>多态变量，它有2种类型，声明类型，动态类型。</p><img src="../../../../../../Pictures/md_images/image-20201007130909327.png" srcset="/img/loading.gif" alt="image-20201007130909327" style="zoom:67%;" /><p>java语言默认是动态绑定。</p><p>wengkai 多态：所谓多态，就是1个变量去调用一个函数，只是写了这么一句话，并不去判断变量的实际类型是什么，不需要去写switch case,不需要写if else ,对应的函数被调用，这个就叫多态。</p><h5 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h5><p>方法名和参数列表一起构成方法签名。</p><p>重载：相同的名字，不同的参数列表。</p><p>重写：在子类中使用和父类一样的签名和返回值类型。</p><ul><li><p>方法重写发生在通过继承相关的不同类中，重写的方法的访问权限只能&gt;=父类的</p></li><li><p>方法重载可以发生在同一个类中，也可以方法重写发生在通过继承相关的不同类中</p></li></ul><h4 id="2-1-3抽象类和接口"><a href="#2-1-3抽象类和接口" class="headerlink" title="2.1.3抽象类和接口"></a>2.1.3抽象类和接口</h4><p>在 Java 8 之前，接口与其实现类之间的 <strong>耦合度</strong> 太高了（<strong>tightly coupled</strong>），当需要为一个接口添加方法时，所有的实现类都必须随之修改。默认方法解决了这个问题，它可以为接口添加新的方法，而不会破坏已有的接口的实现。这在 lambda 表达式作为Java 8 语言的重要特性而出现之际，为升级旧接口且保持向后兼容（backward compatibility）提供了途径。</p><h5 id="一般性理解"><a href="#一般性理解" class="headerlink" title="一般性理解"></a>一般性理解</h5><p>接口和抽象类都可以用于为对象指定共同的行为。</p><p>从设计理念上，接口反映的是 <strong>“like-a”</strong> 关系，抽象类反映的是 <strong>“is-a”</strong> 关系。 </p><p>抽象类表示的是，这个对象是什么。接口表示的是，这个对象能做什么。比如，男人，女人，这两个类（如果是类的话……），他们的抽象类是人。说明，他们都是人。 人可以吃东西，狗也可以吃东西，你可以把“吃东西”定义成一个接口，然后让这些类去实现它. 所以，在高级语言上，一个类只能继承一个类（抽象类）(正如人不可能同时是生物和非生物)，但是可以实现多个接口(吃饭接口、走路接口)。</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><table><thead><tr><th></th><th>抽象类</th><th>接口</th></tr></thead><tbody><tr><td>变量</td><td>无限制</td><td>所有变量是public static final(可以不写)的</td></tr><tr><td>构造方法</td><td>可以有构造方法</td><td>没有构造方法</td></tr><tr><td>方法</td><td>无限制</td><td>必须是public abstract(默认省略)的;</td></tr><tr><td></td><td></td><td>可以有default的修饰</td></tr></tbody></table><ol start="3"><li>接口里定义的变量只能是公共的静态的常量，抽象类中的变量是普通变量。</li><li>抽象类里可以没有抽象方法。</li><li>接口可以被类多实现（被其他接口多继承），抽象类只能被单继承。</li><li>接口中没有 <code>this</code> 指针，没有构造函数，不能拥有实例字段（实例变量）或实例方法。</li><li>抽象类不能在Java 8 的 lambda 表达式中使用。</li><li>只能继承一个抽象类，能实现多个接口</li></ol><h3 id="2-2-反射"><a href="#2-2-反射" class="headerlink" title="2.2 反射"></a>2.2 反射</h3><h4 id="2-2-1-反射一"><a href="#2-2-1-反射一" class="headerlink" title="2.2.1 反射一"></a>2.2.1 反射一</h4><h5 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h5><p><strong>Java反射机制定义</strong></p><p>Java反射机制是在运行状态中，对于任意一个类，都能够知道这个类中的所有属性和方法；</p><p>对于任意一个对象，都能够调用它的任意方法和获取他的属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。<br>        <strong>Java 反射机制的功能</strong></p><p>1.在运行时判断任意一个对象所属的类。</p><p>2.在运行时构造任意一个类的对象。</p><p>3.在运行时判断任意一个类所具有的成员变量和方法。</p><p>4.在运行时调用任意一个对象的方法。</p><p>5.生成动态代理。</p><p><strong>Java 反射机制的应用场景</strong></p><p>1.逆向代码 ，例如反编译</p><p>2.与注解相结合的框架 例如Retrofit</p><p>3.单纯的反射机制应用框架 例如EventBus</p><p>4.动态生成类框架 例如Gson</p><h5 id="二、通过Java反射查看类信息"><a href="#二、通过Java反射查看类信息" class="headerlink" title="二、通过Java反射查看类信息"></a>二、通过Java反射查看类信息</h5><p><strong>获得Class对象</strong><br>每个类被加载之后，系统就会为该类生成一个对应的Class对象。通过该Class对象就可以访问到JVM中的这个类。</p><p>在Java程序中获得Class对象通常有如下三种方式：</p><p>1.使用Class类的forName(String clazzName)静态方法。该方法需要传入字符串参数，该字符串参数的值是某个类的全限定名（必须添加完整包名）。</p><p>2.调用某个类的class属性来获取该类对应的Class对象。</p><p>3.调用某个对象的getClass()方法。该方法是java.lang.Object类中的一个方法。</p><pre class=" language-hljs java"><span class="hljs-comment"><code class="language-hljs java"><span class="hljs-comment">//第一种方式 通过Class类的静态方法——forName()来实现</span>class1 = Class.forName(<span class="hljs-string">"com.lvr.reflection.Person"</span>);<span class="hljs-comment">//第二种方式 通过类的class属性</span>class1 = Person<span class="hljs-class">.<span class="hljs-keyword">class</span></span>;<span class="hljs-comment">//第三种方式 通过对象getClass方法</span>Person person = <span class="hljs-keyword">new</span> Person();Class<?> class1 = person.getClass();</code></pre><p><strong>获取class对象的属性、方法、构造函数等</strong></p><p>1.获取class对象的成员变量</p><pre class=" language-hljs java">Field[] allFields = class1.getDeclaredFields();<span class="hljs-comment"><code class="language-hljs java">Field[] allFields = class1.getDeclaredFields();<span class="hljs-comment">//获取class对象的所有属性,不包括继承过来的</span>Field[] publicFields = class1.getFields();<span class="hljs-comment">//获取class对象及其父类和他实现的接口的public属性</span>Field ageField = class1.getDeclaredField(<span class="hljs-string">"age"</span>);<span class="hljs-comment">//获取class指定属性</span>Field desField = class1.getField(<span class="hljs-string">"des"</span>);<span class="hljs-comment">//获取class指定的public属性</span>Copy</code></pre><p>2.获取class对象的方法</p><pre class=" language-hljs java">Method[] methods = class1.getDeclaredMethods();<span class="hljs-comment"><code class="language-hljs java">Method[] methods = class1.getDeclaredMethods();<span class="hljs-comment">//获取class对象的所有声明方法</span>Method[] allMethods = class1.getMethods();<span class="hljs-comment">//获取class对象的所有public方法 包括父类的方法</span>Method method = class1.getMethod(<span class="hljs-string">"info"</span>, String<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<span class="hljs-comment">//返回次Class对象对应类的、带指定形参列表的public方法</span>Method declaredMethod = class1.getDeclaredMethod(<span class="hljs-string">"info"</span>, String<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<span class="hljs-comment">//返回次Class对象对应类的、带指定形参列表的方法</span>Copy</code></pre><p>3.获取class对象的构造函数</p><pre class=" language-hljs java">Constructor&lt;?&gt;[] allConstructors = class1.getDeclaredConstructors();<span class="hljs-comment"><code class="language-hljs java">Constructor&lt;?&gt;[] allConstructors = class1.getDeclaredConstructors();<span class="hljs-comment">//获取class对象的所有声明构造函数</span>Constructor<?>[] publicConstructors = class1.getConstructors();<span class="hljs-comment">//获取class对象public构造函数</span>Constructor<?> constructor = class1.getDeclaredConstructor(String<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<span class="hljs-comment">//获取指定声明构造函数</span>Constructor publicConstructor = class1.getConstructor(String<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<span class="hljs-comment">//获取指定声明的public构造函数</span>Copy</code></pre><p>4.其他方法</p><pre class=" language-hljs java">Annotation[] annotations = (Annotation[]) class1.getAnnotations();<span class="hljs-comment"><code class="language-hljs java">Annotation[] annotations = (Annotation[]) class1.getAnnotations();<span class="hljs-comment">//获取class对象的所有注解</span>Annotation annotation = (Annotation) class1.getAnnotation(Deprecated<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<span class="hljs-comment">//获取class对象指定注解</span>Type genericSuperclass = class1.getGenericSuperclass();<span class="hljs-comment">//获取class对象的直接超类的 Type</span>Type[] interfaceTypes = class1.getGenericInterfaces();<span class="hljs-comment">//获取class对象的所有接口的type集合</span>Copy</code></pre><p><strong>获取class对象的信息</strong></p><p>比较多。</p><pre class=" language-hljs java"><span class="hljs-keyword">boolean</span> isPrimitive = class1.isPrimitive();<span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">boolean</span> isPrimitive = class1.isPrimitive();<span class="hljs-comment">//判断是否是基础类型</span><span class="hljs-keyword">boolean</span> isArray = class1.isArray();<span class="hljs-comment">//判断是否是集合类</span><span class="hljs-keyword">boolean</span> isAnnotation = class1.isAnnotation();<span class="hljs-comment">//判断是否是注解类</span><span class="hljs-keyword">boolean</span> isInterface = class1.isInterface();<span class="hljs-comment">//判断是否是接口类</span><span class="hljs-keyword">boolean</span> isEnum = class1.isEnum();<span class="hljs-comment">//判断是否是枚举类</span><span class="hljs-keyword">boolean</span> isAnonymousClass = class1.isAnonymousClass();<span class="hljs-comment">//判断是否是匿名内部类</span><span class="hljs-keyword">boolean</span> isAnnotationPresent = class1.isAnnotationPresent(Deprecated<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<span class="hljs-comment">//判断是否被某个注解类修饰</span>String className = class1.getName();<span class="hljs-comment">//获取class名字 包含包名路径</span>Package aPackage = class1.getPackage();<span class="hljs-comment">//获取class的包信息</span>String simpleName = class1.getSimpleName();<span class="hljs-comment">//获取class类名</span><span class="hljs-keyword">int</span> modifiers = class1.getModifiers();<span class="hljs-comment">//获取class访问权限</span>Class<?>[] declaredClasses = class1.getDeclaredClasses();<span class="hljs-comment">//内部类</span>Class<?> declaringClass = class1.getDeclaringClass();<span class="hljs-comment">//外部类</span>Copy</code></pre><h5 id="三、通过Java反射生成并操作对象"><a href="#三、通过Java反射生成并操作对象" class="headerlink" title="三、通过Java反射生成并操作对象"></a>三、通过Java反射生成并操作对象</h5><p><strong>生成类的实例对象</strong></p><p>1.使用Class对象的newInstance()方法来创建该Class对象对应类的实例。这种方式要求该Class对象的对应类有默认构造器，而执行newInstance()方法时实际上是利用默认构造器来创建该类的实例。</p><p>2.先使用Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance()方法来创建该Class对象对应类的实例。通过这种方式可以选择使用指定的构造器来创建实例。</p><pre class=" language-hljs java"><span class="hljs-comment"><code class="language-hljs java"><span class="hljs-comment">//第一种方式 Class对象调用newInstance()方法生成</span>Object obj = class1.newInstance();<span class="hljs-comment">//第二种方式 对象获得对应的Constructor对象，再通过该Constructor对象的newInstance()方法生成</span>Constructor<?> constructor = class1.getDeclaredConstructor(String<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<span class="hljs-comment">//获取指定声明构造函数</span>obj = constructor.newInstance(<span class="hljs-string">"hello"</span>);</code></pre><p><strong>调用类的方法</strong></p><p>1.通过Class对象的getMethods()方法或者getMethod()方法获得指定方法，返回Method数组或对象。</p><p>2.调用Method对象中的<code>Object invoke(Object obj, Object... args)</code>方法。第一个参数对应调用该方法的实例对象，第二个参数对应该方法的参数。</p><pre class=" language-hljs java"> <span class="hljs-comment"><code class="language-hljs java"> <span class="hljs-comment">// 生成新的对象：用newInstance()方法</span> Object obj = class1.newInstance();<span class="hljs-comment">//首先需要获得与该方法对应的Method对象</span>Method method = class1.getDeclaredMethod(<span class="hljs-string">"setAge"</span>, <span class="hljs-keyword">int</span><span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<span class="hljs-comment">//调用指定的函数并传递参数</span>method.invoke(obj, <span class="hljs-number">28</span>);Copy</code></pre><p><strong>当通过Method的invoke()方法来调用对应的方法时，Java会要求程序必须有调用该方法的权限。如果程序确实需要调用某个对象的private方法，则可以先调用Method对象的如下方法。</strong><br><strong>setAccessible(boolean flag)：将Method对象的acessible设置为指定的布尔值。值为true，指示该Method在使用时应该取消Java语言的访问权限检查；值为false，则知识该Method在使用时要实施Java语言的访问权限检查。</strong></p><p><strong>访问成员变量值</strong></p><p>1.通过Class对象的getFields()方法或者getField()方法获得指定方法，返回Field数组或对象。</p><p>2.Field提供了两组方法来读取或设置成员变量的值：<br>getXXX(Object obj):获取obj对象的该成员变量的值。此处的XXX对应8种基本类型。如果该成员变量的类型是引用类型，则取消get后面的XXX。<br>setXXX(Object obj,XXX val)：将obj对象的该成员变量设置成val值。</p><pre class=" language-hljs java"><span class="hljs-comment"><code class="language-hljs java"><span class="hljs-comment">//生成新的对象：用newInstance()方法 </span>Object obj = class1.newInstance();<span class="hljs-comment">//获取age成员变量</span>Field field = class1.getField(<span class="hljs-string">"age"</span>);<span class="hljs-comment">//将obj对象的age的值设置为10</span>field.setInt(obj, <span class="hljs-number">10</span>);<span class="hljs-comment">//获取obj对象的age的值</span>field.getInt(obj);</code></pre><h4 id="2-2-2-反射二"><a href="#2-2-2-反射二" class="headerlink" title="2.2.2 反射二"></a>2.2.2 反射二</h4><h5 id="一、代理模式"><a href="#一、代理模式" class="headerlink" title="一、代理模式"></a>一、代理模式</h5><p><strong>定义：</strong>给某个对象提供一个代理对象，并由代理对象控制对原对象的访问，即客户不直接操控原对象，而是通过代理对象间接地操控原对象。</p><h5 id="1、代理模式的理解"><a href="#1、代理模式的理解" class="headerlink" title="1、代理模式的理解"></a>1、代理模式的理解</h5><p>代理模式使用代理对象完成用户请求，屏蔽用户对真实对象的访问。现实世界的代理人被授权执行当事人的一些事宜，无需当事人出面，从第三方的角度看，似乎当事人并不存在，因为他只和代理人通信。而事实上代理人是要有当事人的授权，并且在核心问题上还需要请示当事人。<br>在软件设计中，使用代理模式的意图也很多</p><ul><li>比如因为安全原因需要屏蔽客户端直接访问真实对象，</li><li>或者在远程调用中需要使用代理类处理远程方法调用的技术细节，</li><li>也可能为了提升系统性能，对真实对象进行封装，从而达到延迟加载的目的。</li><li>要在某些模块方法调用前后加上一些统一的前后处理操作</li></ul><h5 id="2、代理模式的参与者"><a href="#2、代理模式的参与者" class="headerlink" title="2、代理模式的参与者"></a>2、代理模式的参与者</h5><p>代理模式的角色分四种：</p><p><img src="https://codingsky.oss-cn-hangzhou.aliyuncs.com/androidos/articles/content/convert/e89f8c7516b4cb49708793744a2a61ea.dat" srcset="/img/loading.gif" alt="img"></p><p><strong>主题接口：</strong>Subject 是委托对象和代理对象都共同实现的接口，即代理类的所实现的行为接口。Request() 是委托对象和代理对象共同拥有的方法。<br>       <strong>目标对象：</strong>ReaSubject 是原对象，也就是被代理的对象。<br>       <strong>代理对象：</strong>Proxy 是代理对象，用来封装真是主题类的代理类。<br>       <strong>客户端 ：</strong>使用代理类和主题接口完成一些工作。</p><h5 id="3、代理模式的分类"><a href="#3、代理模式的分类" class="headerlink" title="3、代理模式的分类"></a>3、代理模式的分类</h5><p>代理的实现分为：</p><p><strong>静态代理：</strong>代理类是在编译时就实现好的。也就是说 Java 编译完成后代理类是一个实际的 class 文件。<br>       <strong>动态代理：</strong>代理类是在运行时生成的。也就是说 Java 编译完之后并没有实际的 class 文件，而是在运行时动态生成的类字节码，并加载到JVM中。</p><h5 id="4、代理模式的实现思路"><a href="#4、代理模式的实现思路" class="headerlink" title="4、代理模式的实现思路"></a>4、代理模式的实现思路</h5><p>1.代理对象和目标对象均实现同一个行为接口。</p><p>2.代理类和目标类分别具体实现接口逻辑。</p><p>3.在代理类的构造函数中实例化一个目标对象。</p><p>4.在代理类中调用目标对象的行为接口。</p><p>5.客户端想要调用目标对象的行为接口，只能通过代理类来操作。</p><h5 id="5、静态代理模式的简单实现"><a href="#5、静态代理模式的简单实现" class="headerlink" title="5、静态代理模式的简单实现"></a>5、静态代理模式的简单实现</h5><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProxyDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span></span>&#123;        RealSubject subject = <span class="hljs-keyword">new</span> RealSubject();        Proxy p = <span class="hljs-keyword">new</span> Proxy(subject);        p.request();    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Subject</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">request</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RealSubject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Subject</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">request</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">"request"</span>);    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Proxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Subject</span></span>&#123;    <span class="hljs-keyword">private</span> Subject subject;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Proxy</span><span class="hljs-params">(Subject subject)</span></span>&#123;        <span class="hljs-keyword">this</span>.subject = subject;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">request</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">"PreProcess"</span>);        subject.request();        System.out.println(<span class="hljs-string">"PostProcess"</span>);    &#125;&#125;Copy</code></pre><p>目标对象(RealSubject )以及代理对象（Proxy）都实现了主题接口（Subject）。在代理对象（Proxy）中，通过构造函数传入目标对象(RealSubject )，然后重写主题接口（Subject）的request()方法，在该方法中调用目标对象(RealSubject )的request()方法，并可以添加一些额外的处理工作在目标对象(RealSubject )的request()方法的前后。</p><p><strong>代理模式的好处：</strong></p><p>假如有这样的需求，要在某些模块方法调用前后加上一些统一的前后处理操作，比如在添加购物车、修改订单等操作前后统一加上登陆验证与日志记录处理，该怎样实现？首先想到最简单的就是直接修改源码，在对应模块的对应方法前后添加操作。如果模块很多，你会发现，修改源码不仅非常麻烦、难以维护，而且会使代码显得十分臃肿。</p><p>这时候就轮到代理模式上场了，它可以在被调用方法前后加上自己的操作，而不需要更改被调用类的源码，大大地降低了模块之间的耦合性，体现了极大的优势。</p><p>静态代理比较简单，上面的简单实例就是静态代理的应用方式，下面介绍本篇文章的主题：动态代理。</p><h5 id="二、Java反射机制与动态代理"><a href="#二、Java反射机制与动态代理" class="headerlink" title="二、Java反射机制与动态代理"></a>二、Java反射机制与动态代理</h5><p>动态代理的思路和上述思路一致，下面主要讲解如何实现。</p><h5 id="1、动态代理介绍"><a href="#1、动态代理介绍" class="headerlink" title="1、动态代理介绍"></a>1、动态代理介绍</h5><p><strong>动态代理是指在运行时动态生成代理类</strong>。即，代理类的字节码将在运行时生成并载入当前代理的 ClassLoader。与静态处理类相比，动态类有诸多好处。</p><p>①<strong>不需要为(RealSubject )写一个形式上完全一样的封装类</strong>，假如主题接口（Subject）中的方法很多，为每一个接口写一个代理方法也很麻烦。如果接口有变动，则目标对象和代理类都要修改，不利于系统维护；</p><p>②<strong>使用一些动态代理的生成方法甚至可以在运行时制定代理类的执行逻辑</strong>，从而大大提升系统的灵活性。</p><h6 id="2、动态代理涉及的主要类"><a href="#2、动态代理涉及的主要类" class="headerlink" title="2、动态代理涉及的主要类"></a>2、动态代理涉及的主要类</h6><p>主要涉及两个类，内部主要通过反射来实现的。</p><p><strong>java.lang.reflect.Proxy:</strong>这是生成代理类的主类，通过 Proxy 类生成的代理类都继承了 Proxy 类。<br>Proxy提供了用户创建动态代理类和代理对象的静态方法，它是所有动态代理类的父类。</p><p><strong>java.lang.reflect.InvocationHandler:</strong>这里称他为”调用处理器”，它是一个接口。当调用动态代理类中的方法时，将会直接转接到执行自定义的InvocationHandler中的invoke()方法。即我们动态生成的代理类需要完成的具体内容需要自己定义一个类，而这个类必须实现 InvocationHandler 接口，通过重写invoke()方法来执行具体内容。</p><p>Proxy提供了如下两个方法来创建动态代理类和动态代理实例。</p><blockquote><p>static Class<?> getProxyClass(ClassLoader loader, Class<?>… interfaces) 返回代理类的java.lang.Class对象。</p><p>第一个参数是类加载器对象（即哪个类加载器来加载这个代理类到 JVM 的方法区），</p><p>第二个参数是接口（表明你这个代理类需要实现哪些接口），</p><p>第三个参数是调用处理器类实例（指定代理类中具体要干什么），</p><p>该代理类将实现interfaces所指定的所有接口，执行代理对象的每个方法时都会被替换执行InvocationHandler对象的invoke方法。</p><p>static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) 返回代理类实例。参数与上述方法一致。</p></blockquote><p>对应上述两种方法创建动态代理对象的方式：</p><pre class=" language-hljs java">        <span class="hljs-comment"><code class="language-hljs java">        <span class="hljs-comment">//创建一个InvocationHandler对象</span>        InvocationHandler handler = <span class="hljs-keyword">new</span> MyInvocationHandler(.args..);        <span class="hljs-comment">//使用Proxy生成一个动态代理类</span>        Class proxyClass = Proxy.getProxyClass(RealSubject<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">getClassLoader</span>(),<span class="hljs-title">RealSubject</span>.<span class="hljs-title">class</span>.<span class="hljs-title">getInterfaces</span>(), <span class="hljs-title">handler</span>)</span>;        <span class="hljs-comment">//获取proxyClass类中一个带InvocationHandler参数的构造器</span>        Constructor constructor = proxyClass.getConstructor(InvocationHandler<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        <span class="hljs-comment">//调用constructor的newInstance方法来创建动态实例</span>        RealSubject real = (RealSubject)constructor.newInstance(handler);Copy        <span class="hljs-comment">//创建一个InvocationHandler对象</span>        InvocationHandler handler = <span class="hljs-keyword">new</span> MyInvocationHandler(.args..);        <span class="hljs-comment">//使用Proxy直接生成一个动态代理对象</span>        RealSubject real =Proxy.newProxyInstance(RealSubject<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">getClassLoader</span>(),<span class="hljs-title">RealSubject</span>.<span class="hljs-title">class</span>.<span class="hljs-title">getInterfaces</span>(), <span class="hljs-title">handler</span>)</span>;Copy</code></pre><p><strong>newProxyInstance这个方法实际上做了两件事：第一，创建了一个新的类【代理类】，这个类实现了Class[] interfaces中的所有接口，并通过你指定的ClassLoader将生成的类的字节码加载到JVM中，创建Class对象；第二，以你传入的InvocationHandler作为参数创建一个代理类的实例并返回。</strong></p><p>Proxy 类还有一些静态方法，比如：</p><p><code>InvocationHandler getInvocationHandler(Object proxy):</code>获得代理对象对应的调用处理器对象。</p><p><code>Class getProxyClass(ClassLoader loader, Class[] interfaces):</code>根据类加载器和实现的接口获得代理类。</p><p>InvocationHandler 接口中有方法：</p><p><code>invoke(Object proxy, Method method, Object[] args)</code><br>这个函数是在代理对象调用任何一个方法时都会调用的，方法不同会导致第二个参数method不同，第一个参数是代理对象（表示哪个代理对象调用了method方法），第二个参数是 Method 对象（表示哪个方法被调用了），第三个参数是指定调用方法的参数。</p><h5 id="3、动态代理模式的简单实现"><a href="#3、动态代理模式的简单实现" class="headerlink" title="3、动态代理模式的简单实现"></a>3、动态代理模式的简单实现</h5><pre class=" language-hljs java"><span class="hljs-comment"><code class="language-hljs java"><span class="hljs-comment">//1.创建目标对象</span><span class="hljs-comment">//2.创建调用处理器对象(指定代理类中具体要干什么,也用于处理代理对象的方法调用并返回结果)</span><span class="hljs-comment">//3.通过java 动态代理api创建代理对象(参数：真实类的类加载器，真实类的接口数组,调用处理器对象)</span><span class="hljs-comment">//4.调用代理对象实例的响应方法</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DynamicProxyDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//1.创建目标对象</span>        RealSubject realSubject = <span class="hljs-keyword">new</span> RealSubject();            <span class="hljs-comment">//2.创建调用处理器对象</span>        ProxyHandler handler = <span class="hljs-keyword">new</span> ProxyHandler(realSubject);           <span class="hljs-comment">//3.动态生成代理对象</span>        Subject proxySubject = (Subject)Proxy.newProxyInstance(RealSubject<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">getClassLoader</span>(),</span><span class="hljs-class">                                                        <span class="hljs-title">RealSubject</span>.<span class="hljs-title">class</span>.<span class="hljs-title">getInterfaces</span>(), <span class="hljs-title">handler</span>)</span>;           <span class="hljs-comment">//4.通过代理对象调用方法   </span>        proxySubject.request();        &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 主题接口</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Subject</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">request</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 目标对象类</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RealSubject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Subject</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">request</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">"====RealSubject Request===="</span>);    &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 代理类的调用处理器</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProxyHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InvocationHandler</span></span>&#123;    <span class="hljs-keyword">private</span> Subject subject;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ProxyHandler</span><span class="hljs-params">(Subject subject)</span></span>&#123;        <span class="hljs-keyword">this</span>.subject = subject;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span></span><span class="hljs-function">            <span class="hljs-keyword">throws</span> Throwable </span>&#123;        <span class="hljs-comment">//定义预处理的工作，当然你也可以根据 method 的不同进行不同的预处理工作</span>        System.out.println(<span class="hljs-string">"====before===="</span>);       <span class="hljs-comment">//调用RealSubject中的方法</span>        Object result = method.invoke(subject, args);        System.out.println(<span class="hljs-string">"====after===="</span>);        <span class="hljs-keyword">return</span> result;    &#125;&#125;</code></pre><p>可以看到，我们通过newProxyInstance就产生了一个Subject 的实例，即代理类的实例，然后就可以通过Subject .request()，就会调用InvocationHandler中的invoke()方法，传入方法Method对象，以及调用方法的参数，通过Method.invoke调用RealSubject中的方法的request()方法。同时可以在InvocationHandler中的invoke()方法加入其他执行逻辑。</p><h4 id="2-2-3-反射三"><a href="#2-2-3-反射三" class="headerlink" title="2.2.3 反射三"></a>2.2.3 反射三</h4><h5 id="一、泛型和Class类"><a href="#一、泛型和Class类" class="headerlink" title="一、泛型和Class类"></a>一、泛型和Class类</h5><p>从JDK 1.5 后，Java中引入泛型机制，Class类也增加了泛型功能，从而允许使用泛型来限制Class类，例如：String.class的类型实际上是Class<String>。如果Class对应的类暂时未知，则使用Class&lt;?&gt;(?是通配符)。通过反射中使用泛型，可以避免使用反射生成的对象需要强制类型转换。</p><p>泛型的好处众多，最主要的一点就是避免类型转换，防止出现ClassCastException，即类型转换异常。以下面程序为例：</p><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ObjectFactory</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">getInstance</span><span class="hljs-params">(String name)</span></span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//创建指定类对应的Class对象</span>            Class cls = Class.forName(name);            <span class="hljs-comment">//返回使用该Class对象创建的实例</span>            <span class="hljs-keyword">return</span> cls.newInstance();        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException | InstantiationException | IllegalAccessException e) &#123;            e.printStackTrace();            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;    &#125;&#125;Copy</code></pre><p>上面程序是个工厂类，通过指定的字符串创建Class对象并创建一个类的实例对象返回。但是这个对象的类型是Object对象，取出实例后需要强制类型转换。<br>如下例：</p><pre class=" language-hljs java">Date date = (Date) ObjectFactory.getInstance(<span class="hljs-string"><code class="language-hljs java">Date date = (Date) ObjectFactory.getInstance(<span class="hljs-string">"java.util.Date"</span>);Copy</code></pre><p>或者如下：</p><pre class=" language-hljs java">String string = (String) ObjectFactory.getInstance(<span class="hljs-string"><code class="language-hljs java">String string = (String) ObjectFactory.getInstance(<span class="hljs-string">"java.util.Date"</span>);Copy</code></pre><p>上面代码在编译时不会有任何问题，但是运行时将抛出ClassCastException异常，因为程序试图将一个Date对象转换成String对象。</p><p>但是泛型的出现后，就可以避免这种情况。</p><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ObjectFactory</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <T> <span class="hljs-function">T <span class="hljs-title">getInstance</span><span class="hljs-params">(Class<T> cls)</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">// 返回使用该Class对象创建的实例</span>            <span class="hljs-keyword">return</span> cls.newInstance();        &#125; <span class="hljs-keyword">catch</span> (InstantiationException | IllegalAccessException e) &#123;            e.printStackTrace();            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;    &#125;&#125;Copy</code></pre><p>在上面程序的getInstance()方法中传入一个Class<T>参数，这是一个泛型化的Class对象，调用该Class对象的newInstance()方法将返回一个T对象。</p><pre class=" language-hljs java">String instance = ObjectFactory.getInstance(String<span class="hljs-class">.<span class="hljs-keyword"><code class="language-hljs java">String instance = ObjectFactory.getInstance(String<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;Copy</code></pre><p>通过传入<code>String.class</code>便知道T代表String，所以返回的对象是String类型的，避免强制类型转换。</p><p>当然Class类引入泛型的好处不止这一点，在以后的实际应用中会更加能体会到。</p><h5 id="二、使用反射来获取泛型信息"><a href="#二、使用反射来获取泛型信息" class="headerlink" title="二、使用反射来获取泛型信息"></a>二、使用反射来获取泛型信息</h5><p>通过指定类对应的 Class 对象，可以获得该类里包含的所有 Field，不管该 Field 是使用 private 修饰，还是使用 public 修饰。获得了 Field 对象后，就可以很容易地获得该 Field 的数据类型，即使用如下代码即可获得指定 Field 的类型。</p><pre class=" language-hljs java"><span class="hljs-comment"><code class="language-hljs java"><span class="hljs-comment">// 获取 Field 对象 f 的类型</span>Class<?> a = f.getType();Copy</code></pre><p>但这种方式只对普通类型的 Field 有效。如果该 Field 的类型是有泛型限制的类型，如 Map&lt;String, Integer&gt; 类型，则不能准确地得到该 Field 的泛型参数。</p><p>为了获得指定 Field 的泛型类型，应先使用如下方法来获取指定 Field 的类型。</p><pre class=" language-hljs java"><span class="hljs-comment"><code class="language-hljs java"><span class="hljs-comment">// 获得 Field 实例的泛型类型</span>Type type = f.getGenericType();Copy</code></pre><p>然后将 Type 对象强制类型转换为 ParameterizedType 对象，ParameterizedType 代表被参数化的类型，也就是增加了泛型限制的类型。ParameterizedType 类提供了如下两个方法。</p><p><strong>getRawType()：</strong>返回没有泛型信息的原始类型。</p><p><strong>getActualTypeArguments()：</strong>返回泛型参数的类型。</p><p>下面是一个获取泛型类型的完整程序。</p><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenericTest</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-keyword">private</span> Map<String , Integer> score;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span><span class="hljs-function">        <span class="hljs-keyword">throws</span> Exception</span><span class="hljs-function">    </span>&#123;        Class<GenericTest> clazz = GenericTest<span class="hljs-class">.<span class="hljs-keyword">class</span></span>;        Field f = clazz.getDeclaredField(<span class="hljs-string">"score"</span>);        <span class="hljs-comment">// 直接使用getType()取出Field类型只对普通类型的Field有效</span>        Class<?> a = f.getType();        <span class="hljs-comment">// 下面将看到仅输出java.util.Map</span>        System.out.println(<span class="hljs-string">"score的类型是:"</span> + a);        <span class="hljs-comment">// 获得Field实例f的泛型类型</span>        Type gType = f.getGenericType();        <span class="hljs-comment">// 如果gType类型是ParameterizedType对象</span>        <span class="hljs-keyword">if</span>(gType <span class="hljs-keyword">instanceof</span> ParameterizedType)        &#123;            <span class="hljs-comment">// 强制类型转换</span>            ParameterizedType pType = (ParameterizedType)gType;            <span class="hljs-comment">// 获取原始类型</span>            Type rType = pType.getRawType();            System.out.println(<span class="hljs-string">"原始类型是："</span> + rType);            <span class="hljs-comment">// 取得泛型类型的泛型参数</span>            Type[] tArgs = pType.getActualTypeArguments();            System.out.println(<span class="hljs-string">"泛型类型是:"</span>);            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i < tArgs.length; i++)             &#123;                System.out.println(<span class="hljs-string">"第"</span> + i + <span class="hljs-string">"个泛型类型是："</span> + tArgs[i]);            &#125;        &#125;        <span class="hljs-keyword">else</span>        &#123;            System.out.println(<span class="hljs-string">"获取泛型类型出错！"</span>);        &#125;    &#125;&#125;Copy</code></pre><p>输出结果：</p><blockquote><p>score 的类型是: interface java.util.Map<br>原始类型是: interface java.util.Map<br>泛型类型是:<br>第 0 个泛型类型是: class java.lang.String<br>第 1 个泛型类型是：class java.lang.Integer</p></blockquote><p>从上面的运行结果可以看出，直接使用 Field 的 getType() 方法只能获取普通类型的 Field 的数据类型：对于增加了泛型参数的类型的 Field，应该使用 getGenericType() 方法来取得其类型。</p><p>Type 也是 java.lang.reflect 包下的一个接口，该接口代表所有类型的公共高级接口，Class 是 Type 接口的实现类。Type 包括原始类型、参数化类型、数组类型、类型变量和基本类型等。</p><h3 id="2-3-注解"><a href="#2-3-注解" class="headerlink" title="2.3 注解"></a>2.3 注解</h3><h5 id="一、元数据"><a href="#一、元数据" class="headerlink" title="一、元数据"></a>一、元数据</h5><p>要想理解注解（Annotation）的作用，就要先理解Java中元数据的概念。</p><h5 id="1-元数据概念"><a href="#1-元数据概念" class="headerlink" title="1.元数据概念"></a>1.元数据概念</h5><p>元数据是关于数据的数据。在编程语言上下文中，元数据是添加到程序元素如方法、字段、类和包上的额外信息。对数据进行说明描述的数据。</p><h5 id="2-元数据的作用"><a href="#2-元数据的作用" class="headerlink" title="2.元数据的作用"></a>2.元数据的作用</h5><p>一般来说，元数据可以用于创建文档（根据程序元素上的注释创建文档），跟踪代码中的依赖性（可声明方法是重载，依赖父类的方法），执行编译时检查（可声明是否编译期检测），代码分析。<br>如下：<br>1） 编写文档：通过代码里标识的元数据生成文档　　<br>2）代码分析：通过代码里标识的元数据对代码进行分析　　<br>3）编译检查：通过代码里标识的元数据让编译器能实现基本的编译检查</p><h6 id="3-Java平台元数据"><a href="#3-Java平台元数据" class="headerlink" title="3.Java平台元数据"></a>3.Java平台元数据</h6><p>注解Annotation就是java平台的元数据，是 J2SE5.0新增加的功能，该机制允许在Java 代码中添加自定义注释，并允许通过反射（reflection），以编程方式访问元数据注释。通过提供为程序元素（类、方法等）附加额外数据的标准方法，元数据功能具有简化和改进许多应用程序开发领域的潜在能力，其中包括配置管理、框架实现和代码生成。</p><h5 id="二、注解（Annotation）"><a href="#二、注解（Annotation）" class="headerlink" title="二、注解（Annotation）"></a>二、注解（Annotation）</h5><h5 id="1-注解（Annotation）的概念"><a href="#1-注解（Annotation）的概念" class="headerlink" title="1.注解（Annotation）的概念"></a>1.注解（Annotation）的概念</h5><p>注解(Annotation)在JDK1.5之后增加的一个新特性，注解的引入意义很大，有很多非常有名的框架，比如Hibernate、Spring等框架中都大量使用注解。注解作为程序的元数据嵌入到程序。注解可以被解析工具或编译工具解析。</p><p>关于注解（Annotation）的作用，其实就是上述元数据的作用。</p><p><strong>注意：Annotation能被用来为程序元素（类、方法、成员变量等）设置元素据。Annotaion不影响程序代码的执行，无论增加、删除Annotation，代码都始终如一地执行。如果希望让程序中的Annotation起一定的作用，只有通过解析工具或编译工具对Annotation中的信息进行解析和处理。</strong></p><h5 id="2-内建注解"><a href="#2-内建注解" class="headerlink" title="2.内建注解"></a>2.内建注解</h5><p>Java提供了多种内建的注解，下面接下几个比较常用的注解：@Override、@Deprecated、@SuppressWarnings以及@FunctionalInterface这4个注解。内建注解主要实现了元数据的第二个作用：<strong>编译检查</strong>。</p><p><strong>@Override</strong><br>用途：用于告知编译器，我们需要覆写超类的当前方法。如果某个方法带有该注解但并没有覆写超类相应的方法，则编译器会生成一条错误信息。如果父类没有这个要覆写的方法，则编译器也会生成一条错误信息。</p><p>@Override可适用元素为方法，仅仅保留在java源文件中。</p><p><strong>@Deprecated</strong><br>用途：使用这个注解，用于告知编译器，某一程序元素(比如方法，成员变量)不建议使用了（即过时了）。<br>例如：<br>Person类中的info()方法使用<code>@Deprecated</code>表示该方法过时了。</p><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;    <span class="hljs-meta">@Deprecated</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">info</span><span class="hljs-params">()</span></span>&#123;    &#125;&#125;Copy</code></pre><p>调用info()方法会编译器会出现警告，告知该方法已过时。</p><p><img src="https://codingsky.oss-cn-hangzhou.aliyuncs.com/androidos/articles/content/convert/f9d6ee7ca4a451ef3cbd778f07ed3a0a.dat" srcset="/img/loading.gif" alt="img"><br>注解类型分析：<code>@Deprecated</code>可适合用于除注解类型声明之外的所有元素，保留时长为运行时。</p><p><strong>@SuppressWarnings</strong><br>用途：用于告知编译器忽略特定的警告信息，例在泛型中使用原生数据类型，编译器会发出警告，当使用该注解后，则不会发出警告。</p><p>注解类型分析： <code>@SuppressWarnings</code>可适合用于除注解类型声明和包名之外的所有元素，仅仅保留在java源文件中。</p><p>该注解有方法value(）,可支持多个字符串参数，用户指定忽略哪种警告，例如：</p><pre class=" language-hljs java"><span class="hljs-meta">@SupressWarning</span>(value=&#123;<span class="hljs-string">"uncheck"</span>,<span class="hljs-string"><code class="language-hljs java"><span class="hljs-meta">@SupressWarning</span>(value=&#123;<span class="hljs-string">"uncheck"</span>,<span class="hljs-string">"deprecation"</span>&#125;)Copy</code></pre><p><img src="https://codingsky.oss-cn-hangzhou.aliyuncs.com/androidos/articles/content/convert/5bd891da357a1984c07ee50c32061100.dat" srcset="/img/loading.gif" alt="img"></p><p><strong>@FunctionalInterface</strong><br>用途：用户告知编译器，检查这个接口，保证该接口是函数式接口，即只能包含一个抽象方法，否则就会编译出错。</p><p>注解类型分析： <code>@FunctionalInterface</code>可适合用于注解类型声明，保留时长为运行时。</p><h5 id="3-元Annotation"><a href="#3-元Annotation" class="headerlink" title="3.元Annotation"></a>3.元Annotation</h5><p>JDK除了在java.lang提供了上述内建注解外，还在java.lang。annotation包下提供了6个Meta Annotation(元Annotataion)，其中有5个元Annotation都用于修饰其他的Annotation定义。其中@Repeatable专门用户定义Java 8 新增的可重复注解。</p><p>我们先介绍其中4个常用的修饰其他Annotation的元Annotation。在此之前，我们先了解如何自定义Annotation。</p><p><strong>当一个接口直接继承java.lang.annotation.Annotation接口时，仍是接口，而并非注解。要想自定义注解类型，只能通过@interface关键字的方式，其实通过该方式会隐含地继承.Annotation接口。</strong></p><p><strong>@Documented</strong></p><p><code>@Documented</code>用户指定被该元Annotation修饰的Annotation类将会被javadoc工具提取成文档，如果定义Annotation类时使用了<code>@Documented</code>修饰，则所有使用该Annotation修饰的程序元素的API文档中将会包含该Annotation说明。</p><p>例如：</p><pre class=" language-hljs java"><span class="hljs-meta"><code class="language-hljs java"><span class="hljs-meta">@Documented</span><span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)<span class="hljs-meta">@Target</span>(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE&#125;)<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Deprecated &#123;&#125;Copy</code></pre><p>定义<code>@Deprecated</code>时使用了<code>@Documented</code>，则任何元素使用@Deprecated修饰时，在生成API文档时，将会包含<code>@Deprecated</code>的说明<br>以下是String的一个过时的构造方法：</p><pre class=" language-hljs java"><span class="hljs-meta"><code class="language-hljs java"><span class="hljs-meta">@Deprecated</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">String</span><span class="hljs-params">(<span class="hljs-keyword">byte</span>[] ascii,<span class="hljs-keyword">int</span> hibyte,<span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">int</span> count)</span></span><span class="hljs-function">Copy</span></code></pre><p>该注解实现了元数据的第一个功能：<strong>编写文档</strong>。</p><p><strong>@Inherited</strong></p><p><code>@Inherited</code>指定被它修饰的Annotation将具有继承性——如果某个类使用了@Xxx注解（定义该Annotation时使用了<code>@Inherited</code>修饰）修饰，则其子类将自动被@Xxx修饰。</p><p><strong>@Retention</strong></p><p><code>@Retention</code>：表示该注解类型的注解保留的时长。当注解类型声明中没有<code>@Retention</code>元注解，则默认保留策略为RetentionPolicy.CLASS。关于保留策略(RetentionPolicy)是枚举类型，共定义3种保留策略，如下表：<br><img src="https://codingsky.oss-cn-hangzhou.aliyuncs.com/androidos/articles/content/convert/aac7770741abf78a3e25c1f65382b20f.dat" srcset="/img/loading.gif" alt="img"></p><p><strong>@Target</strong></p><p><code>@Target</code>：表示该注解类型的所适用的程序元素类型。当注解类型声明中没有<code>@Target</code>元注解，则默认为可适用所有的程序元素。如果存在指定的<code>@Target</code>元注解，则编译器强制实施相应的使用限制。关于程序元素(ElementType)是枚举类型，共定义8种程序元素，如下表：<br><img src="https://codingsky.oss-cn-hangzhou.aliyuncs.com/androidos/articles/content/convert/106ab8035d6585f1897eb967aa8e8bdf.dat" srcset="/img/loading.gif" alt="img"></p><h5 id="三、自定义注解（Annotation）"><a href="#三、自定义注解（Annotation）" class="headerlink" title="三、自定义注解（Annotation）"></a>三、自定义注解（Annotation）</h5><p>创建自定义注解，与创建接口有几分相似，但注解需要以@开头。</p><pre class=" language-hljs java"><span class="hljs-meta"><code class="language-hljs java"><span class="hljs-meta">@Documented</span><span class="hljs-meta">@Target</span>(ElementType.METHOD)<span class="hljs-meta">@Inherited</span><span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MyAnnotataion&#123;    <span class="hljs-function">String <span class="hljs-title">name</span><span class="hljs-params">()</span></span>;    <span class="hljs-function">String <span class="hljs-title">website</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> "hello"</span>;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">revision</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> 1</span>;&#125;Copy</code></pre><p><strong>自定义注解中定义成员变量的规则：</strong></p><p>其定义是以无形参的方法形式来声明的。即：<br>注解方法不带参数，比如name()，website()；<br>注解方法返回值类型：基本类型、String、Enums、Annotation以及前面这些类型的数组类型<br>注解方法可有默认值，比如default “hello”，默认website=”hello”</p><p><strong>当然注解中也可以不存在成员变量，在使用解析注解进行操作时，仅以是否包含该注解来进行操作。当注解中有成员变量时，若没有默认值，需要在使用注解时，指定成员变量的值。</strong></p><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnnotationDemo</span> </span>&#123;    <span class="hljs-meta">@MyAnnotataion</span>(name=<span class="hljs-string">"lvr"</span>, website=<span class="hljs-string">"hello"</span>, revision=<span class="hljs-number">1</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        System.out.println(<span class="hljs-string">"I am main method"</span>);    &#125;    <span class="hljs-meta">@SuppressWarnings</span>(&#123; <span class="hljs-string">"unchecked"</span>, <span class="hljs-string">"deprecation"</span> &#125;)    <span class="hljs-meta">@MyAnnotataion</span>(name=<span class="hljs-string">"lvr"</span>, website=<span class="hljs-string">"hello"</span>, revision=<span class="hljs-number">2</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">demo</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">"I am demo method"</span>);    &#125;&#125;Copy</code></pre><p>由于该注解的保留策略为<code>RetentionPolicy.RUNTIME</code>，故可在运行期通过反射机制来使用，否则无法通过反射机制来获取。这时候注解实现的就是元数据的第二个作用：<strong>代码分析</strong>。<br>下面来具体介绍如何通过反射机制来进行注解解析。</p><h5 id="四、注解解析"><a href="#四、注解解析" class="headerlink" title="四、注解解析"></a>四、注解解析</h5><p>接下来，通过反射技术来解析自定义注解。关于反射类位于包java.lang.reflect，其中有一个接口AnnotatedElement，该接口主要有如下几个实现类：Class，Constructor，Field，Method，Package。除此之外，该接口定义了注释相关的几个核心方法，如下：<br><img src="https://codingsky.oss-cn-hangzhou.aliyuncs.com/androidos/articles/content/convert/1f1ae034be73c0272360b9fd9d9dd7c6.dat" srcset="/img/loading.gif" alt="img"><br>因此，当获取了某个类的Class对象，然后获取其Field,Method等对象，通过上述4个方法提取其中的注解，然后获得注解的详细信息。</p><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnnotationParser</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> SecurityException, ClassNotFoundException </span>&#123;        String clazz = <span class="hljs-string">"com.lvr.annotation.AnnotationDemo"</span>;        Method[]  demoMethod = AnnotationParser<span class="hljs-class">.<span class="hljs-keyword">class</span></span><span class="hljs-class">                .<span class="hljs-title">getClassLoader</span>().<span class="hljs-title">loadClass</span>(<span class="hljs-title">clazz</span>).<span class="hljs-title">getMethods</span>()</span>;        <span class="hljs-keyword">for</span> (Method method : demoMethod) &#123;            <span class="hljs-keyword">if</span> (method.isAnnotationPresent(MyAnnotataion<span class="hljs-class">.<span class="hljs-keyword">class</span>)) </span>&#123;                 MyAnnotataion annotationInfo = method.getAnnotation(MyAnnotataion<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;                 System.out.println(<span class="hljs-string">"method: "</span>+ method);                 System.out.println(<span class="hljs-string">"name= "</span>+ annotationInfo.name() +                         <span class="hljs-string">" , website= "</span>+ annotationInfo.website()                        + <span class="hljs-string">" , revision= "</span>+annotationInfo.revision());            &#125;        &#125;    &#125;&#125;Copy</code></pre><p>以上仅是一个示例，其实可以根据拿到的注解信息做更多有意义的事。</p><h3 id="2-4-泛型"><a href="#2-4-泛型" class="headerlink" title="2.4 泛型"></a>2.4 泛型</h3><h5 id="一、泛型简介"><a href="#一、泛型简介" class="headerlink" title="一、泛型简介"></a>一、泛型简介</h5><h5 id="1-引入泛型的目的"><a href="#1-引入泛型的目的" class="headerlink" title="1.引入泛型的目的"></a>1.引入泛型的目的</h5><p><strong>泛型的目的：</strong> Java 泛型就是把一种语法糖，通过泛型使得在编译阶段完成一些类型转换的工作，避免在运行时强制类型转换而出现<code>ClassCastException</code>，即类型转换异常。</p><p>在泛型（Generic type或Generics）出现之前，是这么写代码的：</p><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span><span class="hljs-function"></span>&#123;    List list = <span class="hljs-keyword">new</span> ArrayList();    list.add(<span class="hljs-string">"123"</span>);    list.add(<span class="hljs-string">"456"</span>);    System.out.println((String)list.get(<span class="hljs-number">0</span>));&#125;Copy</code></pre><p>这么写会有两个问题：</p><p>1、当一个对象放入集合时，集合不会记住此对象的类型，当再次从集合中取出此对象时，该对象的编译类型变成了Object。</p><p>2、运行时需要人为地强制转换类型到具体目标。</p><h5 id="2-泛型的好处"><a href="#2-泛型的好处" class="headerlink" title="2.泛型的好处"></a>2.泛型的好处</h5><p>①类型安全。类型错误现在在编译期间就被捕获到了，而不是在运行时当作java.lang.ClassCastException展示出来，将类型检查从运行时挪到编译时有助于开发者更容易找到错误，并提高程序的可靠性。</p><p>②消除了代码中许多的强制类型转换，增强了代码的可读性。</p><p>//③为较大的优化带来了可能。</p><h5 id="二、泛型的使用"><a href="#二、泛型的使用" class="headerlink" title="二、泛型的使用"></a>二、泛型的使用</h5><h6 id="1-泛型类和泛型接口"><a href="#1-泛型类和泛型接口" class="headerlink" title="1.泛型类和泛型接口"></a>1.泛型类和泛型接口</h6><p>这就是<strong>泛型的实质：允许在定义接口、类时声明类型形参，类型形参在整个接口、类体内可当成类型使用，几乎所有可使用普通类型的地方都可以使用这种类型形参。</strong></p><p>下面具体讲解泛型类的使用。泛型接口的使用与泛型类几乎相同，可以比对自行学习。</p><p><strong>泛型类</strong>、泛型接口</p><p><strong>泛型类派生子类</strong></p><h6 id="2-泛型的方法"><a href="#2-泛型的方法" class="headerlink" title="2.泛型的方法"></a>2.泛型的方法</h6><p>在另外一些情况下，在类、接口中没有使用泛型时，定义方法时想定义类型形参，就会使用泛型方法。如下方式：</p><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span></span>&#123;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <T> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">out</span><span class="hljs-params">(T t)</span></span>&#123;       System.out.println(t);  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;       out(<span class="hljs-string">"hansheng"</span>);       out(<span class="hljs-number">123</span>);  &#125;&#125;Copy</code></pre><p><strong>所谓泛型方法，就是在声明方法时定义一个或多个类型形参。</strong> 泛型方法的用法格式如下：</p><pre class=" language-hljs java"><code class="language-hljs java">修饰符<T, S> 返回值类型 方法名（形参列表）｛   方法体｝</code></pre><p><strong>注意：</strong> 方法声明中定义的形参只能在该方法里使用，而接口、类声明中定义的类型形参则可以在整个接口、类中使用。</p><h6 id="3-泛型构造器"><a href="#3-泛型构造器" class="headerlink" title="3.泛型构造器"></a>3.泛型构造器</h6><h5 id="三、类型通配符-通配泛型"><a href="#三、类型通配符-通配泛型" class="headerlink" title="三、类型通配符(通配泛型)"></a>三、类型通配符(通配泛型)</h5><p>使用通配符的目的是来对一个泛型类型指定范围。</p><p>类型通配符是一个问号（？)，将一个问号作为类型实参传给List集合，写作：<code>List</code>（意思是元素类型未知的List）。这个问号（？）被成为通配符，它的元素类型可以匹配任何类型。</p><p><strong>为什么需要通配泛型？</strong></p><pre class=" language-hljs java"><span class="hljs-comment"><code class="language-hljs java"><span class="hljs-comment">//这个方法你传GenericStack<Integer> 这种类型的实参过去会报错</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> <span class="hljs-title">max</span><span class="hljs-params">(GenericStack<Number> stack)</span></span>&#123;....&#125;<span class="hljs-comment">//为了解决这个问题，可以用通配泛型</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> <span class="hljs-title">max</span><span class="hljs-params">(GenericStack<? extends Number> stack)</span></span>&#123;....&#125;</code></pre><h6 id="带限（受限）通配符"><a href="#带限（受限）通配符" class="headerlink" title="带限（受限）通配符"></a>带限（受限）通配符</h6><h5 id="1-上限通配符"><a href="#1-上限通配符" class="headerlink" title="1.上限通配符"></a>1.上限通配符</h5><h5 id="2-下限通配符"><a href="#2-下限通配符" class="headerlink" title="2.下限通配符"></a>2.下限通配符</h5><h5 id="四、类型擦除"><a href="#四、类型擦除" class="headerlink" title="四、类型擦除"></a>四、类型擦除</h5><pre class=" language-hljs java">Class c1=<span class="hljs-keyword"><code class="language-hljs java">Class c1=<span class="hljs-keyword">new</span> ArrayList<Integer>().getClass();Class c2=<span class="hljs-keyword">new</span> ArrayList<String>().getClass();System.out.println(c1==c2);Copy</code></pre><p>程序输出：</p><blockquote><p>true。</p></blockquote><p>这是因为不管为泛型的类型形参传入哪一种类型实参，对于Java来说，它们依然被当成同一类处理，在内存中也只占用一块内存空间。从Java泛型这一概念提出的目的来看，其只是作用于代码编译阶段，在编译过程中，对于正确检验泛型结果后，会将泛型的相关信息擦出，也就是说，成功编译过后的class文件中是不包含任何泛型信息的。泛型信息不会进入到运行时阶段。</p><p><strong>在静态方法、静态初始化块或者静态变量的声明和初始化中不允许使用类型形参。由于系统中并不会真正生成泛型类，所以instanceof运算符后不能使用泛型类。</strong></p><ul><li><p>不管实际的具体类型是什么，泛型类被它的所有实例所共享，因此上面返回true</p></li><li><p>当编译泛型类、接口、方法时，编译器用Object类型代替泛型类型</p></li><li><p>如果一个泛型类是受限的，编译器就用该受限类型替换它</p></li></ul><p>注:</p><ul><li>在静态方法、数据域或初始化语句中为类引用泛型类型参数是非法的。</li></ul><pre class=" language-hljs cpp"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title"><code class="language-hljs cpp"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span><E>&#123;</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> E o1;<span class="hljs-comment">//非法</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m</span><span class="hljs-params">(E o1)</span></span>&#123;&#125;<span class="hljs-comment">//非法</span><span class="hljs-keyword">static</span>&#123;E o2;<span class="hljs-comment">//非法</span>&#125;&#125;</code></pre><ul><li>异常类是不能使用泛型的</li><li>不能使用new E():因为运行时泛型类型E是不可用的</li></ul><h3 id="2-5-异常"><a href="#2-5-异常" class="headerlink" title="2.5 异常"></a>2.5 异常</h3><h4 id="Java异常简介"><a href="#Java异常简介" class="headerlink" title="Java异常简介"></a>Java异常简介</h4><p>异常处理使得程序可以处理非预期的情景，并且继续正常的处理。异常是对象，根类是java.lang.Throwable。</p><p><strong>根本优势</strong>：将检测错误从处理错误中分离出来。</p><p>Java异常机制用到的几个关键字：<strong>try、catch、finally、throw、throws。</strong></p><p>• <strong>try</strong> – 用于监听。将要被监听的代码(可能抛出异常的代码)放在try语句块之内，当try语句块内发生异常时，异常就被抛出。</p><p>• <strong>catch</strong> – 用于捕获异常。catch用来捕获try语句块中发生的异常。</p><p>• <strong>finally</strong> – finally语句块总是会被执行。它主要用于回收在try块里打开的物理资源(如数据库连接、网络连接和磁盘文件)。只有finally块执行完成之后，才会回来执行try或者catch块中的return或者throw语句，如果finally中使用了return或者throw等终止方法的语句，则就不会跳回执行，直接停止。</p><p>• <strong>throw</strong> – 用于抛出异常。</p><p>• <strong>throws</strong> – 用在方法签名中，用于声明该方法可能抛出的异常。</p><h4 id="Java异常类型"><a href="#Java异常类型" class="headerlink" title="Java异常类型"></a>Java异常类型</h4><p><img src="https://codingsky.oss-cn-hangzhou.aliyuncs.com/androidos/articles/content/convert/740a7e3142c82e081dd7972366895fb9.jpg" srcset="/img/loading.gif" alt="img"></p><p><strong>1. Throwable</strong></p><p>Throwable是 Java 语言中所有错误或异常的超类。</p><p>Throwable包含两个子类: <strong>Error</strong> 和 <strong>Exception</strong>。它们通常用于指示发生了异常情况。</p><p>Throwable包含了其线程创建时线程执行堆栈的快照，它提供了printStackTrace()等接口用于获取堆栈跟踪数据等信息。</p><p>Java将可抛出(Throwable)的结构分为三种类型：<strong>被检查的异常(Checked Exception)，运行时异常(RuntimeException)和错误(Error)。</strong></p><p><strong>(01) 运行时异常</strong> <strong>定义</strong>: RuntimeException及其子类都被称为运行时异常，描述的是程序设计错误。</p><p><strong>特点</strong>: Java编译器不会检查它。也就是说，当程序中可能出现这类异常时，倘若既”没有通过throws声明抛出它”，也”没有用try-catch语句捕获它”，还是会编译通过。例如，除数为零时产生的ArithmeticException异常，数组越界时产生的IndexOutOfBoundsException异常，fail-fast机制产生的ConcurrentModificationException异常等，都属于运行时异常。</p><p>虽然Java编译器不会检查运行时异常，但是我们也可以通过throws进行声明抛出，也可以通过try-catch对它进行捕获处理。</p><p>如果产生运行时异常，则需要通过修改代码来进行避免。例如，若会发生除数为零的情况，则需要通过代码避免该情况的发生！</p><p><strong>(02) Exception</strong></p><p><strong>定义</strong>: Exception类本身，以及Exception的子类中除了”运行时异常”之外的其它子类都属于被检查异常，描述的是由程序和外部环境所引起的错误，能被程序捕获和处理。</p><p><strong>特点</strong>: Java编译器会检查它。此类异常，要么通过throws进行声明抛出，要么通过try-catch进行捕获处理，否则不能通过编译。例如，CloneNotSupportedException就属于被检查异常。当通过clone()接口去克隆一个对象，而该对象对应的类没有实现Cloneable接口，就会抛出CloneNotSupportedException异常。</p><p>被检查异常通常都是可以恢复的。</p><p><strong>(03) 系统错误</strong></p><p><strong>定义</strong>: 是由Java虚拟机抛出的，用Error类表示，描述的是内部系统错误。很少发生。</p><p><strong>特点</strong>: 和运行时异常一样，编译器也不会对错误进行检查。</p><p>当资源不足、约束失败、或是其它程序无法继续运行的条件发生时，就产生错误。程序本身无法修复这些错误的。例如，VirtualMachineError就属于错误。</p><p><strong>RuntimeException、Error以及它们的子类都称为免检异常(unchecked exception)</strong>。所有其他异常都称为必检异常，意思是编译器会强制程序员检查并通过try-catch块处理它们，或者在方法头声明。</p><p>多数情况下，免检异常都会反映出程序设计上的不可恢复的逻辑错误。</p><h4 id="何时使用异常"><a href="#何时使用异常" class="headerlink" title="何时使用异常?"></a>何时使用异常?</h4><p>当错误需要被方法的使用者处理的时候，方法应该抛出一个异常。</p><h4 id="异常面试题"><a href="#异常面试题" class="headerlink" title="异常面试题"></a>异常面试题</h4><h5 id="try-catch-finally-和-return-，finallize"><a href="#try-catch-finally-和-return-，finallize" class="headerlink" title="try catch finally 和 return ，finallize?"></a>try catch finally 和 return ，finallize?</h5><ul><li>finally中有return 则胡烈 try 和catch中的return</li><li>finally中没有return，则finally中执行完后再执行try中的return</li><li>try必须有，catch或finally可以没有</li></ul><p>finallize:是Object的方法，在垃圾回收器执行时会调用被回收对象的finalize方法。一旦垃圾回收器准备好释放对象占用的空间，将首先调用其fianllize方法，并且在下一次垃圾回收动作发生时，才会真正回收对象占用的内存。</p><h5 id="异常处理的原理是什么？"><a href="#异常处理的原理是什么？" class="headerlink" title="异常处理的原理是什么？"></a>异常处理的原理是什么？</h5><h3 id="2-6-IO"><a href="#2-6-IO" class="headerlink" title="2.6 IO"></a>2.6 IO</h3><h3 id="2-7-NIO"><a href="#2-7-NIO" class="headerlink" title="2.7 NIO"></a>2.7 NIO</h3><h3 id="2-8-集合框架"><a href="#2-8-集合框架" class="headerlink" title="2.8 集合框架"></a>2.8 集合框架</h3><p>Map</p><p>List</p><p>Set</p><h3 id="2-9-新特性"><a href="#2-9-新特性" class="headerlink" title="2.9 新特性"></a>2.9 新特性</h3><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h4><p>毫无疑问，<a href="http://www.oracle.com/technetwork/java/javase/8train-relnotes-latest-2153846.html" target="_blank" rel="noopener">Java 8</a>是Java自Java 5（发布于2004年）之后的最重要的版本。这个版本包含语言、编译器、库、工具和JVM等方面的十多个新特性。在本文中我们将学习这些新特性，并用实际的例子说明在什么场景下适合使用。</p><p>这个教程包含Java开发者经常面对的几类问题：</p><ul><li>语言</li><li>编译器</li><li>库</li><li>工具</li><li>运行时（JVM）</li></ul><h4 id="2-Java语言的新特性"><a href="#2-Java语言的新特性" class="headerlink" title="2. Java语言的新特性"></a>2. Java语言的新特性</h4><p>Java 8是Java的一个重大版本，有人认为，虽然这些新特性领Java开发人员十分期待，但同时也需要花不少精力去学习。在这一小节中，我们将介绍Java 8的大部分新特性。</p><h5 id="2-1-Lambda表达式和函数式接口"><a href="#2-1-Lambda表达式和函数式接口" class="headerlink" title="2.1 Lambda表达式和函数式接口"></a>2.1 Lambda表达式和函数式接口</h5><p>Lambda表达式（也称为闭包）是Java 8中最大和最令人期待的语言改变。它允许我们将函数当成参数传递给某个方法，或者把代码本身当作数据处理：函数式开发者非常熟悉这些概念。很多JVM平台上的语言（Groovy、Scala等）从诞生之日就支持Lambda表达式，但是Java开发者没有选择，只能使用匿名内部类代替Lambda表达式。</p><p>Lambda的设计耗费了很多时间和很大的社区力量，最终找到一种折中的实现方案，可以实现简洁而紧凑的语言结构。最简单的Lambda表达式可由逗号分隔的参数列表、<strong>-&gt;</strong>符号和语句块组成，例如：</p><pre class=" language-hljs java">Arrays.asList( <span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string"><code class="language-hljs java">Arrays.asList( <span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"d"</span> ).forEach( e -> System.out.println( e ) );Copy</code></pre><p>在上面这个代码中的参数<strong>e</strong>的类型是由编译器推理得出的，你也可以显式指定该参数的类型，例如：</p><pre class=" language-hljs java">Arrays.asList( <span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string"><code class="language-hljs java">Arrays.asList( <span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"d"</span> ).forEach( ( String e ) -> System.out.println( e ) );Copy</code></pre><p>如果Lambda表达式需要更复杂的语句块，则可以使用花括号将该语句块括起来，类似于Java中的函数体，例如：</p><pre class=" language-hljs java">Arrays.asList( <span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string"><code class="language-hljs java">Arrays.asList( <span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"d"</span> ).forEach( e -> &#123;    System.out.print( e );    System.out.print( e );&#125; );Copy</code></pre><p>Lambda表达式可以引用类成员和局部变量（会将这些变量隐式得转换成<strong>final</strong>的），例如下列两个代码块的效果完全相同：</p><pre class=" language-hljs java">String separator = <span class="hljs-string"><code class="language-hljs java">String separator = <span class="hljs-string">","</span>;Arrays.asList( <span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"d"</span> ).forEach(     ( String e ) -> System.out.print( e + separator ) );Copy</code></pre><p>和</p><pre class=" language-hljs java"><span class="hljs-keyword">final</span> String separator = <span class="hljs-string"><code class="language-hljs java"><span class="hljs-keyword">final</span> String separator = <span class="hljs-string">","</span>;Arrays.asList( <span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"d"</span> ).forEach(     ( String e ) -> System.out.print( e + separator ) );Copy</code></pre><p>Lambda表达式有返回值，返回值的类型也由编译器推理得出。如果Lambda表达式中的语句块只有一行，则可以不用使用<strong>return</strong>语句，下列两个代码片段效果相同：</p><pre class=" language-hljs java">Arrays.asList( <span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string"><code class="language-hljs java">Arrays.asList( <span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"d"</span> ).sort( ( e1, e2 ) -> e1.compareTo( e2 ) );Copy</code></pre><p>和</p><pre class=" language-hljs java">Arrays.asList( <span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string"><code class="language-hljs java">Arrays.asList( <span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"d"</span> ).sort( ( e1, e2 ) -> &#123;    <span class="hljs-keyword">int</span> result = e1.compareTo( e2 );    <span class="hljs-keyword">return</span> result;&#125; );Copy</code></pre><p>Lambda的设计者们为了让现有的功能与Lambda表达式良好兼容，考虑了很多方法，于是产生了<strong>函数接口</strong>这个概念。函数接口指的是只有一个函数的接口，这样的接口可以隐式转换为Lambda表达式。<strong>java.lang.Runnable</strong>和<strong>java.util.concurrent.Callable</strong>是函数式接口的最佳例子。在实践中，函数式接口非常脆弱：只要某个开发者在该接口中添加一个函数，则该接口就不再是函数式接口进而导致编译失败。为了克服这种代码层面的脆弱性，并显式说明某个接口是函数式接口，Java 8 提供了一个特殊的注解<strong>@FunctionalInterface</strong>（Java 库中的所有相关接口都已经带有这个注解了），举个简单的函数式接口的定义：</p><pre class=" language-hljs java"><span class="hljs-meta"><code class="language-hljs java"><span class="hljs-meta">@FunctionalInterface</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Functional</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span></span>;&#125;Copy</code></pre><p>不过有一点需要注意，<a href="https://www.javacodegeeks.com/2014/05/java-8-features-tutorial.html#Interface_Default" target="_blank" rel="noopener">默认方法和静态方法</a>不会破坏函数式接口的定义，因此如下的代码是合法的。</p><pre class=" language-hljs java"><span class="hljs-meta"><code class="language-hljs java"><span class="hljs-meta">@FunctionalInterface</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">FunctionalDefaultMethods</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">defaultMethod</span><span class="hljs-params">()</span> </span>&#123;                &#125;        &#125;Copy</code></pre><p>Lambda表达式作为Java 8的最大卖点，它有潜力吸引更多的开发者加入到JVM平台，并在纯Java编程中使用函数式编程的概念。如果你需要了解更多Lambda表达式的细节，可以参考<a href="http://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html" target="_blank" rel="noopener">官方文档</a>。</p><h5 id="2-2-接口的默认方法和静态方法"><a href="#2-2-接口的默认方法和静态方法" class="headerlink" title="2.2 接口的默认方法和静态方法"></a>2.2 接口的默认方法和静态方法</h5><p>Java 8使用两个新概念扩展了接口的含义：默认方法和静态方法。<a href="http://www.androidos.net.cn/book/android-road/java/basis/java-8.html" target="_blank" rel="noopener">默认方法</a>使得接口有点类似traits，不过要实现的目标不一样。默认方法使得开发者可以在 不破坏二进制兼容性的前提下，往现存接口中添加新的方法，即不强制那些实现了该接口的类也同时实现这个新加的方法。</p><p>默认方法和抽象方法之间的区别在于抽象方法需要实现，而默认方法不需要。接口提供的默认方法会被接口的实现类继承或者覆写，例子代码如下：</p><pre class=" language-hljs java"><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title"><code class="language-hljs java"><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Defaulable</span> </span>&#123;    <span class="hljs-comment">// Interfaces now allow default methods, the implementer may or </span>    <span class="hljs-comment">// may not implement (override) them.</span>    <span class="hljs-function"><span class="hljs-keyword">default</span> String <span class="hljs-title">notRequired</span><span class="hljs-params">()</span> </span>&#123;         <span class="hljs-keyword">return</span> <span class="hljs-string">"Default implementation"</span>;     &#125;        &#125;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultableImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Defaulable</span> </span>&#123;&#125;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OverridableImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Defaulable</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">notRequired</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"Overridden implementation"</span>;    &#125;&#125;Copy</code></pre><p><strong>Defaulable</strong>接口使用关键字<strong>default</strong>定义了一个默认方法<strong>notRequired()</strong>。<strong>DefaultableImpl</strong>类实现了这个接口，同时默认继承了这个接口中的默认方法；<strong>OverridableImpl</strong>类也实现了这个接口，但覆写了该接口的默认方法，并提供了一个不同的实现。</p><p>Java 8带来的另一个有趣的特性是在接口中可以定义静态方法，例子代码如下：</p><pre class=" language-hljs java"><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title"><code class="language-hljs java"><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">DefaulableFactory</span> </span>&#123;    <span class="hljs-comment">// Interfaces now allow static methods</span>    <span class="hljs-function"><span class="hljs-keyword">static</span> Defaulable <span class="hljs-title">create</span><span class="hljs-params">( Supplier< Defaulable > supplier )</span> </span>&#123;        <span class="hljs-keyword">return</span> supplier.get();    &#125;&#125;Copy</code></pre><p>下面的代码片段整合了默认方法和静态方法的使用场景：</p><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">( String[] args )</span> </span>&#123;    Defaulable defaulable = DefaulableFactory.create( DefaultableImpl::<span class="hljs-keyword">new</span> );    System.out.println( defaulable.notRequired() );    defaulable = DefaulableFactory.create( OverridableImpl::<span class="hljs-keyword">new</span> );    System.out.println( defaulable.notRequired() );&#125;Copy</code></pre><p>这段代码的输出结果如下：</p><pre class=" language-hljs java"><code class="language-hljs java">Default implementationOverridden implementationCopy</code></pre><p>由于JVM上的默认方法的实现在字节码层面提供了支持，因此效率非常高。默认方法允许在不打破现有继承体系的基础上改进接口。该特性在官方库中的应用是：给<strong>java.util.Collection</strong>接口添加新方法，如<strong>stream()</strong>、<strong>parallelStream()</strong>、<strong>forEach()</strong>和<strong>removeIf()</strong>等等。</p><p>尽管默认方法有这么多好处，但在实际开发中应该谨慎使用：在复杂的继承体系中，默认方法可能引起歧义和编译错误。如果你想了解更多细节，可以参考<a href="http://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html" target="_blank" rel="noopener">官方文档</a>。</p><h5 id="2-3-方法引用"><a href="#2-3-方法引用" class="headerlink" title="2.3 方法引用"></a>2.3 方法引用</h5><p>方法引用使得开发者可以直接引用现存的方法、Java类的构造方法或者实例对象。方法引用和Lambda表达式配合使用，使得java类的构造方法看起来紧凑而简洁，没有很多复杂的模板代码。</p><p>西门的例子中，<strong>Car</strong>类是不同方法引用的例子，可以帮助读者区分四种类型的方法引用。</p><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Car <span class="hljs-title">create</span><span class="hljs-params">( <span class="hljs-keyword">final</span> Supplier< Car > supplier )</span> </span>&#123;        <span class="hljs-keyword">return</span> supplier.get();    &#125;                  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">collide</span><span class="hljs-params">( <span class="hljs-keyword">final</span> Car car )</span> </span>&#123;        System.out.println( <span class="hljs-string">"Collided "</span> + car.toString() );    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">follow</span><span class="hljs-params">( <span class="hljs-keyword">final</span> Car another )</span> </span>&#123;        System.out.println( <span class="hljs-string">"Following the "</span> + another.toString() );    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">repair</span><span class="hljs-params">()</span> </span>&#123;           System.out.println( <span class="hljs-string">"Repaired "</span> + <span class="hljs-keyword">this</span>.toString() );    &#125;&#125;Copy</code></pre><p>第一种方法引用的类型是<strong>构造器引用</strong>，语法是<strong>Class::new</strong>，或者更一般的形式：<strong>Class::new</strong>。注意：这个构造器没有参数。</p><pre class=" language-hljs java"><span class="hljs-keyword">final</span> Car car = Car.create( Car::<span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">final</span> Car car = Car.create( Car::<span class="hljs-keyword">new</span> );<span class="hljs-keyword">final</span> List< Car > cars = Arrays.asList( car );Copy</code></pre><p>第二种方法引用的类型是静态方法引用，语法是<strong>Class::static_method</strong>。注意：这个方法接受一个Car类型的参数。</p><pre class=" language-hljs java"><code class="language-hljs java">cars.forEach( Car::collide );Copy</code></pre><p>第三种方法引用的类型是某个类的成员方法的引用，语法是<strong>Class::method</strong>，注意，这个方法没有定义入参：</p><pre class=" language-hljs java"><code class="language-hljs java">cars.forEach( Car::repair );Copy</code></pre><p>第四种方法引用的类型是某个实例对象的成员方法的引用，语法是<strong>instance::method</strong>。注意：这个方法接受一个Car类型的参数：</p><pre class=" language-hljs java"><span class="hljs-keyword">final</span> Car police = Car.create( Car::<span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">final</span> Car police = Car.create( Car::<span class="hljs-keyword">new</span> );cars.forEach( police::follow );Copy</code></pre><p>运行上述例子，可以在控制台看到如下输出（Car实例可能不同）：</p><pre class=" language-hljs java">Collided com.javacodegeeks.java8.method.references.MethodReferences$Car@<span class="hljs-number"><code class="language-hljs java">Collided com.javacodegeeks.java8.method.references.MethodReferences$Car@<span class="hljs-number">7</span>a81197dRepaired com.javacodegeeks.java8.method.references.MethodReferences$Car@<span class="hljs-number">7</span>a81197dFollowing the com.javacodegeeks.java8.method.references.MethodReferences$Car@<span class="hljs-number">7</span>a81197dCopy</code></pre><p>如果想了解和学习更详细的内容，可以参考<a href="http://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html" target="_blank" rel="noopener">官方文档</a></p><h5 id="2-4-重复注解"><a href="#2-4-重复注解" class="headerlink" title="2.4 重复注解"></a>2.4 重复注解</h5><p>自从Java 5中引入<a href="http://www.javacodegeeks.com/2012/08/java-annotations-explored-explained.html" target="_blank" rel="noopener">注解</a>以来，这个特性开始变得非常流行，并在各个框架和项目中被广泛使用。不过，注解有一个很大的限制是：在同一个地方不能多次使用同一个注解。Java 8打破了这个限制，引入了重复注解的概念，允许在同一个地方多次使用同一个注解。</p><p>在Java 8中使用<strong>@Repeatable</strong>注解定义重复注解，实际上，这并不是语言层面的改进，而是编译器做的一个trick，底层的技术仍然相同。可以利用下面的代码说明：</p><pre class=" language-hljs java"><span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">package</span> com.javacodegeeks.java8.repeatable.annotations;<span class="hljs-keyword">import</span> java.lang.annotation.ElementType;<span class="hljs-keyword">import</span> java.lang.annotation.Repeatable;<span class="hljs-keyword">import</span> java.lang.annotation.Retention;<span class="hljs-keyword">import</span> java.lang.annotation.RetentionPolicy;<span class="hljs-keyword">import</span> java.lang.annotation.Target;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RepeatingAnnotations</span> </span>&#123;    <span class="hljs-meta">@Target</span>( ElementType.TYPE )    <span class="hljs-meta">@Retention</span>( RetentionPolicy.RUNTIME )    <span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Filters &#123;        Filter[] value();    &#125;    <span class="hljs-meta">@Target</span>( ElementType.TYPE )    <span class="hljs-meta">@Retention</span>( RetentionPolicy.RUNTIME )    <span class="hljs-meta">@Repeatable</span>( Filters<span class="hljs-class">.<span class="hljs-keyword">class</span> )</span><span class="hljs-class">    <span class="hljs-title">public</span> @<span class="hljs-title">interface</span> <span class="hljs-title">Filter</span> </span>&#123;        <span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params">()</span></span>;    &#125;;    <span class="hljs-meta">@Filter</span>( <span class="hljs-string">"filter1"</span> )    <span class="hljs-meta">@Filter</span>( <span class="hljs-string">"filter2"</span> )    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Filterable</span> </span>&#123;            &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">for</span>( Filter filter: Filterable<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">getAnnotationsByType</span>( <span class="hljs-title">Filter</span>.<span class="hljs-title">class</span> ) ) </span>&#123;            System.out.println( filter.value() );        &#125;    &#125;&#125;Copy</code></pre><p>正如我们所见，这里的<strong>Filter</strong>类使用@Repeatable(Filters.class)注解修饰，而<strong>Filters</strong>是存放<strong>Filter</strong>注解的容器，编译器尽量对开发者屏蔽这些细节。这样，<strong>Filterable</strong>接口可以用两个<strong>Filter</strong>注解注释（这里并没有提到任何关于Filters的信息）。</p><p>另外，反射API提供了一个新的方法：<strong>getAnnotationsByType()</strong>，可以返回某个类型的重复注解，例如<code>Filterable.class.getAnnoation(Filters.class)</code>将返回两个Filter实例，输出到控制台的内容如下所示：</p><pre class=" language-hljs java"><code class="language-hljs java">filter1filter2Copy</code></pre><p>如果你希望了解更多内容，可以参考<a href="http://docs.oracle.com/javase/tutorial/java/annotations/repeating.html" target="_blank" rel="noopener">官方文档</a>。</p><h5 id="2-5-更好的类型推断"><a href="#2-5-更好的类型推断" class="headerlink" title="2.5 更好的类型推断"></a>2.5 更好的类型推断</h5><p>Java 8编译器在类型推断方面有很大的提升，在很多场景下编译器可以推导出某个参数的数据类型，从而使得代码更为简洁。例子代码如下：</p><pre class=" language-hljs Java"><span class="hljs-keyword"><code class="language-hljs Java"><span class="hljs-keyword">package</span> com.javacodegeeks.java8.type.inference;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Value</span>< <span class="hljs-title">T</span> > </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>< T > <span class="hljs-function">T <span class="hljs-title">defaultValue</span><span class="hljs-params">()</span> </span>&#123;         <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;     &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getOrDefault</span><span class="hljs-params">( T value, T defaultValue )</span> </span>&#123;        <span class="hljs-keyword">return</span> ( value != <span class="hljs-keyword">null</span> ) ? value : defaultValue;    &#125;&#125;Copy</code></pre><p>下列代码是<strong>Value</strong>类型的应用：</p><pre class=" language-hljs java"><span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">package</span> com.javacodegeeks.java8.type.inference;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TypeInference</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">final</span> Value< String > value = <span class="hljs-keyword">new</span> Value<>();        value.getOrDefault( <span class="hljs-string">"22"</span>, Value.defaultValue() );    &#125;&#125;Copy</code></pre><p>参数<strong>Value.defaultValue()</strong>的类型由编译器推导得出，不需要显式指明。在Java 7中这段代码会有编译错误，除非使用<code>Value.defaultValue()</code>。</p><h5 id="2-6-拓宽注解的应用场景"><a href="#2-6-拓宽注解的应用场景" class="headerlink" title="2.6 拓宽注解的应用场景"></a>2.6 拓宽注解的应用场景</h5><p>Java 8拓宽了注解的应用场景。现在，注解几乎可以使用在任何元素上：局部变量、接口类型、超类和接口实现类，甚至可以用在函数的异常定义上。下面是一些例子：</p><pre class=" language-hljs java"><span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">package</span> com.javacodegeeks.java8.annotations;<span class="hljs-keyword">import</span> java.lang.annotation.ElementType;<span class="hljs-keyword">import</span> java.lang.annotation.Retention;<span class="hljs-keyword">import</span> java.lang.annotation.RetentionPolicy;<span class="hljs-keyword">import</span> java.lang.annotation.Target;<span class="hljs-keyword">import</span> java.util.ArrayList;<span class="hljs-keyword">import</span> java.util.Collection;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Annotations</span> </span>&#123;    <span class="hljs-meta">@Retention</span>( RetentionPolicy.RUNTIME )    <span class="hljs-meta">@Target</span>( &#123; ElementType.TYPE_USE, ElementType.TYPE_PARAMETER &#125; )    <span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> NonEmpty &#123;            &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Holder</span>< @<span class="hljs-title">NonEmpty</span> <span class="hljs-title">T</span> > <span class="hljs-keyword">extends</span> @<span class="hljs-title">NonEmpty</span> <span class="hljs-title">Object</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> @NonEmpty Exception </span>&#123;                    &#125;    &#125;    <span class="hljs-meta">@SuppressWarnings</span>( <span class="hljs-string">"unused"</span> )    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">final</span> Holder< String > holder = <span class="hljs-keyword">new</span> <span class="hljs-meta">@NonEmpty</span> Holder< String >();                <span class="hljs-meta">@NonEmpty</span> Collection< <span class="hljs-meta">@NonEmpty</span> String > strings = <span class="hljs-keyword">new</span> ArrayList<>();            &#125;&#125;Copy</code></pre><p><strong>ElementType.TYPE_USER</strong>和<strong>ElementType.TYPE_PARAMETER</strong>是Java 8新增的两个注解，用于描述注解的使用场景。Java 语言也做了对应的改变，以识别这些新增的注解。</p><h4 id="3-Java编译器的新特性"><a href="#3-Java编译器的新特性" class="headerlink" title="3. Java编译器的新特性"></a>3. Java编译器的新特性</h4><h5 id="3-1-参数名称"><a href="#3-1-参数名称" class="headerlink" title="3.1 参数名称"></a>3.1 参数名称</h5><p>为了在运行时获得Java程序中方法的参数名称，老一辈的Java程序员必须使用不同方法，例如<a href="https://github.com/paul-hammant/paranamer" target="_blank" rel="noopener">Paranamer liberary</a>。Java 8终于将这个特性规范化，在语言层面（使用反射API和<strong>Parameter.getName()方法</strong>）和字节码层面（使用新的<strong>javac</strong>编译器以及<strong>-parameters</strong>参数）提供支持。</p><pre class=" language-hljs java"><span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">package</span> com.javacodegeeks.java8.parameter.names;<span class="hljs-keyword">import</span> java.lang.reflect.Method;<span class="hljs-keyword">import</span> java.lang.reflect.Parameter;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ParameterNames</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        Method method = ParameterNames.class.getMethod( "main", String[].class );        <span class="hljs-keyword">for</span>( <span class="hljs-keyword">final</span> Parameter parameter: method.getParameters() ) &#123;            System.out.println( <span class="hljs-string">"Parameter: "</span> + parameter.getName() );        &#125;    &#125;&#125;Copy</code></pre><p>在Java 8中这个特性是默认关闭的，因此如果不带<strong>-parameters</strong>参数编译上述代码并运行，则会输出如下结果：</p><pre class=" language-hljs java"><code class="language-hljs java">Parameter: arg0Copy</code></pre><p>如果带<strong>-parameters</strong>参数，则会输出如下结果（正确的结果）：</p><pre class=" language-hljs java"><code class="language-hljs java">Parameter: argsCopy</code></pre><p>如果你使用Maven进行项目管理，则可以在<strong>maven-compiler-plugin</strong>编译器的配置项中配置<strong>-parameters</strong>参数：</p><pre class=" language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name"><code class="language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>></span>    <span class="hljs-tag"><<span class="hljs-name">groupId</span>></span>org.apache.maven.plugins<span class="hljs-tag"></<span class="hljs-name">groupId</span>></span>    <span class="hljs-tag"><<span class="hljs-name">artifactId</span>></span>maven-compiler-plugin<span class="hljs-tag"></<span class="hljs-name">artifactId</span>></span>    <span class="hljs-tag"><<span class="hljs-name">version</span>></span>3.1<span class="hljs-tag"></<span class="hljs-name">version</span>></span>    <span class="hljs-tag"><<span class="hljs-name">configuration</span>></span>        <span class="hljs-tag"><<span class="hljs-name">compilerArgument</span>></span>-parameters<span class="hljs-tag"></<span class="hljs-name">compilerArgument</span>></span>        <span class="hljs-tag"><<span class="hljs-name">source</span>></span>1.8<span class="hljs-tag"></<span class="hljs-name">source</span>></span>        <span class="hljs-tag"><<span class="hljs-name">target</span>></span>1.8<span class="hljs-tag"></<span class="hljs-name">target</span>></span>    <span class="hljs-tag"></<span class="hljs-name">configuration</span>></span><span class="hljs-tag"></<span class="hljs-name">plugin</span>></span>Copy</code></pre><h4 id="4-Java官方库的新特性"><a href="#4-Java官方库的新特性" class="headerlink" title="4. Java官方库的新特性"></a>4. Java官方库的新特性</h4><p>Java 8增加了很多新的工具类（date/time类），并扩展了现存的工具类，以支持现代的并发编程、函数式编程等。</p><h5 id="4-1-Optional"><a href="#4-1-Optional" class="headerlink" title="4.1 Optional"></a>4.1 Optional</h5><p>Java应用中最常见的bug就是<a href="http://examples.javacodegeeks.com/java-basics/exceptions/java-lang-nullpointerexception-how-to-handle-null-pointer-exception/" target="_blank" rel="noopener">空值异常</a>。在Java 8之前，<a href="http://code.google.com/p/guava-libraries/" target="_blank" rel="noopener">Google Guava</a>引入了<strong>Optionals</strong>类来解决<strong>NullPointerException</strong>，从而避免源码被各种<strong>null</strong>检查污染，以便开发者写出更加整洁的代码。Java 8也将<strong>Optional</strong>加入了官方库。</p><p><strong>Optional</strong>仅仅是一个容易：存放T类型的值或者null。它提供了一些有用的接口来避免显式的null检查，可以参考<a href="http://docs.oracle.com/javase/8/docs/api/" target="_blank" rel="noopener">Java 8官方文档</a>了解更多细节。</p><p>接下来看一点使用<strong>Optional</strong>的例子：可能为空的值或者某个类型的值：</p><pre class=" language-hljs java">Optional&lt; String &gt; fullName = Optional.ofNullable( <span class="hljs-keyword"><code class="language-hljs java">Optional&lt; String &gt; fullName = Optional.ofNullable( <span class="hljs-keyword">null</span> );System.out.println( <span class="hljs-string">"Full Name is set? "</span> + fullName.isPresent() );        System.out.println( <span class="hljs-string">"Full Name: "</span> + fullName.orElseGet( () -> <span class="hljs-string">"[none]"</span> ) ); System.out.println( fullName.map( s -> <span class="hljs-string">"Hey "</span> + s + <span class="hljs-string">"!"</span> ).orElse( <span class="hljs-string">"Hey Stranger!"</span> ) );Copy</code></pre><p>如果<strong>Optional</strong>实例持有一个非空值，则<strong>isPresent()</strong>方法返回true，否则返回false；<strong>orElseGet()</strong>方法，<strong>Optional</strong>实例持有null，则可以接受一个lambda表达式生成的默认值；<strong>map()</strong>方法可以将现有的<strong>Opetional</strong>实例的值转换成新的值；<strong>orElse()</strong>方法与<strong>orElseGet()</strong>方法类似，但是在持有null的时候返回传入的默认值。</p><p>上述代码的输出结果如下：</p><pre class=" language-hljs pgsql"><span class="hljs-keyword">Full</span> <span class="hljs-type">Name</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span>? <span class="hljs-keyword"><code class="language-hljs pgsql"><span class="hljs-keyword">Full</span> <span class="hljs-type">Name</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span>? <span class="hljs-keyword">false</span><span class="hljs-keyword">Full</span> <span class="hljs-type">Name</span>: [<span class="hljs-keyword">none</span>]Hey Stranger!<span class="hljs-keyword">Copy</span></code></pre><p>再看下另一个简单的例子：</p><pre class=" language-hljs java">Optional&lt; String &gt; firstName = Optional.of( <span class="hljs-string"><code class="language-hljs java">Optional&lt; String &gt; firstName = Optional.of( <span class="hljs-string">"Tom"</span> );System.out.println( <span class="hljs-string">"First Name is set? "</span> + firstName.isPresent() );        System.out.println( <span class="hljs-string">"First Name: "</span> + firstName.orElseGet( () -> <span class="hljs-string">"[none]"</span> ) ); System.out.println( firstName.map( s -> <span class="hljs-string">"Hey "</span> + s + <span class="hljs-string">"!"</span> ).orElse( <span class="hljs-string">"Hey Stranger!"</span> ) );System.out.println();Copy</code></pre><p>这个例子的输出是：</p><pre class=" language-hljs pgsql">First <span class="hljs-type">Name</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span>? <span class="hljs-keyword"><code class="language-hljs pgsql">First <span class="hljs-type">Name</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span>? <span class="hljs-keyword">true</span>First <span class="hljs-type">Name</span>: TomHey Tom!<span class="hljs-keyword">Copy</span></code></pre><p>如果想了解更多的细节，请参考<a href="http://docs.oracle.com/javase/8/docs/api/java/util/Optional.html" target="_blank" rel="noopener">官方文档</a>。</p><h5 id="4-2-Streams"><a href="#4-2-Streams" class="headerlink" title="4.2 Streams"></a>4.2 Streams</h5><p>新增的<a href="http://www.javacodegeeks.com/2014/05/the-effects-of-programming-with-java-8-streams-on-algorithm-performance.html" target="_blank" rel="noopener">Stream API</a>（java.util.stream）将生成环境的函数式编程引入了Java库中。这是目前为止最大的一次对Java库的完善，以便开发者能够写出更加有效、更加简洁和紧凑的代码。</p><p>Stream API极大得简化了集合操作（后面我们会看到不止是集合），首先看下这个叫Task的类：</p><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Streams</span>  </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">enum</span> Status &#123;        OPEN, CLOSED    &#125;;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Task</span> </span>&#123;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Status status;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Integer points;        Task( <span class="hljs-keyword">final</span> Status status, <span class="hljs-keyword">final</span> Integer points ) &#123;            <span class="hljs-keyword">this</span>.status = status;            <span class="hljs-keyword">this</span>.points = points;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getPoints</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> points;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> Status <span class="hljs-title">getStatus</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> status;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> String.format( <span class="hljs-string">"[%s, %d]"</span>, status, points );        &#125;    &#125;&#125;Copy</code></pre><p>Task类有一个分数（或伪复杂度）的概念，另外还有两种状态：OPEN或者CLOSED。现在假设有一个task集合：</p><pre class=" language-hljs java"><span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">final</span> Collection< Task > tasks = Arrays.asList(    <span class="hljs-keyword">new</span> Task( Status.OPEN, <span class="hljs-number">5</span> ),    <span class="hljs-keyword">new</span> Task( Status.OPEN, <span class="hljs-number">13</span> ),    <span class="hljs-keyword">new</span> Task( Status.CLOSED, <span class="hljs-number">8</span> ) );Copy</code></pre><p>首先看一个问题：在这个task集合中一共有多少个OPEN状态的点？在Java 8之前，要解决这个问题，则需要使用<strong>foreach</strong>循环遍历task集合；但是在Java 8中可以利用steams解决：包括一系列元素的列表，并且支持顺序和并行处理。</p><pre class=" language-hljs java"><span class="hljs-comment"><code class="language-hljs java"><span class="hljs-comment">// Calculate total points of all active tasks using sum()</span><span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> totalPointsOfOpenTasks = tasks    .stream()    .filter( task -> task.getStatus() == Status.OPEN )    .mapToInt( Task::getPoints )    .sum();System.out.println( <span class="hljs-string">"Total points: "</span> + totalPointsOfOpenTasks );Copy</code></pre><p>运行这个方法的控制台输出是：</p><pre class=" language-hljs dockerfile">Total points: <span class="hljs-number"><code class="language-hljs dockerfile">Total points: <span class="hljs-number">18</span><span class="hljs-keyword">Copy</span></code></pre><p>这里有很多知识点值得说。首先，tasks集合被转换成steam表示；其次，在steam上的<strong>filter</strong>操作会过滤掉所有CLOSED的task；第三，<strong>mapToInt</strong>操作基于每个task实例的<strong>Task::getPoints</strong>方法将task流转换成Integer集合；最后，通过<strong>sum</strong>方法计算总和，得出最后的结果。</p><p>在学习下一个例子之前，还需要记住一些steams（<a href="http://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html#StreamOps" target="_blank" rel="noopener">点此更多细节</a>）的知识点。Steam之上的操作可分为中间操作和晚期操作。</p><p>中间操作会返回一个新的steam——执行一个中间操作（例如<strong>filter</strong>）并不会执行实际的过滤操作，而是创建一个新的steam，并将原steam中符合条件的元素放入新创建的steam。</p><p>晚期操作（例如<strong>forEach</strong>或者<strong>sum</strong>），会遍历steam并得出结果或者附带结果；在执行晚期操作之后，steam处理线已经处理完毕，就不能使用了。在几乎所有情况下，晚期操作都是立刻对steam进行遍历。</p><p>steam的另一个价值是创造性地支持并行处理（parallel processing）。对于上述的tasks集合，我们可以用下面的代码计算所有任务的点数之和：</p><pre class=" language-hljs java"><span class="hljs-comment"><code class="language-hljs java"><span class="hljs-comment">// Calculate total points of all tasks</span><span class="hljs-keyword">final</span> <span class="hljs-keyword">double</span> totalPoints = tasks   .stream()   .parallel()   .map( task -> task.getPoints() ) <span class="hljs-comment">// or map( Task::getPoints ) </span>   .reduce( <span class="hljs-number">0</span>, Integer::sum );System.out.println( <span class="hljs-string">"Total points (all tasks): "</span> + totalPoints );Copy</code></pre><p>这里我们使用<strong>parallel</strong>方法并行处理所有的task，并使用<strong>reduce</strong>方法计算最终的结果。控制台输出如下：</p><pre class=" language-hljs dockerfile">Total points（all tasks）: <span class="hljs-number"><code class="language-hljs dockerfile">Total points（all tasks）: <span class="hljs-number">26.0</span><span class="hljs-keyword">Copy</span></code></pre><p>对于一个集合，经常需要根据某些条件对其中的元素分组。利用steam提供的API可以很快完成这类任务，代码如下：</p><pre class=" language-hljs java"><span class="hljs-comment"><code class="language-hljs java"><span class="hljs-comment">// Group tasks by their status</span><span class="hljs-keyword">final</span> Map< Status, List< Task > > map = tasks    .stream()    .collect( Collectors.groupingBy( Task::getStatus ) );System.out.println( map );Copy</code></pre><p>控制台的输出如下：</p><pre class=" language-hljs lua">&#123;CLOSED=<span class="hljs-string">[[CLOSED, 8]]</span>, OPEN=<span class="hljs-string"><code class="language-hljs lua">&#123;CLOSED=<span class="hljs-string">[[CLOSED, 8]]</span>, OPEN=<span class="hljs-string">[[OPEN, 5], [OPEN, 13]]</span>&#125;Copy</code></pre><p>最后一个关于tasks集合的例子问题是：如何计算集合中每个任务的点数在集合中所占的比重，具体处理的代码如下：</p><pre class=" language-hljs java"><span class="hljs-comment"><code class="language-hljs java"><span class="hljs-comment">// Calculate the weight of each tasks (as percent of total points) </span><span class="hljs-keyword">final</span> Collection< String > result = tasks    .stream()                                        <span class="hljs-comment">// Stream< String ></span>    .mapToInt( Task::getPoints )                     <span class="hljs-comment">// IntStream</span>    .asLongStream()                                  <span class="hljs-comment">// LongStream</span>    .mapToDouble( points -> points / totalPoints )   <span class="hljs-comment">// DoubleStream</span>    .boxed()                                         <span class="hljs-comment">// Stream< Double ></span>    .mapToLong( weigth -> ( <span class="hljs-keyword">long</span> )( weigth * <span class="hljs-number">100</span> ) ) <span class="hljs-comment">// LongStream</span>    .mapToObj( percentage -> percentage + <span class="hljs-string">"%"</span> )      <span class="hljs-comment">// Stream< String> </span>    .collect( Collectors.toList() );                 <span class="hljs-comment">// List< String > </span>System.out.println( result );Copy</code></pre><p>控制台输出结果如下：</p><pre class=" language-hljs angelscript">[<span class="hljs-number">19</span>%, <span class="hljs-number">50</span>%, <span class="hljs-number"><code class="language-hljs angelscript">[<span class="hljs-number">19</span>%, <span class="hljs-number">50</span>%, <span class="hljs-number">30</span>%]Copy</code></pre><p>最后，正如之前所说，Steam API不仅可以作用于Java集合，传统的IO操作（从文件或者网络一行一行得读取数据）可以受益于steam处理，这里有一个小例子：</p><pre class=" language-hljs java"><span class="hljs-keyword">final</span> Path path = <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">final</span> Path path = <span class="hljs-keyword">new</span> File( filename ).toPath();<span class="hljs-keyword">try</span>( Stream< String > lines = Files.lines( path, StandardCharsets.UTF_8 ) ) &#123;    lines.onClose( () -> System.out.println(<span class="hljs-string">"Done!"</span>) ).forEach( System.out::println );&#125;Copy</code></pre><p>Stream的方法<strong>onClose</strong> 返回一个等价的有额外句柄的Stream，当Stream的close（）方法被调用的时候这个句柄会被执行。Stream API、Lambda表达式还有接口默认方法和静态方法支持的方法引用，是Java 8对软件开发的现代范式的响应。</p><h5 id="4-3-Date-Time-API-JSR-310"><a href="#4-3-Date-Time-API-JSR-310" class="headerlink" title="4.3 Date/Time API(JSR 310)"></a>4.3 Date/Time API(JSR 310)</h5><p>Java 8引入了<a href="https://jcp.org/en/jsr/detail?id=310" target="_blank" rel="noopener">新的Date-Time API(JSR 310)</a>来改进时间、日期的处理。时间和日期的管理一直是最令Java开发者痛苦的问题。<strong>java.util.Date</strong>和后来的<strong>java.util.Calendar</strong>一直没有解决这个问题（甚至令开发者更加迷茫）。</p><p>因为上面这些原因，诞生了第三方库<a href="http://www.joda.org/joda-time/" target="_blank" rel="noopener">Joda-Time</a>，可以替代Java的时间管理API。Java 8中新的时间和日期管理API深受Joda-Time影响，并吸收了很多Joda-Time的精华。新的java.time包包含了所有关于日期、时间、时区、Instant（跟日期类似但是精确到纳秒）、duration（持续时间）和时钟操作的类。新设计的API认真考虑了这些类的不变性（从java.util.Calendar吸取的教训），如果某个实例需要修改，则返回一个新的对象。</p><p>我们接下来看看java.time包中的关键类和各自的使用例子。首先，<strong>Clock</strong>类使用时区来返回当前的纳秒时间和日期。<strong>Clock</strong>可以替代<strong>System.currentTimeMillis()</strong>和<strong>TimeZone.getDefault()</strong>。</p><pre class=" language-hljs java"><span class="hljs-comment"><code class="language-hljs java"><span class="hljs-comment">// Get the system clock as UTC offset </span><span class="hljs-keyword">final</span> Clock clock = Clock.systemUTC();System.out.println( clock.instant() );System.out.println( clock.millis() );Copy</code></pre><p>这个例子的输出结果是：</p><pre class=" language-hljs angelscript"><span class="hljs-number">2014</span><span class="hljs-number">-04</span><span class="hljs-number">-12</span>T15:<span class="hljs-number">19</span>:<span class="hljs-number"><code class="language-hljs angelscript"><span class="hljs-number">2014</span><span class="hljs-number">-04</span><span class="hljs-number">-12</span>T15:<span class="hljs-number">19</span>:<span class="hljs-number">29.282</span>Z<span class="hljs-number">1397315969360</span>Copy</code></pre><p>第二，关注下<strong>LocalDate</strong>和<strong>LocalTime</strong>类。<strong>LocalDate</strong>仅仅包含ISO-8601日历系统中的日期部分；<strong>LocalTime</strong>则仅仅包含该日历系统中的时间部分。这两个类的对象都可以使用Clock对象构建得到。</p><pre class=" language-hljs java"><span class="hljs-comment"><code class="language-hljs java"><span class="hljs-comment">// Get the local date and local time</span><span class="hljs-keyword">final</span> LocalDate date = LocalDate.now();<span class="hljs-keyword">final</span> LocalDate dateFromClock = LocalDate.now( clock );System.out.println( date );System.out.println( dateFromClock );<span class="hljs-comment">// Get the local date and local time</span><span class="hljs-keyword">final</span> LocalTime time = LocalTime.now();<span class="hljs-keyword">final</span> LocalTime timeFromClock = LocalTime.now( clock );System.out.println( time );System.out.println( timeFromClock );Copy</code></pre><p>上述例子的输出结果如下：</p><pre class=" language-hljs angelscript"><span class="hljs-number">2014</span><span class="hljs-number">-04</span><span class="hljs-number"><code class="language-hljs angelscript"><span class="hljs-number">2014</span><span class="hljs-number">-04</span><span class="hljs-number">-12</span><span class="hljs-number">2014</span><span class="hljs-number">-04</span><span class="hljs-number">-12</span><span class="hljs-number">11</span>:<span class="hljs-number">25</span>:<span class="hljs-number">54.568</span><span class="hljs-number">15</span>:<span class="hljs-number">25</span>:<span class="hljs-number">54.568</span>Copy</code></pre><p><strong>LocalDateTime</strong>类包含了LocalDate和LocalTime的信息，但是不包含ISO-8601日历系统中的时区信息。这里有一些<a href="https://www.javacodegeeks.com/2014/04/java-8-date-time-api-tutorial-localdatetime.html" target="_blank" rel="noopener">关于LocalDate和LocalTime的例子</a>：</p><pre class=" language-hljs java"><span class="hljs-comment"><code class="language-hljs java"><span class="hljs-comment">// Get the local date/time</span><span class="hljs-keyword">final</span> LocalDateTime datetime = LocalDateTime.now();<span class="hljs-keyword">final</span> LocalDateTime datetimeFromClock = LocalDateTime.now( clock );System.out.println( datetime );System.out.println( datetimeFromClock );Copy</code></pre><p>上述这个例子的输出结果如下：</p><pre class=" language-hljs angelscript"><span class="hljs-number">2014</span><span class="hljs-number">-04</span><span class="hljs-number">-12</span>T11:<span class="hljs-number">37</span>:<span class="hljs-number"><code class="language-hljs angelscript"><span class="hljs-number">2014</span><span class="hljs-number">-04</span><span class="hljs-number">-12</span>T11:<span class="hljs-number">37</span>:<span class="hljs-number">52.309</span><span class="hljs-number">2014</span><span class="hljs-number">-04</span><span class="hljs-number">-12</span>T15:<span class="hljs-number">37</span>:<span class="hljs-number">52.309</span>Copy</code></pre><p>如果你需要特定时区的data/time信息，则可以使用<strong>ZoneDateTime</strong>，它保存有ISO-8601日期系统的日期和时间，而且有时区信息。下面是一些使用不同时区的例子：</p><pre class=" language-hljs java"><span class="hljs-comment"><code class="language-hljs java"><span class="hljs-comment">// Get the zoned date/time</span><span class="hljs-keyword">final</span> ZonedDateTime zonedDatetime = ZonedDateTime.now();<span class="hljs-keyword">final</span> ZonedDateTime zonedDatetimeFromClock = ZonedDateTime.now( clock );<span class="hljs-keyword">final</span> ZonedDateTime zonedDatetimeFromZone = ZonedDateTime.now( ZoneId.of( <span class="hljs-string">"America/Los_Angeles"</span> ) );System.out.println( zonedDatetime );System.out.println( zonedDatetimeFromClock );System.out.println( zonedDatetimeFromZone );Copy</code></pre><p>这个例子的输出结果是：</p><pre class=" language-hljs angelscript"><span class="hljs-number">2014</span><span class="hljs-number">-04</span><span class="hljs-number">-12</span>T11:<span class="hljs-number">47</span>:<span class="hljs-number">01.017</span><span class="hljs-number">-04</span>:<span class="hljs-number"><code class="language-hljs angelscript"><span class="hljs-number">2014</span><span class="hljs-number">-04</span><span class="hljs-number">-12</span>T11:<span class="hljs-number">47</span>:<span class="hljs-number">01.017</span><span class="hljs-number">-04</span>:<span class="hljs-number">00</span>[America/New_York]<span class="hljs-number">2014</span><span class="hljs-number">-04</span><span class="hljs-number">-12</span>T15:<span class="hljs-number">47</span>:<span class="hljs-number">01.017</span>Z<span class="hljs-number">2014</span><span class="hljs-number">-04</span><span class="hljs-number">-12</span>T08:<span class="hljs-number">47</span>:<span class="hljs-number">01.017</span><span class="hljs-number">-07</span>:<span class="hljs-number">00</span>[America/Los_Angeles]Copy</code></pre><p>最后看下<strong>Duration</strong>类，它持有的时间精确到秒和纳秒。这使得我们可以很容易得计算两个日期之间的不同，例子代码如下：</p><pre class=" language-hljs Java"><span class="hljs-comment"><code class="language-hljs Java"><span class="hljs-comment">// Get duration between two dates</span><span class="hljs-keyword">final</span> LocalDateTime from = LocalDateTime.of( <span class="hljs-number">2014</span>, Month.APRIL, <span class="hljs-number">16</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span> );<span class="hljs-keyword">final</span> LocalDateTime to = LocalDateTime.of( <span class="hljs-number">2015</span>, Month.APRIL, <span class="hljs-number">16</span>, <span class="hljs-number">23</span>, <span class="hljs-number">59</span>, <span class="hljs-number">59</span> );<span class="hljs-keyword">final</span> Duration duration = Duration.between( from, to );System.out.println( <span class="hljs-string">"Duration in days: "</span> + duration.toDays() );System.out.println( <span class="hljs-string">"Duration in hours: "</span> + duration.toHours() );Copy</code></pre><p>这个例子用于计算2014年4月16日和2015年4月16日之间的天数和小时数，输出结果如下：</p><pre class=" language-hljs yaml"><span class="hljs-attr">Duration in days:</span> <span class="hljs-number"><code class="language-hljs yaml"><span class="hljs-attr">Duration in days:</span> <span class="hljs-number">365</span><span class="hljs-attr">Duration in hours:</span> <span class="hljs-number">8783</span><span class="hljs-string">Copy</span></code></pre><p>对于Java 8的新日期时间的总体印象还是比较积极的，一部分是因为Joda-Time的积极影响，另一部分是因为官方终于听取了开发人员的需求。如果希望了解更多细节，可以参考<a href="http://docs.oracle.com/javase/tutorial/datetime/index.html" target="_blank" rel="noopener">官方文档</a>。</p><h5 id="4-4-Nashorn-JavaScript引擎"><a href="#4-4-Nashorn-JavaScript引擎" class="headerlink" title="4.4 Nashorn JavaScript引擎"></a>4.4 Nashorn JavaScript引擎</h5><p>Java 8提供了新的<a href="http://www.javacodegeeks.com/2014/02/java-8-compiling-lambda-expressions-in-the-new-nashorn-js-engine.html" target="_blank" rel="noopener">Nashorn JavaScript引擎</a>，使得我们可以在JVM上开发和运行JS应用。Nashorn JavaScript引擎是javax.script.ScriptEngine的另一个实现版本，这类Script引擎遵循相同的规则，允许Java和JavaScript交互使用，例子代码如下：</p><pre class=" language-hljs java">ScriptEngineManager manager = <span class="hljs-keyword"><code class="language-hljs java">ScriptEngineManager manager = <span class="hljs-keyword">new</span> ScriptEngineManager();ScriptEngine engine = manager.getEngineByName( <span class="hljs-string">"JavaScript"</span> );System.out.println( engine.getClass().getName() );System.out.println( <span class="hljs-string">"Result:"</span> + engine.eval( <span class="hljs-string">"function f() &#123; return 1; &#125;; f() + 1;"</span> ) );Copy</code></pre><p>这个代码的输出结果如下：</p><pre class=" language-hljs css"><span class="hljs-selector-tag">jdk</span><span class="hljs-selector-class">.nashorn</span><span class="hljs-selector-class">.api</span><span class="hljs-selector-class">.scripting</span><span class="hljs-selector-class"><code class="language-hljs css"><span class="hljs-selector-tag">jdk</span><span class="hljs-selector-class">.nashorn</span><span class="hljs-selector-class">.api</span><span class="hljs-selector-class">.scripting</span><span class="hljs-selector-class">.NashornScriptEngine</span><span class="hljs-selector-tag">Result</span>: 2<span class="hljs-selector-tag">Copy</span></code></pre><h5 id="4-5-Base64"><a href="#4-5-Base64" class="headerlink" title="4.5 Base64"></a>4.5 Base64</h5><p><a href="http://www.javacodegeeks.com/2014/04/base64-in-java-8-its-not-too-late-to-join-in-the-fun.html" target="_blank" rel="noopener">对Base64编码的支持</a>已经被加入到Java 8官方库中，这样不需要使用第三方库就可以进行Base64编码，例子代码如下：</p><pre class=" language-hljs java"><span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">package</span> com.javacodegeeks.java8.base64;<span class="hljs-keyword">import</span> java.nio.charset.StandardCharsets;<span class="hljs-keyword">import</span> java.util.Base64;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base64s</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">final</span> String text = <span class="hljs-string">"Base64 finally in Java 8!"</span>;        <span class="hljs-keyword">final</span> String encoded = Base64            .getEncoder()            .encodeToString( text.getBytes( StandardCharsets.UTF_8 ) );        System.out.println( encoded );        <span class="hljs-keyword">final</span> String decoded = <span class="hljs-keyword">new</span> String(             Base64.getDecoder().decode( encoded ),            StandardCharsets.UTF_8 );        System.out.println( decoded );    &#125;&#125;Copy</code></pre><p>这个例子的输出结果如下：</p><pre class=" language-hljs dockerfile"><code class="language-hljs dockerfile">QmFzZTY0IGZpbmFsbHkgaW4gSmF2YSA4IQ==Base64 finally in Java <span class="hljs-number">8</span>!<span class="hljs-keyword">Copy</span></code></pre><p>新的Base64API也支持URL和MINE的编码解码。 (<strong>Base64.getUrlEncoder()</strong> / <strong>Base64.getUrlDecoder()</strong>, <strong>Base64.getMimeEncoder()</strong> / <strong>Base64.getMimeDecoder()</strong>)。</p><h6 id="4-6-并行数组"><a href="#4-6-并行数组" class="headerlink" title="4.6 并行数组"></a>4.6 并行数组</h6><p>Java8版本新增了很多新的方法，用于支持并行数组处理。最重要的方法是<strong>parallelSort()</strong>，可以显著加快多核机器上的数组排序。下面的例子论证了<strong>parallexXxx</strong>系列的方法：</p><pre class=" language-hljs java"><span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">package</span> com.javacodegeeks.java8.parallel.arrays;<span class="hljs-keyword">import</span> java.util.Arrays;<span class="hljs-keyword">import</span> java.util.concurrent.ThreadLocalRandom;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ParallelArrays</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">( String[] args )</span> </span>&#123;        <span class="hljs-keyword">long</span>[] arrayOfLong = <span class="hljs-keyword">new</span> <span class="hljs-keyword">long</span> [ <span class="hljs-number">20000</span> ];                Arrays.parallelSetAll( arrayOfLong,             index -> ThreadLocalRandom.current().nextInt( <span class="hljs-number">1000000</span> ) );        Arrays.stream( arrayOfLong ).limit( <span class="hljs-number">10</span> ).forEach(             i -> System.out.print( i + <span class="hljs-string">" "</span> ) );        System.out.println();        Arrays.parallelSort( arrayOfLong );                Arrays.stream( arrayOfLong ).limit( <span class="hljs-number">10</span> ).forEach(             i -> System.out.print( i + <span class="hljs-string">" "</span> ) );        System.out.println();    &#125;&#125;Copy</code></pre><p>上述这些代码使用<strong>parallelSetAll()</strong>方法生成20000个随机数，然后使用<strong>parallelSort()</strong>方法进行排序。这个程序会输出乱序数组和排序数组的前10个元素。上述例子的代码输出的结果是：</p><pre class=" language-hljs yaml"><span class="hljs-attr">Unsorted:</span> <span class="hljs-number">591217</span> <span class="hljs-number">891976</span> <span class="hljs-number">443951</span> <span class="hljs-number">424479</span> <span class="hljs-number">766825</span> <span class="hljs-number">351964</span> <span class="hljs-number">242997</span> <span class="hljs-number">642839</span> <span class="hljs-number">119108</span> <span class="hljs-number"><code class="language-hljs yaml"><span class="hljs-attr">Unsorted:</span> <span class="hljs-number">591217</span> <span class="hljs-number">891976</span> <span class="hljs-number">443951</span> <span class="hljs-number">424479</span> <span class="hljs-number">766825</span> <span class="hljs-number">351964</span> <span class="hljs-number">242997</span> <span class="hljs-number">642839</span> <span class="hljs-number">119108</span> <span class="hljs-number">552378</span> <span class="hljs-attr">Sorted:</span> <span class="hljs-number">39</span> <span class="hljs-number">220</span> <span class="hljs-number">263</span> <span class="hljs-number">268</span> <span class="hljs-number">325</span> <span class="hljs-number">607</span> <span class="hljs-number">655</span> <span class="hljs-number">678</span> <span class="hljs-number">723</span> <span class="hljs-number">793</span><span class="hljs-string">Copy</span></code></pre><h6 id="4-7-并发性"><a href="#4-7-并发性" class="headerlink" title="4.7 并发性"></a>4.7 并发性</h6><p>基于新增的lambda表达式和steam特性，为Java 8中为<strong>java.util.concurrent.ConcurrentHashMap</strong>类添加了新的方法来支持聚焦操作；另外，也为<strong>java.util.concurrentForkJoinPool</strong>类添加了新的方法来支持通用线程池操作（更多内容可以参考<a href="http://academy.javacodegeeks.com/course/java-concurrency-essentials/" target="_blank" rel="noopener">我们的并发编程课程</a>）。</p><p>Java 8还添加了新的<strong>java.util.concurrent.locks.StampedLock</strong>类，用于支持基于容量的锁——该锁有三个模型用于支持读写操作（可以把这个锁当做是<strong>java.util.concurrent.locks.ReadWriteLock</strong>的替代者）。</p><p>在<strong>java.util.concurrent.atomic</strong>包中也新增了不少工具类，列举如下：</p><ul><li>DoubleAccumulator</li><li>DoubleAdder</li><li>LongAccumulator</li><li>LongAdder</li></ul><h4 id="5-新的Java工具"><a href="#5-新的Java工具" class="headerlink" title="5. 新的Java工具"></a>5. 新的Java工具</h4><p>Java 8提供了一些新的命令行工具，这部分会讲解一些对开发者最有用的工具。</p><h5 id="5-1-Nashorn引擎：jjs"><a href="#5-1-Nashorn引擎：jjs" class="headerlink" title="5.1 Nashorn引擎：jjs"></a>5.1 Nashorn引擎：jjs</h5><p><strong>jjs</strong>是一个基于标准Nashorn引擎的命令行工具，可以接受js源码并执行。例如，我们写一个<strong>func.js</strong>文件，内容如下：</p><pre class=" language-hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title"><code class="language-hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>() &#123;      <span class="hljs-keyword">return</span> <span class="hljs-type">1</span>; &#125;; print( f() + <span class="hljs-number">1</span> );Copy</code></pre><p>可以在命令行中执行这个命令：<code>jjs func.js</code>，控制台输出结果是：</p><pre class=" language-hljs dockerfile"><span class="hljs-number"><code class="language-hljs dockerfile"><span class="hljs-number">2</span><span class="hljs-keyword">Copy</span></code></pre><p>如果需要了解细节，可以参考<a href="http://docs.oracle.com/javase/8/docs/technotes/tools/unix/jjs.html" target="_blank" rel="noopener">官方文档</a>。</p><h5 id="5-2-类依赖分析器：jdeps"><a href="#5-2-类依赖分析器：jdeps" class="headerlink" title="5.2 类依赖分析器：jdeps"></a>5.2 类依赖分析器：jdeps</h5><p><strong>jdeps</strong>是一个相当棒的命令行工具，它可以展示包层级和类层级的Java类依赖关系，它以<strong>.class</strong>文件、目录或者Jar文件为输入，然后会把依赖关系输出到控制台。</p><p>我们可以利用jedps分析下<a href="http://www.androidos.net.cn/book/android-road/java/basis/java-8.html" target="_blank" rel="noopener">Spring Framework库</a>，为了让结果少一点，仅仅分析一个JAR文件：<strong>org.springframework.core-3.0.5.RELEASE.jar</strong>。</p><pre class=" language-hljs css"><span class="hljs-selector-tag">jdeps</span> <span class="hljs-selector-tag">org</span><span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.core-3</span><span class="hljs-selector-class">.0</span><span class="hljs-selector-class">.5</span><span class="hljs-selector-class">.RELEASE</span><span class="hljs-selector-class"><code class="language-hljs css"><span class="hljs-selector-tag">jdeps</span> <span class="hljs-selector-tag">org</span><span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.core-3</span><span class="hljs-selector-class">.0</span><span class="hljs-selector-class">.5</span><span class="hljs-selector-class">.RELEASE</span><span class="hljs-selector-class">.jar</span><span class="hljs-selector-tag">Copy</span></code></pre><p>这个命令会输出很多结果，我们仅看下其中的一部分：依赖关系按照包分组，如果在classpath上找不到依赖，则显示”not found”.</p><pre class=" language-hljs css"><span class="hljs-selector-tag">org</span><span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.core-3</span><span class="hljs-selector-class">.0</span><span class="hljs-selector-class">.5</span><span class="hljs-selector-class">.RELEASE</span><span class="hljs-selector-class">.jar</span> <span class="hljs-selector-tag">-</span>&gt; <span class="hljs-selector-tag">C</span>:\<span class="hljs-selector-tag">Program</span> <span class="hljs-selector-tag">Files</span>\<span class="hljs-selector-tag">Java</span>\<span class="hljs-selector-tag">jdk1</span><span class="hljs-selector-class">.8</span><span class="hljs-selector-class">.0</span>\<span class="hljs-selector-tag">jre</span>\<span class="hljs-selector-tag">lib</span>\<span class="hljs-selector-tag">rt</span><span class="hljs-selector-class"><code class="language-hljs css"><span class="hljs-selector-tag">org</span><span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.core-3</span><span class="hljs-selector-class">.0</span><span class="hljs-selector-class">.5</span><span class="hljs-selector-class">.RELEASE</span><span class="hljs-selector-class">.jar</span> <span class="hljs-selector-tag">-</span>&gt; <span class="hljs-selector-tag">C</span>:\<span class="hljs-selector-tag">Program</span> <span class="hljs-selector-tag">Files</span>\<span class="hljs-selector-tag">Java</span>\<span class="hljs-selector-tag">jdk1</span><span class="hljs-selector-class">.8</span><span class="hljs-selector-class">.0</span>\<span class="hljs-selector-tag">jre</span>\<span class="hljs-selector-tag">lib</span>\<span class="hljs-selector-tag">rt</span><span class="hljs-selector-class">.jar</span>   <span class="hljs-selector-tag">org</span><span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.core</span> (<span class="hljs-selector-tag">org</span><span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.core-3</span><span class="hljs-selector-class">.0</span><span class="hljs-selector-class">.5</span><span class="hljs-selector-class">.RELEASE</span><span class="hljs-selector-class">.jar</span>)      <span class="hljs-selector-tag">-</span>> <span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.io</span>                                                  <span class="hljs-selector-tag">-</span>> <span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.lang</span>                                                <span class="hljs-selector-tag">-</span>> <span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.annotation</span>                                     <span class="hljs-selector-tag">-</span>> <span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.ref</span>                                            <span class="hljs-selector-tag">-</span>> <span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.reflect</span>                                        <span class="hljs-selector-tag">-</span>> <span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.util</span>                                                <span class="hljs-selector-tag">-</span>> <span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span>                                     <span class="hljs-selector-tag">-</span>> <span class="hljs-selector-tag">org</span><span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.commons</span><span class="hljs-selector-class">.logging</span>                         <span class="hljs-selector-tag">not</span> <span class="hljs-selector-tag">found</span>      <span class="hljs-selector-tag">-</span>> <span class="hljs-selector-tag">org</span><span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.asm</span>                            <span class="hljs-selector-tag">not</span> <span class="hljs-selector-tag">found</span>      <span class="hljs-selector-tag">-</span>> <span class="hljs-selector-tag">org</span><span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.asm</span><span class="hljs-selector-class">.commons</span>                    <span class="hljs-selector-tag">not</span> <span class="hljs-selector-tag">found</span>   <span class="hljs-selector-tag">org</span><span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.core</span><span class="hljs-selector-class">.annotation</span> (<span class="hljs-selector-tag">org</span><span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.core-3</span><span class="hljs-selector-class">.0</span><span class="hljs-selector-class">.5</span><span class="hljs-selector-class">.RELEASE</span><span class="hljs-selector-class">.jar</span>)      <span class="hljs-selector-tag">-</span>> <span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.lang</span>                                                <span class="hljs-selector-tag">-</span>> <span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.annotation</span>                                     <span class="hljs-selector-tag">-</span>> <span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.reflect</span>                                        <span class="hljs-selector-tag">-</span>> <span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.util</span><span class="hljs-selector-tag">Copy</span></code></pre><p>更多的细节可以参考<a href="http://docs.oracle.com/javase/8/docs/technotes/tools/unix/jdeps.html" target="_blank" rel="noopener">官方文档</a>。</p><h4 id="6-JVM的新特性"><a href="#6-JVM的新特性" class="headerlink" title="6. JVM的新特性"></a>6. JVM的新特性</h4><p>使用<strong>Metaspace</strong>（<a href="http://openjdk.java.net/jeps/122" target="_blank" rel="noopener">JEP 122</a>）代替持久代（<strong>PermGen</strong> space）。在JVM参数方面，使用<strong>-XX:MetaSpaceSize</strong>和<strong>-XX:MaxMetaspaceSize</strong>代替原来的<strong>-XX:PermSize</strong>和<strong>-XX:MaxPermSize</strong>。</p><h3 id="2-10-其他"><a href="#2-10-其他" class="headerlink" title="2.10 其他"></a>2.10 其他</h3><h4 id="Object的方法"><a href="#Object的方法" class="headerlink" title="Object的方法"></a>Object的方法</h4><h4 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h4><h4 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h4><h4 id="对象转化和Instance-of"><a href="#对象转化和Instance-of" class="headerlink" title="对象转化和Instance of"></a>对象转化和Instance of</h4><h4 id="防止扩展和重写"><a href="#防止扩展和重写" class="headerlink" title="防止扩展和重写"></a>防止扩展和重写</h4><h4 id="static"><a href="#static" class="headerlink" title="static"></a>static</h4><h4 id="如何实现函数指针"><a href="#如何实现函数指针" class="headerlink" title="如何实现函数指针?"></a>如何实现函数指针?</h4><h4 id="char占几个字节，其他基本类型占几个字节"><a href="#char占几个字节，其他基本类型占几个字节" class="headerlink" title="char占几个字节，其他基本类型占几个字节?"></a>char占几个字节，其他基本类型占几个字节?</h4><p>char占2个字节；</p><p>boolean占至少1个字节，JVM规范中 boolean变量当做int处理;而boolean数组中每个元素是1字节。</p><h4 id="什么是向上转型？"><a href="#什么是向上转型？" class="headerlink" title="什么是向上转型？"></a>什么是向上转型？</h4><p>把子类的引用转换为父类的引用称作<strong>向上转型</strong>，这个术语基于类继承图。就是参数是父类的引用，传入了子类的引用。</p><h4 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal?"></a>ThreadLocal?</h4><h4 id="equals和hashcode"><a href="#equals和hashcode" class="headerlink" title="equals和hashcode"></a>equals和hashcode</h4><h5 id="equals规范"><a href="#equals规范" class="headerlink" title="equals规范"></a>equals规范</h5><p>java编程思想中定义的合适的equals函数需满足：</p><ol><li><p>如果<strong>右值</strong>是<strong>null</strong>，那么不相等。</p></li><li><p>如果<strong>右值</strong>是<strong>this</strong>，那么两个对象相等。</p></li><li><p>如果<strong>右值</strong>不是同一个类型或者子类，那么两个对象不相等。</p></li><li><p>如果所有上面的检查通过了，那么你必须决定 <strong>右值</strong> 中的哪些字段是重要的，然后比较这些字段。 Java 7 引入了 <strong>Objects</strong> 类型来帮助这个流程，这样我们能够写出更好的 <strong>equals()</strong> 函数。</p><p>注：</p><ol><li><strong>instanceof</strong>检查减少了<strong>null</strong>检查的需要。</li><li>和<strong>this</strong>的比较是多余的。(但是还是写，这样块)</li></ol></li></ol><ul><li><p><strong>Objects.equals()</strong> 会在你组合其他类型的时候发挥很大的作用</p><h4 id="不同子类的相等性"><a href="#不同子类的相等性" class="headerlink" title="不同子类的相等性"></a>不同子类的相等性</h4></li><li><p>HashMap使用equals()判断当前的键是否与表中存在的键相同。</p></li><li><p>hashCode()并不需要总是能够返回唯一的标识码（稍后你会理解其原因），但是equals() 方法必须严格地判断两个对象是否相同。</p></li><li><p>如果不为你的键覆盖hashCode() 和equals() ，那么使用散列的数据结构（HashSet，HashMap，LinkedHashst或LinkedHashMap）就无法正确处理你的键</p></li><li><p>使用散列的目的在于：想要使用一个对象来查找另一个对象</p></li></ul><h4 id="基本类型和包装类型"><a href="#基本类型和包装类型" class="headerlink" title="基本类型和包装类型"></a>基本类型和包装类型</h4><p>包装类没有无参构造方法，包装类的实例都是不可变的.</p><p>每一个数值包装类都有常量MAX_VALUE和MIN_VALUE，MIN_VALUE表示float和double的最小正值1.4E-45。</p><p><strong>包装类型对象的大小比较</strong></p><ul><li>包装类的<strong>compareTo</strong>()，大于等于小于分别返回1，0，-1</li></ul><p><strong>数值或字符串转数值包装类</strong></p><ul><li>包装类的静态方法<strong>valueof</strong>(String s)，将字符串转化为对应的包装类对象。</li><li>包装类都有2个重载的方法parse***，将数值字符串转为正确的以10进制或其他基数的数值。</li><li>valueof(String s)的实现是调用了parse***实现。</li></ul><p><strong>自动装箱</strong></p><ul><li>自动调用了包装类的构造函数</li></ul><h3 id="2-11-枚举"><a href="#2-11-枚举" class="headerlink" title="2.11 枚举"></a>2.11 枚举</h3><p>使用枚举而不是整数字面量可以让程序更加易于阅读和维护。</p><ul><li><strong>所有的枚举值都是 public static final 的(整数)</strong>，且非抽象的枚举类不能再派生子类</li><li>枚举类<strong>可以拥有多个构造方法,构造方法只能是private的</strong>，可以不写。</li><li>枚举类型可以有方法和属性，<strong>枚举值得出现在第一行</strong>。</li><li>枚举被当做Class，是Object和Comparable的子类</li><li>JDK1.5之后switch支持枚举</li><li><strong>枚举类型声明在类中时，只能是static的</strong>，可以不写</li></ul><h3 id="2-12-字符串"><a href="#2-12-字符串" class="headerlink" title="2.12 字符串"></a>2.12 字符串</h3><p>java将字符串直接量看做String对象.</p><h4 id="String，StringBuilder，StringBuffer-StrongTokenizer"><a href="#String，StringBuilder，StringBuffer-StrongTokenizer" class="headerlink" title="String，StringBuilder，StringBuffer,StrongTokenizer?"></a>String，StringBuilder，StringBuffer,StrongTokenizer?</h4><ul><li><p>String是final修饰的，不能被继承，是不可变类，对String对象的任何改变都不影响原对象，相关的任何change操作都会生成的对象。</p></li><li><p>StringBuilder，StringBuffer是可变字符串，后者都是用synchroinzed修饰的，是线程安全的。</p></li><li><p>StrongTokenizer用于字符串分割.</p></li><li><p>String字符串 +  操作是通过构造StringBuilder对象，append方法，并最后通过它的toString方法实现的，StringBuilder&amp;toString方法也是做了一份拷贝</p><pre class=" language-hljs smali"><code class="language-hljs smali">@Override   <span class="hljs-keyword"> public</span> String toString() &#123;        // Create a copy, don't share the array       <span class="hljs-built_in"> return </span>new String(value, 0, count);    &#125;</code></pre></li><li><p>Character也是final修饰的，用于对单个字符操作.</p></li><li><p>String str = “i”+”love”+”java”;</p><p>其中的字符串在编译时就能确认，编译器会直接将其拼接成一个字符串放在常量池（编译器优化）：”i love java”；</p></li></ul><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h3 id="2-12-随机数"><a href="#2-12-随机数" class="headerlink" title="2.12 随机数"></a>2.12 随机数</h3><p>1.使用Math.random()获取一个[0.0到1.0)范围内的随机double值（实际也是Random对象的nextDouble方法）</p><p>2.使用java.util.Random类，它可以产生一个int、long、float、double,boolean型值</p><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>+Random()</td><td>以当前时间为种子创建一个Random对象</td><td></td></tr><tr><td>+Random(seed:long)</td><td>以给定值作为种子创建一个Random对象</td><td></td></tr><tr><td>+nextInt(): int</td><td></td><td></td></tr><tr><td>+nextInt(n:int): int</td><td>返回[0,n)之间的随机int类型的值</td><td></td></tr><tr><td>+nextLong():long</td><td>返回一个随机的long值</td><td></td></tr><tr><td>+nextFloat():float</td><td>返回一个[0.0f，1.0f)之间的float类型的随机值</td><td></td></tr><tr><td>+nextDouble():double</td><td></td><td></td></tr><tr><td>+nextBoolean():boolean</td><td></td><td></td></tr></tbody></table><p>种子是一个用于初始化一个随机数字生成器的数字。如果2个Random对象有相同的种子，那他们将产生相同的序列。</p><h3 id="2-13-Scanner"><a href="#2-13-Scanner" class="headerlink" title="2.13 Scanner"></a>2.13 Scanner</h3><p>可以从文件、键盘、字符串读取数据。Scanner将输入分为由空白字符分隔的标记，标记就是2个分隔符中间的部分。next<strong>*()被称为标记读取方法，因为它们会读取用分隔符分隔开的标记，</strong>默认情况下分隔符是空格**。可以使用usesrDelimiter(String regex)设置新的分隔符。</p><p>next***方法如何工作？</p><p>一个标记读取方法首先跳过任意分隔符（默认是空格），然后读取一个以分隔符结束的标记，然后转型，比如nextInt就转型为int。</p><p>next()无须转化，读取一个由分隔符分割的字符串；nextLine()读取一个以换行符结束的行。</p><blockquote><p> 注:</p><p>1.行分隔符字符串不同的系统不同。windows是\r\n，unix平台是\n，如果从键盘输入，每行以\n(回车键)结束。得到特定平台的行分隔符，使用<code>String lineSeparator = System.getProperty(&quot;line.separator&quot;)</code></p><p>2.标记读取方法不能读取标记后面的分隔符</p></blockquote><h2 id="3-Java并发"><a href="#3-Java并发" class="headerlink" title="3.Java并发"></a>3.Java并发</h2><h3 id="3-1"><a href="#3-1" class="headerlink" title="3.1"></a>3.1</h3><h4 id="一、对象的创建"><a href="#一、对象的创建" class="headerlink" title="一、对象的创建"></a>一、<strong>对象的创建</strong></h4><p>1.虚拟机遇到一个new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用；</p><p>2.检查这个符号引用代表的类是否已经被加载，解析和初始化过。如果没有，那必须先执行响应的类加载过程；</p><p>3.在类加载检查功通过后，为新生对象分配内存。对象所需的内存大小在类加载完成后便可完全确定。</p><h4 id="二、对象的内存布局"><a href="#二、对象的内存布局" class="headerlink" title="二、对象的内存布局"></a>二、对象的内存布局</h4><p><strong>分为3个区域：对象头，实例数据，对齐填充。</strong></p><h5 id="对象头："><a href="#对象头：" class="headerlink" title="对象头："></a>对象头：</h5><p>包括两部分信息，第一部分：对象自身的运行时数据，如哈希码，GC分代年龄，锁状态标志，线程持有的锁，偏向线程ID，偏向时间戳等，这部分数据的长度在32位和64位的虚拟机中分别为32 bit和64 bit，官方称它为“Mark Word”。</p><p>第二部分：类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。如果对象是一个java数组，那在对象头中还必须有一块用于记录数组长度的数据。</p><h5 id="实例数据："><a href="#实例数据：" class="headerlink" title="实例数据："></a>实例数据：</h5><p>是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。</p><h5 id="对齐填充："><a href="#对齐填充：" class="headerlink" title="对齐填充："></a>对齐填充：</h5><p>对齐填充不是必然存在的。HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，也就是说对象的大小必须是8字节的整数倍。而对象头部分正好是8字节的整数倍。因此，当对象实例数据部分没有对齐时，就需要通过对其补充来补全了。</p><h4 id="三、对象的访问定位"><a href="#三、对象的访问定位" class="headerlink" title="三、对象的访问定位"></a>三、对象的访问定位</h4><p>Java程序需要通过栈上了reference数据来操作堆上的具体对象。</p><p>目前主流的访问方式有使用句柄和直接指针两种。</p><h5 id="句柄访问："><a href="#句柄访问：" class="headerlink" title="句柄访问："></a>句柄访问：</h5><p>Java堆中会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对实例数据与类型数据的各自具体的地址信息。</p><p><img src="https://codingsky.oss-cn-hangzhou.aliyuncs.com/androidos/articles/content/convert/60b10cc0752c2f3fbb4c5f35497fbcda.dat" srcset="/img/loading.gif" alt="img"></p><h5 id="直接指针访问："><a href="#直接指针访问：" class="headerlink" title="直接指针访问："></a>直接指针访问：</h5><p>reference中存储的直接就是对象地址。</p><p><img src="https://codingsky.oss-cn-hangzhou.aliyuncs.com/androidos/articles/content/convert/db797ac3cf00acbd3f2ba269eded3148.dat" srcset="/img/loading.gif" alt="img"></p><h3 id="3-2-Java内存区域与内存模型"><a href="#3-2-Java内存区域与内存模型" class="headerlink" title="3.2 Java内存区域与内存模型"></a>3.2 Java内存区域与内存模型</h3><h4 id="一、Java内存区域"><a href="#一、Java内存区域" class="headerlink" title="一、Java内存区域"></a>一、Java内存区域</h4><p><strong>方法区（公有）：</strong> 用来存储已被虚拟机加载的类信息(加载class成Class对象)，常量(final修饰的变量)，静态变量，即时编译器编译后的代码等数据。异常状态 OutOfMemoryError。</p><p>其中包含常量池：用户存放编译器生成的各种字面量(数值，字符串值)和符号引用（类引用，字段引用，方法引用）；可以看做是一张表，虚拟机指令根据这张表找到要执行的类名，方法名，参数类型，字面量等信息。</p><p><strong>堆（公有）：</strong> 是JVM所管理的内存中最大的一块。唯一目的就是存放实例对象，几乎所有的对象实例都在这里分配。Java堆是垃圾收集器管理的主要区域，因此很多时候也被称为“GC堆”。异常状态 OutOfMemoryError</p><p><strong>虚拟机栈（线程私有）：</strong> 描述的是java方法执行的内存模型：每个方法在执行时都会创建一个栈帧，用户存储局部变量表，操作数栈，动态连接，方法出口等信息。每一个方法从调用直至完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。 对这个区域定义了两种异常状态 OutOfMemoryError StackOverflowError</p><p><strong>本地方法栈（线程私有）:</strong> 与虚拟机栈所发挥的作用相似。它们之间的区别不过是虚拟机栈为虚拟机执行java方法，而本地方法栈为虚拟机使用到的Native方法服务。</p><p><strong>程序计数器（线程私有）：</strong> 一块较小的内存，当前线程所执行的字节码的行号指示器。字节码解释器工作时，就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。</p><p><img src="https://codingsky.oss-cn-hangzhou.aliyuncs.com/androidos/articles/content/convert/784172a0282cfb0665b49f5960d0a4d4.dat" srcset="/img/loading.gif" alt="img"></p><h4 id="二、Java内存模型"><a href="#二、Java内存模型" class="headerlink" title="二、Java内存模型"></a>二、Java内存模型</h4><p><strong>Java内存模型的目的：</strong> 屏蔽掉各种硬件和操作系统的内存访问差异，以实现让java程序在各种平台下都能达到一致的内存访问效果。</p><p><strong>主要目标：</strong> 定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。此处的变量与Java变成中所说的变量是有所区别，它包括了实例字段，静态字段和构成数组对象的元素，但不包括局部变量和方法参数。</p><p><strong>Java内存模型规定了所有的变量都存储在主内存中。每条线程中还有自己的工作内存，线程的工作内存中保存了被该线程所使用到的变量（这些变量是从主内存中拷贝而来）。线程对变量的所有操作（读取，赋值）都必须在工作内存中进行。不同线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。</strong></p><hr><p><img src="https://codingsky.oss-cn-hangzhou.aliyuncs.com/androidos/articles/content/convert/5330cc1af735870368d55d7f90b9b0ad.dat" srcset="/img/loading.gif" alt="img"></p><p>关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节，Java内存模型中定义了8种操作来完成，并且每种操作都是原子的、不可再分的。</p><h5 id="八种操作："><a href="#八种操作：" class="headerlink" title="八种操作："></a>八种操作：</h5><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>lock</td><td>作用于主内存的变量，把一个变量标识为一条线程独占的状态</td></tr><tr><td>unlock</td><td>作用于主内存的变量，把一个处于锁定状态的变量释放出来。</td></tr><tr><td>read</td><td>把一个变量的值从主内存传输到工作内存中，以便随后的load使用。</td></tr><tr><td>load</td><td>把read操作从主内存中得到的变量值放入到工作内存的变量副本中。</td></tr><tr><td>use</td><td>把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。</td></tr><tr><td>assign</td><td>把一个从执行引擎中接收到的值赋值给工作内存中的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</td></tr><tr><td>store</td><td>把工作内存中的一个变量的值传递到主内存，以便随后的write使用。</td></tr><tr><td>write</td><td>把store操作从工作内存中得到的变量值放入到主内存的变量中。</td></tr></tbody></table><h3 id="3-3-Java类加载机制及类加载器详解"><a href="#3-3-Java类加载机制及类加载器详解" class="headerlink" title="3.3 Java类加载机制及类加载器详解"></a>3.3 Java类加载机制及类加载器详解</h3><h4 id="一、类加载机制"><a href="#一、类加载机制" class="headerlink" title="一、类加载机制"></a>一、类加载机制</h4><h5 id="1-定义："><a href="#1-定义：" class="headerlink" title="1.定义："></a>1.定义：</h5><p>把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型。</p><p>在Java语言里，类型的加载、连接和初始化过程都是在程序运行期间完成的，这种策略虽然会令类加载时稍微增加一些性能开销，但是会为Java应用程序提供高度的灵活性，Java里天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点来实现的。</p><h5 id="2-类的生命周期："><a href="#2-类的生命周期：" class="headerlink" title="2.类的生命周期："></a>2.类的生命周期：</h5><p>加载，验证，准备，解析，初始化，使用和卸载。其中验证，准备，解析3个部分统称为连接。</p><p>这7个阶段发生顺序如下图：</p><p><img src="https://codingsky.oss-cn-hangzhou.aliyuncs.com/androidos/articles/content/convert/6435baca077dbbb1bd5bff371fc5ee9b.dat" srcset="/img/loading.gif" alt="img"></p><p>加载，验证，准备，初始化，卸载这5个阶段的顺序是确定的，而解析阶段则不一定：它在某些情况下可以在初始化完成后在开始，这是为了支持Java语言的运行时绑定。</p><p><strong>其中加载，验证，准备，解析及初始化是属于类加载机制中的步骤。注意此处的加载不等同于类加载。</strong></p><h5 id="3-触发类加载的条件："><a href="#3-触发类加载的条件：" class="headerlink" title="3.触发类加载的条件："></a>3.触发类加载的条件：</h5><p>①.遇到new,getstatic,putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发初始化。生成这4条指令的最常见的Java代码场景是：</p><ul><li>使用new关键字实例化对象的时候，</li><li>读取或设置一个类的静态字段的时候（被final修饰，已在编译期把结果放入常量池的静态字段除外），</li><li>以及调用一个类的静态方法的时候。</li></ul><p>②.使用java.lang.reflect包的方法对类进行反射调用的时候。</p><p>③.当初始化一个类的时候，发现其父类还没有进行过初始化，则需要先触发父类的初始化。</p><p>④.当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。</p><p>⑤.当使用JDK1.7的动态语言支持时，如果一个<code>java.lang.invoke.MethodHandle</code>实例最后的解析结果<code>REF_getStatic,REF_putStatic,REF_invokeStatic</code>的方法句柄，并且这个方法句柄所对应的类没有进行初始化，则需要先出发初始化。</p><h5 id="4-类加载的具体过程："><a href="#4-类加载的具体过程：" class="headerlink" title="4.类加载的具体过程："></a>4.类加载的具体过程：</h5><p><strong>加载:</strong></p><p>①.通过一个类的全限定名来获取定义此类的二进制字节流</p><p>②.将这个字节流所代表的静态存储结构转换为方法区内的运行时数据结构</p><p>③.在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</p><p><strong>验证：</strong></p><p>是连接阶段的第一步，目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p><p>包含四个阶段的校验动作</p><p>a.文件格式验证</p><p>验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。</p><p>b.元数据验证</p><p>对类的元数据信息进行语义校验，是否不存在不符合Java语言规范的元数据信息</p><p>c.字节码验证</p><p>最复杂的一个阶段，主要目的是通过数据流和控制流分析，确定程序语义是合法的，符合逻辑的。对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件。</p><p>d.符号引用验证</p><p>最后一个阶段的校验发生在虚拟机将符号引用转换为直接引用的时候，这个转换动作将在连接的第三个阶段——解析阶段中发生。</p><p>符号验证的目的是确保解析动作能正常进行。</p><p><strong>准备：</strong></p><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段。这些变量所使用的内存都将在方法区中分配。只包括类变量。初始值“通常情况”下是数据类型的零值。</p><p>“特殊情况”下，如果类字段的字段属性表中存在ConstantValue属性，那么在准备阶段变量的值就会被初始化为ConstantValue属性所指定的值。</p><p><strong>解析：</strong></p><p>虚拟机将常量池内的符号引用替换为直接引用的过程。直接引用可以是直接指向目标的指针。在执行getfield、getstatic、instanceof、invokedynamic、invokestatic、invokespecial、ldc、new等用于操作符号引用的指令前，先对使用的符号引用进行解析。</p><p>解析动作主要针对类或接口、字段、类方法、接口方法等符号引用进行。</p><p>1、类或接口的解析。</p><p><strong>初始化：</strong></p><p>类加载过程中的最后一步。</p><p>初始化阶段是执行类构造器<code>&lt;cinit&gt;</code>方法的过程。</p><p><code>&lt;cinit&gt;</code>方法是由编译器自动收集类中的<strong>所有类变量的赋值动作和静态语句块中的语句合并产生的</strong>。</p><p><code>&lt;cinit&gt;</code>与类的构造函数不同，它不需要显示地调用父类构造器，虚拟机会保证在子类的<code>&lt;cinit&gt;</code>方法执行之前，父类的<code>()</code>方法已经执行完毕。</p><p><strong>简单地说，初始化就是对类变量进行赋值及执行静态代码块。</strong></p><h4 id="二、类加载器"><a href="#二、类加载器" class="headerlink" title="二、类加载器"></a>二、类加载器</h4><p>通过上述的了解，我们已经知道了类加载机制的大概流程及各个部分的功能。其中加载部分的功能是将类的class文件读入内存，并为之创建一个java.lang.Class对象。这部分功能就是由类加载器来实现的。</p><h5 id="1-类加载器分类："><a href="#1-类加载器分类：" class="headerlink" title="1.类加载器分类："></a>1.类加载器分类：</h5><p>不同的类加载器负责加载不同的类。主要分为两类。</p><p><strong>启动类加载器（Bootstrap ClassLoader）：</strong> 由C++语言实现（针对HotSpot）,负责将存放在\lib目录或-Xbootclasspath参数指定的路径中的类库加载到内存中，即负责加载Java的核心类。</p><p><strong>其他类加载器：</strong> 由Java语言实现，继承自抽象类ClassLoader。如：</p><p><strong>扩展类加载器（Extension ClassLoader）：</strong> 负责加载\lib\ext目录或java.ext.dirs系统变量指定的路径中的所有类库，即负责加载Java扩展的核心类之外的类。</p><p><strong>应用程序类加载器（Application ClassLoader）：</strong> 负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器，通过ClassLoader.getSystemClassLoader()方法直接获取。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。</p><p>以上2大类，3小类类加载器基本上负责了所有Java类的加载。下面我们来具体了解上述几个类加载器实现类加载过程时相互配合协作的流程。</p><h5 id="2-双亲委派模型"><a href="#2-双亲委派模型" class="headerlink" title="2.双亲委派模型"></a>2.双亲委派模型</h5><p>双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</p><p><img src="https://codingsky.oss-cn-hangzhou.aliyuncs.com/androidos/articles/content/convert/0a6a057d0d13d9d91b553c25e1fdd47e.dat" srcset="/img/loading.gif" alt="img"></p><p>这样的好处是不同层次的类加载器具有不同优先级，比如所有Java对象的超级父类java.lang.Object，位于rt.jar，无论哪个类加载器加载该类，最终都是由启动类加载器进行加载，保证安全。即使用户自己编写一个java.lang.Object类并放入程序中，虽能正常编译，但不会被加载运行，保证不会出现混乱。</p><h5 id="3-双亲委派模型的代码实现"><a href="#3-双亲委派模型的代码实现" class="headerlink" title="3.双亲委派模型的代码实现"></a>3.双亲委派模型的代码实现</h5><p>ClassLoader中loadClass方法实现了双亲委派模型</p><pre class=" language-hljs java"><span class="hljs-keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="hljs-keyword">boolean</span> resolve)    <span class="hljs-keyword">throws</span> ClassNotFoundException&#123;    <span class="hljs-keyword">synchronized</span> (getClassLoadingLock(name)) &#123;        <span class="hljs-comment">//检查该类是否已经加载过</span>        Class c = findLoadedClass(name);        <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-comment">//如果该类没有加载，则进入该分支</span>            <span class="hljs-keyword">long</span> t0 = System.nanoTime();            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-keyword">if</span> (parent != <span class="hljs-keyword">null</span>) &#123;                    <span class="hljs-comment">//当父类的加载器不为空，则通过父类的loadClass来加载该类</span>                    c = parent.loadClass(name, <span class="hljs-keyword">false</span>);                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-comment">//当父类的加载器为空，则调用启动类加载器来加载该类</span>                    c = findBootstrapClassOrNull(name);                &#125;            &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;                <span class="hljs-comment">//非空父类的类加载器无法找到相应的类，则抛出异常</span>            &#125;            <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-comment">//当父类加载器无法加载时，则调用findClass方法来加载该类</span>                <span class="hljs-keyword">long</span> t1 = System.nanoTime();                c = findClass(name); <span class="hljs-comment">//用户可通过覆写该方法，来自定义类加载器</span>                <span class="hljs-comment">//用于统计类加载器相关的信息</span>                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);                sun.misc.PerfCounter.getFindClasses().increment();            &#125;        &#125;        <span class="hljs-keyword">if</span> (resolve) &#123;            <span class="hljs-comment">//对类进行link操作</span>            resolveClass(c);        &#125;        <span class="hljs-keyword">return</span> c;    &#125;&#125;Copy</code></pre><p>整个流程大致如下：</p><p>a.首先，检查一下指定名称的类是否已经加载过，如果加载过了，就不需要再加载，直接返回。</p><p>b.如果此类没有加载过，那么，再判断一下是否有父加载器；如果有父加载器，则由父加载器加载（即调用parent.loadClass(name, false);）.或者是调用bootstrap类加载器来加载。</p><p>c.如果父加载器及bootstrap类加载器都没有找到指定的类，那么调用当前类加载器的findClass方法来完成类加载。</p><p>关于自定义类加载器，本篇文章就不介绍了，主要是重写findClass方法，有兴趣的可以参考<a href="http://www.jianshu.com/p/acc7595f1b9d" target="_blank" rel="noopener">这篇文章</a>。</p><h3 id="3-4-JVM中垃圾收集算法及垃圾回收"><a href="#3-4-JVM中垃圾收集算法及垃圾回收" class="headerlink" title="3.4 JVM中垃圾收集算法及垃圾回收"></a>3.4 JVM中垃圾收集算法及垃圾回收</h3><h4 id="一、垃圾收集算法"><a href="#一、垃圾收集算法" class="headerlink" title="一、垃圾收集算法"></a>一、垃圾收集算法</h4><h5 id="1-标记-清除算法"><a href="#1-标记-清除算法" class="headerlink" title="1.标记-清除算法"></a>1.标记-清除算法</h5><p>最基础的收集算法是“标记-清除”（Mark-Sweep）算法，如同它的名字一样，算法分为“标记”和“清除”两个阶段。</p><p>①首先标记出所有需要回收的对象</p><p>②在标记完成后统一回收所有被标记的对象。</p><p><strong>不足：</strong></p><p>效率问题：标记和清除两个过程的效率都不高</p><p>空间问题：标记清除之后产生大量不连续的内存碎片，空间碎片太多可能会导致以后程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</p><p><img src="https://codingsky.oss-cn-hangzhou.aliyuncs.com/androidos/articles/content/convert/6f5d8750cf38f5e4c5341bc57c5b19bd.dat" srcset="/img/loading.gif" alt="img"></p><h5 id="2-复制算法"><a href="#2-复制算法" class="headerlink" title="2.复制算法"></a>2.复制算法</h5><p><strong>目的：</strong> 为了解决效率问题。</p><p>将可用内存按容量大小划分为大小相等的两块，每次只使用其中的一块。当一块内存使用完了，就将还存活着的对象复制到另一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况。</p><p><strong>缺点：</strong> 将内存缩小为了原来的一半。</p><p><img src="https://codingsky.oss-cn-hangzhou.aliyuncs.com/androidos/articles/content/convert/dde277046cee52ebd154730b08a2ef6b.dat" srcset="/img/loading.gif" alt="img"></p><p>现代的商业虚拟机都采用这种收集算法来回收新生代，IBM公司的专门研究表明，新生代中对象98%对象是“朝生夕死”的，所以不需要按照1：1的比例来划分内存空间，而是<strong>将内存分为较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。HotSpot虚拟机中默认Eden和Survivor的大小比例是8：1。</strong></p><h5 id="3-标记-整理算法"><a href="#3-标记-整理算法" class="headerlink" title="3.标记-整理算法"></a>3.标记-整理算法</h5><p>复制收集算法在对象存活率较高时，就要进行较多的复制操作，效率就会变低。 根据老年代的特点，提出了“标记-整理”算法。</p><p>标记过程仍然与”标记-清除“算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存。</p><p><img src="https://codingsky.oss-cn-hangzhou.aliyuncs.com/androidos/articles/content/convert/a1a3d51e5f23a91aa93e0dab96c13bad.dat" srcset="/img/loading.gif" alt="img"></p><h5 id="4-分代收集算法"><a href="#4-分代收集算法" class="headerlink" title="4.分代收集算法"></a>4.分代收集算法</h5><p>一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。</p><p>在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法。</p><p>在老年代中，因为对象存活率高、没有额外空间对它进行分配担保，就必须采用“标记-清除”或“标记-整理”算法来进行回收。</p><h4 id="二、垃圾回收机制的一些知识"><a href="#二、垃圾回收机制的一些知识" class="headerlink" title="二、垃圾回收机制的一些知识"></a>二、垃圾回收机制的一些知识</h4><h5 id="1-JVM中的年代"><a href="#1-JVM中的年代" class="headerlink" title="1.JVM中的年代"></a>1.JVM中的年代</h5><p><strong>JVM中分为年轻代（Young generation）和老年代(Tenured generation)</strong>。</p><p><strong>HotSpot JVM把年轻代分为了三部分</strong>：1个Eden区和2个Survivor区（分别叫from和to）。默认比例为8：1，为啥默认会是这个比例，接下来我们会聊到。</p><p><strong>一般情况下，新创建的对象都会被分配到Eden区</strong>(一些大对象特殊处理)，这些对象经过第一次Minor GC后，如果仍然存活，将会被移到Survivor区。对象在Survivor区中每熬过一次Minor GC，年龄就会增加1岁，当它的年龄增加到一定程度时，就会被移动到年老代中。 因为年轻代中的对象基本都是朝生夕死的(80%以上)，所以<strong>在年轻代的垃圾回收算法使用的是复制算法</strong>，复制算法的基本思想就是将内存分为两块，每次只用其中一块，当这一块内存用完，就将还活着的对象复制到另外一块上面。复制算法不会产生内存碎片。</p><p>在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。紧接着进行GC，Eden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置)的对象会被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。经过这次GC后，Eden区和From区已经被清空。这个时候，“From”和“To”会交换他们的角色，也就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”。不管怎样，都会保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。</p><h5 id="2-Minor-GC和Full-GC的区别"><a href="#2-Minor-GC和Full-GC的区别" class="headerlink" title="2.Minor GC和Full GC的区别"></a>2.Minor GC和Full GC的区别</h5><p>Minor GC:指发生在新生代的垃圾收集动作，该动作非常频繁。</p><p>Full GC/Major GC:指发生在老年代的垃圾收集动作，出现了Major GC，经常会伴随至少一次的Minor GC。Major GC的速度一般会比Minor GC慢10倍以上。</p><h5 id="3-空间分配担保"><a href="#3-空间分配担保" class="headerlink" title="3. 空间分配担保"></a>3. 空间分配担保</h5><p>在发生Minor GC之前，虚拟机会<strong>先检查老年代最大可用的连续空间是否大于新生代所有对象的总空间</strong>，如果这个条件成立，那么Minor GC可以 确保是安全的。如果不成立，则虚拟机<strong>会查看HandlePromotionFailure设置值是否允许担保失败</strong>。如果允许，那会继续检查老年代最大可用的连续空间<strong>是否大于历次晋升到老年代对象的平均大小，如果大于，则将尝试进行一次Minor GC</strong>，尽管这个Minor GC是有风险的。如果小于，或者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC。</p><p>以上便是在垃圾回收过程中，需要了解的一些必要的知识。下面我们就来介绍具体的垃圾收集器。</p><h4 id="三、垃圾收集器"><a href="#三、垃圾收集器" class="headerlink" title="三、垃圾收集器"></a>三、垃圾收集器</h4><p><img src="https://codingsky.oss-cn-hangzhou.aliyuncs.com/androidos/articles/content/convert/b20c0f0b75d26a739a9caba80c5021ac.dat" srcset="/img/loading.gif" alt="img"></p><p>上图展示了7种作用于不同分代的收集器，如果两个收集器之间存在连线，说明它们可以搭配使用。</p><p><img src="../../../../../../Pictures/md_images/image-20201009224845853.png" srcset="/img/loading.gif" alt="image-20201009224845853"></p><h5 id="1-Serial收集器"><a href="#1-Serial收集器" class="headerlink" title="1.Serial收集器"></a>1.Serial收集器</h5><p>是最基本、发展历史最悠久的收集器。这是一个<strong>单线程收集器</strong>。但它的“单线程”的意义并不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。</p><p><img src="https://codingsky.oss-cn-hangzhou.aliyuncs.com/androidos/articles/content/convert/81e974fdcc0608371c2d340a031e8fe3.dat" srcset="/img/loading.gif" alt="img"></p><p>是虚拟机运行在Client模式下的默认新生代收集器。</p><p><strong>优势：</strong> 简单而高效（与其他收集器的单线程比），对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程效率。</p><h5 id="2-ParNew收集器"><a href="#2-ParNew收集器" class="headerlink" title="2.ParNew收集器"></a>2.ParNew收集器</h5><p>ParNew收集器其实就是Serial收集器的多线程版本。</p><p>是许多运行在Server模式下的虚拟机中首选的新生代收集器，其中一个与性能无关但很重要的原因是，除了Serial收集器外，目前只有它能与CMS收集器配合工作。</p><p>ParNew收集器默认开启的收集线程数与CPU的数量相同。 下图是ParNew/Serial Old收集器运行示意图</p><p><img src="https://codingsky.oss-cn-hangzhou.aliyuncs.com/androidos/articles/content/convert/53dcb98663961325ba5e7f102ff493d9.dat" srcset="/img/loading.gif" alt="img"></p><h5 id="3-Parallel-Scavenge收集器"><a href="#3-Parallel-Scavenge收集器" class="headerlink" title="3.Parallel Scavenge收集器"></a>3.Parallel Scavenge收集器</h5><p>Parallel Scavenge收集器是一个新生代收集器，使用复制算法，又是并行的多线程收集器。</p><p><strong>最大的特点是：</strong> Parallel Scavenge收集器的目标是达到一个可控制的吞吐量。</p><p><strong>所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值</strong>，即吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间）。</p><p>高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，<strong>主要适合在后台运算而不需要太多交互的任务。</strong></p><p><img src="https://codingsky.oss-cn-hangzhou.aliyuncs.com/androidos/articles/content/convert/f3dbd38f2d4dd8a6fb1f603a19e6ae2f.dat" srcset="/img/loading.gif" alt="img"></p><h5 id="4-Serial-Old收集器"><a href="#4-Serial-Old收集器" class="headerlink" title="4.Serial Old收集器"></a>4.Serial Old收集器</h5><p>Serial Old是Serial收集器的老年代版本，同样是一个单线程收集器，使用“标记-整理”算法。这个收集器的主要意义也是在于给Client模式下虚拟机使用。</p><p>如果在Server模式下，它主要还有<strong>两大用途</strong>：</p><p>1.与Parallel Scavenge收集器搭配使用</p><p>2.作为CMS收集器的后备预案，在并发收集发生Conurrent Mode Failure使用。</p><h5 id="5-Parallel-Old收集器"><a href="#5-Parallel-Old收集器" class="headerlink" title="5.Parallel Old收集器"></a>5.Parallel Old收集器</h5><p>Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。</p><p><strong>在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge+Parallel Old收集器</strong></p><h5 id="6-CMS（Concurrent-Mark-Sweep）收集器"><a href="#6-CMS（Concurrent-Mark-Sweep）收集器" class="headerlink" title="6.CMS（Concurrent Mark Sweep）收集器"></a>6.CMS（Concurrent Mark Sweep）收集器</h5><p><strong>是HotSpot虚拟机中第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程同时工作。</strong></p><p><strong>关注点：</strong> 尽可能地缩短垃圾收集时用户线程的停顿时间。</p><p>CMS收集器是基于“标记-清除”算法实现的，<strong>整个过程分为4个步骤</strong>：</p><p>①初始标记</p><p>②并发标记</p><p>③重新标记</p><p>④并发清除</p><p>其中，初始标记，重新标记这两个步骤仍然需要“Stop The World”。初始标记仅仅只标记一下GC Roots能直接关联到的对象，速度很快。并发标记阶段就是 进行GC Roots Tracing的过程。</p><p>重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记几率，这个阶段的停顿时间一般会比初始标记阶段稍长，但远比并发标记时间短。</p><p>整个过程耗时最长的阶段是并发标记，并发清除过程，但这两个过程可以和用户线程一起工作。</p><p><img src="https://codingsky.oss-cn-hangzhou.aliyuncs.com/androidos/articles/content/convert/481f3b8c3f9a924350a02df120e2fec8.dat" srcset="/img/loading.gif" alt="img"></p><p><strong>缺点：</strong></p><p>①CMS收集器对CPU资源非常敏感。在并发阶段，它虽然不会导致用户线程停顿，但是会因为占用了一部分线程（或者说CPU资源）而导致应用程序变慢，总吞吐量会降低。</p><p>②CMS收集器无法处理浮动垃圾，可能出现“Conurrent Mode Failure”失败而导致另一次Full GC的产生。由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就还会产生新的垃圾，这一部分垃圾出现在标记过程之后，CMS无法在档次收集中处理掉它们，只好留待下一次GC时再清理掉。这部分垃圾就称为“浮动垃圾”。因此CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分空间提供并发收集时程序运作使用。在JDK1.5的默认设置下，CMS收集器当老年代使用了68%的空间后就会被激活。如果预留空间无法满足程序需要，就会出现一次“Concurrent Mode Failure”失败，这时虚拟机将启动后备预案Serial Old。</p><p>③CMS是一款基于“标记-清除”算法实现的收集器，所以会有大量空间碎片问题。</p><h5 id="7-G1收集器"><a href="#7-G1收集器" class="headerlink" title="7.G1收集器"></a>7.G1收集器</h5><p>是当今收集器技术发展的最前沿成果之一。是一款面向服务端应用的垃圾收集器。</p><p><strong>特点：</strong></p><p><strong>①并行与并发</strong></p><p>能充分利用多CPU，多核环境下的硬件优势，缩短Stop-The-World停顿的时间，同时可以通过并发的方式让Java程序继续执行</p><p><strong>②分代收集</strong></p><p>可以不需要其他收集器的配合管理整个堆，但是仍采用不同的方式去处理分代的对象。</p><p><strong>③空间整合</strong></p><p>G1从整体上来看，采用基于“标记-整理”算法实现收集器</p><p>G1从局部上来看，采用基于“复制”算法实现。</p><p><strong>④可预测停顿</strong></p><p>使用G1收集器时，Java堆内存布局与其他收集器有很大差别，它将整个Java堆划分成为多个大小相等的独立区域。 G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。</p><h3 id="3-5-JVM怎么判断是垃圾"><a href="#3-5-JVM怎么判断是垃圾" class="headerlink" title="3.5 JVM怎么判断是垃圾"></a>3.5 JVM怎么判断是垃圾</h3><h4 id="一、引用计数法"><a href="#一、引用计数法" class="headerlink" title="一、引用计数法"></a>一、引用计数法</h4><p>给对象添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能被再使用的。</p><p><strong>主流的JVM里面没有选用引用计数算法来管理内存，其中最主要的原因是它很难解决对象间的互循环引用的问题。</strong></p><h4 id="二、可达性分析算法"><a href="#二、可达性分析算法" class="headerlink" title="二、可达性分析算法"></a>二、可达性分析算法</h4><p>通过一些列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时（就是从GC Roots 到这个对象是不可达），则证明此对象是不可用的。所以它们会被判定为可回收对象（例如图B中的对象既是不可达的）。</p><p>在Java语言中，可以作为GC Roots的对象包括下面几种：</p><ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象<ul><li>方法参数，局部变量引用的对象</li></ul></li><li>方法区中类静态属性引用的对象；<ul><li>static变量引用的对象</li></ul></li><li>方法区中常量引用的对象；</li><li>本地方法栈中JNI（即一般说的Native方法）引用的对象；</li><li>所有被synchronized持有的对象</li><li>一些常驻的异常对象，系统类加载器</li></ul><p>总结就是，方法运行时，方法中引用的对象；类的静态变量引用的对象；类中常量引用的对象；Native方法中引用的对象</p><p><img src="https://codingsky.oss-cn-hangzhou.aliyuncs.com/androidos/articles/content/convert/0184f1cfc88a6bf12725cb021a42c135.dat" srcset="/img/loading.gif" alt="img"></p><p><strong>在可达性分析算法中，要真正宣告一个对象死亡，至少要经历两次标记过程：</strong></p><p>1.如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。当对象没有 覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。</p><p>2.如果这个对象被判定为有必要执行finalize()方法，那么这个对象将会放置在一个叫做F-Queue队列之中，并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去执行它。finalize()方法是对象逃脱死亡命运的最后一次机会，稍候GC将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalie()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己（this关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将会被移除出“即将回收”的集合；如果对象这时候还没有逃脱，那基本上它就真的被回收了。</p><h4 id="三、判断对象是否存活与“引用”有关"><a href="#三、判断对象是否存活与“引用”有关" class="headerlink" title="三、判断对象是否存活与“引用”有关"></a>三、判断对象是否存活与“引用”有关</h4><p>在JDK1.2之后，Java对引用的概念进行了扩充，将引用分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）四种，这四种<strong>引用强度依次逐渐减弱</strong>。</p><p><strong>强引用：</strong> 就是指在程序代码之中普遍存在的，类似“Object obj = new Object()”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。</p><p><strong>软引用：</strong> 用来描述一些还有用但并非必须的对象。在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。</p><p>图片缓存。</p><p><strong>弱引用：</strong> 用户描述非必须对象的。被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。</p><p>除了<code>WeakHashMap</code>使用了弱引用，<code>ThreadLocal</code>类中也是用了弱引用</p><p><strong>虚引用：</strong> 一个对象是否有虚引用存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用的唯一目的就是能在这个对象被收集器回收时刻得到一个系统通知。</p><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>中心思想：将物理主存扩大到便宜、大容量的磁盘上，即将磁盘空间看做是主存空间的一部分。用户程序可部分存放在内存。</p><p>如果存在一个程序，所需内存空间超过了内存容量，那么由于该程序无法装入内存所以也就无法运行。单纯的增加物理内存只能解决一部分问题，但是仍然会出现无法装入单个或者无法同时装入多个程序的问题。但是可以从逻辑的角度扩充内存容量，即可解决上述两种问题。</p><p>基于局部性原理，<strong>在程序装入时，可以将程序的一部分装入内存，而将其余部分留在外存</strong>，就可以启动程序执行。在程序执行过程中，<strong>当所访问的信息不在内存时，由操作系统将所需要的部分调入内存,然后继续执行程序</strong>。另一方面，操作系统将内存中<strong>暂时不使用的内容换出到外存上，从而腾出空间存放将要调入内存的信息</strong>。这样，系统好像为用户提供了一个比实际内存大得多的存储器，称为虚拟存储器。</p><p>虚拟存储器的特征：</p><ol><li>多次性：一个作业可以分多次被调入内存。多次性是虚拟存储特有的属性</li><li>对换性：作业运行过程中存在换进换出的过程(换出暂时不用的数据换入需要的数据)</li><li>虚拟性：虚拟性体现在其从逻辑上扩充了内存的容量(可以运行实际内存需求比物理内存大的应用程序)。虚拟性是虚拟存储器的最重要特征也是其最终目标。虚拟性建立在多次性和对换性的基础上行，多次性和对换性又建立在离散分配的基础上。</li></ol><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><h4 id="1-管道"><a href="#1-管道" class="headerlink" title="1.管道"></a>1.管道</h4><p>管道是一种半双工通信（单向交替传输）的方式，数据只能单向流动，而且只能在父子进程或者兄弟进程中使用</p><p>管道是1个特殊的文件，这个文件只存在于内存中。创建管道时，系统为管道分配一个页面作为数据缓冲区。</p><pre class=" language-hljs angelscript"><code class="language-hljs angelscript">#include <unistd.h> <span class="hljs-built_in">int</span> pipe(<span class="hljs-built_in">int</span> fd[<span class="hljs-number">2</span>]);/调用成功返回<span class="hljs-number">0</span>，并且数组中将包含<span class="hljs-number">2</span>个新的文件描述符,有错误发生返回<span class="hljs-number">-1</span></code></pre><h4 id="2-消息队列"><a href="#2-消息队列" class="headerlink" title="2.消息队列"></a>2.消息队列</h4><p>消息队列是存放在内核中的消息链表，每个消息队列由消息队列标识符标识。消息队列克服了信号传递信息量少、管道只能承载无格式字节流以及缓冲区大小受限等特点。</p><h4 id="3-信号量"><a href="#3-信号量" class="headerlink" title="3.信号量"></a>3.信号量</h4><p>信号量是一个计数器，常用于处理进程或线程的同步问题，特别是对临界资源的访问。信号量的值大于或等于0时表示可供并发进程使用的资源实体数；小于0时代表正在等待使用临界资源的进程数。</p><h4 id="4-共享内存"><a href="#4-共享内存" class="headerlink" title="4.共享内存"></a>4.共享内存</h4><p>就是分配一块能被其他进程访问的内存，需要使用信号量用来同步对共享存储的访问。</p><p>多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存。</p><p>允许多个进程共享一个给定的存储区。因为数据不需要在进程之间复制，所以这是最快的一种 IPC。</p><h4 id="5-socket"><a href="#5-socket" class="headerlink" title="5.socket"></a>5.socket</h4><p>与其它通信机制不同的是，它可用于不同机器间的进程通信。</p><h4 id="为什么要使用Binder？"><a href="#为什么要使用Binder？" class="headerlink" title="为什么要使用Binder？"></a>为什么要使用Binder？</h4><ol><li><strong>管道：</strong>在创建时分配一个page大小的内存，缓存区大小比较有限；</li><li><strong>消息队列</strong>：信息复制两次，额外的CPU消耗；不合适频繁或信息量大的通信；</li><li><strong>共享内存</strong>：无须复制，共享缓冲区直接付附加到进程虚拟地址空间，速度快；但进程间的同步问题操作系统无法实现，必须各进程利用同步工具解决；</li><li><strong>套接字</strong>：作为更通用的接口，传输效率低，主要用于不通机器或跨网络的通信；</li></ol><p><strong>性能方面</strong></p><p>Binder数据拷贝只需要一次，而管道、消息队列、Socket都需要2次，共享内存方式一次内存拷贝都不需要，但实现方式又比较复杂。</p><p>死锁</p><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h3 id="原则："><a href="#原则：" class="headerlink" title="原则："></a>原则：</h3><ul><li>多用组合，少用继承</li><li>针对接口编程，不针对实现编程</li><li>为交互对象之间的松耦合设计而努力</li><li>类应该对扩展开放，对修改关闭<ul><li>观察者模式中，通过加入新的观察者，可以在任何时候扩展Subject，而不需要往Subject中添加代码</li><li>装饰者模式，通过加入新的装饰者，可以在任何时候扩展被装饰者，而不需要修改装饰者的代码</li></ul></li><li>依赖抽象，不要依赖具体类</li><li>SOLID原则<ul><li>单一职责</li><li>open</li><li></li></ul></li></ul><h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><p>工厂模式总结：</p><p>所有的工厂都是用来封装对象的创建；所有工程模式都通过减少应用程序和具体类之间的依赖促进松耦合；</p><p>依赖倒置原则，指导我们避免依赖具体类型，而要尽量依赖抽象；</p><p>工厂是很有威力的技巧，帮助我们针对抽象编程，而不用针对具体类编程。</p><p>①简单工厂，虽然不是真正的设计模式，但不失为一个简单的方法，可以将客户程序从具体类解耦。</p><p>②工程方法使用继承：定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法允许将类实例化延迟到子类执行</p><p>③抽象工厂使用对象组合：对象的创建被实现在工厂接口暴露出来的方法中，抽象工厂创建相关的对象家族，而不需要依赖它们的具体类</p><h3 id="1-简单工厂模式"><a href="#1-简单工厂模式" class="headerlink" title="1.简单工厂模式"></a>1.简单工厂模式</h3><h5 id="1-1定义"><a href="#1-1定义" class="headerlink" title="1.1定义"></a>1.1定义</h5><p>简单工厂模式(Simple Factory Pattern)：又称为静态工厂方法(Static Factory Method)模式，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。</p><h5 id="1-2-应用"><a href="#1-2-应用" class="headerlink" title="1.2.应用"></a><strong>1.2.应用</strong></h5><p>①JDK类库中广泛使用了简单工厂模式，如工具类java.text.DateFormat，它用于格式化一个本地日期或者时间。</p><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> DateFormat <span class="hljs-title">getDateInstance</span><span class="hljs-params"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> DateFormat <span class="hljs-title">getDateInstance</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> DateFormat <span class="hljs-title">getDateInstance</span><span class="hljs-params">(<span class="hljs-keyword">int</span> style)</span></span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> DateFormat <span class="hljs-title">getDateInstance</span><span class="hljs-params">(<span class="hljs-keyword">int</span> style,Locale</span></span><span class="hljs-function"><span class="hljs-params">locale)</span></span>;Copy</code></pre><p>②Java加密技术<br>获取不同加密算法的密钥生成器:</p><pre class=" language-hljs java">KeyGenerator keyGen=KeyGenerator.getInstance(<span class="hljs-string"><code class="language-hljs java">KeyGenerator keyGen=KeyGenerator.getInstance(<span class="hljs-string">"DESede"</span>);</code></pre><p>创建密码器:</p><pre class=" language-hljs java">Cipher cp=Cipher.getInstance(<span class="hljs-string"><code class="language-hljs java">Cipher cp=Cipher.getInstance(<span class="hljs-string">"DESede"</span>);</code></pre><h3 id="2-工厂方法模式"><a href="#2-工厂方法模式" class="headerlink" title="2.工厂方法模式"></a>2.工厂方法模式</h3><p><strong>Intent</strong></p><p>​    定义了一个创建对象的接口，但由子类决定要实例化哪个类。工厂方法把实例化操作推迟到子类。</p><p> <strong>Class Diagram</strong> </p><p>在简单工厂中，创建对象的是另一个类，而在工厂方法中，是由子类来创建对象。</p><p>工厂方法模式包含如下角色：</p><p>●Product：抽象产品，工厂方法模式所创建的对象的超类，也就是所有产品类的共同父类或共同拥有的接口。在实际的系统中，这个角色也常常使用抽象类实现。</p><p>●ConcreteProduct：具体产品，这个角色实现了抽象产品（Product）所声明的接口，工厂方法模式所创建的每一个对象都是某个具体产品的实例。</p><p>●Factory：抽象工厂，担任这个角色的是工厂方法模式的核心，任何在模式中创建对象的工厂类必须实现这个接口。在实际的系统中，这个角色也常常使用抽象类实现。</p><p>●ConcreteFactory：具体工厂，担任这个角色的是实现了抽象工厂接口的具体Java类。具体工厂角色含有与业务密切相关的逻辑，并且受到使用者的调用以创建具体产品对象。</p><h3 id="3-抽象工厂模式"><a href="#3-抽象工厂模式" class="headerlink" title="3.抽象工厂模式"></a>3.抽象工厂模式</h3><p>定义一个创建一组相关产品的接口，接口内的每个方法创建一个具体产品，具体工厂来实现具体的做法。</p><p>优点：抽象工厂允许客户使用抽象的接口来创建一组相关的产品，而不需要知道实际产出的具体产品是什么。这样一来，客户就从具体的产品中被解耦。工厂方法模式只是用于创建一个对象。</p><p>抽象工厂模式包含如下角色：</p><p>AbstractFactory：抽象工厂<br>ConcreteFactory：具体工厂<br>AbstractProduct：抽象产品<br>Product：具体产品</p><h3 id="4-单例模式"><a href="#4-单例模式" class="headerlink" title="4.单例模式"></a>4.单例模式</h3><p><strong>Intent</strong></p><p>确保一个类只有一个实例，并提供该实例的全局访问点。</p><p>Class Diagram</p><p>使用一个私有构造函数、一个私有静态变量以及一个公有静态函数来实现。</p><p>实现方法：</p><p>①静态内部类的方式</p><p>②饿汉式</p><p>③懒汉式</p><p>④DCL 懒汉式</p><p>⑤枚举</p><h3 id="5-建造者模式"><a href="#5-建造者模式" class="headerlink" title="5.建造者模式"></a>5.建造者模式</h3><p>定义：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示，用户不需要知道内部的具体构建细节。</p><p>使用场景：</p><ul><li>初始化一个对象参数很多的时候，且很多参数都具有默认值    </li><li>产品类非常复杂，或者产品类的调用顺序不同产生了不同的作用</li></ul><p>角色：</p><ol><li>Product：产品的抽象类</li><li>Builder:抽象Builder类，一般由子类实现具体的构建过程</li><li>ConcreteBuilder:具体Builder类</li><li>Director:统一组装过程</li></ol><p>现实开发过程中：Director角色经常会被省略，而直接使用一个Builder来进行对象的组装，这个Builder通常为链式调用，这种形式结构简单。</p><p>Android中：</p><p>Builder是AlertDialog的内部类，Builder持有AlertController.AlertParams对象，Builder的set***方法都是设置AlertParams对象的属性，Builder的create方法new 了产品对象AlertDialog，并把前面设置的参数传给AlertDialog对象并返回。</p><h2 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h2><h3 id="1-适配器模式"><a href="#1-适配器模式" class="headerlink" title="1.适配器模式"></a>1.适配器模式</h3><h3 id="2-装饰者模式"><a href="#2-装饰者模式" class="headerlink" title="2.装饰者模式"></a>2.装饰者模式</h3><p>定义：装饰者模式动态地将责任附加到对象（咖啡加调料）身上。若要扩展功能，装饰者提供有别于继承的另一种选择。</p><p>要点：</p><ul><li>装饰者可以在被装饰者的行为前后加上的自己的行为，甚至整个取代掉，而达到特定目的</li><li>可以用无数个装饰者包装一个组件</li><li>装饰者和被装饰者有相同的超类型</li><li>对象可以在任何时候被装饰，所以可以在运行时动态地、不限量地用你喜欢的装饰者来装饰对象</li></ul><p>在装饰模式中的角色有：</p><p>​    ●　抽象构件(Component)角色：给出一个抽象接口，以规范准备接收附加责任的对象。</p><p>　●　具体构件(ConcreteComponent)角色：定义一个将要接收附加责任的类。</p><p>　●　装饰(Decorator)角色：持有一个构件(Component)对象的实例，并定义一个与抽象构件接口一致的接口。</p><p>　●　具体装饰(ConcreteDecorator)角色：负责给构件对象“贴上”附加的责任。</p><p>依赖继承，类的行为只能在编译时静态决定，利用组合，可以把装饰者混合着用，而且是在运行时。</p><p>缺点：利用装饰者模式，常常造成设计中有大量的小类，数量实在太多，可能会造成使用此API程序员的困扰。</p><p>应用：</p><ul><li>Java IO流</li><li>Android Context</li><li>抽象饮料:   get描述(),获取价格cost()；</li></ul><p>​       具体饮料：柠檬水，奶茶，酸奶，果汁等等；</p><p>​       装饰者：   各种调料，糖，冰，珍珠等等</p><h3 id="3-代理模式"><a href="#3-代理模式" class="headerlink" title="3.代理模式"></a>3.代理模式</h3><p>定义：包装一个对象，并提供对它的访问。</p><p>代理模式包含如下角色：</p><ul><li>Subject: 抽象主题角色</li><li>Proxy: 代理主题角色</li><li>RealSubject: 真实主题角色</li></ul><p>代理在结构上类似装饰者，但是目的不同。装饰者模式为对象加上行为，而代理是控制访问。</p><p>和装饰者模式一样，代理也会造成设计中类的数目增加。</p><h2 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h2><h3 id="1-观察者模式-发布订阅模式"><a href="#1-观察者模式-发布订阅模式" class="headerlink" title="1.观察者模式(发布订阅模式)"></a>1.观察者模式(发布订阅模式)</h3><p>定义：观察者模式定义了对象之间的一对多关系，使得每当一个对象改变状态，所有依赖它的对象都会得到通知并更新。</p><p>要点：</p><ul><li>主题(被观察者)用一个共同的接口来更新观察者</li><li>观察者和被观察者之间松耦合方式结合，被观察者不知道观察者的细节，只知道观察者实现了观察者接口</li></ul><p><img src="../../../../../../Pictures/md_images/image-20201011112950503.png" srcset="/img/loading.gif" alt="image-20201011112950503"></p><p>观察者模式所涉及的角色有：</p><p>　　●　　<strong>抽象主题(Subject)角色：</strong>抽象主题角色把所有对观察者对象的引用保存在一个集合（比如ArrayList对象）里，每个主题都可以有任何数量的观察者。抽象主题提供一个接口，可以增加和删除观察者对象，抽象主题角色又叫做抽象被观察者(Observable)角色。</p><p>　　●　　<strong>具体主题(ConcreteSubject)角色：</strong>将有关状态存入具体观察者对象；在具体主题的内部状态改变时，给所有登记过的观察者发出通知。具体主题角色又叫做具体被观察者(Concrete Observable)角色。</p><p>　　●　　<strong>抽象观察者(Observer)角色：</strong>为所有的具体观察者定义一个接口，在得到主题的通知时更新自己，这个接口叫做更新接口。</p><p>　　●　　<strong>具体观察者(ConcreteObserver)角色：</strong>存储与主题的状态自恰的状态。具体观察者角色实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题的状态相协调。如果需要，具体观察者角色可以保持一个指向具体主题对象的引用。</p><h3 id="2-迭代器模式"><a href="#2-迭代器模式" class="headerlink" title="2.迭代器模式"></a>2.迭代器模式</h3><h1 id="-1"><a href="#-1" class="headerlink" title=""></a></h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>mobile/flutter/flutter</title>
      <link href="2020/09/27/mobile/flutter/flutter/"/>
      <url>2020/09/27/mobile/flutter/flutter/</url>
      
        <content type="html"><![CDATA[<p>页面跳转</p><p>网格中Container 设置 boarder radius 设置圆角不起效果是为什么？</p><p>用PhysicalModel实现圆角</p><p>一个Column里面  2个widget 高度一样，如何实现？</p><p>通过Expanded</p><p>FractionallySizedBox是什么？</p><p>Container 和Padding设置padding有区别吗？</p><p>fit 属性的意思</p><pre class=" language-hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier"><code class="language-hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Image</span>.</span></span>network(   salesBoxModel.icon,  height: <span class="hljs-number">15</span>,  fit: <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">BoxFit</span>.</span></span>fill,),</code></pre><h3 id="mainAxisAlignment属性："><a href="#mainAxisAlignment属性：" class="headerlink" title="mainAxisAlignment属性："></a>mainAxisAlignment属性：</h3><ul><li><p>start: 将所有子控件放在主轴的开始位置</p></li><li><p>end:将所有子控件放在主轴的结束位置</p></li><li><p>center:将子控件放在主轴的中间位置</p></li><li><p>spaceBetween:将主轴空白位置进行均分，排列子元素，第一个子widget(主轴start方向)没有空白，最后一个子widget(主轴end方向)没有空白.</p></li><li><p>spaceAround:将主轴空白区域均分，使中间各个子控件间距相等，首尾子控件间距(尾widget距离end)为中间子控件间距的一半</p></li><li><p>spaceEvenly:将主轴空白区域均分，使各个子控件间距相等</p></li></ul><h5 id="获取屏幕宽度"><a href="#获取屏幕宽度" class="headerlink" title="获取屏幕宽度"></a>获取屏幕宽度</h5><pre class=" language-hljs css"><span class="hljs-selector-tag">MediaQuery</span><span class="hljs-selector-class">.of</span>(<span class="hljs-selector-tag">context</span>)<span class="hljs-selector-class">.size</span><span class="hljs-selector-class"><code class="language-hljs css"><span class="hljs-selector-tag">MediaQuery</span><span class="hljs-selector-class">.of</span>(<span class="hljs-selector-tag">context</span>)<span class="hljs-selector-class">.size</span><span class="hljs-selector-class">.width</span></code></pre><h2 id="一些库："><a href="#一些库：" class="headerlink" title="一些库："></a>一些库：</h2><h3 id="flutter-webview-plugin"><a href="#flutter-webview-plugin" class="headerlink" title="flutter_webview_plugin"></a>flutter_webview_plugin</h3><p><a href="https://pub.dev/packages/flutter_webview_plugin" target="_blank" rel="noopener">https://pub.dev/packages/flutter_webview_plugin</a></p><p>Plugin that allows Flutter to communicate with a native WebView.</p><pre class=" language-hljs ebnf"><span class="hljs-attribute"><code class="language-hljs ebnf"><span class="hljs-attribute">WebviewScaffold</span></code></pre><ul><li>h5页面状态变化的监听</li><li>h5页面url变化的监听</li><li>h5页面加载网页error的时候的监听</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>dart语言</title>
      <link href="2020/09/27/mobile/flutter/dart/dart%E8%AF%AD%E8%A8%80/"/>
      <url>2020/09/27/mobile/flutter/dart/dart%E8%AF%AD%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<h2 id="重要的概念"><a href="#重要的概念" class="headerlink" title="重要的概念"></a>重要的概念</h2><ul><li>在 Dart 中一切都是对象，即使变量是数字 类型默认值也是 null</li><li>在创建对象时，<code>new</code>关键字并不是必须的，可以省略不写。在写Flutter界面时，不建议写<code>new</code>关键字实例化对象</li></ul><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量仅存储对象引用；</p><h3 id="var、dynamic、Object的区别"><a href="#var、dynamic、Object的区别" class="headerlink" title="var、dynamic、Object的区别"></a>var、dynamic、Object的区别</h3><p>编译时:</p><ul><li><p>dynamic修饰的变量，不会推断其类型，可以指向其他类型的对象，运行时类型会随之改变</p></li><li><p>var修饰的变量，会推断其类型，不可以再指向其他类型的对象</p></li><li><p>Object修饰的变量，可以指向其他类型的对象，运行时类型会随之改变</p><pre class=" language-hljs gauss">void <span class="hljs-built_in">main</span>()<span class="hljs-comment"><code class="language-hljs gauss">void <span class="hljs-built_in">main</span>()<span class="hljs-comment">//dynamic，var，object三者的区别</span>&#123;  <span class="hljs-comment">//dynamic</span>  <span class="hljs-keyword">print</span>(<span class="hljs-string">"=====dynamic======="</span>);  dynamic x = 'hello';<span class="hljs-comment">//编译时不会揣测数据类型，但是运行时会推断</span>  <span class="hljs-keyword">print</span>(x.runtimeType);<span class="hljs-comment">//String</span>  <span class="hljs-keyword">print</span>(x);  <span class="hljs-comment">//但是这样的坏处就是会让dart的语法检查失效，所以有可能会造成混乱而不报错</span>  <span class="hljs-comment">//所以不要直接使用dynamic</span>  <span class="hljs-keyword">print</span>('');  x = <span class="hljs-number">123</span>;  <span class="hljs-keyword">print</span>(x.runtimeType);<span class="hljs-comment">//int，说明类型是可变的</span>  <span class="hljs-keyword">print</span>(x);  <span class="hljs-keyword">print</span>('');  <span class="hljs-comment">//var</span>  <span class="hljs-keyword">print</span>(<span class="hljs-string">"=====var======="</span>);  var a = 'hello';  <span class="hljs-keyword">print</span>(a.runtimeType);  <span class="hljs-keyword">print</span>(a);  <span class="hljs-comment">//a = 123;//会报错</span>  a = '<span class="hljs-number">123</span>';  <span class="hljs-keyword">print</span>(a);  <span class="hljs-keyword">print</span>(<span class="hljs-string">"=====object======="</span>);  <span class="hljs-comment">//Object</span>  Object w = <span class="hljs-number">1</span>;  <span class="hljs-keyword">print</span>(w.runtimeType);  <span class="hljs-keyword">print</span>(w);  <span class="hljs-comment">//不能调用Object不存在的方法</span>  w = <span class="hljs-string">"123"</span>;  <span class="hljs-keyword">print</span>(w);  <span class="hljs-keyword">print</span>(w.runtimeType);&#125;</code></pre><pre class=" language-hljs dart">=====<span class="hljs-built_in"><code class="language-hljs dart">=====<span class="hljs-built_in">dynamic</span>=======<span class="hljs-built_in">String</span>hello<span class="hljs-built_in">int</span><span class="hljs-number">123</span>=====<span class="hljs-keyword">var</span>=======<span class="hljs-built_in">String</span>hello<span class="hljs-number">123</span>=====object=======<span class="hljs-built_in">int</span><span class="hljs-number">1</span><span class="hljs-number">123</span><span class="hljs-built_in">String</span></code></pre></li></ul><h4 id="推荐："><a href="#推荐：" class="headerlink" title="推荐："></a>推荐：</h4><p>1.要为类型是任何对象的参数使用 <code>Object</code> ，而不是 <code>dynamic</code>，比如打日志方法的参数</p><p>void log(Object obj){…}</p><p>2.<strong>避免</strong> 为初始化过的局部变量指定类型，就是直接用var修饰，省略局部变量类型会将读者的注意力集中在变量的 <em>名称</em>及初始化值上</p><p>3.没有初始化的局部变量最好加上类型</p><h3 id="const-和final的区别"><a href="#const-和final的区别" class="headerlink" title="const 和final的区别"></a>const 和final的区别</h3><ul><li><code>const</code>比<code>final</code>更加严格，const 修饰的 是编译时常量；final 只是要求变量在初始化后值不变；</li></ul><h2 id="内建类型"><a href="#内建类型" class="headerlink" title="内建类型"></a>内建类型</h2><p>变量类型可以不用写吗？</p><pre class=" language-hljs ebnf"><span class="hljs-attribute"><code class="language-hljs ebnf"><span class="hljs-attribute">final webviewPlugin</span> = FlutterWebviewPlugin();</code></pre><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>??   如果左边的为null,返回右边的，否则返回左边的。</p><p>foo?.bar     表达式的值为 foo 不为null 则 取foo.bar 否则 为null    </p><h1 id="Effective-Dart-设计"><a href="#Effective-Dart-设计" class="headerlink" title="Effective Dart: 设计"></a>Effective Dart: 设计</h1><p><a href="https://www.dartcn.com/guides/language/effective-dart/design#库" target="_blank" rel="noopener">库</a></p><ul><li><a href="https://www.dartcn.com/guides/language/effective-dart/design#推荐-使用私有声明" target="_blank" rel="noopener"><strong>推荐</strong> 使用私有声明。</a></li><li><a href="https://www.dartcn.com/guides/language/effective-dart/design#考虑-声明多个类在一个库中" target="_blank" rel="noopener"><strong>考虑</strong> 声明多个类在一个库中。</a></li></ul><p><a href="https://www.dartcn.com/guides/language/effective-dart/design#构造函数" target="_blank" rel="noopener">构造函数</a></p><ul><li><p><a href="https://www.dartcn.com/guides/language/effective-dart/design#考虑-在类支持的情况下指定构造函数为--const" target="_blank" rel="noopener"><strong>考虑</strong> 在类支持的情况下，指定构造函数为 <code>const</code>。</a></p></li><li><p>类型</p><ul><li><a href="https://www.dartcn.com/guides/language/effective-dart/design#推荐-为类型不明显的公共字段和公共顶级变量指定类型注解" target="_blank" rel="noopener"><strong>推荐</strong> 为类型不明显的公共字段和公共顶级变量指定类型注解。</a></li><li><a href="https://www.dartcn.com/guides/language/effective-dart/design#考虑-为类型不明显的私有字段和私有顶级变量指定类型注解" target="_blank" rel="noopener"><strong>考虑</strong> 为类型不明显的私有字段和私有顶级变量指定类型注解。</a></li><li><a href="https://www.dartcn.com/guides/language/effective-dart/design#避免-为初始化的局部变量添加类型注解" target="_blank" rel="noopener"><strong>避免</strong> 为初始化的局部变量添加类型注解。</a></li><li><a href="https://www.dartcn.com/guides/language/effective-dart/design#避免-在函数表达式上注解推断的参数类型" target="_blank" rel="noopener"><strong>避免</strong> 在函数表达式上注解推断的参数类型。</a></li><li><a href="https://www.dartcn.com/guides/language/effective-dart/design#避免-在泛型调用中参数类型的冗余使用" target="_blank" rel="noopener"><strong>避免</strong> 在泛型调用中参数类型的冗余使用。</a></li><li><a href="https://www.dartcn.com/guides/language/effective-dart/design#要-在-dart-推断类型错误的时候进行类型注解" target="_blank" rel="noopener"><strong>要</strong> 在 Dart 推断类型错误的时候进行类型注解。</a></li><li><a href="https://www.dartcn.com/guides/language/effective-dart/design#推荐-使用-dynamic-注解替换推断失败的情况" target="_blank" rel="noopener"><strong>推荐</strong> 使用 <code>dynamic</code> 注解替换推断失败的情况。</a></li><li><a href="https://www.dartcn.com/guides/language/effective-dart/design#推荐-使-function-类型注解的特征更明显" target="_blank" rel="noopener"><strong>推荐</strong> 使 function 类型注解的特征更明显</a></li><li><a href="https://www.dartcn.com/guides/language/effective-dart/design#不要-为-setter-方法指定返回类型" target="_blank" rel="noopener"><strong>不要</strong> 为 setter 方法指定返回类型。</a></li><li><a href="https://www.dartcn.com/guides/language/effective-dart/design#不要-使用弃用的-typedef-语法" target="_blank" rel="noopener"><strong>不要</strong> 使用弃用的 typedef 语法。</a></li><li><a href="https://www.dartcn.com/guides/language/effective-dart/design#推荐-优先使用内联函数类型而后是-typedef-" target="_blank" rel="noopener"><strong>推荐</strong> 优先使用内联函数类型，而后是 typedef 。</a></li><li><a href="https://www.dartcn.com/guides/language/effective-dart/design#考虑-在参数上使用函数类型语法" target="_blank" rel="noopener"><strong>考虑</strong> 在参数上使用函数类型语法。</a></li><li><a href="https://www.dartcn.com/guides/language/effective-dart/design#要-为类型是任何对象的参数使用-object-注解而不是-dynamic-" target="_blank" rel="noopener"><strong>要</strong> 为类型是任何对象的参数使用 <code>Object</code> 注解，而不是 <code>dynamic</code> 。</a></li><li><a href="https://www.dartcn.com/guides/language/effective-dart/design#要-使用-futurevoid-作为无法回值异步成员的返回类型" target="_blank" rel="noopener"><strong>要</strong> 使用 <code>Future</code> 作为无法回值异步成员的返回类型。</a></li><li><a href="https://www.dartcn.com/guides/language/effective-dart/design#避免-使用-futureort-作为返回类型" target="_blank" rel="noopener"><strong>避免</strong> 使用 <code>FutureOr</code> 作为返回类型。</a></li></ul></li><li><p>参数</p><ul><li><a href="https://www.dartcn.com/guides/language/effective-dart/design#避免-布尔类型的位置参数" target="_blank" rel="noopener"><strong>避免</strong> 布尔类型的位置参数。</a></li><li><a href="https://www.dartcn.com/guides/language/effective-dart/design#避免-在调用者需要省略前面参数的方法中使用位置可选参数" target="_blank" rel="noopener"><strong>避免</strong> 在调用者需要省略前面参数的方法中，使用位置可选参数。</a></li><li><a href="https://www.dartcn.com/guides/language/effective-dart/design#避免-强制参数去接受一个特定表示空参数的值" target="_blank" rel="noopener"><strong>避免</strong> 强制参数去接受一个特定表示”空参数”的值。</a></li><li><a href="https://www.dartcn.com/guides/language/effective-dart/design#要-使用开始为闭区间结束为开区间的半开半闭区间作为接受范围" target="_blank" rel="noopener"><strong>要</strong> 使用开始为闭区间，结束为开区间的半开半闭区间作为接受范围。</a></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> dart </tag>
            
            <tag> flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo进阶功能</title>
      <link href="2020/09/20/hexo/hexo%E8%BF%9B%E9%98%B6%E5%8A%9F%E8%83%BD/"/>
      <url>2020/09/20/hexo/hexo%E8%BF%9B%E9%98%B6%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<h2 id="进阶功能"><a href="#进阶功能" class="headerlink" title="进阶功能"></a>进阶功能</h2><h3 id="abbrlink生成唯一永久文章链接"><a href="#abbrlink生成唯一永久文章链接" class="headerlink" title="abbrlink生成唯一永久文章链接"></a>abbrlink生成唯一永久文章链接</h3><h4 id="1-安装插件"><a href="#1-安装插件" class="headerlink" title="1.安装插件"></a>1.安装插件</h4><pre class=" language-hljs js"><code class="language-hljs js">npm install hexo-abbrlink --save</code></pre><blockquote><p>执行此命令可能会不成功，提示你缺少相应的依赖<br> 比如<code>babel-eslint</code>、<code>mini-css-extract-plugin</code>、<code>webpack-cli</code>…<br> 使用npm命令安装即可，比如<code>npm install eslint@4.x babel-eslint@8 --save-dev</code></p></blockquote><h4 id="2-配置"><a href="#2-配置" class="headerlink" title="2.配置"></a>2.配置</h4><p>修改根目录配置文件<code>config.yml</code>，改为：</p><pre class=" language-hljs js"><code class="language-hljs js">permalink: blog/:abbrlink.html  # 也可以直接使用 :/abbrlinkabbrlink:    alg: crc32   #算法： crc16(default) and crc32    rep: hex     #进制： dec(default) and hex</code></pre><p>生成完后，原<code>md</code>文件的Front-matter(就是— —中间的内容) 内会增加<code>abbrlink</code> 字段，值为生成的ID 。这个字段确保了在我们修改了Front-matter 内的博客标题title或创建日期date字段之后而不会改变链接地址。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo笔记</title>
      <link href="2020/09/20/hexo/hexo%E7%AC%94%E8%AE%B0/"/>
      <url>2020/09/20/hexo/hexo%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="layout-post-、draft-和-page的区别"><a href="#layout-post-、draft-和-page的区别" class="headerlink" title="layout:  post 、draft 和 page的区别"></a>layout:  post 、draft 和 page的区别</h2><p>1.路径不同</p><p>Hexo 有三种默认布局：<code>post</code>、<code>page</code> 和 <code>draft</code>。在创建者三种不同类型的文件时，它们将会被保存到不同的路径；而您自定义的其他布局和 <code>post</code> 相同，都将储存到 <code>source/_posts</code> 文件夹。</p><table><thead><tr><th align="left">布局</th><th align="left">路径</th></tr></thead><tbody><tr><td align="left"><code>post</code></td><td align="left"><code>source/_posts</code></td></tr><tr><td align="left"><code>page</code></td><td align="left"><code>source</code></td></tr><tr><td align="left"><code>draft</code></td><td align="left"><code>source/_drafts</code></td></tr></tbody></table><p>2.作用不同</p><p>page生成的页面用于导航，post是文章</p><h2 id="标签和分类没有内容"><a href="#标签和分类没有内容" class="headerlink" title="标签和分类没有内容"></a>标签和分类没有内容</h2><p><code>source/tags/index.md</code>中 下面应为layout 而不是 tags，同理分类处也是layout</p><pre class=" language-hljs yaml"><span class="hljs-attr">title:</span> <span class="hljs-string"><code class="language-hljs yaml"><span class="hljs-attr">title:</span> <span class="hljs-string">标签</span><span class="hljs-attr">date:</span> <span class="hljs-number">2020</span><span class="hljs-number">-09</span><span class="hljs-number">-20</span> <span class="hljs-number">19</span><span class="hljs-string">:19:19</span><span class="hljs-attr">layout:</span> <span class="hljs-string">"tags"</span></code></pre><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><pre class=" language-hljs gauss">$ hexo <span class="hljs-keyword">new</span> [layout] &lt;<span class="hljs-built_in"><code class="language-hljs gauss">$ hexo <span class="hljs-keyword">new</span> [layout] &lt;<span class="hljs-built_in">title</span>></code></pre><p>新建一篇文章。如果没有设置 <code>layout</code> 的话，默认使用 <a href="https://hexo.io/zh-cn/docs/configuration" target="_blank" rel="noopener">_config.yml</a> 中的 <code>default_layout</code> 参数代替。如果标题包含空格的话，请使用引号括起来。</p><pre class=" language-hljs actionscript">$ hexo <span class="hljs-keyword">new</span> <span class="hljs-string"><code class="language-hljs actionscript">$ hexo <span class="hljs-keyword">new</span> <span class="hljs-string">"post title with whitespace"</span></code></pre><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-p</code>, <code>--path</code></td><td align="left">自定义新文章的路径</td></tr><tr><td align="left"><code>-r</code>, <code>--replace</code></td><td align="left">如果存在同名文章，将其替换</td></tr><tr><td align="left"><code>-s</code>, <code>--slug</code></td><td align="left">文章的 Slug，作为新文章的文件名和发布后的 URL</td></tr></tbody></table><p>默认情况下，Hexo 会使用文章的标题来决定文章文件的路径。对于独立页面来说，Hexo 会创建一个以标题为名字的目录，并在目录中放置一个 <code>index.md</code> 文件。你可以使用 <code>--path</code> 参数来覆盖上述行为、自行决定文件的目录：</p><pre class=" language-hljs routeros">hexo new<span class="hljs-built_in"> page </span>--path about/me <span class="hljs-string"><code class="language-hljs routeros">hexo new<span class="hljs-built_in"> page </span>--path about/me <span class="hljs-string">"About me"</span></code></pre><p>以上命令会创建一个 <code>source/about/me.md</code> 文件，同时 Front Matter 中的 title 为 <code>&quot;About me&quot;</code></p><p>注意！title 是必须指定的！如果你这么做并不能达到你的目的：</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>github</title>
      <link href="2020/09/20/github/"/>
      <url>2020/09/20/github/</url>
      
        <content type="html"><![CDATA[<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><h4 id="git-init——初始化仓库"><a href="#git-init——初始化仓库" class="headerlink" title="git init——初始化仓库"></a>git init——初始化仓库</h4><pre class=" language-hljs stata">$ <span class="hljs-keyword">mkdir</span> git-<span class="hljs-keyword"><code class="language-hljs stata">$ <span class="hljs-keyword">mkdir</span> git-<span class="hljs-keyword">tutorial</span>$ <span class="hljs-keyword">cd</span> git-<span class="hljs-keyword">tutorial</span>$ git initInitialized empty Git repository <span class="hljs-keyword">in</span> /Users/hirocaster/github/github-book/git-<span class="hljs-keyword">tutorial</span>/.git/</code></pre><p>​        如果初始化成功，执行了 git init 命令的目录下就会生成 .git 目 录。这个 .git 目录里存储着管理当前目录内容所需的仓库数据。</p><p>​        在 Git 中，我们将这个目录的内容称为“附属于该仓库的工作树”。 文件的编辑等操作在工作树中进行，然后记录到仓库中，以此管理文件 的历史快照。</p><h4 id="git-status——查看仓库的状态"><a href="#git-status——查看仓库的状态" class="headerlink" title="git status——查看仓库的状态"></a>git status——查看仓库的状态</h4><p>所谓提交 （Commit），是指“记录工作树中所有文件的当前状态”。</p><p>git fetch  = pull(远端仓库，可以是别人的仓库) + merge本地分支   </p><pre class=" language-hljs dockerfile">git fetch origin     //origin是 git remote <span class="hljs-keyword">add</span><span class="bash"><code class="language-hljs dockerfile">git fetch origin     //origin是 git remote <span class="hljs-keyword">add</span><span class="bash"> ...添加的</span></code></pre><p>merge</p><pre class=" language-hljs stata">git checkout master <span class="hljs-comment"><code class="language-hljs stata">git checkout master <span class="hljs-comment">//切换到master分支</span><span class="hljs-comment">//为了在历史记录中明确记录下本次分支合 并，我们需要创建合并提交。因此，在合并时加上 --no-ff 参数。</span>git <span class="hljs-keyword">merge</span> --<span class="hljs-keyword">no</span>-ff feature-A  <span class="hljs-comment">// 合并feature-A到merge</span></code></pre><p>pull </p><p>git push :  推送到远程仓库</p><p>rebase</p><p>git clone</p><p>git add 文件    提交到暂存区</p><p>git commit -m描述：       提交到本地仓库</p><ul><li>-m</li><li>-am</li><li>–amend</li></ul><p>git status 查看状态</p><p>在远程仓库中也创建 develop 分支</p><p>开发者要时刻注意，对分支进行任何操作之前都必须先执行 pull 获 取最新代码，修改完毕后应尽快进行 push 操作，保证 GitHub 端远程仓 库内的代码为最新状态。</p><p>GitHub 端的远程仓库为 remotes/origin</p><h4 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h4><pre class=" language-hljs armasm"><code class="language-hljs armasm">//查看<span class="hljs-symbol">git</span> <span class="hljs-keyword">branch </span>: 显示本地分支一览表<span class="hljs-symbol">git</span> <span class="hljs-keyword">branch </span>-r : 查看远程仓库的分支<span class="hljs-symbol">git</span> <span class="hljs-keyword">branch </span>-a : 查看本地和远程仓库的所有分支//创建<span class="hljs-symbol">git</span> checkout -<span class="hljs-keyword">b </span>分支名 ：以当前分支为基础，创建切换分支//切换<span class="hljs-symbol">git</span> checkout master: 切换到master分支<span class="hljs-symbol">git</span> checkout - : 切换回上一个分支<span class="hljs-symbol">git</span> checkout -<span class="hljs-keyword">b </span>本地分支名 origin/远程分支名:将远程git仓库里的指定分支拉取到本地（本地不存在的分支）//删除<span class="hljs-symbol">git</span> <span class="hljs-keyword">branch </span>-d <span class="hljs-keyword">bug_xzx </span>删除本地的<span class="hljs-keyword">bug_xzx分支</span><span class="hljs-keyword">git </span><span class="hljs-keyword">push </span>origin --delete <span class="hljs-keyword">bug_xzx </span> 删除远程的<span class="hljs-keyword">bug_xzx分支</span></code></pre><h3 id="二、push操作"><a href="#二、push操作" class="headerlink" title="二、push操作"></a>二、push操作</h3><p>1、将本地当前分支 推送到 远程指定分支上（注意：pull是远程在前本地在后，push相反）：</p><pre class=" language-hljs xml">git push origin <span class="hljs-tag">&lt;<span class="hljs-name">本地分支名</span>&gt;</span>:<span class="hljs-tag">&lt;<span class="hljs-name"><code class="language-hljs xml">git push origin <span class="hljs-tag">&lt;<span class="hljs-name">本地分支名</span>&gt;</span>:<span class="hljs-tag">&lt;<span class="hljs-name">远程分支名</span>></span></code></pre><p>2、将本地当前分支 推送到 与本地当前分支同名的远程分支上（注意：pull是远程在前本地在后，push相反）：</p><pre class=" language-hljs maxima">git <span class="hljs-built_in">push</span> <span class="hljs-built_in"><code class="language-hljs maxima">git <span class="hljs-built_in">push</span> <span class="hljs-built_in">origin</span> <本地分支名></code></pre><p>3、将本地当前分支 推送到 与本地当前分支同名的远程分支上(需先关联远程分支，方法见文章末尾)</p><pre class=" language-hljs maxima">git <span class="hljs-built_in">push</span>同样的，推荐使用第<span class="hljs-number">2</span>种方式，git <span class="hljs-built_in">push</span> <span class="hljs-built_in"><code class="language-hljs maxima">git <span class="hljs-built_in">push</span>同样的，推荐使用第<span class="hljs-number">2</span>种方式，git <span class="hljs-built_in">push</span> <span class="hljs-built_in">origin</span> <远程同名分支名></code></pre><p>git diff</p><p>不妨养成这样一个好习惯：在执行 git commit 命令之前先执行 <code>git diff HEAD</code> 命令，查看本次提交与上次提交之间有什么差别，等 确认完毕后再进行提交。这里的 HEAD 是指向当前分支中最新一次提交 的指针。</p><p>取消刚刚所有添加进暂存区的</p><pre class=" language-hljs sql">git <span class="hljs-keyword">restore</span> <span class="hljs-comment"><code class="language-hljs sql">git <span class="hljs-keyword">restore</span> <span class="hljs-comment">--staged .</span></code></pre><p>取消添加进暂存区的某个文件</p><pre class=" language-hljs sql">git <span class="hljs-keyword">restore</span> <span class="hljs-comment"><code class="language-hljs sql">git <span class="hljs-keyword">restore</span> <span class="hljs-comment">--staged <file></span></code></pre><p>查看远程仓库的地址</p><pre class=" language-hljs ebnf"><span class="hljs-attribute"><code class="language-hljs ebnf"><span class="hljs-attribute">git remote -v</span></code></pre><p>设置新的远程仓库地址</p><pre class=" language-hljs dsconfig"><span class="hljs-string">git </span><span class="hljs-string">remote </span><span class="hljs-built_in">set-url</span> <span class="hljs-string">origin </span><span class="hljs-string">git@</span><span class="hljs-string">github.</span><span class="hljs-string">com:</span>****/*****-<span class="hljs-string">client-5.</span><span class="hljs-string"><code class="language-hljs dsconfig"><span class="hljs-string">git </span><span class="hljs-string">remote </span><span class="hljs-built_in">set-url</span> <span class="hljs-string">origin </span><span class="hljs-string">git@</span><span class="hljs-string">github.</span><span class="hljs-string">com:</span>****/*****-<span class="hljs-string">client-5.</span><span class="hljs-string">git</span></code></pre><h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3><h4 id="1-查看远程仓库"><a href="#1-查看远程仓库" class="headerlink" title="1.查看远程仓库"></a>1.查看远程仓库</h4><pre class=" language-hljs properties"><span class="hljs-attr">git</span> <span class="hljs-string"><code class="language-hljs properties"><span class="hljs-attr">git</span> <span class="hljs-string">remote 查看远程仓库的名字</span><span class="hljs-attr">git</span> <span class="hljs-string">remote -v 显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL</span></code></pre><h4 id="2-添加远程仓库"><a href="#2-添加远程仓库" class="headerlink" title="2.添加远程仓库"></a>2.添加远程仓库</h4><h5 id="2-1自动添加"><a href="#2-1自动添加" class="headerlink" title="2.1自动添加"></a>2.1自动添加</h5><p>git clone https:…..会自动添加远程仓库 并命名远程仓库名为origin.</p><h5 id="2-2手动添加"><a href="#2-2手动添加" class="headerlink" title="2.2手动添加"></a>2.2手动添加</h5><pre class=" language-hljs vim">git remote <span class="hljs-built_in">add</span> <span class="hljs-symbol">&lt;shortname&gt;</span> <span class="hljs-symbol"><code class="language-hljs vim">git remote <span class="hljs-built_in">add</span> <span class="hljs-symbol">&lt;shortname&gt;</span> <span class="hljs-symbol"><url></span><span class="hljs-keyword">e</span><span class="hljs-variable">g:</span>$ git remote <span class="hljs-built_in">add</span> pb http<span class="hljs-variable">s:</span>//github.<span class="hljs-keyword">com</span>/paulboone/ticgit</code></pre><p>之后可以在命令行中使用字符串 <code>pb</code> 来代替整个 URL</p><blockquote><p>什么是origin    : 如果你已经克隆了自己的仓库，那么至少应该能看到 origin ——这是 Git 给你克隆的仓库服务器的默认名字：</p></blockquote><h4 id="3-从远程仓库中抓取与拉取"><a href="#3-从远程仓库中抓取与拉取" class="headerlink" title="3.从远程仓库中抓取与拉取"></a>3.从远程仓库中抓取与拉取</h4><blockquote><p><a href="https://git-scm.com/book/zh/v2/Git-基础-远程仓库的使用" target="_blank" rel="noopener">https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8</a></p></blockquote><p>git pull 根据配置的不同，可为git fetch + git merge 或 git fetch + git rebase</p><p><img src="https://gzr-blog.oss-cn-shanghai.aliyuncs.com/uPic/image-20200826162749286_2020-09-20_14:09:42.png" srcset="/img/loading.gif" alt="image-20200826162749286"></p><pre class=" language-hljs crmsh"><span class="hljs-comment"><code class="language-hljs crmsh"><span class="hljs-comment"># 将远程主机的master分支最新内容拉下来后与当前本地分支直接合并</span>git  pull origin <span class="hljs-keyword">master</span> <span class="hljs-title"></span><span class="hljs-title"># git</span> pull <span class="hljs-tag"><远程主机名></span> <span class="hljs-tag"><远程分支名></span>:<span class="hljs-tag"><本地分支名></span>git pull origin <span class="hljs-literal">master</span>:feature-wxDemo  <span class="hljs-comment"># 将远程主机的最新内容拉到本地，不进行合并</span>git fetch origin <span class="hljs-literal">master</span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ListView与RecyclerView</title>
      <link href="2020/05/13/mobile/Android/UI/ListView%E4%B8%8ERecyclerView/"/>
      <url>2020/05/13/mobile/Android/UI/ListView%E4%B8%8ERecyclerView/</url>
      
        <content type="html"><![CDATA[<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><p>1.[美团2020]listview和 recyclerview 的区别</p><p><a href="https://www.jianshu.com/p/cd8244d1c19a" target="_blank" rel="noopener">https://www.jianshu.com/p/cd8244d1c19a</a></p><p>ListView的父类AbsListVIew中的RecycleBin内部类保存了一个View[]数组mActiveViews，用来保存屏幕上正在显示的所有View</p><p>还保存了一个ArrayList<View>集合mScrapViews，用来保存所有滑出屏幕等待复用的View。</p><p>当用户滑动屏幕时，ListView会从mActiveViews中将滑出屏幕的view加入mScrapViews</p><p>并从后者取出view传给adapter的getView()方法供其复用<br>————————————————<br>版权声明：本文为CSDN博主「leo1302」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/leo1302/article/details/38680205" target="_blank" rel="noopener">https://blog.csdn.net/leo1302/article/details/38680205</a></p><p>第一次Layout过程当中向ListView添加了这么多的子View。调用了RecycleBin的fillActiveViews()方法，第二次layout效果可就不一样了，因为目前ListView中已经有子View了，所有的子View都会被缓存到RecycleBin的mActiveViews数组当中。</p><p>detachAllViewsFromParent()方法。这个方法会将所有ListView当中的子View全部清除掉</p><p>在obtainView()方法中会去infalte布局的话</p><p>setupChild()方法的最后一个参数传入的是true，这个参数表明当前的View是之前被回收过的</p><p>recycled现在是true，所以会执行attachViewToParent()</p><h2 id="listview"><a href="#listview" class="headerlink" title="listview"></a>listview</h2><h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><h3 id="listview原理"><a href="#listview原理" class="headerlink" title="listview原理"></a>listview原理</h3><p>ListView能够展示大量数据而不会OOM，是因为RecycleBin这个类，它是AbsListView的内部类，ListView继承自AbsListView。</p><p>RecycleBin的作用就是重用view，它内部存有<em>ActiveViews 和 ScrapViews</em></p><pre class=" language-hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol"><code class="language-hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">RecycleBin</span> &#123; <span class="hljs-keyword">private</span> View[] mActiveViews = new View[<span class="hljs-number">0</span>];<span class="hljs-keyword">private</span> ArrayList<View>[] mScrapViews; <span class="hljs-keyword">private</span> ArrayList<View> mCurrentScrap;&#125;</code></pre><p><strong>ActiveViews</strong>:是一个view数组，存屏幕可见的view，<strong>fillActiveViews()</strong> 方法往里面存，<strong>getActiveView()</strong> 从中取出，取出的view会从mActiveViews中移除，mActiveViews不能被重复利用。</p><p><strong>ScrapViews</strong>：是一些被移出屏幕的能够被adapter重用的view，避免为每个item创建新的view。</p><ul><li><p>mCurrentScrap:ArrayList类型，用于存储离屏的 View</p></li><li><p>mScrapViews</p></li><li><ul><li>ArrayList[] 类型</li><li>数组中每个元素都是 ArrayList类型，效果同 mCurrentScrap</li><li>mScrapViews[0] 就是 mCurrentScrap</li><li>其数组长度应为 ViewTypeCount。因为针对不同的 ViewType，ListView 都要有一个专门的 ArrayList 链表来缓存它对应的 View</li></ul></li></ul><h4 id="listview展示在界面的调用过程"><a href="#listview展示在界面的调用过程" class="headerlink" title="listview展示在界面的调用过程"></a>listview展示在界面的调用过程</h4><p><img src="../../../../../Pictures/md_images/listview2020-10-04.jpg" srcset="/img/loading.gif" alt="listview2020-10-04"></p><h4 id="listview滑动时的调用过程"><a href="#listview滑动时的调用过程" class="headerlink" title="listview滑动时的调用过程"></a>listview滑动时的调用过程</h4><p><img src="../../../../../Pictures/md_images/listview%E6%BB%91%E5%8A%A8%E8%BF%87%E7%A8%8B.jpg" srcset="/img/loading.gif" alt="listview滑动过程"></p><img src="../../../../../Pictures/md_images/image-20201003150726815.png" srcset="/img/loading.gif" alt="image-20201003150726815" style="zoom:90%;" /><h4 id="2个重要方法"><a href="#2个重要方法" class="headerlink" title="2个重要方法"></a>2个重要方法</h4><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> View <span class="hljs-title">makeAndAddView</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">boolean</span> flow, <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> View <span class="hljs-title">makeAndAddView</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">boolean</span> flow, <span class="hljs-keyword">int</span> childrenLeft,</span></span><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">boolean</span> selected)</span> </span>&#123;    <span class="hljs-keyword">if</span> (!mDataChanged) &#123;        <span class="hljs-comment">// Try to use an existing view for this position.</span>        <span class="hljs-keyword">final</span> View activeView = mRecycler.getActiveView(position);        <span class="hljs-keyword">if</span> (activeView != <span class="hljs-keyword">null</span>) &#123;            setupChild(activeView, position, y, flow, childrenLeft, selected, <span class="hljs-keyword">true</span>);            <span class="hljs-keyword">return</span> activeView;        &#125;    &#125;    <span class="hljs-comment">// Make a new view for this position, or convert an unused view if</span>    <span class="hljs-comment">// possible.</span>    <span class="hljs-keyword">final</span> View child = obtainView(position, mIsScrap);    <span class="hljs-comment">// This needs to be positioned and measured.</span>    setupChild(child, position, y, flow, childrenLeft, selected, mIsScrap[<span class="hljs-number">0</span>]);    <span class="hljs-keyword">return</span> child;&#125;</code></pre><ul><li>数据没有变化，先从activeview中取</li><li>数据有变化，直接从scrapView中取</li></ul><pre class=" language-hljs java"><span class="hljs-comment"><code class="language-hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Get a view and have it show the data associated with the specified</span><span class="hljs-comment"> * position. This is called when we have already discovered that the view is</span><span class="hljs-comment"> * not available for reuse in the recycle bin. The only choices left are</span><span class="hljs-comment"> * converting an old view or making a new one.</span><span class="hljs-comment"> * </span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> position</span><span class="hljs-comment"> *            The position to display</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> isScrap</span><span class="hljs-comment"> *            Array of at least 1 boolean, the first entry will become true</span><span class="hljs-comment"> *            if the returned view was taken from the scrap heap, false if</span><span class="hljs-comment"> *            otherwise.</span><span class="hljs-comment"> * </span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> A view displaying the data associated with the specified position</span><span class="hljs-comment"> */</span><span class="hljs-function">View <span class="hljs-title">obtainView</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position, <span class="hljs-keyword">boolean</span>[] isScrap)</span> </span>&#123;isScrap[<span class="hljs-number">0</span>] = <span class="hljs-keyword">false</span>;View scrapView;scrapView = mRecycler.getScrapView(position);View child;<span class="hljs-keyword">if</span> (scrapView != <span class="hljs-keyword">null</span>) &#123;child = mAdapter.getView(position, scrapView, <span class="hljs-keyword">this</span>);<span class="hljs-keyword">if</span> (child != scrapView) &#123;mRecycler.addScrapView(scrapView);<span class="hljs-keyword">if</span> (mCacheColorHint != <span class="hljs-number">0</span>) &#123;child.setDrawingCacheBackgroundColor(mCacheColorHint);&#125;&#125; <span class="hljs-keyword">else</span> &#123;isScrap[<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;dispatchFinishTemporaryDetach(child);&#125;&#125; <span class="hljs-keyword">else</span> &#123;child = mAdapter.getView(position, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">this</span>);<span class="hljs-keyword">if</span> (mCacheColorHint != <span class="hljs-number">0</span>) &#123;child.setDrawingCacheBackgroundColor(mCacheColorHint);&#125;&#125;<span class="hljs-keyword">return</span> child;&#125;</code></pre><p>另外：若getView中 不复用convertview，scrapview的数量随着移出屏幕的view的数量的增加而增加，不会减少。</p><h4 id="数据变化时，activeViews的情况，TODO…"><a href="#数据变化时，activeViews的情况，TODO…" class="headerlink" title="数据变化时，activeViews的情况，TODO…"></a>数据变化时，activeViews的情况，TODO…</h4><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><blockquote><p><a href="https://mp.weixin.qq.com/s?__biz=MzA5MzI3NjE2MA==&mid=2650242452&idx=1&sn=4ed1449da00917508302afb27df6eb72&chksm=88638cfbbf1405ed2c3d3c110e3d9ab40b59a82bf7e6cfdcaf8dea19041c2f4234cd5b986f94&mpshare=1&scene=23&srcid=1004Ycps2Hmuz07Q5ivUBr68&sharer_sharetime=1601798572801&sharer_shareid=bdce9fa9b15be34893c6ab661a3409fe%23rd" target="_blank" rel="noopener">1.通过可视化的方式精解ListView缓存机制</a></p><p><a href="http://blog.csdn.net/guolin_blog/article/details/44996879" target="_blank" rel="noopener">2.Android ListView工作原理完全解析</a></p></blockquote><h3 id="listview优化"><a href="#listview优化" class="headerlink" title="listview优化"></a>listview优化</h3><ol><li><p>优化加载view:convertView的使用，避免每个item都从xml中加载生成</p></li><li><p>优化找子view:viewholder的使用，避免每次都要findviewbyid(这是dfs的操作).</p><ol><li>Holder内部类要设置成静态的吗？有什么区别？</li></ol></li><li><p>异步加载数据，分页加载数据。</p></li><li><p>使用 WeakRefrence 引用 ImageView 对象</p></li></ol><h2 id="RecyclerView"><a href="#RecyclerView" class="headerlink" title="RecyclerView"></a>RecyclerView</h2><h3 id="使用步骤："><a href="#使用步骤：" class="headerlink" title="使用步骤："></a>使用步骤：</h3><h3 id="缓存原理"><a href="#缓存原理" class="headerlink" title="缓存原理"></a>缓存原理</h3><p>LinearyLayoutManager</p><h2 id="listview与recyclerview对比"><a href="#listview与recyclerview对比" class="headerlink" title="listview与recyclerview对比"></a>listview与recyclerview对比</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2020/03/15/hello-world/"/>
      <url>2020/03/15/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-hljs bash">$ hexo new <span class="hljs-string"><code class="language-hljs bash">$ hexo new <span class="hljs-string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-hljs bash"><code class="language-hljs bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-hljs bash"><code class="language-hljs bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-hljs bash"><code class="language-hljs bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> Hellox </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
