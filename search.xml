<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>hexo进阶功能</title>
      <link href="blog/3878378061.html"/>
      <url>blog/3878378061.html</url>
      
        <content type="html"><![CDATA[<h2 id="进阶功能"><a href="#进阶功能" class="headerlink" title="进阶功能"></a>进阶功能</h2><h3 id="abbrlink生成唯一永久文章链接"><a href="#abbrlink生成唯一永久文章链接" class="headerlink" title="abbrlink生成唯一永久文章链接"></a>abbrlink生成唯一永久文章链接</h3><h4 id="1-安装插件"><a href="#1-安装插件" class="headerlink" title="1.安装插件"></a>1.安装插件</h4><pre class=" language-js"><code class="language-js">npm install hexo<span class="token operator">-</span>abbrlink <span class="token operator">--</span>save</code></pre><blockquote><p>执行此命令可能会不成功，提示你缺少相应的依赖<br> 比如<code>babel-eslint</code>、<code>mini-css-extract-plugin</code>、<code>webpack-cli</code>…<br> 使用npm命令安装即可，比如<code>npm install eslint@4.x babel-eslint@8 --save-dev</code></p></blockquote><h4 id="2-配置"><a href="#2-配置" class="headerlink" title="2.配置"></a>2.配置</h4><p>修改根目录配置文件<code>config.yml</code>，改为：</p><pre class=" language-js"><code class="language-js">permalink<span class="token punctuation">:</span> blog<span class="token operator">/</span><span class="token punctuation">:</span>abbrlink<span class="token punctuation">.</span>html  # 也可以直接使用 <span class="token punctuation">:</span><span class="token operator">/</span>abbrlinkabbrlink<span class="token punctuation">:</span>    alg<span class="token punctuation">:</span> crc32   #算法： <span class="token function">crc16</span><span class="token punctuation">(</span><span class="token keyword">default</span><span class="token punctuation">)</span> and crc32    rep<span class="token punctuation">:</span> hex     #进制： <span class="token function">dec</span><span class="token punctuation">(</span><span class="token keyword">default</span><span class="token punctuation">)</span> and hex</code></pre><p>生成完后，原<code>md</code>文件的Front-matter(就是— —中间的内容) 内会增加<code>abbrlink</code> 字段，值为生成的ID 。这个字段确保了在我们修改了Front-matter 内的博客标题title或创建日期date字段之后而不会改变链接地址。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo笔记</title>
      <link href="blog/3852849821.html"/>
      <url>blog/3852849821.html</url>
      
        <content type="html"><![CDATA[<h2 id="layout-post-、draft-和-page的区别"><a href="#layout-post-、draft-和-page的区别" class="headerlink" title="layout:  post 、draft 和 page的区别"></a>layout:  post 、draft 和 page的区别</h2><p>1.路径不同</p><p>Hexo 有三种默认布局：<code>post</code>、<code>page</code> 和 <code>draft</code>。在创建者三种不同类型的文件时，它们将会被保存到不同的路径；而您自定义的其他布局和 <code>post</code> 相同，都将储存到 <code>source/_posts</code> 文件夹。</p><table><thead><tr><th align="left">布局</th><th align="left">路径</th></tr></thead><tbody><tr><td align="left"><code>post</code></td><td align="left"><code>source/_posts</code></td></tr><tr><td align="left"><code>page</code></td><td align="left"><code>source</code></td></tr><tr><td align="left"><code>draft</code></td><td align="left"><code>source/_drafts</code></td></tr></tbody></table><p>2.作用不同</p><p>page生成的页面用于导航，post是文章</p><h2 id="标签和分类没有内容"><a href="#标签和分类没有内容" class="headerlink" title="标签和分类没有内容"></a>标签和分类没有内容</h2><p><code>source/tags/index.md</code>中 下面应为layout 而不是 tags，同理分类处也是layout</p><pre><code>title: 标签date: 2020-09-20 19:19:19layout: &quot;tags&quot;</code></pre><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><pre><code>$ hexo new [layout] &lt;title&gt;</code></pre><p>新建一篇文章。如果没有设置 <code>layout</code> 的话，默认使用 <a href="https://hexo.io/zh-cn/docs/configuration" target="_blank" rel="noopener">_config.yml</a> 中的 <code>default_layout</code> 参数代替。如果标题包含空格的话，请使用引号括起来。</p><pre><code>$ hexo new &quot;post title with whitespace&quot;</code></pre><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-p</code>, <code>--path</code></td><td align="left">自定义新文章的路径</td></tr><tr><td align="left"><code>-r</code>, <code>--replace</code></td><td align="left">如果存在同名文章，将其替换</td></tr><tr><td align="left"><code>-s</code>, <code>--slug</code></td><td align="left">文章的 Slug，作为新文章的文件名和发布后的 URL</td></tr></tbody></table><p>默认情况下，Hexo 会使用文章的标题来决定文章文件的路径。对于独立页面来说，Hexo 会创建一个以标题为名字的目录，并在目录中放置一个 <code>index.md</code> 文件。你可以使用 <code>--path</code> 参数来覆盖上述行为、自行决定文件的目录：</p><pre><code>hexo new page --path about/me &quot;About me&quot;</code></pre><p>以上命令会创建一个 <code>source/about/me.md</code> 文件，同时 Front Matter 中的 title 为 <code>&quot;About me&quot;</code></p><p>注意！title 是必须指定的！如果你这么做并不能达到你的目的：</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>github</title>
      <link href="blog/1669114857.html"/>
      <url>blog/1669114857.html</url>
      
        <content type="html"><![CDATA[<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><h4 id="git-init——初始化仓库"><a href="#git-init——初始化仓库" class="headerlink" title="git init——初始化仓库"></a>git init——初始化仓库</h4><pre><code>$ mkdir git-tutorial$ cd git-tutorial$ git initInitialized empty Git repository in /Users/hirocaster/github/github-book/git-tutorial/.git/</code></pre><p>​        如果初始化成功，执行了 git init 命令的目录下就会生成 .git 目 录。这个 .git 目录里存储着管理当前目录内容所需的仓库数据。</p><p>​        在 Git 中，我们将这个目录的内容称为“附属于该仓库的工作树”。 文件的编辑等操作在工作树中进行，然后记录到仓库中，以此管理文件 的历史快照。</p><h4 id="git-status——查看仓库的状态"><a href="#git-status——查看仓库的状态" class="headerlink" title="git status——查看仓库的状态"></a>git status——查看仓库的状态</h4><p>所谓提交 （Commit），是指“记录工作树中所有文件的当前状态”。</p><p>git fetch  = pull(远端仓库，可以是别人的仓库) + merge本地分支   </p><pre><code>git fetch origin     //origin是 git remote add ...添加的</code></pre><p>merge</p><pre><code>git checkout master //切换到master分支//为了在历史记录中明确记录下本次分支合 并，我们需要创建合并提交。因此，在合并时加上 --no-ff 参数。git merge --no-ff feature-A  // 合并feature-A到merge</code></pre><p>pull </p><p>git push :  推送到远程仓库</p><p>rebase</p><p>git clone</p><p>git add 文件    提交到暂存区</p><p>git commit -m描述：       提交到本地仓库</p><ul><li>-m</li><li>-am</li><li>–amend</li></ul><p>git status 查看状态</p><p>在远程仓库中也创建 develop 分支</p><p>开发者要时刻注意，对分支进行任何操作之前都必须先执行 pull 获 取最新代码，修改完毕后应尽快进行 push 操作，保证 GitHub 端远程仓 库内的代码为最新状态。</p><p>GitHub 端的远程仓库为 remotes/origin</p><h4 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h4><pre><code>//查看git branch : 显示本地分支一览表git branch -r : 查看远程仓库的分支git branch -a : 查看本地和远程仓库的所有分支//创建git checkout -b 分支名 ：以当前分支为基础，创建切换分支//切换git checkout master: 切换到master分支git checkout - : 切换回上一个分支git checkout -b 本地分支名 origin/远程分支名:        将远程git仓库里的指定分支拉取到本地（本地不存在的分支）//删除git branch -d bug_xzx 删除本地的bug_xzx分支git push origin --delete bug_xzx  删除远程的bug_xzx分支</code></pre><h3 id="二、push操作"><a href="#二、push操作" class="headerlink" title="二、push操作"></a>二、push操作</h3><p>1、将本地当前分支 推送到 远程指定分支上（注意：pull是远程在前本地在后，push相反）：</p><pre><code>git push origin &lt;本地分支名&gt;:&lt;远程分支名&gt;</code></pre><p>2、将本地当前分支 推送到 与本地当前分支同名的远程分支上（注意：pull是远程在前本地在后，push相反）：</p><pre><code>git push origin &lt;本地分支名&gt;</code></pre><p>3、将本地当前分支 推送到 与本地当前分支同名的远程分支上(需先关联远程分支，方法见文章末尾)</p><pre><code>git push同样的，推荐使用第2种方式，git push origin &lt;远程同名分支名&gt;</code></pre><p>git diff</p><p>不妨养成这样一个好习惯：在执行 git commit 命令之前先执行 <code>git diff HEAD</code> 命令，查看本次提交与上次提交之间有什么差别，等 确认完毕后再进行提交。这里的 HEAD 是指向当前分支中最新一次提交 的指针。</p><p>取消刚刚所有添加进暂存区的</p><pre><code>git restore --staged .</code></pre><p>取消添加进暂存区的某个文件</p><pre><code>git restore --staged &lt;file&gt;</code></pre><p>查看远程仓库的地址</p><pre><code>git remote -v</code></pre><p>设置新的远程仓库地址</p><pre><code>git remote set-url origin git@github.com:****/*****-client-5.git</code></pre><h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3><h4 id="1-查看远程仓库"><a href="#1-查看远程仓库" class="headerlink" title="1.查看远程仓库"></a>1.查看远程仓库</h4><pre><code>git remote 查看远程仓库的名字git remote -v 显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL</code></pre><h4 id="2-添加远程仓库"><a href="#2-添加远程仓库" class="headerlink" title="2.添加远程仓库"></a>2.添加远程仓库</h4><h5 id="2-1自动添加"><a href="#2-1自动添加" class="headerlink" title="2.1自动添加"></a>2.1自动添加</h5><p>git clone https:…..会自动添加远程仓库 并命名远程仓库名为origin.</p><h5 id="2-2手动添加"><a href="#2-2手动添加" class="headerlink" title="2.2手动添加"></a>2.2手动添加</h5><pre><code> git remote add &lt;shortname&gt; &lt;url&gt; eg:$ git remote add pb https://github.com/paulboone/ticgit</code></pre><p>之后可以在命令行中使用字符串 <code>pb</code> 来代替整个 URL</p><blockquote><p>什么是origin    : 如果你已经克隆了自己的仓库，那么至少应该能看到 origin ——这是 Git 给你克隆的仓库服务器的默认名字：</p></blockquote><h4 id="3-从远程仓库中抓取与拉取"><a href="#3-从远程仓库中抓取与拉取" class="headerlink" title="3.从远程仓库中抓取与拉取"></a>3.从远程仓库中抓取与拉取</h4><blockquote><p><a href="https://git-scm.com/book/zh/v2/Git-基础-远程仓库的使用" target="_blank" rel="noopener">https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8</a></p></blockquote><p>git pull 根据配置的不同，可为git fetch + git merge 或 git fetch + git rebase</p><p><img src="https://gzr-blog.oss-cn-shanghai.aliyuncs.com/uPic/image-20200826162749286_2020-09-20_14:09:42.png" alt="image-20200826162749286"></p><pre><code># 将远程主机的master分支最新内容拉下来后与当前本地分支直接合并git  pull origin master # git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;git pull origin master:feature-wxDemo  # 将远程主机的最新内容拉到本地，不进行合并git fetch origin master</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/剑指offer leetcode/递归</title>
      <link href="blog/3894826479.html"/>
      <url>blog/3894826479.html</url>
      
        <content type="html"><![CDATA[<p>36 二叉搜索树与双向链表</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/Android/Dart/flutter/第12章</title>
      <link href="blog/3802554250.html"/>
      <url>blog/3802554250.html</url>
      
        <content type="html"><![CDATA[<h1 id="12-2-插件开发：平台通道简介"><a href="#12-2-插件开发：平台通道简介" class="headerlink" title="12.2 插件开发：平台通道简介"></a>12.2 插件开发：平台通道简介</h1><p>Flutter本身只是一个UI系统，它本身是无法提供一些系统能力，比如使用蓝牙、相机、GPS等，因此要在Flutter APP中调用这些能力就必须和原生平台进行通信。为此，Flutter中提供了一个平台通道（platform channel），用于Flutter和原生平台的通信。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/Android/Dart/flutter/错误/1</title>
      <link href="blog/1438004775.html"/>
      <url>blog/1438004775.html</url>
      
        <content type="html"><![CDATA[<h1 id="如何解决“Waiting-for-another-flutter-command-to-…”"><a href="#如何解决“Waiting-for-another-flutter-command-to-…”" class="headerlink" title="如何解决“Waiting for another flutter command to …”"></a>如何解决“Waiting for another flutter command to …”</h1><p>执行 <code>Flutter</code> 包管理相关命令时有可能遇到 <code>Waiting for another flutter command to release the startup lock...</code> 这样的错误，可尝试杀死所有的 <code>dart</code> 进程解决：</p><pre class=" language-text"><code class="language-text">// Linuxkillall -9 dart// Windowstaskkill /F /IM dart.exe</code></pre><p>经  测试，亦可通过删除 <code>flutter</code> 安装目录下的 <code>bin/cache/lockfile</code> 文件解决。</p><p>参考：</p><ul><li><a href="https://link.zhihu.com/?target=https%3A//stackoverflow.com/questions/51679269/waiting-for-another-flutter-command-to-release-the-startup-lock">Waiting for another flutter command to release the startup lock</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/Android/Dart/flutter/第七章 功能型组件</title>
      <link href="blog/3905490961.html"/>
      <url>blog/3905490961.html</url>
      
        <content type="html"><![CDATA[<h1 id="7-2-数据共享（InheritedWidget）"><a href="#7-2-数据共享（InheritedWidget）" class="headerlink" title="7.2 数据共享（InheritedWidget）"></a>7.2 数据共享（InheritedWidget）</h1><p><code>InheritedWidget</code>是Flutter中非常重要的一个功能型组件，它提供了一种数据在widget树中从上到下传递、共享的方式，比如我们在应用的根widget中通过<code>InheritedWidget</code>共享了一个数据，那么我们便可以在任意子widget中来获取该共享的数据！这个特性在一些需要在widget树中共享数据的场景中非常方便！如Flutter SDK中正是通过InheritedWidget来共享应用主题（<code>Theme</code>）和Locale (当前语言环境)信息的。</p><blockquote><p><code>InheritedWidget</code>和React中的context功能类似，和逐级传递数据相比，它们能实现组件跨级传递数据。<code>InheritedWidget</code>的在widget树中数据传递方向是从上到下的，这和通知<code>Notification</code>（将在下一章中介绍）的传递方向正好相反。</p></blockquote><h4 id="应该在didChangeDependencies-中做什么？"><a href="#应该在didChangeDependencies-中做什么？" class="headerlink" title="应该在didChangeDependencies()中做什么？"></a>应该在didChangeDependencies()中做什么？</h4><p>一般来说，子widget很少会重写此方法，因为在依赖改变后framework也都会调用<code>build()</code>方法。但是，如果你需要在依赖改变后执行一些昂贵的操作，比如网络请求，这时最好的方式就是在此方法中执行，这样可以避免每次<code>build()</code>都执行这些昂贵操作。</p><h3 id="深入了解InheritedWidget"><a href="#深入了解InheritedWidget" class="headerlink" title="深入了解InheritedWidget"></a>深入了解InheritedWidget</h3><p><strong>调用<code>dependOnInheritedWidgetOfExactType()</code> 和 <code>getElementForInheritedWidgetOfExactType()</code>的区别就是前者会注册依赖关系，而后者不会</strong>，所以在调用<code>dependOnInheritedWidgetOfExactType()</code>时，<code>InheritedWidget</code>和依赖它的子孙组件关系便完成了注册，之后当<code>InheritedWidget</code>发生变化时，就会更新依赖它的子孙组件，也就是会调这些子孙组件的<code>didChangeDependencies()</code>方法和<code>build()</code>方法。而当调用的是 <code>getElementForInheritedWidgetOfExactType()</code>时，由于没有注册依赖关系，所以之后当<code>InheritedWidget</code>发生变化时，就不会更新相应的子孙Widget。</p><p>那么，现在就带来了一个问题：实际上，我们只想更新子树中依赖了<code>ShareDataWidget</code>的组件，而现在只要调用<code>_InheritedWidgetTestRouteState</code>的<code>setState()</code>方法，所有子节点都会被重新build，这很没必要，那么有什么办法可以避免呢？答案是缓存！一个简单的做法就是通过封装一个<code>StatefulWidget</code>，将子Widget树缓存起来，具体做法下一节我们将通过实现一个<code>Provider</code> Widget 来演示如何缓存，以及如何利用<code>InheritedWidget</code> 来实现Flutter全局状态共享。</p><h1 id="7-3-跨组件状态共享（Provider）"><a href="#7-3-跨组件状态共享（Provider）" class="headerlink" title="7.3 跨组件状态共享（Provider）"></a>7.3 跨组件状态共享（Provider）</h1><p>在Flutter开发中，状态管理是一个永恒的话题。一般的原则是：如果状态是组件私有的，则应该由组件自己管理；如果状态要跨组件共享，则该状态应该由各个组件共同的父元素来管理。对于组件私有的状态管理很好理解，但对于跨组件共享的状态，管理的方式就比较多了，如使用全局事件总线EventBus（将在下一章中介绍），它是一个观察者模式的实现，通过它就可以实现跨组件状态同步：状态持有方（发布者）负责更新、发布状态，状态使用方（观察者）监听状态改变事件来执行一些操作。下面我们看一个登陆状态同步的简单示例：</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/Android/Dart/flutter/第六章 可滚动组件</title>
      <link href="blog/3682543782.html"/>
      <url>blog/3682543782.html</url>
      
        <content type="html"><![CDATA[<h1 id="6-3-ListView"><a href="#6-3-ListView" class="headerlink" title="6.3 ListView"></a>6.3 ListView</h1><p><code>ListView</code>是最常用的可滚动组件之一，它可以沿一个方向线性排布所有子组件，并且它也支持基于Sliver的延迟构建模型。</p><h3 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h3><p>默认构造函数有一个<code>children</code>参数，它接受一个Widget列表（List）。这种方式适合只有少量的子组件的情况，因为这种方式需要将所有<code>children</code>都提前创建好（这需要做大量工作），而不是等到子widget真正显示的时候再创建，也就是说通过默认构造函数构建的ListView没有应用基于Sliver的懒加载模型。实际上通过此方式创建的<code>ListView</code>和使用<code>SingleChildScrollView</code>+<code>Column</code>的方式没有本质的区别</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/Android/Dart/flutter/第五章 容器类</title>
      <link href="blog/2498644385.html"/>
      <url>blog/2498644385.html</url>
      
        <content type="html"><![CDATA[<h2 id="5-1-填充（Padding）"><a href="#5-1-填充（Padding）" class="headerlink" title="5.1 填充（Padding）"></a>5.1 填充（Padding）</h2><p><code>Padding</code>可以给其子节点添加填充（留白），和边距效果类似。我们在前面很多示例中都已经使用过它了，现在来看看它的定义：</p><pre class=" language-dart"><code class="language-dart"><span class="token function">Padding</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  EdgeInsetsGeometry padding<span class="token punctuation">,</span>  Widget child<span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p><code>EdgeInsetsGeometry</code>是一个抽象类，开发中，我们一般都使用<code>EdgeInsets</code>类，它是<code>EdgeInsetsGeometry</code>的一个子类，定义了一些设置填充的便捷方法。</p><ul><li><code>fromLTRB(double left, double top, double right, double bottom)</code>：分别指定四个方向的填充。</li><li><code>all(double value)</code> : 所有方向均使用相同数值的填充。</li><li><code>only({left, top, right ,bottom })</code>：可以设置具体某个方向的填充(可以同时指定多个方向)。</li><li><code>symmetric({ vertical, horizontal })</code>：用于设置对称方向的填充，<code>vertical</code>指<code>top</code>和<code>bottom</code>，<code>horizontal</code>指<code>left</code>和<code>right</code>。</li></ul><p>容器可以容纳布局</p><h2 id="5-2-尺寸限制类容器"><a href="#5-2-尺寸限制类容器" class="headerlink" title="5.2 尺寸限制类容器"></a>5.2 尺寸限制类容器</h2><p>尺寸限制类容器用于限制容器大小，Flutter中提供了多种这样的容器，如<code>ConstrainedBox</code>、<code>SizedBox</code>、<code>UnconstrainedBox</code>、<code>AspectRatio</code>等，本节将介绍一些常用的。</p><h3 id="5-2-1-ConstrainedBox"><a href="#5-2-1-ConstrainedBox" class="headerlink" title="5.2.1 ConstrainedBox"></a>5.2.1 ConstrainedBox</h3><p><code>ConstrainedBox</code>用于对子组件添加额外的约束。例如，如果你想让子组件的最小高度是80像素，你可以使用<code>const BoxConstraints(minHeight: 80.0)</code>作为子组件的约束。</p><h3 id="5-2-2-SizedBox"><a href="#5-2-2-SizedBox" class="headerlink" title="5.2.2 SizedBox"></a>5.2.2 SizedBox</h3><p><code>SizedBox</code>用于给子元素指定固定的宽高，如：</p><pre class=" language-dart"><code class="language-dart"><span class="token function">SizedBox</span><span class="token punctuation">(</span>  width<span class="token punctuation">:</span> <span class="token number">80.0</span><span class="token punctuation">,</span>  height<span class="token punctuation">:</span> <span class="token number">80.0</span><span class="token punctuation">,</span>  child<span class="token punctuation">:</span> redBox<span class="token punctuation">)</span></code></pre><p>运行效果如图5-3所示：</p><p><img src="https://pcdn.flutterchina.club/imgs/5-3.png" alt="图5-3"></p><p>实际上<code>SizedBox</code>只是<code>ConstrainedBox</code>的一个定制，上面代码等价于：</p><h3 id="5-2-3-多重限制"><a href="#5-2-3-多重限制" class="headerlink" title="5.2.3 多重限制"></a>5.2.3 多重限制</h3><p>如果某一个组件有多个父级<code>ConstrainedBox</code>限制，那么最终会是哪个生效？</p><p>对于<code>minWidth</code>和<code>minHeight</code>来说，是取父子中相应数值较大的。</p><p>思考题：对于<code>maxWidth</code>和<code>maxHeight</code>，多重限制的策略是什么样的呢？</p><h3 id="5-2-4-UnconstrainedBox"><a href="#5-2-4-UnconstrainedBox" class="headerlink" title="5.2.4 UnconstrainedBox"></a>5.2.4 UnconstrainedBox</h3><p><code>UnconstrainedBox</code>不会对子组件产生任何限制，它允许其子组件按照其本身大小绘制。一般情况下，我们会很少直接使用此组件，但在”去除”多重限制的时候也许会有帮助</p><h3 id="5-2-5-其它尺寸限制类容器"><a href="#5-2-5-其它尺寸限制类容器" class="headerlink" title="5.2.5 其它尺寸限制类容器"></a>5.2.5 其它尺寸限制类容器</h3><p>除了上面介绍的这些常用的尺寸限制类容器外，还有一些其他的尺寸限制类容器，比如<code>AspectRatio</code>，它可以指定子组件的长宽比、<code>LimitedBox</code> 用于指定最大宽高、<code>FractionallySizedBox</code> 可以根据父容器宽高的百分比来设置子组件宽高等</p><h2 id="5-3-装饰容器DecoratedBox"><a href="#5-3-装饰容器DecoratedBox" class="headerlink" title="5.3 装饰容器DecoratedBox"></a>5.3 装饰容器DecoratedBox</h2><p><code>DecoratedBox</code>可以在其子组件绘制前(或后)绘制一些装饰（Decoration），如背景、边框、渐变等。<code>DecoratedBox</code>定义如下：</p><pre class=" language-dart"><code class="language-dart"><span class="token keyword">const</span> <span class="token function">DecoratedBox</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  Decoration decoration<span class="token punctuation">,</span>  DecorationPosition position <span class="token operator">=</span> DecorationPosition<span class="token punctuation">.</span>background<span class="token punctuation">,</span>  Widget child<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><ul><li><p><code>decoration</code>：代表将要绘制的装饰，它的类型为<code>Decoration</code>。<code>Decoration</code>是一个抽象类，它定义了一个接口 <code>createBoxPainter()</code>，子类的主要职责是需要通过实现它来创建一个画笔，该画笔用于绘制装饰。</p></li><li><pre><code>position</code></pre><p>：此属性决定在哪里绘制</p><pre><code>Decoration</code></pre><p>，它接收</p><pre><code>DecorationPosition</code></pre><p>的枚举类型，该枚举类有两个值：</p><ul><li><code>background</code>：在子组件之后绘制，即背景装饰。</li><li><code>foreground</code>：在子组件之上绘制，即前景。</li></ul></li></ul><h1 id="5-5-Container"><a href="#5-5-Container" class="headerlink" title="5.5 Container"></a>5.5 Container</h1><p>我们在前面的章节示例中多次用到过<code>Container</code>组件，本节我们就详细介绍一下<code>Container</code>组件。<code>Container</code>是一个组合类容器，它本身不对应具体的<code>RenderObject</code>，它是<code>DecoratedBox</code>、<code>ConstrainedBox、Transform</code>、<code>Padding</code>、<code>Align</code>等组件组合的一个多功能容器，所以我们只需通过一个<code>Container</code>组件可以实现同时需要装饰、变换、限制的场景。下面是<code>Container</code>的定义：</p><pre class=" language-dart"><code class="language-dart"><span class="token function">Container</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>alignment<span class="token punctuation">,</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>padding<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//容器内补白，属于decoration的装饰范围</span>  Color color<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 背景色</span>  Decoration decoration<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 背景装饰</span>  Decoration foregroundDecoration<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//前景装饰</span>  double width<span class="token punctuation">,</span><span class="token comment" spellcheck="true">//容器的宽度</span>  double height<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//容器的高度</span>  BoxConstraints constraints<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//容器大小的限制条件</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>margin<span class="token punctuation">,</span><span class="token comment" spellcheck="true">//容器外补白，不属于decoration的装饰范围</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>transform<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//变换</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>child<span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p><code>Container</code>的大多数属性在介绍其它容器时都已经介绍过了，不再赘述，但有两点需要说明：</p><ul><li>容器的大小可以通过<code>width</code>、<code>height</code>属性来指定，也可以通过<code>constraints</code>来指定；如果它们同时存在时，<code>width</code>、<code>height</code>优先。实际上Container内部会根据<code>width</code>、<code>height</code>来生成一个<code>constraints</code>。</li><li><code>color</code>和<code>decoration</code>是互斥的，如果同时设置它们则会报错！实际上，当指定<code>color</code>时，<code>Container</code>内会自动创建一个<code>decoration</code>。</li></ul><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>我们通过<code>Container</code>来实现如图5-16所示的卡片：</p><p><img src="https://pcdn.flutterchina.club/imgs/5-16.png" alt="图5-16"></p><p>实现代码如下：</p><pre class=" language-dart"><code class="language-dart"><span class="token function">Container</span><span class="token punctuation">(</span>  margin<span class="token punctuation">:</span> EdgeInsets<span class="token punctuation">.</span><span class="token function">only</span><span class="token punctuation">(</span>top<span class="token punctuation">:</span> <span class="token number">50.0</span><span class="token punctuation">,</span> left<span class="token punctuation">:</span> <span class="token number">120.0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//容器外填充</span>  constraints<span class="token punctuation">:</span> BoxConstraints<span class="token punctuation">.</span><span class="token function">tightFor</span><span class="token punctuation">(</span>width<span class="token punctuation">:</span> <span class="token number">200.0</span><span class="token punctuation">,</span> height<span class="token punctuation">:</span> <span class="token number">150.0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//卡片大小</span>  decoration<span class="token punctuation">:</span> <span class="token function">BoxDecoration</span><span class="token punctuation">(</span><span class="token comment" spellcheck="true">//背景装饰</span>      gradient<span class="token punctuation">:</span> <span class="token function">RadialGradient</span><span class="token punctuation">(</span> <span class="token comment" spellcheck="true">//背景径向渐变</span>          colors<span class="token punctuation">:</span> <span class="token punctuation">[</span>Colors<span class="token punctuation">.</span>red<span class="token punctuation">,</span> Colors<span class="token punctuation">.</span>orange<span class="token punctuation">]</span><span class="token punctuation">,</span>          center<span class="token punctuation">:</span> Alignment<span class="token punctuation">.</span>topLeft<span class="token punctuation">,</span>          radius<span class="token punctuation">:</span> <span class="token punctuation">.</span><span class="token number">98</span>      <span class="token punctuation">)</span><span class="token punctuation">,</span>      boxShadow<span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token comment" spellcheck="true">//卡片阴影</span>        <span class="token function">BoxShadow</span><span class="token punctuation">(</span>            color<span class="token punctuation">:</span> Colors<span class="token punctuation">.</span>black54<span class="token punctuation">,</span>            offset<span class="token punctuation">:</span> <span class="token function">Offset</span><span class="token punctuation">(</span><span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            blurRadius<span class="token punctuation">:</span> <span class="token number">4.0</span>        <span class="token punctuation">)</span>      <span class="token punctuation">]</span>  <span class="token punctuation">)</span><span class="token punctuation">,</span>  transform<span class="token punctuation">:</span> Matrix4<span class="token punctuation">.</span><span class="token function">rotationZ</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//卡片倾斜变换</span>  alignment<span class="token punctuation">:</span> Alignment<span class="token punctuation">.</span>center<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//卡片内文字居中</span>  child<span class="token punctuation">:</span> <span class="token function">Text</span><span class="token punctuation">(</span> <span class="token comment" spellcheck="true">//卡片文字</span>    <span class="token string">"5.20"</span><span class="token punctuation">,</span> style<span class="token punctuation">:</span> <span class="token function">TextStyle</span><span class="token punctuation">(</span>color<span class="token punctuation">:</span> Colors<span class="token punctuation">.</span>white<span class="token punctuation">,</span> fontSize<span class="token punctuation">:</span> <span class="token number">40.0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>可以看到<code>Container</code>具备多种组件的功能，通过查看<code>Container</code>源码，我们会很容易发现它正是前面我们介绍过的多种组件组合而成。在Flutter中，<code>Container</code>组件也正是组合优先于继承的实例。</p><h3 id="Padding和Margin"><a href="#Padding和Margin" class="headerlink" title="Padding和Margin"></a>Padding和Margin</h3><p>接下来我们来研究一下<code>Container</code>组件<code>margin</code>和<code>padding</code>属性的区别:</p><pre class=" language-dart"><code class="language-dart"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token function">Container</span><span class="token punctuation">(</span>  margin<span class="token punctuation">:</span> EdgeInsets<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token number">20.0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//容器外补白</span>  color<span class="token punctuation">:</span> Colors<span class="token punctuation">.</span>orange<span class="token punctuation">,</span>  child<span class="token punctuation">:</span> <span class="token function">Text</span><span class="token punctuation">(</span><span class="token string">"Hello world!"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">Container</span><span class="token punctuation">(</span>  padding<span class="token punctuation">:</span> EdgeInsets<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token number">20.0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//容器内补白</span>  color<span class="token punctuation">:</span> Colors<span class="token punctuation">.</span>orange<span class="token punctuation">,</span>  child<span class="token punctuation">:</span> <span class="token function">Text</span><span class="token punctuation">(</span><span class="token string">"Hello world!"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></code></pre><p><img src="https://pcdn.flutterchina.club/imgs/5-17.png" alt="图5-17"></p><p>可以发现，直观的感觉就是<code>margin</code>的留白是在容器外部，而<code>padding</code>的留白是在容器内部，读者需要记住这个差异。事实上，<code>Container</code>内<code>margin</code>和<code>padding</code>都是通过<code>Padding</code> 组件来实现的，上面的示例代码实际上等价于：</p><pre class=" language-dart"><code class="language-dart"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token function">Padding</span><span class="token punctuation">(</span>  padding<span class="token punctuation">:</span> EdgeInsets<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token number">20.0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  child<span class="token punctuation">:</span> <span class="token function">DecoratedBox</span><span class="token punctuation">(</span>    decoration<span class="token punctuation">:</span> <span class="token function">BoxDecoration</span><span class="token punctuation">(</span>color<span class="token punctuation">:</span> Colors<span class="token punctuation">.</span>orange<span class="token punctuation">)</span><span class="token punctuation">,</span>    child<span class="token punctuation">:</span> <span class="token function">Text</span><span class="token punctuation">(</span><span class="token string">"Hello world!"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">DecoratedBox</span><span class="token punctuation">(</span>  decoration<span class="token punctuation">:</span> <span class="token function">BoxDecoration</span><span class="token punctuation">(</span>color<span class="token punctuation">:</span> Colors<span class="token punctuation">.</span>orange<span class="token punctuation">)</span><span class="token punctuation">,</span>  child<span class="token punctuation">:</span> <span class="token function">Padding</span><span class="token punctuation">(</span>    padding<span class="token punctuation">:</span> <span class="token keyword">const</span> EdgeInsets<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token number">20.0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    child<span class="token punctuation">:</span> <span class="token function">Text</span><span class="token punctuation">(</span><span class="token string">"Hello world!"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/Android/Dart/flutter/第四章 布局类</title>
      <link href="blog/2145167380.html"/>
      <url>blog/2145167380.html</url>
      
        <content type="html"><![CDATA[<h1 id="本章目录"><a href="#本章目录" class="headerlink" title="本章目录"></a>本章目录</h1><ul><li><a href="https://book.flutterchina.club/chapter4/intro.html" target="_blank" rel="noopener">4.1：布局类组件简介</a></li><li><a href="https://book.flutterchina.club/chapter4/row_and_column.html" target="_blank" rel="noopener">4.2：线性布局（Row、Column）</a></li><li><a href="https://book.flutterchina.club/chapter4/flex.html" target="_blank" rel="noopener">4.3：弹性布局（Flex）</a></li><li><a href="https://book.flutterchina.club/chapter4/wrap_and_flow.html" target="_blank" rel="noopener">4.4：流式布局（Wrap、Flow）</a></li><li><a href="https://book.flutterchina.club/chapter4/stack.html" target="_blank" rel="noopener">4.5：层叠布局（Stack、Positioned）</a></li><li><a href="https://book.flutterchina.club/chapter4/alignment.html" target="_blank" rel="noopener">4.6：对齐与相对定位（Align）</a></li></ul><h1 id="4-1-布局类组件简介"><a href="#4-1-布局类组件简介" class="headerlink" title="4.1 布局类组件简介"></a>4.1 布局类组件简介</h1><p>布局类组件都会包含一个或多个子组件，不同的布局类组件对子组件排版(layout)方式不同。我们在前面说过<code>Element</code>树才是最终的绘制树，<code>Element</code>树是通过Widget树来创建的（通过<code>Widget.createElement()</code>），Widget其实就是Element的配置数据。在Flutter中，根据Widget是否需要包含子节点将Widget分为了三类，分别对应三种Element，如下表：</p><table><thead><tr><th>Widget</th><th>对应的Element</th><th>用途</th></tr></thead><tbody><tr><td>LeafRenderObjectWidget</td><td>LeafRenderObjectElement</td><td>Widget树的叶子节点，用于没有子节点的widget，通常基础组件都属于这一类，如Image。</td></tr><tr><td>SingleChildRenderObjectWidget</td><td>SingleChildRenderObjectElement</td><td>包含一个子Widget，如：ConstrainedBox、DecoratedBox等</td></tr><tr><td>MultiChildRenderObjectWidget</td><td>MultiChildRenderObjectElement</td><td>包含多个子Widget，一般都有一个children参数，接受一个Widget数组。如Row、Column、Stack等</td></tr></tbody></table><blockquote><p>注意，Flutter中的很多Widget是直接继承自StatelessWidget或StatefulWidget，然后在<code>build()</code>方法中构建真正的RenderObjectWidget，如Text，它其实是继承自StatelessWidget，然后在<code>build()</code>方法中通过RichText来构建其子树，而RichText才是继承自MultiChildRenderObjectWidget。所以为了方便叙述，我们也可以直接说Text属于MultiChildRenderObjectWidget（其它widget也可以这么描述），这才是本质。读到这里我们也会发现，其实<strong>StatelessWidget和StatefulWidget就是两个用于组合Widget的基类，它们本身并不关联最终的渲染对象（RenderObjectWidget）</strong>。</p></blockquote><p>布局类组件就是指直接或间接继承(包含)<code>MultiChildRenderObjectWidget</code>的Widget，它们一般都会有一个<code>children</code>属性用于接收子Widget。我们看一下继承关系 Widget &gt; RenderObjectWidget &gt; (Leaf/SingleChild/MultiChild)RenderObjectWidget 。</p><h1 id="4-2-线性布局（Row和Column）"><a href="#4-2-线性布局（Row和Column）" class="headerlink" title="4.2 线性布局（Row和Column）"></a>4.2 线性布局（Row和Column）</h1><p>所谓线性布局，即指沿水平或垂直方向排布子组件。Flutter中通过<code>Row</code>和<code>Column</code>来实现线性布局，类似于Android中的<code>LinearLayout</code>控件。<code>Row</code>和<code>Column</code>都继承自<code>Flex</code>，我们将在弹性布局一节中详细介绍<code>Flex</code>。</p><h3 id="主轴和纵轴"><a href="#主轴和纵轴" class="headerlink" title="主轴和纵轴"></a>主轴和纵轴</h3><p>对于线性布局，有主轴和纵轴之分，如果布局是沿水平方向，那么主轴就是指水平方向，而纵轴即垂直方向；如果布局沿垂直方向，那么主轴就是指垂直方向，而纵轴就是水平方向。在线性布局中，有两个定义对齐方式的枚举类<code>MainAxisAlignment</code>和<code>CrossAxisAlignment</code>，分别代表主轴对齐和纵轴对齐。</p><h3 id="Expanded"><a href="#Expanded" class="headerlink" title="Expanded"></a>Expanded</h3><p>可以按比例“扩伸” <code>Row</code>、<code>Column</code>和<code>Flex</code>子组件所占用的空间。</p><pre class=" language-dart"><code class="language-dart"><span class="token keyword">const</span> <span class="token function">Expanded</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  int flex <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span>   <span class="token metadata symbol">@required</span> Widget child<span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p><code>flex</code>参数为弹性系数，如果为0或<code>null</code>，则<code>child</code>是没有弹性的，即不会被扩伸占用的空间。如果大于0，所有的<code>Expanded</code>按照其flex的比例来分割主轴的全部空闲空间</p><p>spacer</p><p><code>Spacer</code>的功能是占用指定比例的空间，实际上它只是<code>Expanded</code>的一个包装类</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/Android/Dart/flutter/快捷键</title>
      <link href="blog/1762892650.html"/>
      <url>blog/1762892650.html</url>
      
        <content type="html"><![CDATA[<p>ihof   Create ThemeData from an InheritedWidget</p><p>inh    New Inherited widget</p><p>stanim    New Stateful widget with AnimationController</p><p>stful     New Stateful widget</p><p>stless        New Stateless widget</p><p>thof    Create ThemeData from build context</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/Android/Dart/flutter/第三章 基础组件</title>
      <link href="blog/2931185028.html"/>
      <url>blog/2931185028.html</url>
      
        <content type="html"><![CDATA[<h2 id="本章目录"><a href="#本章目录" class="headerlink" title="本章目录"></a>本章目录</h2><ul><li><a href="https://book.flutterchina.club/chapter3/flutter_widget_intro.html" target="_blank" rel="noopener">3.1：Widget简介</a></li><li><a href="https://book.flutterchina.club/chapter3/state_manage.html" target="_blank" rel="noopener">3.2：状态管理</a></li><li><a href="https://book.flutterchina.club/chapter3/text.html" target="_blank" rel="noopener">3.3：文本、字体样式</a></li><li><a href="https://book.flutterchina.club/chapter3/buttons.html" target="_blank" rel="noopener">3.4：按钮</a></li><li><a href="https://book.flutterchina.club/chapter3/img_and_icon.html" target="_blank" rel="noopener">3.5：图片和Icon</a></li><li><a href="https://book.flutterchina.club/chapter3/radio_and_checkbox.html" target="_blank" rel="noopener">3.6：单选框和复选框</a></li><li><a href="https://book.flutterchina.club/chapter3/input_and_form.html" target="_blank" rel="noopener">3.7：输入框和表单</a></li><li><a href="https://book.flutterchina.club/chapter3/progress.html" target="_blank" rel="noopener">3.8：进度指示器</a></li></ul><h1 id="3-1-Widget简介"><a href="#3-1-Widget简介" class="headerlink" title="3.1 Widget简介"></a>3.1 Widget简介</h1><h3 id="3-1-1-概念"><a href="#3-1-1-概念" class="headerlink" title="3.1.1 概念"></a>3.1.1 概念</h3><p>Flutter中几乎所有的对象都是一个Widget。与原生开发中“控件”不同的是，Flutter中的Widget的概念更广泛，它不仅可以表示UI元素，也可以表示一些功能性的组件如：用于手势检测的 <code>GestureDetector</code> widget、用于APP主题数据传递的<code>Theme</code>等等，而原生开发中的控件通常只是指UI元素</p><p>Flutter主要就是用于构建用户界面的，所以，在大多数时候，读者可以认为widget就是一个控件，不必纠结于概念</p><h3 id="3-1-2-Widget与Element"><a href="#3-1-2-Widget与Element" class="headerlink" title="3.1.2 Widget与Element"></a>3.1.2 Widget与Element</h3><p>在Flutter中，Widget的功能是“描述一个UI元素的配置数据”，它就是说，Widget其实并不是表示最终绘制在设备屏幕上的显示元素，而它只是描述显示元素的一个配置数据。</p><p>实际上，Flutter中真正代表屏幕上显示元素的类是<code>Element</code>，也就是说Widget只是描述<code>Element</code>的配置数据！现在，读者只需要知道：<strong>Widget只是UI元素的一个配置数据，并且一个Widget可以对应多个<code>Element</code></strong>。</p><p>总结一下：</p><ul><li>Widget实际上就是<code>Element</code>的配置数据，Widget树实际上是一个配置树，而真正的UI渲染树是由<code>Element</code>构成；不过，由于<code>Element</code>是通过Widget生成的，所以它们之间有对应关系，在大多数场景，我们可以宽泛地认为Widget树就是指UI控件树或UI渲染树。</li><li>一个Widget对象可以对应多个<code>Element</code>对象。这很好理解，根据同一份配置（Widget），可以创建多个实例（Element）。</li></ul><p>读者应该将这两点<font color="red"><strong>牢记</strong>在心中。</font></p><h3 id="3-1-3-Widget主要接口"><a href="#3-1-3-Widget主要接口" class="headerlink" title="3.1.3 Widget主要接口"></a>3.1.3 Widget主要接口</h3><ul><li><code>Widget</code>类继承自<code>DiagnosticableTree</code>，<code>DiagnosticableTree</code>即“诊断树”，主要作用是提供调试信息。</li><li><code>Key</code>: 这个<code>key</code>属性类似于React/Vue中的<code>key</code>，主要的作用是决定是否在下一次<code>build</code>时复用旧的widget，决定的条件在<code>canUpdate()</code>方法中。</li><li><code>createElement()</code>：正如前文所述“一个Widget可以对应多个<code>Element</code>”；Flutter Framework在构建UI树时，会先调用此方法生成对应节点的<code>Element</code>对象。此方法是Flutter Framework隐式调用的，在我们开发过程中基本不会调用到。</li><li><code>debugFillProperties(...)</code> 复写父类的方法，主要是设置诊断树的一些特性。</li><li><code>canUpdate(...)</code>是一个静态方法，它主要用于在Widget树重新<code>build</code>时复用旧的widget，其实具体来说，应该是：是否用新的Widget对象去更新旧UI树上所对应的<code>Element</code>对象的配置；通过其源码我们可以看到，只要<code>newWidget</code>与<code>oldWidget</code>的<code>runtimeType</code>和<code>key</code>同时相等时就会用<code>newWidget</code>去更新<code>Element</code>对象的配置，否则就会创建新的<code>Element</code>。</li></ul><p>有关Key和Widget复用的细节将会在本书后面高级部分深入讨论，读者现在只需知道，为Widget显式添加key的话可能（但不一定）会使UI在重新构建时变的高效，读者目前可以先忽略此参数。本书后面的示例中，只会在构建列表项UI时会显式指定Key。</p><p>另外<code>Widget</code>类本身是一个抽象类，其中最核心的就是定义了<code>createElement()</code>接口，在Flutter开发中，我们一般都不用直接继承<code>Widget</code>类来实现一个新组件，相反，我们通常会通过继承<code>StatelessWidget</code>或<code>StatefulWidget</code>来间接继承<code>Widget</code>类来实现。<code>StatelessWidget</code>和<code>StatefulWidget</code>都是直接继承自<code>Widget</code>类，而这两个类也正是Flutter中非常重要的两个抽象类，它们引入了两种Widget模型，接下来我们将重点介绍一下这两个类。</p><h2 id="3-1-4-StatelessWidget"><a href="#3-1-4-StatelessWidget" class="headerlink" title="3.1.4 StatelessWidget"></a>3.1.4 StatelessWidget</h2><p>在之前的章节中，我们已经简单介绍过<code>StatelessWidget</code>，<code>StatelessWidget</code>相对比较简单，它继承自<code>Widget</code>类，重写了<code>createElement()</code>方法：</p><blockquote><p> 按照惯例，<code>widget</code>的构造函数参数应使用命名参数，命名参数中的必要参数要添加<code>@required</code>标注，这样有利于静态代码分析器进行检查。另外，在继承<code>widget</code>时，第一个参数通常应该是<code>Key</code>，另外，如果Widget需要接收子Widget，那么<code>child</code>或<code>children</code>参数通常应被放在参数列表的最后。同样是按照惯例，Widget的属性应尽可能的被声明为<code>final</code>，防止被意外改变。</p></blockquote><pre class=" language-dart"><code class="language-dart"><span class="token keyword">class</span> <span class="token class-name">Echo</span> <span class="token keyword">extends</span> <span class="token class-name">StatelessWidget</span> <span class="token punctuation">{</span>  <span class="token keyword">const</span> <span class="token function">Echo</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    Key key<span class="token punctuation">,</span>      <span class="token metadata symbol">@required</span> <span class="token keyword">this</span><span class="token punctuation">.</span>text<span class="token punctuation">,</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>backgroundColor<span class="token punctuation">:</span>Colors<span class="token punctuation">.</span>grey<span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">super</span><span class="token punctuation">(</span>key<span class="token punctuation">:</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">final</span> String text<span class="token punctuation">;</span>  <span class="token keyword">final</span> Color backgroundColor<span class="token punctuation">;</span>  <span class="token metadata symbol">@override</span>  Widget <span class="token function">build</span><span class="token punctuation">(</span>BuildContext context<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">Center</span><span class="token punctuation">(</span>      child<span class="token punctuation">:</span> <span class="token function">Container</span><span class="token punctuation">(</span>        color<span class="token punctuation">:</span> backgroundColor<span class="token punctuation">,</span>        child<span class="token punctuation">:</span> <span class="token function">Text</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">,</span>      <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//上面的代码，实现了一个回显字符串的Echo widget。</span></code></pre><p>然后我们可以通过如下方式使用它：</p><pre class=" language-dart"><code class="language-dart">Widget <span class="token function">build</span><span class="token punctuation">(</span>BuildContext context<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token function">Echo</span><span class="token punctuation">(</span>text<span class="token punctuation">:</span> <span class="token string">"hello world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h3><p><code>build</code>方法有一个<code>context</code>参数，它是<code>BuildContext</code>类的一个实例，表示当前widget在widget树中的上下文，每一个widget都会对应一个context对象（因为每一个widget都是widget树上的一个节点）。实际上，<code>context</code>是当前widget在widget树中位置中执行”相关操作“的一个句柄，比如它提供了从当前widget开始向上遍历widget树以及按照widget类型查找父级widget的方法。下面是在子树中获取父级widget的一个示例：</p><h2 id="3-1-5-StatefulWidget"><a href="#3-1-5-StatefulWidget" class="headerlink" title="3.1.5 StatefulWidget"></a>3.1.5 StatefulWidget</h2><p>和<code>StatelessWidget</code>不同的是<code>createElement()</code>方法返回的<code>Element</code> 对象不同；另外<code>StatefulWidget</code>类中添加了一个新的接口<code>createState()</code>。</p><p>下面我们看看<code>StatefulWidget</code>的类定义：</p><pre class=" language-dart"><code class="language-dart"><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">StatefulWidget</span> <span class="token keyword">extends</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span>  <span class="token keyword">const</span> <span class="token function">StatefulWidget</span><span class="token punctuation">(</span><span class="token punctuation">{</span> Key key <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token keyword">super</span><span class="token punctuation">(</span>key<span class="token punctuation">:</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token metadata symbol">@override</span>  StatefulElement <span class="token function">createElement</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">new</span> <span class="token class-name">StatefulElement</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token metadata symbol">@protected</span>  State <span class="token function">createState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li><p><code>StatefulElement</code> 间接继承自<code>Element</code>类，与StatefulWidget相对应（作为其配置数据）。<code>StatefulElement</code>中可能会多次调用<code>createState()</code>来创建状态(State)对象。</p></li><li><p><code>createState()</code> 用于创建和Stateful widget相关的状态，它在Stateful widget的生命周期中可能会被多次调用。例如，当一个Stateful widget同时插入到widget树的多个位置时，Flutter framework就会调用该方法为每一个位置生成一个独立的State实例，其实，本质上就是一个<code>StatefulElement</code>对应一个State实例。</p><blockquote><p>在本书中经常会出现“树”的概念，在不同的场景可能指不同的意思，在说“widget树”时它可以指widget结构树，但由于widget与Element有对应关系（一可能对多），在有些场景（Flutter的SDK文档中）也代指“UI树”的意思。而在stateful widget中，State对象也和<code>StatefulElement</code>具有对应关系（一对一），所以在Flutter的SDK文档中，可以经常看到“从树中移除State对象”或“插入State对象到树中”这样的描述。其实，无论哪种描述，其意思都是在描述“一棵构成用户界面的节点元素的树”，读者不必纠结于这些概念，还是那句话“得其神，忘其形”，因此，本书中出现的各种“树”，如果没有特别说明，读者都可抽象的认为它是“一棵构成用户界面的节点元素的树”。</p></blockquote></li></ul><h4 id="State生命周期"><a href="#State生命周期" class="headerlink" title="State生命周期"></a>State生命周期</h4><p><font color="red">理解State的生命周期对flutter开发非常重要</font>，为了加深读者印象，本节我们通过一个实例来演示一下State的生命周期。在接下来的示例中，我们实现一个计数器widget，点击它可以使计数器加1，由于要保存计数器的数值状态，所以我们应继承StatefulWidget，代码如下：</p><pre class=" language-dart"><code class="language-dart"><span class="token keyword">class</span> <span class="token class-name">CounterWidget</span> <span class="token keyword">extends</span> <span class="token class-name">StatefulWidget</span> <span class="token punctuation">{</span>  <span class="token keyword">const</span> <span class="token function">CounterWidget</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    Key key<span class="token punctuation">,</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>initValue<span class="token punctuation">:</span> <span class="token number">0</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">final</span> int initValue<span class="token punctuation">;</span>  <span class="token metadata symbol">@override</span>  _CounterWidgetState <span class="token function">createState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">new</span> <span class="token class-name">_CounterWidgetState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><code>CounterWidget</code>接收一个<code>initValue</code>整型参数，它表示计数器的初始值。下面我们看一下State的代码：</p><pre class=" language-dart"><code class="language-dart"><span class="token keyword">class</span> <span class="token class-name">_CounterWidgetState</span> <span class="token keyword">extends</span> <span class="token class-name">State</span><span class="token operator">&lt;</span>CounterWidget<span class="token operator">></span> <span class="token punctuation">{</span>    int _counter<span class="token punctuation">;</span>  <span class="token metadata symbol">@override</span>  <span class="token keyword">void</span> <span class="token function">initState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">initState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//初始化状态  </span>    _counter<span class="token operator">=</span>widget<span class="token punctuation">.</span>initValue<span class="token punctuation">;</span>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"initState"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token metadata symbol">@override</span>  Widget <span class="token function">build</span><span class="token punctuation">(</span>BuildContext context<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"build"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">Scaffold</span><span class="token punctuation">(</span>      body<span class="token punctuation">:</span> <span class="token function">Center</span><span class="token punctuation">(</span>        child<span class="token punctuation">:</span> <span class="token function">FlatButton</span><span class="token punctuation">(</span>          child<span class="token punctuation">:</span> <span class="token function">Text</span><span class="token punctuation">(</span><span class="token string">'$_counter'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>          <span class="token comment" spellcheck="true">//点击后计数器自增</span>          onPressed<span class="token punctuation">:</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span> <span class="token operator">++</span>_counter<span class="token punctuation">,</span>          <span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">)</span><span class="token punctuation">,</span>      <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token metadata symbol">@override</span>  <span class="token keyword">void</span> <span class="token function">didUpdateWidget</span><span class="token punctuation">(</span>CounterWidget oldWidget<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">didUpdateWidget</span><span class="token punctuation">(</span>oldWidget<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"didUpdateWidget"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token metadata symbol">@override</span>  <span class="token keyword">void</span> <span class="token function">deactivate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">deactivate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"deactive"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token metadata symbol">@override</span>  <span class="token keyword">void</span> <span class="token function">dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"dispose"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token metadata symbol">@override</span>  <span class="token keyword">void</span> <span class="token function">reassemble</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">reassemble</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"reassemble"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token metadata symbol">@override</span>  <span class="token keyword">void</span> <span class="token function">didChangeDependencies</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">didChangeDependencies</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"didChangeDependencies"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>接下来，我们创建一个新路由，在新路由中，我们只显示一个<code>CounterWidget</code>：</p><pre class=" language-dart"><code class="language-dart">Widget <span class="token function">build</span><span class="token punctuation">(</span>BuildContext context<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token function">CounterWidget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>我们运行应用并打开该路由页面，在新路由页打开后，屏幕中央就会出现一个数字0，然后控制台日志输出：</p><pre><code>I/flutter ( 5436): initStateI/flutter ( 5436): didChangeDependenciesI/flutter ( 5436): build</code></pre><p>可以看到，在StatefulWidget插入到Widget树时首先<code>initState</code>方法会被调用。</p><p>然后我们点击⚡️按钮热重载，控制台输出日志如下：</p><pre><code>I/flutter ( 5436): reassembleI/flutter ( 5436): didUpdateWidgetI/flutter ( 5436): build</code></pre><p>可以看到此时<code>initState</code> 和<code>didChangeDependencies</code>都没有被调用，而此时<code>didUpdateWidget</code>被调用。</p><p>接下来，我们在widget树中移除<code>CounterWidget</code>，将路由<code>build</code>方法改为：</p><pre class=" language-dart"><code class="language-dart">Widget <span class="token function">build</span><span class="token punctuation">(</span>BuildContext context<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//移除计数器 </span>  <span class="token comment" spellcheck="true">//return CounterWidget();</span>  <span class="token comment" spellcheck="true">//随便返回一个Text()</span>  <span class="token keyword">return</span> <span class="token function">Text</span><span class="token punctuation">(</span><span class="token string">"xxx"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>然后热重载，日志如下：</p><pre><code>I/flutter ( 5436): reassembleI/flutter ( 5436): deactiveI/flutter ( 5436): dispose</code></pre><p>我们可以看到，在<code>CounterWidget</code>从widget树中移除时，<code>deactive</code>和<code>dispose</code>会依次被调用。</p><p>下面我们来看看各个回调函数：</p><ul><li><code>initState</code>：当Widget第一次插入到Widget树时会被调用，对于每一个State对象，Flutter framework只会调用一次该回调，所以，通常在该回调中做一些一次性的操作，如状态初始化、订阅子树的事件通知等。</li><li><code>didChangeDependencies()</code>：当State对象的依赖发生变化时会被调用；例如：在之前<code>build()</code> 中包含了一个<code>InheritedWidget</code>，然后在之后的<code>build()</code> 中<code>InheritedWidget</code>发生了变化，那么此时<code>InheritedWidget</code>的子widget的<code>didChangeDependencies()</code>回调都会被调用。典型的场景是当系统语言Locale或应用主题改变时，Flutter framework会通知widget调用此回调。</li><li><code>build()</code>：此回调读者现在应该已经相当熟悉了，它主要是用于构建Widget子树的，会在如下场景被调用：<ol><li>在调用<code>initState()</code>之后。</li><li>在调用<code>didUpdateWidget()</code>之后。</li><li>在调用<code>setState()</code>之后。</li><li>在调用<code>didChangeDependencies()</code>之后。</li><li>在State对象从树中一个位置移除后（会调用deactivate）又重新插入到树的其它位置之后。</li></ol></li><li><code>reassemble()</code>：此回调是专门为了开发调试而提供的，在热重载(hot reload)时会被调用，此回调在Release模式下永远不会被调用。</li><li><code>didUpdateWidget()</code>：在widget重新构建时，Flutter framework会调用<code>Widget.canUpdate</code>来检测Widget树中同一位置的新旧节点，然后决定是否需要更新，如果<code>Widget.canUpdate</code>返回<code>true</code>则会调用此回调。</li><li><code>deactivate()</code>：当State对象从树中被移除时，会调用此回调。在一些场景下，Flutter framework会将State对象重新插到树中，如包含此State对象的子树在树的一个位置移动到另一个位置时（可以通过GlobalKey来实现）。如果移除后没有重新插入到树中则紧接着会调用<code>dispose()</code>方法。</li><li><code>dispose()</code>：当State对象从树中被永久移除时调用；通常在此回调中释放资源。</li></ul><h3 id="为什么要将build方法放在State中，而不是放在StatefulWidget中？"><a href="#为什么要将build方法放在State中，而不是放在StatefulWidget中？" class="headerlink" title="为什么要将build方法放在State中，而不是放在StatefulWidget中？"></a>为什么要将build方法放在State中，而不是放在StatefulWidget中？</h3><h1 id="3-4-按钮"><a href="#3-4-按钮" class="headerlink" title="3.4 按钮"></a>3.4 按钮</h1><h3 id="3-4-1-Material组件库中的按钮"><a href="#3-4-1-Material组件库中的按钮" class="headerlink" title="3.4.1 Material组件库中的按钮"></a>3.4.1 Material组件库中的按钮</h3><h3 id="RaisedButton"><a href="#RaisedButton" class="headerlink" title="RaisedButton"></a>RaisedButton</h3><p><code>RaisedButton</code> 即”漂浮”按钮，它默认带有阴影和灰色背景。按下后，阴影会变大，如图3-10所示：</p><p><img src="https://pcdn.flutterchina.club/imgs/3-10.png" alt="图3-10"></p><h3 id="FlatButton"><a href="#FlatButton" class="headerlink" title="FlatButton"></a>FlatButton</h3><p><code>FlatButton</code>即扁平按钮，默认背景透明并不带阴影。按下后，会有背景色，如图3-11所示：</p><p><img src="https://pcdn.flutterchina.club/imgs/3-11.png" alt="图3-11"></p><h3 id="OutlineButton"><a href="#OutlineButton" class="headerlink" title="OutlineButton"></a>OutlineButton</h3><p><code>OutlineButton</code>默认有一个边框，不带阴影且背景透明。按下后，边框颜色会变亮、同时出现背景和阴影(较弱)，如图3-12所示：</p><p><img src="https://pcdn.flutterchina.club/imgs/3-12.png" alt="图3-12"></p><h3 id="IconButton"><a href="#IconButton" class="headerlink" title="IconButton"></a>IconButton</h3><p><code>IconButton</code>是一个可点击的Icon，不包括文字，默认没有背景，点击后会出现背景，如图3-13所示：</p><p><img src="https://pcdn.flutterchina.club/imgs/3-13.png" alt="图3-13"></p><h3 id="带图标的按钮"><a href="#带图标的按钮" class="headerlink" title="带图标的按钮"></a>带图标的按钮</h3><p><code>RaisedButton</code>、<code>FlatButton</code>、<code>OutlineButton</code>都有一个<code>icon</code> 构造函数，通过它可以轻松创建带图标的按钮，如图3-14所示：</p><p><img src="https://pcdn.flutterchina.club/imgs/3-14.png" alt="图3-14"></p><h2 id="3-4-2-自定义按钮外观"><a href="#3-4-2-自定义按钮外观" class="headerlink" title="3.4.2 自定义按钮外观"></a>3.4.2 自定义按钮外观</h2><p>按钮外观可以通过其属性来定义，不同按钮属性大同小异，我们以FlatButton为例，介绍一下常见的按钮属性，详细的信息可以查看API文档。</p><pre class=" language-dart"><code class="language-dart"><span class="token keyword">const</span> <span class="token function">FlatButton</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token metadata symbol">@required</span> <span class="token keyword">this</span><span class="token punctuation">.</span>onPressed<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//按钮点击回调</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>textColor<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//按钮文字颜色</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>disabledTextColor<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//按钮禁用时的文字颜色</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>color<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//按钮背景颜色</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>disabledColor<span class="token punctuation">,</span><span class="token comment" spellcheck="true">//按钮禁用时的背景颜色</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>highlightColor<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//按钮按下时的背景颜色</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>splashColor<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//点击时，水波动画中水波的颜色</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>colorBrightness<span class="token punctuation">,</span><span class="token comment" spellcheck="true">//按钮主题，默认是浅色主题 </span>  <span class="token keyword">this</span><span class="token punctuation">.</span>padding<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//按钮的填充</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>shape<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//外形</span>  <span class="token metadata symbol">@required</span> <span class="token keyword">this</span><span class="token punctuation">.</span>child<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//按钮的内容</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>其中大多数属性名都是自解释的，我们不赘述。下面我们通过一个示例来看看如何自定义按钮。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>定义一个背景蓝色，两边圆角的按钮。效果如图3-15所示：</p><p><img src="https://pcdn.flutterchina.club/imgs/3-15.png" alt="图3-15"></p><p>代码如下：</p><pre class=" language-dart"><code class="language-dart"><span class="token function">FlatButton</span><span class="token punctuation">(</span>  color<span class="token punctuation">:</span> Colors<span class="token punctuation">.</span>blue<span class="token punctuation">,</span>  highlightColor<span class="token punctuation">:</span> Colors<span class="token punctuation">.</span>blue<span class="token punctuation">[</span><span class="token number">700</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  colorBrightness<span class="token punctuation">:</span> Brightness<span class="token punctuation">.</span>dark<span class="token punctuation">,</span>  splashColor<span class="token punctuation">:</span> Colors<span class="token punctuation">.</span>grey<span class="token punctuation">,</span>  child<span class="token punctuation">:</span> <span class="token function">Text</span><span class="token punctuation">(</span><span class="token string">"Submit"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  shape<span class="token punctuation">:</span><span class="token function">RoundedRectangleBorder</span><span class="token punctuation">(</span>borderRadius<span class="token punctuation">:</span> BorderRadius<span class="token punctuation">.</span><span class="token function">circular</span><span class="token punctuation">(</span><span class="token number">20.0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  onPressed<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">)</span></code></pre><h2 id="3-5-图片及ICON"><a href="#3-5-图片及ICON" class="headerlink" title="3.5 图片及ICON"></a>3.5 图片及ICON</h2><h2 id="3-5-1-图片"><a href="#3-5-1-图片" class="headerlink" title="3.5.1 图片"></a>3.5.1 图片</h2><p>Flutter中，我们可以通过<code>Image</code>组件来加载并显示图片，<code>Image</code>的数据源可以是asset、文件、内存以及网络。</p><h3 id="ImageProvider"><a href="#ImageProvider" class="headerlink" title="ImageProvider"></a>ImageProvider</h3><p><code>ImageProvider</code> 是一个抽象类，主要定义了图片数据获取的接口<code>load()</code>，从不同的数据源获取图片需要实现不同的<code>ImageProvider</code> ，如<code>AssetImage</code>是实现了从Asset中加载图片的ImageProvider，而<code>NetworkImage</code>实现了从网络加载图片的ImageProvider。</p><h3 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h3><p><code>Image</code> widget有一个必选的<code>image</code>参数，它对应一个ImageProvider。下面我们分别演示一下如何从asset和网络加载图片。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/Android/Dart/dart语法</title>
      <link href="blog/3650152030.html"/>
      <url>blog/3650152030.html</url>
      
        <content type="html"><![CDATA[<h4 id="命名构造函数"><a href="#命名构造函数" class="headerlink" title="命名构造函数"></a>命名构造函数</h4><p>使用命名构造函数可为一个类实现多个构造函数， 也可以使用命名构造函数来更清晰的表明函数意图：</p><pre><code>class Point {  num x, y;  Point(this.x, this.y);  // 命名构造函数  Point.origin() {    x = 0;    y = 0;  }}</code></pre><h2 id="异步支持"><a href="#异步支持" class="headerlink" title="异步支持"></a>异步支持</h2><p>Dart 库中包含许多返回 Future 或 Stream 对象的函数. 这些函数在设置完耗时任务（例如 I/O 曹组）后， 就立即返回了，不会等待耗任务完成。 使用 <code>async</code> 和 <code>await</code> 关键字实现异步编程。 可以让你像编写同步代码一样实现异步操作。</p><h3 id="处理-Future"><a href="#处理-Future" class="headerlink" title="处理 Future"></a>处理 Future</h3><p>可以通过下面两种方式，获得 Future 执行完成的结果：</p><ul><li>使用 <code>async</code> 和 <code>await</code>.</li><li>使用 Future API，具体描述，参考 <a href="https://www.dartcn.com/guides/libraries/library-tour#future" target="_blank" rel="noopener">库概览</a>.</li></ul><p>使用 <code>async</code> 和 <code>await</code> 关键字的代码是异步的。 虽然看起来有点想同步代码。 例如，下面的代码使用 <code>await</code> 等待异步函数的执行结果。</p><pre class=" language-dart"><code class="language-dart"><span class="token keyword">await</span> <span class="token function">lookUpVersion</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>要使用 <code>await</code> ， 代码必须在 <em>异步函数</em>（使用 <code>async</code> 标记的函数）中：</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/Android/Dart/2020-09-01 </title>
      <link href="blog/238630408.html"/>
      <url>blog/238630408.html</url>
      
        <content type="html"><![CDATA[<p>每次热更新时，<code>build</code>方法都会被执行</p><h2 id="其它依赖方式"><a href="#其它依赖方式" class="headerlink" title="其它依赖方式"></a>其它依赖方式</h2><p>依赖本地包</p><p>依赖Git：</p><h1 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h1><h3 id="指定-assets"><a href="#指定-assets" class="headerlink" title="指定 assets"></a>指定 assets</h3><p>和包管理一样，Flutter也使用<a href="https://www.dartlang.org/tools/pub/pubspec" target="_blank" rel="noopener"><code>pubspec.yaml</code></a>文件来管理应用程序所需的资源，举个例子:</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">flutter</span><span class="token punctuation">:</span>  <span class="token key atrule">assets</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> assets/my_icon.png    <span class="token punctuation">-</span> assets/background.png</code></pre><p>资源文件要先在yaml中配置。</p><h3 id="更新启动页"><a href="#更新启动页" class="headerlink" title="更新启动页"></a>更新启动页</h3><p>在Flutter框架加载时，Flutter会使用本地平台机制绘制启动页</p><h2 id="Dart单线程模型"><a href="#Dart单线程模型" class="headerlink" title="Dart单线程模型"></a>Dart单线程模型</h2><p>在Java和Objective-C（以下简称“OC”）中，如果程序发生异常且没有被捕获，那么程序将会终止.</p><p>Dart和JavaScript不会，它们都是单线程模型.</p><img src=".2020-09-01 _images/image-20200901150510059.png" alt="image-20200901150510059" style="zoom:50%;" /><p>Dart 在单线程中是以消息循环机制来运行的，其中包含两个任务队列，一个是“微任务队列” <strong>microtask queue</strong>，另一个叫做“事件队列” <strong>event queue</strong>。从图中可以发现，微任务队列的执行优先级高于事件队列。</p><p>必须得保证微任务队列不会太长</p><p>通过<code>Future.microtask(…)</code>方法向微任务队列插入一个任务</p><p>在事件循环中，当某个任务发生异常并没有被捕获时，程序并不会退出，而直接导致的结果是<strong>当前任务</strong>的后续代码就不会被执行了，也就是说一个任务中的异常是不会影响其它任务执行的。</p><h3 id="Flutter异常捕获"><a href="#Flutter异常捕获" class="headerlink" title="Flutter异常捕获"></a>Flutter异常捕获</h3><p>Dart中可以通过<code>try/catch/finally</code>来捕获代码块异常</p><p>Flutter 框架为我们在很多关键的方法进行了异常捕获。这里举一个例子，当我们布局发生越界或不合规范时，Flutter就会自动弹出一个错误界面，这是因为Flutter已经在执行build方法时添加了异常捕获</p><p>如果我们想自己上报异常，只需要提供一个自定义的错误处理回调即可，如：</p><pre class=" language-dart"><code class="language-dart"><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  FlutterError<span class="token punctuation">.</span>onError <span class="token operator">=</span> <span class="token punctuation">(</span>FlutterErrorDetails details<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">reportError</span><span class="token punctuation">(</span>details<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre><h3 id="其它异常捕获与日志收集"><a href="#其它异常捕获与日志收集" class="headerlink" title="其它异常捕获与日志收集"></a>其它异常捕获与日志收集</h3><p>在Flutter中，还有一些Flutter没有为我们捕获的异常，如调用空对象方法异常、Future中的异常。在Dart中，异常分两类：同步异常和异步异常，同步异常可以通过<code>try/catch</code>捕获，而异步异常则比较麻烦，如下面的代码是捕获不了<code>Future</code>的异常的：</p><pre class=" language-dart"><code class="language-dart"><span class="token keyword">try</span><span class="token punctuation">{</span>    Future<span class="token punctuation">.</span><span class="token function">delayed</span><span class="token punctuation">(</span><span class="token function">Duration</span><span class="token punctuation">(</span>seconds<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> Future<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"xxx"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">e</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">print</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我们最终的异常捕获和上报代码大致如下：</p><pre class=" language-dart"><code class="language-dart"><span class="token keyword">void</span> <span class="token function">collectLog</span><span class="token punctuation">(</span>String line<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment" spellcheck="true">//收集日志</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">reportErrorAndLog</span><span class="token punctuation">(</span>FlutterErrorDetails details<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment" spellcheck="true">//上报错误和日志逻辑</span><span class="token punctuation">}</span>FlutterErrorDetails <span class="token function">makeDetails</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">,</span> StackTrace stack<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment" spellcheck="true">// 构建错误信息</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  FlutterError<span class="token punctuation">.</span>onError <span class="token operator">=</span> <span class="token punctuation">(</span>FlutterErrorDetails details<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">reportErrorAndLog</span><span class="token punctuation">(</span>details<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token function">runZoned</span><span class="token punctuation">(</span>    <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">runApp</span><span class="token punctuation">(</span><span class="token function">MyApp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    zoneSpecification<span class="token punctuation">:</span> <span class="token function">ZoneSpecification</span><span class="token punctuation">(</span>      print<span class="token punctuation">:</span> <span class="token punctuation">(</span>Zone self<span class="token punctuation">,</span> ZoneDelegate parent<span class="token punctuation">,</span> Zone zone<span class="token punctuation">,</span> String line<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">collectLog</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 收集日志</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">)</span><span class="token punctuation">,</span>    onError<span class="token punctuation">:</span> <span class="token punctuation">(</span>Object obj<span class="token punctuation">,</span> StackTrace stack<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">var</span> details <span class="token operator">=</span> <span class="token function">makeDetails</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> stack<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">reportErrorAndLog</span><span class="token punctuation">(</span>details<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/Android/Dart/第一个app计算器</title>
      <link href="blog/3394577965.html"/>
      <url>blog/3394577965.html</url>
      
        <content type="html"><![CDATA[<h3 id="应用结构："><a href="#应用结构：" class="headerlink" title="应用结构："></a>应用结构：</h3><img src=".第一个app计算器_images/image-20200831161228115.png" alt="image-20200831161228115" style="zoom:50%;" /><ul><li><p>应用本身也是一个widget:</p><p>class MyApp extends StatelessWidget</p></li><li><p>在Flutter中，大多数东西都是widget（后同“组件”或“部件”），包括对齐(alignment)、填充(padding)和布局(layout)等，它们都是以widget的形式提供</p></li><li><p><strong>widget的主要工作是提供一个build()方法来描述如何构建UI界面</strong>（通常是通过组合、拼装其它基础widget）</p></li><li><p><code>MaterialApp</code> 是Material库中提供的Flutter APP框架，通过它可以设置应用的名称、主题、语言、首页及路由列表等。<code>MaterialApp</code>也是一个widget。</p></li><li><p><code>home</code> 为Flutter应用的首页，它也是一个widget。</p></li></ul><h2 id="首页"><a href="#首页" class="headerlink" title="首页"></a>首页</h2><pre class=" language-dart"><code class="language-dart">   <span class="token keyword">class</span> <span class="token class-name">MyHomePage</span> <span class="token keyword">extends</span> <span class="token class-name">StatefulWidget</span> <span class="token punctuation">{</span>     <span class="token function">MyHomePage</span><span class="token punctuation">(</span><span class="token punctuation">{</span>Key key<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>title<span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token keyword">super</span><span class="token punctuation">(</span>key<span class="token punctuation">:</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">final</span> String title<span class="token punctuation">;</span>     <span class="token metadata symbol">@override</span>     _MyHomePageState <span class="token function">createState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">new</span> <span class="token class-name">_MyHomePageState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token keyword">class</span> <span class="token class-name">_MyHomePageState</span> <span class="token keyword">extends</span> <span class="token class-name">State</span><span class="token operator">&lt;</span>MyHomePage<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>   <span class="token punctuation">}</span></code></pre><p><code>MyHomePage</code> 是Flutter应用的首页，它继承自<code>StatefulWidget</code>类，表示它是一个有状态的组件（Stateful widget）。关于Stateful widget，现在我们只需简单认为有状态的组件（Stateful widget） 和无状态的组件（Stateless widget）有两点不同：</p><ol><li><p>Stateful widget可以拥有状态（变量），这些状态在widget生命周期中是可以变的，而Stateless widget是不可变的。</p></li><li><p><strong>Stateful widget至少由两个类组成</strong>：</p><ul><li>一个<code>StatefulWidget</code>类。</li><li>一个 <code>State</code>类； <code>StatefulWidget</code>类本身是不变的，但是<code>State</code>类中持有的状态在widget生命周期中可能会发生变化。</li></ul><p><code>_MyHomePageState</code>类是<code>MyHomePage</code>类对应的状态类。和<code>MyApp</code> 类不同， <code>MyHomePage</code>类中并没有<code>build</code>方法，build<code>方法被挪到了</code>_MyHomePageState`方法中，至于为什么这么做，先留个疑问，在分析完完整代码后再来解答。</p></li></ol><h3 id="State类"><a href="#State类" class="headerlink" title="State类"></a>State类</h3><p>接下来，我们看看<code>_MyHomePageState</code>中都包含哪些东西：</p><ol><li><p>该组件的状态。由于我们只需要维护一个点击次数计数器，所以定义一个<code>_counter</code>状态：</p><pre class=" language-dart"><code class="language-dart">int _counter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//用于记录按钮点击的总次数</span></code></pre><p><code>_counter</code> 为保存屏幕右下角带“+”号按钮点击次数的状态。</p></li><li><p>设置状态的自增函数。</p><pre class=" language-dart"><code class="language-dart"><span class="token keyword">void</span> <span class="token function">_incrementCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     _counter<span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>当按钮点击时，会调用此函数，<strong>该函数的作用是先自增<code>_counter</code>，然后调用<code>setState</code> 方法</strong>。<strong><code>setState</code>方法的作用是通知Flutter框架，有状态发生了改变，Flutter框架收到通知后，会执行<code>build</code>方法来根据新的状态重新构建界面</strong>， Flutter 对此方法做了优化，使重新执行变的很快，所以你可以重新构建任何需要更新的东西，而无需分别去修改各个widget。</p></li><li><p>构建UI界面</p><p>构建UI界面的逻辑在<code>build</code>方法中，当<code>MyHomePage</code>第一次创建时，<code>_MyHomePageState</code>类会被创建，当初始化完成后，Flutter框架会调用Widget的<code>build</code>方法来构建widget树，最终将widget树渲染到设备屏幕上。所以，我们看看<code>_MyHomePageState</code>的<code>build</code>方法中都干了什么事：</p><pre class=" language-dart"><code class="language-dart">  Widget <span class="token function">build</span><span class="token punctuation">(</span>BuildContext context<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Scaffold</span><span class="token punctuation">(</span>      appBar<span class="token punctuation">:</span> <span class="token keyword">new</span> <span class="token class-name">AppBar</span><span class="token punctuation">(</span>        title<span class="token punctuation">:</span> <span class="token keyword">new</span> <span class="token class-name">Text</span><span class="token punctuation">(</span>widget<span class="token punctuation">.</span>title<span class="token punctuation">)</span><span class="token punctuation">,</span>      <span class="token punctuation">)</span><span class="token punctuation">,</span>      body<span class="token punctuation">:</span> <span class="token keyword">new</span> <span class="token class-name">Center</span><span class="token punctuation">(</span>        child<span class="token punctuation">:</span> <span class="token keyword">new</span> <span class="token class-name">Column</span><span class="token punctuation">(</span>          mainAxisAlignment<span class="token punctuation">:</span> MainAxisAlignment<span class="token punctuation">.</span>center<span class="token punctuation">,</span>          children<span class="token punctuation">:</span> <span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token punctuation">[</span>            <span class="token keyword">new</span> <span class="token class-name">Text</span><span class="token punctuation">(</span>              <span class="token string">'You have pushed the button this many times:'</span><span class="token punctuation">,</span>            <span class="token punctuation">)</span><span class="token punctuation">,</span>            <span class="token keyword">new</span> <span class="token class-name">Text</span><span class="token punctuation">(</span>              <span class="token string">'$_counter'</span><span class="token punctuation">,</span>              style<span class="token punctuation">:</span> Theme<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">.</span>textTheme<span class="token punctuation">.</span>headline4<span class="token punctuation">,</span>            <span class="token punctuation">)</span><span class="token punctuation">,</span>          <span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token punctuation">)</span><span class="token punctuation">,</span>      <span class="token punctuation">)</span><span class="token punctuation">,</span>      floatingActionButton<span class="token punctuation">:</span> <span class="token keyword">new</span> <span class="token class-name">FloatingActionButton</span><span class="token punctuation">(</span>        onPressed<span class="token punctuation">:</span> _incrementCounter<span class="token punctuation">,</span>        tooltip<span class="token punctuation">:</span> <span class="token string">'Increment'</span><span class="token punctuation">,</span>        child<span class="token punctuation">:</span> <span class="token keyword">new</span> <span class="token class-name">Icon</span><span class="token punctuation">(</span>Icons<span class="token punctuation">.</span>add<span class="token punctuation">)</span><span class="token punctuation">,</span>      <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span></code></pre><ul><li><code>Scaffold</code> 是 Material 库中提供的页面脚手架，它提供了默认的导航栏、标题和包含主屏幕widget树（后同“组件树”或“部件树”）的<code>body</code>属性，组件树可以很复杂。本书后面示例中，路由默认都是通过<code>Scaffold</code>创建。</li><li><code>body</code>的组件树中包含了一个<code>Center</code> 组件，<code>Center</code> 可以将其子组件树对齐到屏幕中心。此例中， <code>Center</code> 子组件是一个<code>Column</code> 组件，<code>Column</code>的作用是将其所有子组件沿屏幕垂直方向依次排列； 此例中<code>Column</code>子组件是两个 <code>Text</code>，第一个<code>Text</code> 显示固定文本 “You have pushed the button this many times:”，第二个<code>Text</code> 显示<code>_counter</code>状态的数值。</li><li><code>floatingActionButton</code>是页面右下角的带“+”的悬浮按钮，它的<code>onPressed</code>属性接受一个回调函数，代表它被点击后的处理器，本例中直接将<code>_incrementCounter</code>方法作为其处理函数。</li></ul></li></ol><p>现在，我们将整个计数器执行流程串起来：当右下角的<code>floatingActionButton</code>按钮被点击之后，会调用<code>_incrementCounter</code>方法。在<code>_incrementCounter</code>方法中，首先会自增<code>_counter</code>计数器（状态），然后<code>setState</code>会通知Flutter框架状态发生变化，接着，Flutter框架会调用<code>build</code>方法以新的状态重新构建UI，最终显示在设备屏幕上。</p><h4 id="为什么要将build方法放在State中，而不是放在StatefulWidget中？"><a href="#为什么要将build方法放在State中，而不是放在StatefulWidget中？" class="headerlink" title="为什么要将build方法放在State中，而不是放在StatefulWidget中？"></a>为什么要将build方法放在State中，而不是放在StatefulWidget中？</h4><p>现在，我们回答之前提出的问题，为什么<code>build()</code>方法放在State（而不是<code>StatefulWidget</code>）中 ？这主要是为了提高开发的灵活性。如果将<code>build()</code>方法放在<code>StatefulWidget</code>中则会有两个问题：</p><ul><li><p>状态访问不便</p><p>试想一下，如果我们的<code>StatefulWidget</code>有很多状态，而每次状态改变都要调用<code>build</code>方法，由于状态是保存在State中的，如果<code>build</code>方法在<code>StatefulWidget</code>中，那么<code>build</code>方法和状态分别在两个类中，那么构建时读取状态将会很不方便！试想一下，如果真的将<code>build</code>方法放在StatefulWidget中的话，由于构建用户界面过程需要依赖State，所以<code>build</code>方法将必须加一个<code>State</code>参数，大概是下面这样：</p><pre class=" language-dart"><code class="language-dart">  Widget <span class="token function">build</span><span class="token punctuation">(</span>BuildContext context<span class="token punctuation">,</span> State state<span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">//state.counter</span>      <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token punctuation">}</span></code></pre><p>这样的话就只能将State的所有状态声明为公开的状态，这样才能在State类外部访问状态！但是，将状态设置为公开后，状态将不再具有私密性，这就会导致对状态的修改将会变的不可控。但如果将<code>build()</code>方法放在State中的话，构建过程不仅可以直接访问状态，而且也无需公开私有状态，这会非常方便。</p></li><li><p>继承<code>StatefulWidget</code>不便</p><p>例如，Flutter中有一个动画widget的基类<code>AnimatedWidget</code>，它继承自<code>StatefulWidget</code>类。<code>AnimatedWidget</code>中引入了一个抽象方法<code>build(BuildContext context)</code>，继承自<code>AnimatedWidget</code>的动画widget都要实现这个<code>build</code>方法。现在设想一下，如果<code>StatefulWidget</code> 类中已经有了一个<code>build</code>方法，正如上面所述，此时<code>build</code>方法需要接收一个state对象，这就意味着<code>AnimatedWidget</code>必须将自己的State对象(记为_animatedWidgetState)提供给其子类，因为子类需要在其<code>build</code>方法中调用父类的<code>build</code>方法，代码可能如下：</p><pre class=" language-dart"><code class="language-dart"><span class="token keyword">class</span> <span class="token class-name">MyAnimationWidget</span> <span class="token keyword">extends</span> <span class="token class-name">AnimatedWidget</span><span class="token punctuation">{</span>    <span class="token metadata symbol">@override</span>    Widget <span class="token function">build</span><span class="token punctuation">(</span>BuildContext context<span class="token punctuation">,</span> State state<span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">//由于子类要用到AnimatedWidget的状态对象_animatedWidgetState，</span>      <span class="token comment" spellcheck="true">//所以AnimatedWidget必须通过某种方式将其状态对象_animatedWidgetState</span>      <span class="token comment" spellcheck="true">//暴露给其子类   </span>      <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> _animatedWidgetState<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这样很显然是不合理的，因为</p><ol><li><code>AnimatedWidget</code>的状态对象是<code>AnimatedWidget</code>内部实现细节，不应该暴露给外部。</li><li>如果要将父类状态暴露给子类，那么必须得有一种传递机制，而做这一套传递机制是无意义的，因为父子类之间状态的传递和子类本身逻辑是无关的。</li></ol></li></ul><p>综上所述，可以发现，对于<code>StatefulWidget</code>，将<code>build</code>方法放在State中，可以给开发带来很大的灵活性。</p><h2 id="2-路由管理"><a href="#2-路由管理" class="headerlink" title="2.路由管理"></a>2.路由管理</h2><p>路由对应android的activity,就是页面，路由管理就是页面跳转管理</p><p>FlatButton是什么？</p><p>下面是什么用法？</p><pre><code>   FlatButton(         child: Text(&quot;open new route&quot;),         textColor: Colors.blue,         onPressed: () {          //导航到新路由             Navigator.push( context,           MaterialPageRoute(builder: (context) {//              return NewRoute();           }));</code></pre><h3 id="MaterialPageRoute"><a href="#MaterialPageRoute" class="headerlink" title="MaterialPageRoute"></a>MaterialPageRoute</h3><p><code>MaterialPageRoute</code>继承自<code>PageRoute</code>类，<code>PageRoute</code>类是一个抽象类，表示占有整个屏幕空间的一个模态路由页面，它还定义了路由构建及切换时过渡动画的相关接口及属性。<code>MaterialPageRoute</code> 是Material组件库提供的组件，它可以针对不同平台，实现与平台页面切换动画风格一致的路由切换动画：</p><ul><li>对于Android，当打开新页面时，新的页面会从屏幕底部滑动到屏幕顶部；当关闭页面时，当前页面会从屏幕顶部滑动到屏幕底部后消失，同时上一个页面会显示到屏幕上。</li><li>对于iOS，当打开页面时，新的页面会从屏幕右侧边缘一致滑动到屏幕左边，直到新页面全部显示到屏幕上，而上一个页面则会从当前屏幕滑动到屏幕左侧而消失；当关闭页面时，正好相反，当前页面会从屏幕右侧滑出，同时上一个页面会从屏幕左侧滑入。</li></ul><h3 id="Navigator"><a href="#Navigator" class="headerlink" title="Navigator"></a>Navigator</h3><p><code>Navigator</code>是一个路由管理的组件，它提供了打开和退出路由页方法。<code>Navigator</code>通过一个栈来管理活动路由集合。通常当前屏幕显示的页面就是栈顶的路由。<code>Navigator</code>提供了一系列方法来管理路由栈，在此我们只介绍其最常用的两个方法：</p><h4 id="1-Future-push-BuildContext-context-Route-route"><a href="#1-Future-push-BuildContext-context-Route-route" class="headerlink" title="1.Future push(BuildContext context, Route route)"></a>1.Future push(BuildContext context, Route route)</h4><p>将给定的路由入栈（即打开新的页面），返回值是一个<code>Future</code>对象，用以接收新路由出栈（即关闭）时的返回数据。</p><h4 id="2-bool-pop-BuildContext-context-result"><a href="#2-bool-pop-BuildContext-context-result" class="headerlink" title="2.bool pop(BuildContext context, [ result ])"></a>2.bool pop(BuildContext context, [ result ])</h4><p>将栈顶路由出栈，<code>result</code>为页面关闭时返回给上一个页面的数据。</p><p><code>Navigator</code> 还有很多其它方法，如<code>Navigator.replace</code>、<code>Navigator.popUntil</code>等，详情请参考API文档或SDK源码注释，在此不再赘述。下面我们还需要介绍一下路由相关的另一个概念“命名路由”。</p><h4 id="3-实例方法"><a href="#3-实例方法" class="headerlink" title="3.实例方法"></a>3.实例方法</h4><p>Navigator类中第一个参数为context的<strong>静态方法</strong>都对应一个Navigator的<strong>实例方法</strong>， 比如<code>Navigator.push(BuildContext context, Route route)</code>等价于<code>Navigator.of(context).push(Route route)</code> ，下面命名路由相关的方法也是一样的。</p><h3 id="路由-界面-传值"><a href="#路由-界面-传值" class="headerlink" title="路由(界面)传值"></a>路由(界面)传值</h3><p>很多时候，在路由跳转时我们需要带一些参数，比如打开商品详情页时，我们需要带一个商品id，这样商品详情页才知道展示哪个商品信息；又比如我们在填写订单时需要选择收货地址，打开地址选择页并选择地址后，可以将用户选择的地址返回到订单页等等。下面我们通过一个简单的示例来演示新旧路由如何传参。</p><h3 id="命名路由"><a href="#命名路由" class="headerlink" title="命名路由"></a>命名路由</h3><h4 id="1-路由表"><a href="#1-路由表" class="headerlink" title="1.路由表"></a>1.路由表</h4><p>注册路由表就是给路由起名字，路由表的定义如下：</p><pre class=" language-dart"><code class="language-dart">Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> WidgetBuilder<span class="token operator">></span> routes<span class="token punctuation">;</span></code></pre><p>它是一个<code>Map</code>，key为路由的名字，是个字符串；value是个<code>builder</code>回调函数，用于生成相应的路由widget</p><p>我们在通过路由名字打开新路由时，应用会根据路由名字在路由表中查找到对应的<code>WidgetBuilder</code>回调函数，然后调用该回调函数生成路由widget并返回。</p><h4 id="2-注册路由表"><a href="#2-注册路由表" class="headerlink" title="2.注册路由表"></a>2.注册路由表</h4><p>在<code>MyApp</code>类的<code>build</code>方法中找到<code>MaterialApp</code>，添加<code>routes</code>属性</p><pre><code>//注册路由表  routes:{   &quot;new_page&quot;:(context) =&gt; NewRoute(),    ... // 省略其它路由注册信息  } ,</code></pre><h4 id="3-通过路由名打开新路由页"><a href="#3-通过路由名打开新路由页" class="headerlink" title="3.通过路由名打开新路由页"></a>3.通过路由名打开新路由页</h4><p>要通过路由名称来打开新路由，可以使用<code>Navigator</code> 的<code>pushNamed</code>方法：</p><pre class=" language-dart"><code class="language-dart">Future <span class="token function">pushNamed</span><span class="token punctuation">(</span>BuildContext context<span class="token punctuation">,</span> String routeName<span class="token punctuation">,</span><span class="token punctuation">{</span>Object arguments<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><h4 id="4-命名路由参数传递"><a href="#4-命名路由参数传递" class="headerlink" title="4.命名路由参数传递"></a>4.命名路由参数传递</h4><p>先在App注册路由，然后在路由页通过<code>RouteSetting</code>对象获取路由参数：</p><pre class=" language-dart"><code class="language-dart"><span class="token keyword">class</span> <span class="token class-name">EchoRoute</span> <span class="token keyword">extends</span> <span class="token class-name">StatelessWidget</span> <span class="token punctuation">{</span>  <span class="token metadata symbol">@override</span>  Widget <span class="token function">build</span><span class="token punctuation">(</span>BuildContext context<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//获取路由参数  </span>    <span class="token keyword">var</span> args<span class="token operator">=</span>ModalRoute<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">.</span>settings<span class="token punctuation">.</span>arguments<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//...省略无关代码</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>在打开路由时传递参数</p><pre class=" language-dart"><code class="language-dart">Navigator<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">pushNamed</span><span class="token punctuation">(</span><span class="token string">"new_page"</span><span class="token punctuation">,</span> arguments<span class="token punctuation">:</span> <span class="token string">"hi"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/Android/Dart/first</title>
      <link href="blog/4070539055.html"/>
      <url>blog/4070539055.html</url>
      
        <content type="html"><![CDATA[<p>尽管 Dart 是强类型的，但是 Dart 可以推断类型</p><p><strong>main()</strong></p><p>程序开始执行函数，该函数是特定的、<em>必须的</em>、顶级函数。</p><ul><li><p>Dart 支持泛型，如 <code>List</code> （整数列表）或 <code>List</code> （任何类型的对象列表）。</p></li><li><p>与 Java 不同，Dart 没有关键字 “public” ， “protected” 和 “private” 。 如果标识符以下划线（_）开头，则它相对于库是私有的</p></li><li><p><em>标识符</em> 以字母或下划线（_）开头，后跟任意字母和数字组合。</p></li></ul><h3 id="动态类型"><a href="#动态类型" class="headerlink" title="动态类型"></a>动态类型</h3><p>如果对象不限定为单个类型，可以指定为 <code>对象类型</code> 或 <code>动态类型</code>.</p><pre><code>dynamic name = &#39;Bob&#39;;</code></pre><h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><p>未初始化的变量默认值是 <code>null</code>。即使变量是数字 类型默认值也是 null，因为在 Dart 中一切都是对象，</p><h3 id="Final-和-Const"><a href="#Final-和-Const" class="headerlink" title="Final 和 Const"></a>Final 和 Const</h3><p>Const 变量在编译时就已经固定</p><p>Final 变量的值只能被设置一次</p><h2 id="内建类型"><a href="#内建类型" class="headerlink" title="内建类型"></a>内建类型</h2><p>Dart 语言支持以下内建类型：</p><ul><li>Number</li><li>String</li><li>Boolean</li><li>List (也被称为 <em>Array</em>)</li><li>Map</li><li>Set</li><li>Rune (用于在字符串中表示 Unicode 字符)</li><li>Symbol</li></ul><p>这些类型都可以被初始化为字面量。 例如, <code>&#39;this is a string&#39;</code> 是一个字符串的字面量， <code>true</code> 是一个布尔的字面量。</p><p>因为在 Dart 所有的变量终究是一个对象（一个类的实例）， 所以变量可以使用 <em>构造涵数</em> 进行初始化。 一些内建类型拥有自己的构造函数。 例如， 通过 <code>Map()</code> 来构造一个 map 变量。</p><h3 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h3><p>Dart 语言的 Number 有两种类型:</p><ul><li><p><a href="https://api.dartlang.org/stable/dart-core/int-class.html" target="_blank" rel="noopener">int</a></p><p>整数值不大于64位， 具体取决于平台。 在 Dart VM 上， 值的范围从 -263 到 263 - 1. Dart 被编译为 JavaScript 时，使用 <a href="https://stackoverflow.com/questions/2802957/number-of-bits-in-javascript-numbers/2803010#2803010" target="_blank" rel="noopener">JavaScript numbers,</a> 值的范围从 -253 到 253 - 1.</p></li><li><p><a href="https://api.dartlang.org/stable/dart-core/double-class.html" target="_blank" rel="noopener">double</a></p><p>64位（双精度）浮点数，依据 IEEE 754 标准。</p></li></ul><p>整数类型不包含小数点。</p><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>Dart 字符串是一组 UTF-16 单元序列。 字符串通过单引号或者双引号创建。</p><p><strong>提示：</strong> <code>==</code> 运算符用来测试两个对象是否相等。 在字符串中，如果两个字符串包含了相同的编码序列，那么这两个字符串相等。 units.</p><p>使用连续三个单引号或者三个双引号实现多行字符串对象的创建：</p><p>使用 <code>r</code> 前缀，可以创建 “原始 raw” 字符串：</p><h3 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h3><p>Dart 使用 <code>bool</code> 类型表示布尔值。 Dart 只有字面量 <code>true</code> and <code>false</code> 是布尔类型， 这两个对象都是编译时常量。</p><p>Dart 中的 List 字面量非常像 JavaScript 中的 array 字面量。 下面是一个 Dart List 的示例：</p><pre class=" language-dart"><code class="language-dart"><span class="token keyword">var</span> list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre><p><strong>提示：</strong> Dart 推断 <code>list</code> 的类型为 <code>List</code> 。 </p><p>在 List 字面量之前添加 const 关键字，可以定义 List 类型的编译时常量：</p><pre class=" language-dart"><code class="language-dart"><span class="token keyword">var</span> constantList <span class="token operator">=</span> <span class="token keyword">const</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// constantList[1] = 1; // 取消注释会引起错误。</span></code></pre><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数也是对象，并且有一个类型<strong>Function</strong>。这意味着函数可以赋值给变量或作为参数传递给其他函数，这是函数式编程的典型特征</p><p>1.函数声明</p><p>Dart函数声明如果没有显式声明返回值类型时会默认当做<code>dynamic</code>处理，注意，函数返回值没有类型推断：</p><p><strong>2.对于只包含一个表达式的函数，可以使用简写语法</strong></p><pre class=" language-dart"><code class="language-dart">bool <span class="token function">isNoble</span> <span class="token punctuation">(</span>int atomicNumber<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span> _nobleGases <span class="token punctuation">[</span> atomicNumber <span class="token punctuation">]</span> ！<span class="token operator">=</span> <span class="token keyword">null</span> <span class="token punctuation">;</span></code></pre><p>3.函数作为变量</p><pre class=" language-dart"><code class="language-dart"><span class="token keyword">var</span> say <span class="token operator">=</span> <span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token function">print</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token string">"hi world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>4.函数作为参数传递</p><pre class=" language-dart"><code class="language-dart"><span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">var</span> callback<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"xxx"</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>6.可选的命名参数</p><p>定义函数时，使用{param1, param2, …}，放在参数列表的最后面，用于指定命名参数。例如：</p><pre class=" language-dart"><code class="language-dart"><span class="token comment" spellcheck="true">//设置[bold]和[hidden]标志</span><span class="token keyword">void</span> <span class="token function">enableFlags</span><span class="token punctuation">(</span><span class="token punctuation">{</span>bool bold<span class="token punctuation">,</span> bool hidden<span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ... </span><span class="token punctuation">}</span></code></pre><p><font color="red">调用函数时，可以使用指定命名参数。例如：<code>paramName: value</code></font></p><pre class=" language-dart"><code class="language-dart"><span class="token function">enableFlags</span><span class="token punctuation">(</span>bold<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> hidden<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><font color="red" >可选命名参数在Flutter中使用非常多。</font></p><p><strong>注意，不能同时使用可选的位置参数和可选的命名参数</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/剑指offer leetcode/kmp</title>
      <link href="blog/2273095501.html"/>
      <url>blog/2273095501.html</url>
      
        <content type="html"><![CDATA[<p>进阶班第一次课</p><h5 id="什么是kmp算法-是由Kmp三个人发明的，75年的，扣边界，考coding。"><a href="#什么是kmp算法-是由Kmp三个人发明的，75年的，扣边界，考coding。" class="headerlink" title="什么是kmp算法?是由Kmp三个人发明的，75年的，扣边界，考coding。"></a>什么是kmp算法?是由Kmp三个人发明的，75年的，扣边界，考coding。</h5><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>有2个字符串str1长度n,str2长度m，如果str2是str1的子串，求str2在str1中首次出现的位置，否则返回-1.</p><blockquote><p>注： 子串，子数组一定连续，子序列不一定连续。</p></blockquote><h4 id="蛮力法"><a href="#蛮力法" class="headerlink" title="蛮力法"></a>蛮力法</h4><p>算法思想：遍历str1的每个字符，判断以它开始的字符串是否与第二个字符串匹配。</p><p>时间复杂度：O(mn)</p><p>缺点：从str1的哪个字符开始没有关系，也就是没有利用字符串间的位置关系，也没有利用前面的结果。</p><p>​        如果是从i位置开始，则下一次总是从i+1位置开始，kmp不是这样，kmp选一定一个位置j，从j开始，跳过了(i ,j)</p><h4 id="kmp"><a href="#kmp" class="headerlink" title="kmp"></a>kmp</h4><p>流程</p><ol><li>主串遍历指针i1从0(也可以认为从一个非具体的位置i开始)位置开始，子串遍历指针也从0位置开始，一路比较</li><li>2个相等同时右移一位，<strong>否则</strong>看next[i2] == -1 。<ul><li>如果等于表示i2处于子串第一个字符，此时主串i1位置的字符与子串第一个不等，主串遍历指针i1右移一位；</li><li>如果i2不是处于子串第一个字符，则更新<code>i2 = next[i2]</code>（这里本来应该主串有个索引j，主串从j开始，j的位置为不相等的那个字符的位置 - 最长匹配后缀的长度，子串从0开始，因为）</li></ul></li></ol><p><strong>Q1:为什么(i，j)位置上肯定配不出str2？</strong></p><p>假设存在k ∈ 0 ~ j，主串从k出发，子串从0出发，可以配出str2。那么k -到X之前的 应该和子串 相等长度的前缀相同，这可能吗？为什么不可能？</p><img src=".kmp_images/image-20200830225708485.png" alt="image-20200830225708485" style="zoom:50%;" /><ul><li>3和4是匹配的最长前缀和最长后缀</li><li>如果1 和 2 是相同的，因为 1和 5是相同的（主串i位置到x之前的 和 子串str2 0位置 到 Y之前的都相同），那么==&gt;2和5是相同的，而5比4长，说明找到了一个更长的匹配的最长前缀和最长后缀，这产生了矛盾。</li></ul><p>next[i] =** 0 ~ i-1位置上的串 的前缀 和后缀 匹配的 最大长度(不包括长第一个和最后1个字符)，next[0] = -1 ,next[1] = 0.</p><pre><code>a b c a b c0 1 2 3 4 5next[0] = -1next[1] = 0next[2] = 0next[3] = 0next[4] = 1next[5] = 2</code></pre><h4 id="next数组怎么求？"><a href="#next数组怎么求？" class="headerlink" title="next数组怎么求？"></a>next数组怎么求？</h4><p>next[i]</p><p>比较i-1位置上的字符与 前缀 + 1位置上的字符是否相等，</p><p>如果相等则next[i] = next[i-1] + 1;(为什么不能更大，采用反证法证明)</p><img src=".kmp_images/image-20200830231510119.png" alt="image-20200830231510119" style="zoom:50%;" /><p>如果不相等,如a b a b c a b a b t k</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/Android/Gradle/仓库地址</title>
      <link href="blog/2643005463.html"/>
      <url>blog/2643005463.html</url>
      
        <content type="html"><![CDATA[<pre><code>maven { url &#39;https://maven.aliyun.com/repository/central&#39;}maven { url &#39;https://maven.aliyun.com/repository/google&#39; }maven { url &#39;https://maven.aliyun.com/repository/jcenter&#39; }</code></pre><blockquote><p><a href="https://maven.aliyun.com/mvn/view" target="_blank" rel="noopener">https://maven.aliyun.com/mvn/view</a></p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/Android/Gradle/手动下载</title>
      <link href="blog/124240317.html"/>
      <url>blog/124240317.html</url>
      
        <content type="html"><![CDATA[<h4 id="1-获取url并下载"><a href="#1-获取url并下载" class="headerlink" title="1.获取url并下载"></a>1.获取url并下载</h4><p>在gradle-wrapper.properties中获取url</p><pre><code>#Thu Nov 29 10:32:13 CST 2018distributionBase=GRADLE_USER_HOMEdistributionPath=wrapper/distszipStoreBase=GRADLE_USER_HOMEzipStorePath=wrapper/distsdistributionUrl=https\://services.gradle.org/distributions/gradle-4.1-all.zip</code></pre><p>将<a href="https://services.gradle.org/distributions/gradle-4.1-all.zip复制到迅雷或其他工具下载，会很快。" target="_blank" rel="noopener">https://services.gradle.org/distributions/gradle-4.1-all.zip复制到迅雷或其他工具下载，会很快。</a></p><h4 id="2-放到gradle目录"><a href="#2-放到gradle目录" class="headerlink" title="2.放到gradle目录"></a>2.放到gradle目录</h4><p>mac下gralde目录在 ~/.gradle中</p><p>将下载的压缩包放到~/.gradle/wrapper/dists/gradle-4.1-all/<strong>生成的文件夹</strong>/ 下并解压</p><p>将gradle-4.1-all.zip.part文件删除；复制一份gradle-4.1-all.zip.lck文件，重命名为gradle-4.1-all.zip.ok；<br>点击Sync Project With Gradle Files。</p><p><img src=".%E6%89%8B%E5%8A%A8%E4%B8%8B%E8%BD%BD_images/image-20200828112607671.png" alt="image-20200828112607671"></p><blockquote><p>“”生成的文件夹””是studio中gradle自动下载时生成的.</p></blockquote><p>android gradle插件 和 gradle版本对应关系参见</p><blockquote><p><a href="https://developer.android.google.cn/studio/releases/gradle-plugin#updating-plugin" target="_blank" rel="noopener">https://developer.android.google.cn/studio/releases/gradle-plugin#updating-plugin</a></p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/Android/摄像头/camera/Untitled</title>
      <link href="blog/616584614.html"/>
      <url>blog/616584614.html</url>
      
        <content type="html"><![CDATA[<h3 id="访问相机"><a href="#访问相机" class="headerlink" title="访问相机"></a>访问相机</h3><p>获取 <code>Camera</code> 对象的实例是直接控制相机流程的第一步. 打开建议在子线程中操作.</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">safeCameraOpen</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">boolean</span> qOpened <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token function">releaseCameraAndPreview</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            camera <span class="token operator">=</span> Camera<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>            qOpened <span class="token operator">=</span> <span class="token punctuation">(</span>camera <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            Log<span class="token punctuation">.</span><span class="token function">e</span><span class="token punctuation">(</span><span class="token function">getString</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>string<span class="token punctuation">.</span>app_name<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"failed to open Camera"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> qOpened<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">releaseCameraAndPreview</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        preview<span class="token punctuation">.</span><span class="token function">setCamera</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>camera <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            camera<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            camera <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><h3 id="检查相机功能"><a href="#检查相机功能" class="headerlink" title="检查相机功能"></a>检查相机功能</h3><p>使用 <code>Camera.getParameters()</code> 方法获取有关相机功能的详细信息</p><p>使用 <code>Camera.getCameraInfo()</code> 确定设备的摄像头是前置还是后置，以及图像的屏幕方向</p><h3 id="创建预览类"><a href="#创建预览类" class="headerlink" title="创建预览类"></a>创建预览类</h3><p>相机预览类是一个 <code>SurfaceView</code>，可以显示来自相机的实时图像数据.</p><p>以下示例代码演示如何创建可包含在 <code>View</code> 布局中的基础相机预览类。此类实现 <code>SurfaceHolder.Callback</code>，以便捕获用于创建和销毁视图的回调事件，这些是分配相机预览输入的必需事件。</p><pre><code>/** A basic Camera preview class */public class CameraPreview extends SurfaceView implements SurfaceHolder.Callback {    private SurfaceHolder mHolder;    private Camera mCamera;    public CameraPreview(Context context, Camera camera) {        super(context);        mCamera = camera;        // Install a SurfaceHolder.Callback so we get notified when the        // underlying surface is created and destroyed.        mHolder = getHolder();        mHolder.addCallback(this);        // deprecated setting, but required on Android versions prior to 3.0        mHolder.setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS);    }    public void surfaceCreated(SurfaceHolder holder) {        // The Surface has been created, now tell the camera where to draw the preview.        try {            mCamera.setPreviewDisplay(holder);            mCamera.startPreview();        } catch (IOException e) {            Log.d(TAG, &quot;Error setting camera preview: &quot; + e.getMessage());        }    }    public void surfaceDestroyed(SurfaceHolder holder) {        // empty. Take care of releasing the Camera preview in your activity.    }    public void surfaceChanged(SurfaceHolder holder, int format, int w, int h) {        // If your preview can change or rotate, take care of those events here.        // Make sure to stop the preview before resizing or reformatting it.        if (mHolder.getSurface() == null){          // preview surface does not exist          return;        }        // stop preview before making changes        try {            mCamera.stopPreview();        } catch (Exception e){          // ignore: tried to stop a non-existent preview        }        // set preview size and make any resize, rotate or        // reformatting changes here        // start preview with new settings        try {            mCamera.setPreviewDisplay(mHolder);            mCamera.startPreview();        } catch (Exception e){            Log.d(TAG, &quot;Error starting camera preview: &quot; + e.getMessage());        }    }}</code></pre><h3 id="在布局中放置预览"><a href="#在布局中放置预览" class="headerlink" title="在布局中放置预览"></a>在布局中放置预览</h3><p>surfaceview可以添加到framelayout中</p><blockquote><p>可使用 <code>setDisplayOrientation()</code> 方法设置预览图像的旋转。为了在用户重定向手机时改变预览屏幕方向，请在您预览类的 <code>surfaceChanged()</code> 方法中，首先使用 <code>Camera.stopPreview()</code> 停止预览并更改屏幕方向，然后使用 <code>Camera.startPreview()</code> 重新启动预览。</p></blockquote><blockquote><p>用完相机后，请记得通过调用 <code>Camera.release()</code> 来释放 <code>Camera</code> 对象</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/网络/retrofit/retrofit源码分析</title>
      <link href="blog/1938605699.html"/>
      <url>blog/1938605699.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/操作系统/信号量</title>
      <link href="blog/2338238242.html"/>
      <url>blog/2338238242.html</url>
      
        <content type="html"><![CDATA[<p>信号量集，就是由多个信号量组成的一个数组。作为一个整体，信号量集中的所有信号量使用同一个等待队列。Linux的信号量集为进程请求多个资源创造了条件。<strong>Linux规定，当进程的一个操作需要多个共享资源时，如果只成功获得了其中的部分资源，那么这个请求即告失败，进程必须立即释放所有已获得资源，以防止形成死锁。</strong></p><p>描述信号量的内核数据结构如下：</p><pre><code>struct sem {    int    semval;        /* 信号量的当前值 */    int    sempid;        /* 上一次操作本信号的进程PID */};</code></pre><blockquote><p><a href="https://blog.csdn.net/qq_38410730/article/details/81674118" target="_blank" rel="noopener">https://blog.csdn.net/qq_38410730/article/details/81674118</a></p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/Android/jetpack/viewbinding</title>
      <link href="blog/4181776835.html"/>
      <url>blog/4181776835.html</url>
      
        <content type="html"><![CDATA[<h4 id="1-作用：代替findViewbyid"><a href="#1-作用：代替findViewbyid" class="headerlink" title="1.作用：代替findViewbyid"></a>1.作用：代替findViewbyid</h4><h4 id="2-什么是-View-Binding"><a href="#2-什么是-View-Binding" class="headerlink" title="2.什么是 View Binding ?"></a>2.什么是 View Binding ?</h4><p>View Binding 是一项使你能更轻松地编写与视图交互的代码的功能. 在模块中启用 View Binding 后, 它会为该模块中存在的每一个 XML 文件生成一个对应的绑定类(binding class). 绑定类的实例包含了对应布局中所有具有 ID 的 view 的直接引用.</p><p>大多数情况下, View Binding 可以替换 findViewById.</p><h4 id="3-为什么不是-Data-Binding"><a href="#3-为什么不是-Data-Binding" class="headerlink" title="3.为什么不是 Data Binding ?"></a>3.为什么不是 Data Binding ?</h4><ul><li>只有布局文件的根标签是 `` 时, Data Binding 才会生成对应的 binding class, View Binding 没有这样的要求;</li><li>Data Binding 会影响构建的速度. Data Binding 底层其实是通过 annotation processor 实现的, 对构建速度是有负面影响的. 而 View Binding 并不是通过 annotation processor 实现的, 因此解决了 Data Binding 的性能问题.</li></ul><h4 id="4-如何使用-View-Binding"><a href="#4-如何使用-View-Binding" class="headerlink" title="4.如何使用 View Binding ?"></a>4.如何使用 View Binding ?</h4><h5 id="使用要求"><a href="#使用要求" class="headerlink" title="使用要求"></a>使用要求</h5><p>你至少需要使用 <strong>Android Studio 3.6 Canary 11 及以上版本</strong> 才可以开启 View Binding.</p><h5 id="设置指南"><a href="#设置指南" class="headerlink" title="设置指南"></a>设置指南</h5><p>View Binding 可以逐模块(module)开启. 比如我们的项目由 2 个模块(A 和 B)组成, 我们可以选择只在模块 A 启用 View Binding 而不会对模块 B 产生影响. 在模块中启用 View Binding, 首先需要在该模块的 <code>build.gradle</code> 文件中添加以下代码:</p><pre class=" language-text"><code class="language-text">android {    ...    viewBinding {        enabled = true    }}</code></pre><p>如果想要在生成 binding class 时忽略某个布局文件, 我们需要在该布局文件的根元素添加 <code>tools:viewBindingIgnore=&quot;true&quot;</code> 属性.</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>LinearLayout</span>        <span class="token attr-name">...</span>        <span class="token attr-name"><span class="token namespace">tools:</span>viewBindingIgnore</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token punctuation">></span></span>    ...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>LinearLayout</span><span class="token punctuation">></span></span></code></pre><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>和 Data Binding 一样, View Binding 会将 XML 文件的下划线风格的名称转换生成一个驼峰风格并以 <code>Binding</code> 结尾的 binding class.</p><p>例如我们有个 <code>result_profile.xml</code> 布局文件:</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>LinearLayout</span> <span class="token attr-name">...</span> <span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>TextView</span> <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@+id/name<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ImageView</span> <span class="token attr-name"><span class="token namespace">android:</span>cropToPadding</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Button</span> <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@+id/button<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>background</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@drawable/rounded_button<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>LinearLayout</span><span class="token punctuation">></span></span></code></pre><p>生成的 binding class 的名称就是 <code>ResultProfileBinding</code>. 这个类有两个字段: 一个叫 <code>name</code> 的 <code>TextView</code> 和一个叫 <code>button</code> 的 <code>Button</code>, 布局文件中的 <code>ImageView</code> 因为没有 ID, 所以 binding class 中没有对其的引用.</p><p>每一个 binding class 都包含了一个 <code>getRoot()</code> 的方法, 提供了一个相应布局文件的根 view 的直接引用. 在上面的例子中, <code>ResultProfileBinding</code> 类中的 <code>getRoot()</code> 方法返回了根 view <code>LinearLayout</code>.</p><p>我们可以调用 <code>inflate()</code> 静态方法来获取生成的 binding class 的实例. 通常来说, 你需要调用 <code>setContentView()</code> 方法, 将生成类的根 view 作为参数传递, 作为屏幕上的内容. 在上面的例子中, 我们可以在 activity 中调用 <code>ResultProfileBinding.inflate()</code>.</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">private</span> <span class="token keyword">lateinit</span> <span class="token keyword">var</span> binding<span class="token operator">:</span> ResultProfileBinding<span class="token annotation builtin">@Override</span><span class="token keyword">fun</span> <span class="token function">onCreate</span><span class="token punctuation">(</span>savedInstanceState<span class="token operator">:</span> Bundle<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onCreate</span><span class="token punctuation">(</span>savedInstanceState<span class="token punctuation">)</span>    binding <span class="token operator">=</span> ResultProfileBinding<span class="token punctuation">.</span><span class="token function">inflate</span><span class="token punctuation">(</span>layoutInflater<span class="token punctuation">)</span>    <span class="token function">setContentView</span><span class="token punctuation">(</span>binding<span class="token punctuation">.</span>root<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>然后就可以通过 binding class 引用任何 view:</p><pre class=" language-kotlin"><code class="language-kotlin">binding<span class="token punctuation">.</span>name<span class="token punctuation">.</span>text <span class="token operator">=</span> viewModel<span class="token punctuation">.</span>namebinding<span class="token punctuation">.</span>button<span class="token punctuation">.</span><span class="token function">setOnClickListener</span> <span class="token punctuation">{</span> viewModel<span class="token punctuation">.</span><span class="token function">userClicked</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/Android/UI/ViewPager用法</title>
      <link href="blog/1190793014.html"/>
      <url>blog/1190793014.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、使用FragmentPagerAdapter"><a href="#一、使用FragmentPagerAdapter" class="headerlink" title="一、使用FragmentPagerAdapter"></a>一、使用FragmentPagerAdapter</h3><h4 id="1-配合FragmentPagerAdapter-TabLayout"><a href="#1-配合FragmentPagerAdapter-TabLayout" class="headerlink" title="1.配合FragmentPagerAdapter + TabLayout"></a>1.配合FragmentPagerAdapter + TabLayout</h4><p>1.1.activity布局文件中使用viewpager标签和TabLayout标签</p><p>1.2.创建适配器:自定义类继承FragmentPagerAdapter</p><p>1.3.viewpager设置适配器</p><p>1.4.tablayout.setupWithViewPager(viewPager);</p><pre><code>public class MyPagerAdapter extends FragmentPagerAdapter {    //重写getItem()和getCount()方法，并添加构造器    public MyPagerAdapter(@NonNull FragmentManager fm, int behavior) {        super(fm, behavior);    }    @NonNull    @Override    public Fragment getItem(int position) {        return null;    }    @Override    public int getCount() {        return 0;    }}</code></pre><blockquote><p>getItem中获得Fragment对象，新建的可以存入hashmap中</p></blockquote><p>效果</p><img src=".ViewPager用法_images/image-20200825111421109.png" alt="image-20200825111421109" style="zoom:50%;" /><h4 id="2-配合FragmentPagerAdapter-第三方指示器库-himalaya"><a href="#2-配合FragmentPagerAdapter-第三方指示器库-himalaya" class="headerlink" title="2.配合FragmentPagerAdapter + 第三方指示器库(himalaya)"></a>2.配合FragmentPagerAdapter + 第三方指示器库(himalaya)</h4><p>fragment存入hashmap</p><h4 id="3-NoScrollViewPager-FragmentPagerAdapter-左侧expandlistview-评估师"><a href="#3-NoScrollViewPager-FragmentPagerAdapter-左侧expandlistview-评估师" class="headerlink" title="3.NoScrollViewPager+FragmentPagerAdapter + 左侧expandlistview(评估师)"></a>3.NoScrollViewPager+FragmentPagerAdapter + 左侧expandlistview(评估师)</h4><pre><code>//切换viewpager.setCurrentItem(index, false);</code></pre><h3 id="二-使用FragmentStatePagerAdapter"><a href="#二-使用FragmentStatePagerAdapter" class="headerlink" title="二.使用FragmentStatePagerAdapter"></a>二.使用FragmentStatePagerAdapter</h3><p>和上面一样的，只是FragmentStatePagerAdapter适合比较多的Fragment</p><h3 id="三、自定类继承PagerAdapter"><a href="#三、自定类继承PagerAdapter" class="headerlink" title="三、自定类继承PagerAdapter"></a>三、自定类继承PagerAdapter</h3><p>重写4个方法</p><pre><code>默认重写getCount()isViewFromObject()如果需要滑动效果还需要下面3个instantiateItem（）是用于往viewpage中添加控件，添加内容destroyItem（）是加入页面的时候，默认缓存三个，如不做处理，滑多了程序就会蹦getPageTitle是展示和viewpager上面tltle的展示文字的效果</code></pre><pre><code>public class AdapterViewpager extends PagerAdapter {    private List&lt;View&gt; mViewList;    public AdapterViewpager(List&lt;View&gt; mViewList) {        this.mViewList = mViewList;    }    @Override    public int getCount() {//必须实现        return mViewList.size();    }    //判断是否是否为同一张图片，这里返回方法中的两个参数做比较就可以    @Override    public boolean isViewFromObject(View view, Object object) {//必须实现        return view == object;    }    //设置viewpage内部东西的方法，如果viewpage内没有子空间滑动产生不了动画效    @Override    public Object instantiateItem(ViewGroup container, int position) {//必须实现，实例化        container.addView(mViewList.get(position));        return mViewList.get(position);    }    @Override    public void destroyItem(ViewGroup container, int position, Object object) {        container.removeView(mViewList.get(position));    }}</code></pre><blockquote><p><a href="https://www.kaelli.com/30.html" target="_blank" rel="noopener">https://www.kaelli.com/30.html</a></p></blockquote><h2 id="Fragment-bottombar"><a href="#Fragment-bottombar" class="headerlink" title="Fragment + bottombar"></a>Fragment + bottombar</h2><p>点击底部item ，show当前item,hide其他item . (没有add则先add)</p><pre><code> mBottomBar.setOnTabSelectedListener(new BottomBar.OnTabSelectedListener() {            @Override            public void onTabSelected(int position, int prePosition) {                if (position &gt;= fragments.length || prePosition &gt;= fragments.length) {                    return;                }                // 获取要显示的 fg 并且显示它                BaseViewFragment fragment = getFragment(position);                FragmentTransaction trx = getSupportFragmentManager().beginTransaction();                if (fragment != null &amp;&amp; !fragment.isAdded()) {                    trx.add(R.id.fl_container, fragment);                }                trx.show(fragment);                // 获取要隐藏的 fg 隐藏它                BaseViewFragment fragmentHide = getFragment(prePosition);                if (fragmentHide != null &amp;&amp; fragmentHide.isAdded()) {                    trx.hide(fragmentHide);                }                trx.commitAllowingStateLoss();            }</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/Java虚拟机/宋/方法区</title>
      <link href="blog/3562876400.html"/>
      <url>blog/3562876400.html</url>
      
        <content type="html"><![CDATA[<p><img src=".%E6%96%B9%E6%B3%95%E5%8C%BA_images/image-20200823233544406.png" alt="image-20200823233544406"></p><img src=".方法区_images/image-20200823233626955.png" alt="image-20200823233626955" style="zoom:50%;" /><p><img src=".%E6%96%B9%E6%B3%95%E5%8C%BA_images/image-20200823233832540.png" alt="image-20200823233832540"></p><ul><li>方法区是多个线程共享的</li><li>方法区类似于操作系统进程的代码段”text segment”</li><li>方法区类似于存储 编译过后的代码</li><li>它存储每个类的结构，比如运行时常量池，方法和构造器的字节码，包括一些特殊的用于类和实例初始化还有接口初始化的特殊方法</li></ul><p><img src=".%E6%96%B9%E6%B3%95%E5%8C%BA_images/image-20200823234850332.png" alt="image-20200823234850332"></p><ul><li>工具jvisualvm</li></ul><p><img src=".%E6%96%B9%E6%B3%95%E5%8C%BA_images/image-20200823235228461.png" alt="image-20200823235228461"></p><p><img src=".%E6%96%B9%E6%B3%95%E5%8C%BA_images/image-20200823235655414.png" alt="image-20200823235655414"></p><p><img src=".%E6%96%B9%E6%B3%95%E5%8C%BA_images/image-20200823235857336.png" alt="image-20200823235857336"></p><p><img src=".%E6%96%B9%E6%B3%95%E5%8C%BA_images/image-20200823235934552.png" alt="image-20200823235934552"></p><p><img src=".%E6%96%B9%E6%B3%95%E5%8C%BA_images/image-20200824000451979.png" alt="image-20200824000451979"></p><p>static final 修饰的 基本类型和字符串变量  编译时 就确定了他的值</p><h2 id="方法区中非常重要的结构：运行时常量池"><a href="#方法区中非常重要的结构：运行时常量池" class="headerlink" title="方法区中非常重要的结构：运行时常量池"></a>方法区中非常重要的结构：运行时常量池</h2><p><img src=".%E6%96%B9%E6%B3%95%E5%8C%BA_images/image-20200824002946460.png" alt="image-20200824002946460"></p><p><img src=".%E6%96%B9%E6%B3%95%E5%8C%BA_images/image-20200824003356356.png" alt="image-20200824003356356"></p><p>符号引用中的符号是画上的美女，java源码中写的类名，字符串，作用是让文件非常小</p><p>utf0_info 就是字面量，Integer_info 也是字面量,里面还有方法引用，属性引用，</p><p><img src=".%E6%96%B9%E6%B3%95%E5%8C%BA_images/image-20200824004920810.png" alt="image-20200824004920810"></p><p><img src=".%E6%96%B9%E6%B3%95%E5%8C%BA_images/image-20200824004948099.png" alt="image-20200824004948099"></p><p><img src=".%E6%96%B9%E6%B3%95%E5%8C%BA_images/image-20200824005053653.png" alt="image-20200824005053653"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/Java虚拟机/宋/运行时数据区</title>
      <link href="blog/3310938823.html"/>
      <url>blog/3310938823.html</url>
      
        <content type="html"><![CDATA[<p><img src=".运行时数据区_images/image-20200823143449593.png" alt="image-20200823143449593" style="zoom:50%;" /><a href="https://docs.oracle.com/javase/specs/jvms/se8/jvms8.pdf" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jvms/se8/jvms8.pdf</a></p><p><img src=".%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA_images/image-20200823191110480.png" alt="image-20200823191110480"></p><img src=".运行时数据区_images/image-20200823193502247.png" alt="image-20200823193502247" style="zoom:50%;" /><img src=".运行时数据区_images/image-20200823193704028.png" alt="image-20200823193704028" style="zoom:50%;" /><ul><li>start PC + Length 表示它的作用域</li></ul><p><img src=".%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA_images/image-20200823194402871.png" alt="image-20200823194402871"></p><p><img src=".%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA_images/image-20200823194508084.png" alt="image-20200823194508084"></p><ul><li>栈是管运行的，堆是馆数据存储的</li></ul><img src=".运行时数据区_images/image-20200823195111314.png" alt="image-20200823195111314" style="zoom:50%;" /><p>执行引擎会将字节码指令翻译成机器指令去执行</p><p><img src=".%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA_images/image-20200823195344228.png" alt="image-20200823195344228"></p><ul><li>操作数栈用数组实现</li></ul><p>stack=2 表示操作数栈的深度</p><p>locals=3表示局部变量表中元素个数，他俩都是数组实现。</p><p>istore_1   从操作数栈中取出放到局部变量表slot为1的位置，是出栈的操作，操作数栈中原来的数没有了。</p><p>iload_1    局部变量表还有。</p><p><img src=".%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA_images/image-20200823201132772.png" alt="image-20200823201132772"></p><img src=".运行时数据区_images/image-20200823201309200.png" alt="image-20200823201309200" style="zoom:50%;" /><ul><li>第3类问题  代码不怎么写</li></ul><img src=".运行时数据区_images/image-20200823201335971.png" alt="image-20200823201335971" style="zoom:50%;" /><ul><li>第4个 有点恶心</li></ul><p>答：老师讲 第一类问题 字节码是一样的。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/java/1</title>
      <link href="blog/2436391255.html"/>
      <url>blog/2436391255.html</url>
      
        <content type="html"><![CDATA[<img src=".1_images/image-20200823114308625.png" alt="image-20200823114308625" style="zoom:50%;" /><p>jvm参数</p><img src=".1_images/image-20200823120140027.png" alt="image-20200823120140027" style="zoom:50%;" /><ul><li>一个方法对应一个栈帧</li><li>一个线程一个虚拟机栈也叫线程栈，一个栈有很多个栈帧。线程栈的大小一般为1Mb</li></ul><p>虚拟机栈：</p><p>一个栈帧：局部变量表，操作数栈，动态链接，返回地址</p><p><img src=".1_images/image-20200823121739409.png" alt="image-20200823121739409"></p><p>方法区的实现：</p><p>&lt;=1.7叫 永久代</p><p>&gt;=1.8叫元空间</p><p><img src=".1_images/image-20200823125342725.png" alt="image-20200823125342725"></p><p>HSDB工具：查看</p><p>2：30：00</p><p><img src=".1_images/image-20200823133850958.png" alt="image-20200823133850958"></p><p>oos:什么时候抛出</p><p>类的</p><p>static 变量： 方法区</p><p>static 常量</p><p>虚拟机优化技术：</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/操作系统/线程和进程</title>
      <link href="blog/1951421711.html"/>
      <url>blog/1951421711.html</url>
      
        <content type="html"><![CDATA[<p>进程：资源分配的单位.</p><img src=".线程和进程_images/image-20200823093811362.png" alt="image-20200823093811362" style="zoom:50%;" /><pre><code>task_struct*mm： 内存资源，内存的描述*fs：文件系统资源，比如*pwd当前目录，root*files：进行打开的文件，打开的fd数组(这些文件对应的fd)*signal：</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/网络/http</title>
      <link href="blog/4099552919.html"/>
      <url>blog/4099552919.html</url>
      
        <content type="html"><![CDATA[<p>no-cache这个名字有一点误导。设置了no-cache之后，并不是说浏览器就不再缓存数据，只是浏览器在使用缓存数据时，需要先确认一下数据是否还跟服务器保持一致。如果设置了no-cache，而ETag的实现没有反应出资源的变化，那就会导致浏览器的缓存数据一直得不到更新的情况。</p><p>304: 请求头max-age&lt;=0 时 ,向server 发送http 请求确认 ,该资源是否有修改，有的话 返回200 ,无的话 返回304. 有没有修改 比较请求头 If-Modified-Since: Tue, 14 Jul 2020 08:11:27 GMT 和响应头 last-modified: Tue, 14 Jul 2020 08:11:27 GMT 的时间。</p><p>POST: 参数放在url和body中有什么区别？</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/教训/Untitled</title>
      <link href="blog/2871206814.html"/>
      <url>blog/2871206814.html</url>
      
        <content type="html"><![CDATA[<ol><li>项目下载量</li><li>项目内容</li><li>内部使用还是外部使用，用户规模</li><li>主要用到的哪些技术，</li><li>用第三方框架吗</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/Android/rxjava/rxjava操作符</title>
      <link href="blog/2937742373.html"/>
      <url>blog/2937742373.html</url>
      
        <content type="html"><![CDATA[<p>just:可以接收1-10个参数，几个参数就发送几个。</p><pre><code>Observable.fromArray(list,list)  : 几个参数发送几个Observable.fromIterable(iterable) : 参数iterable关联的集合有多少个元素就发送几个</code></pre><p>map 只能1对1</p><p>flatmap : 能多对多，也能1对1.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/Android/Gradle/变体</title>
      <link href="blog/460469251.html"/>
      <url>blog/460469251.html</url>
      
        <content type="html"><![CDATA[<p>buildTypes:默认有release 和debug2种， 项目中自定了一种叫fakerelease,继承自debug类型，方便后端调试。</p><p>productFlavors ： 针对功能的 。比如免费版，付费版</p><p>上面产生4种变体buildVariants</p><p><strong>对于每一种变体，都会有一个 BuildConfig 与之一一对应。</strong><br>我们来看看构建变体 free.debug 的BuildConfig：</p><pre><code>public final class BuildConfig {  public static final boolean DEBUG = Boolean.parseBoolean(&quot;true&quot;);  public static final String APPLICATION_ID = &quot;com.ygs.test.free.debug&quot;;  public static final String BUILD_TYPE = &quot;debug&quot;;  public static final String FLAVOR = &quot;free&quot;;  public static final int VERSION_CODE = 1;  public static final String VERSION_NAME = &quot;1.0-free&quot;;  // Fields from product flavor: free  public static final String NAME = &quot;免费版&quot;;}</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/面经/字节跳动/我</title>
      <link href="blog/1683780741.html"/>
      <url>blog/1683780741.html</url>
      
        <content type="html"><![CDATA[<p>1mian</p><p>https</p><p>equals  和hashmap ==</p><p>2mian</p><p>手写equals</p><p>访问一个网址的全过程</p><p>实现下拉刷新</p><p>合并1个升序链表 1个降序链表</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/Android/Gradle/gradle代码块指南</title>
      <link href="blog/3434344148.html"/>
      <url>blog/3434344148.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/网络/retrofit/retrofit用法</title>
      <link href="blog/3556713803.html"/>
      <url>blog/3556713803.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/Android/rxjava/rxjava初学</title>
      <link href="blog/159426248.html"/>
      <url>blog/159426248.html</url>
      
        <content type="html"><![CDATA[<p>二、</p><ul><li><p>上下游默认是在同一个线程工作</p></li><li><p>我们需要先改变上游发送事件的线程, 让它去子线程中发送事件, 然后再改变下游的线程, 让它去主线程接收事件. 通过RxJava内置的线程调度器可以很轻松的做到这一点</p><pre><code>observable.subscribeOn(Schedulers.newThread())                                                          .observeOn(AndroidSchedulers.mainThread())                                                      .subscribe(consumer);   </code></pre></li></ul><p><code>subscribeOn()</code> 指定的是上游发送事件的线程, <code>observeOn()</code> 指定的是下游接收事件的线程.</p><p>多次指定上游的线程只有第一次指定的有效, 也就是说多次调用<code>subscribeOn()</code> 只有第一次的有效, 其余的会被忽略.</p><p>多次指定下游的线程是可以的, 也就是说每调用一次<code>observeOn()</code> , 下游的线程就会切换一次.</p><p>Rxjava内置线程调度器</p><ul><li>Schedulers.io() 代表io操作的线程, 通常用于网络,读写文件等io密集型的操作</li><li>Schedulers.computation() 代表CPU计算密集型的操作, 例如需要大量计算的操作</li><li>Schedulers.newThread() 代表一个常规的新线程</li><li>AndroidSchedulers.mainThread()  代表Android的主线程</li></ul><p>如果在请求的过程中Activity已经退出了, 这个时候如果回到主线程去更新UI, 那么APP肯定就崩溃了, 怎么办呢?</p><p>可以在Activity中将这个<code>Disposable</code> 保存起来, 当Activity退出时, 切断它即可</p><p>如果有多个<code>Disposable</code> 该怎么办呢?</p><p>RxJava中已经内置了一个容器<code>CompositeDisposable</code>, 每当我们得到一个<code>Disposable</code>时就调用<code>CompositeDisposable.add()</code>将它添加到容器中, 在退出的时候, 调用<code>CompositeDisposable.clear()</code> 即可切断所有的水管.</p><p>例子：</p><p>1.rxjava 和retrofit实现网络请求</p><p>2.rxjava 操作数据库ccccc</p><p>3.先注册 后登陆 （连环请求 或者嵌套请求  怎么写）？</p><p>①分别写在2个人法中（不够优雅）</p><p>②（优雅）flatMap</p><p>登录和注册返回的都是一个上游Observable, 而我们的flatMap操作符的作用就是把一个Observable转换为另一个Observable, 因此</p><pre class=" language-java"><code class="language-java">            api<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">RegisterRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">//发起注册请求</span>                <span class="token punctuation">.</span><span class="token function">subscribeOn</span><span class="token punctuation">(</span>Schedulers<span class="token punctuation">.</span><span class="token function">io</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>               <span class="token comment" spellcheck="true">//在IO线程进行网络请求</span>                <span class="token punctuation">.</span><span class="token function">observeOn</span><span class="token punctuation">(</span>AndroidSchedulers<span class="token punctuation">.</span><span class="token function">mainThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//回到主线程去处理请求注册结果</span>                <span class="token punctuation">.</span><span class="token function">doOnNext</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Consumer</span><span class="token operator">&lt;</span>RegisterResponse<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token annotation punctuation">@Override</span>                    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">accept</span><span class="token punctuation">(</span>RegisterResponse registerResponse<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>                        <span class="token comment" spellcheck="true">//先根据注册的响应结果去做一些操作</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">observeOn</span><span class="token punctuation">(</span>Schedulers<span class="token punctuation">.</span><span class="token function">io</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                 <span class="token comment" spellcheck="true">//回到IO线程去发起登录请求</span>                <span class="token punctuation">.</span><span class="token function">flatMap</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Function</span><span class="token operator">&lt;</span>RegisterResponse<span class="token punctuation">,</span> ObservableSource<span class="token operator">&lt;</span>LoginResponse<span class="token operator">>></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token annotation punctuation">@Override</span>                    <span class="token keyword">public</span> ObservableSource<span class="token operator">&lt;</span>LoginResponse<span class="token operator">></span> <span class="token function">apply</span><span class="token punctuation">(</span>RegisterResponse registerResponse<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>                        <span class="token keyword">return</span> api<span class="token punctuation">.</span><span class="token function">login</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">LoginRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">observeOn</span><span class="token punctuation">(</span>AndroidSchedulers<span class="token punctuation">.</span><span class="token function">mainThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//回到主线程去处理请求登录的结果</span>                <span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Consumer</span><span class="token operator">&lt;</span>LoginResponse<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token annotation punctuation">@Override</span>                    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">accept</span><span class="token punctuation">(</span>LoginResponse loginResponse<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>                        Toast<span class="token punctuation">.</span><span class="token function">makeText</span><span class="token punctuation">(</span>MainActivity<span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token string">"登录成功"</span><span class="token punctuation">,</span> Toast<span class="token punctuation">.</span>LENGTH_SHORT<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Consumer</span><span class="token operator">&lt;</span>Throwable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token annotation punctuation">@Override</span>                    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">accept</span><span class="token punctuation">(</span>Throwable throwable<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>                        Toast<span class="token punctuation">.</span><span class="token function">makeText</span><span class="token punctuation">(</span>MainActivity<span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token string">"登录失败"</span><span class="token punctuation">,</span> Toast<span class="token punctuation">.</span>LENGTH_SHORT<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>③</p><p>Map(类似装饰模式？)</p><p>map是RxJava中最简单的一个变换操作符了, 它的作用就是对上游发送的每一个事件应用一个函数, 使得每一个事件都按照指定的函数去变化</p><p><code>FlatMap</code>将一个发送事件的上游Observable变换为多个发送事件的Observables，然后将它们发射的事件合并后放进一个单独的Observable里.</p><p>上游每发送一个事件, flatMap都将创建一个新的水管, 然后发送转换之后的新的事件, 下游接收到的就是这些新的水管发送的数据.  <strong>这里需要注意的是, flatMap并不保证事件的顺序,</strong>  也就是图中所看到的, 并不是事件1就在事件2的前面. 如果需要保证顺序则需要使用<code>concatMap</code>.</p><p>doOnNext() 执行在订阅者的onNext()方法之前，创建型之后。</p><ol><li>订阅者onSubscribe    main</li><li>map   io</li><li>被观察者subscribe  ，执行完发送事件  io</li><li>flatmap 1      main</li><li>flatmap 2    main</li><li>doOnNext&amp;accept()  main</li><li>onNext  main</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/Android/进阶解密/第6章</title>
      <link href="blog/1732408841.html"/>
      <url>blog/1732408841.html</url>
      
        <content type="html"><![CDATA[<p>ActivityManagerService</p><p>ActivityState</p><p>ActivityStack(1个？)</p><ul><li>TaskRecord(多个)<ul><li>ActivityRecord</li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/Android/rxjava/使用场景</title>
      <link href="blog/112105285.html"/>
      <url>blog/112105285.html</url>
      
        <content type="html"><![CDATA[<ol><li><p>验车流程中切换页面 时，先保存数据到本地数据库，这里用到了rxjava 异步去保存</p></li><li><p>预约信息界面InitData()中  加载城市列表时，需要访问本地数据，也是rxjava  在io线程访问</p></li><li><p>验车流程首先获取已经提交过的价格, 用于显示修改价格dialog</p></li></ol><pre><code>RetrofitSingleton                    .getIntance()                    .getEnsureService()                    .getPrice(car_id)</code></pre><p>4.提交严选车</p><pre><code>StudioRetrofitSingleton.getInstance().getService()                .signWellChosen(req)</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/Android/rxjava/rxjava</title>
      <link href="blog/3655612431.html"/>
      <url>blog/3655612431.html</url>
      
        <content type="html"><![CDATA[<h3 id="debounce-500-TimeUnit-MILLISECONDS"><a href="#debounce-500-TimeUnit-MILLISECONDS" class="headerlink" title="debounce(500, TimeUnit.MILLISECONDS)"></a>debounce(500, TimeUnit.MILLISECONDS)</h3><p>去抖。当调用函数N秒后，才会执行函数中动作，若在这<code>N</code>秒内又重复调用该函数则将取消前一次调用，并重新计算执行时间。</p><h3 id="subscribeOn（）和observeOn（）"><a href="#subscribeOn（）和observeOn（）" class="headerlink" title="subscribeOn（）和observeOn（）"></a>subscribeOn（）和observeOn（）</h3><p>实际上线程调度只有subscribeOn（）和observeOn（）两个方法。对于初学者，只需要掌握两点：</p><ul><li>subscribeOn（）它指示Observable在一个指定的调度器上<strong>创建</strong>（只作用于被观察者创建阶段）。只能指定一次，如果指定多次则以第一次为准</li><li>observeOn（）指定在事件传递（加工变换）和最终被处理（观察者）的发生在哪一个调度器。可指定多次，每次指定完都在下一步生效。</li></ul><p><img src=".rxjava_images/image-20200804171954995.png" alt="image-20200804171954995"></p><img src=".rxjava_images/image-20200804172056012.png" alt="image-20200804172056012" style="zoom:50%;" /><h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><h3 id="创建操作符"><a href="#创建操作符" class="headerlink" title="创建操作符"></a>创建操作符</h3><p>1.create、just和from</p><p>2.interval</p><p>创建一个按固定时间间隔发射整数序列的Observable，相当于定时器，</p><p>3.range</p><p>创建发射指定范围的整数序列的Observable，可以拿来替代for循环，发射一个范围内的有序整数序列。</p><p>4.repeat 创建一个N次重复发射特定数据的Observable，</p><h3 id="变换操作符"><a href="#变换操作符" class="headerlink" title="变换操作符"></a>变换操作符</h3><p>变换操作符的作用是对Observable发射的数据按照一定规则做一些变换操作，然后将变换后的数据发射 出去。变换操作符有map、flatMap、concatMap、switchMap、flatMapIterable、buffer、groupBy、cast、 window、scan 等，</p><p><strong>1.map</strong></p><p>map操作符通过指定一个Func对象，将Observable转换为一个新的Observable对象并发射，观察者将收 到新的Observable处理。假设我们要访问网络，Host地址时常是变化的，它有时是测试服务器地址，有时可 能是正式服务器地址，但是具体界面的URL地址则是不变的。因此，我们可以用map操作符来进行转换字符 操作.</p><h3 id="过滤操作符"><a href="#过滤操作符" class="headerlink" title="过滤操作符"></a>过滤操作符</h3><p>过滤操作符用于过滤和选择Observable发射的数据序列，让Observable只返回满足我们条件的数据。过 滤操作符有filter、elementAt、distinct、skip、take、skipLast、takeLast、ignoreElements、throttleFirst、 sample、debounce和throttleWithTimeout等，这里会介绍filter、elementAt、distinct、skip、take、 ignoreElements、throttleFirst和throttleWithTimeOut。</p><p><strong>1.debounce  去抖</strong></p><p>debounce(500, TimeUnit.MILLISECONDS)</p><p>去抖。当调用函数N秒后，才会执行函数中动作，若在这<code>N</code>秒内又重复调用该函数则将取消前一次调用，并重新计算执行时间。</p><h3 id="组合操作符"><a href="#组合操作符" class="headerlink" title="组合操作符"></a>组合操作符</h3><p>组合操作符可以同时处理多个Observable来创建我们所需要的Observable。组合操作符有startWith、 merge、concat、zip、combineLastest、join和switch等，这里介绍startWith、merge、concat、zip和 combineLastest。</p><h3 id="辅助操作符"><a href="#辅助操作符" class="headerlink" title="辅助操作符"></a>辅助操作符</h3><p>辅助操作符可以帮助我们更加方便地处理 Observable。辅助操作符包括 delay、DO、subscribeOn、 observeOn、timeout、materialize、dematerialize、timeInterval、timestamp和to等。在这里介绍delay、Do、 subscribeOn、observeOn和timeout。</p><h3 id="错误处理操作符"><a href="#错误处理操作符" class="headerlink" title="错误处理操作符"></a>错误处理操作符</h3><p>RxJava在错误出现的时候就会调用Subscriber的onError方法将错误分发出去，由Subscriber自己来处理错 误。但是如果每个 Subscriber 都处理一遍的话，工作量就有点大了，这时候可以使用错误处理操作符。错误 处理操作符有catch和 retry。</p><h3 id="条件操作符和布尔操作符"><a href="#条件操作符和布尔操作符" class="headerlink" title="条件操作符和布尔操作符"></a>条件操作符和布尔操作符</h3><p>条件操作符和布尔操作符可用于根据条件发射或变换Observable，或者对它们做布尔运算。现在先来了 解条件操作符。</p><p>1.布尔操作符</p><p>布尔操作符有all、contains、isEmpty、exists和sequenceEqual，这里介绍前3个操作符。</p><p>2.条件操作符 条件操作符有amb、defaultIfEmpty、skipUntil、skipWhile、takeUntil和takeWhile等</p><h3 id="转换操作符"><a href="#转换操作符" class="headerlink" title="转换操作符"></a>转换操作符</h3><p>转换操作符用来将 Observable 转换为另一个对象或数据结构，转换操作符有 toMap、toMultiMap、getIterator和nest等，这里介绍前3种。</p><h2 id="RxJava的线程控制"><a href="#RxJava的线程控制" class="headerlink" title="RxJava的线程控制"></a>RxJava的线程控制</h2><p>如果我们不指定线程，默认是在<strong>调用subscribe方法的线程上</strong>进行回调的。如果我们想切换线程，就需要 使用Scheduler。RxJava 已经内置了如下5个Scheduler。</p><p><strong>1.内置的Scheduler</strong></p><ul><li><p>Schedulers.immediate（）：直接在当前线程运行，它是timeout、timeInterval和timestamp操作符的默认 调度器。</p></li><li><p>Schedulers.newThread（）：总是启用新线程，并在新线程执行操作。</p></li><li><p>Schedulers.io（）：I/O操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模 式和 newThread（）差不多，区别在于 io（） 的内部实现是用一个无数量上限的线程池，可以重用空闲的 线程，因此多数情况下 io（） 比 newThread（） 更有效率。</p></li><li><p>Schedulers.trampoline（）：当我们想在当前线程执行一个任务时，并不是立即时，可以 用.trampoline（）将它入队。这个调度器将会处理它的队列并且按序运行队列中的每一个任务。它是repeat 和retry操作符默认的调度器。</p></li><li><p>AndroidSchedulers.mainThread（）—RxAndroid库中提供的Scheduler，它指定的操作在主线程中运行。</p></li></ul><p><strong>2.控制线程</strong></p><p>在RxJava中用subscribeOn和observeOn操作符来控制线程.</p><p>subscribeOn操作符用于指定Observable自身在哪个线程上运行。如果Observable需要执行耗时操作，一 般可以让其在新开的一个子线程上运行。observerOn用来指定Observer所运行的线程，也就是发射出的数据 在哪个线程上使用。一般情况下会指定在主线程中运行，这样就可以修改UI。</p><p>subscribeOn（Schedulers.newThread（））表示 Observable 运行在新开的线程，observeOn （AndroidSchedulers.mainThread（））表示运行在主线程。其中，AndroidSchedulers是RxAndroid库提供的 Scheduler，Scheduler的知识后面会讲到。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><h3 id="2-RxJava结合Retrofit访问网络"><a href="#2-RxJava结合Retrofit访问网络" class="headerlink" title="2.RxJava结合Retrofit访问网络"></a>2.RxJava结合Retrofit访问网络</h3><p>1）配置build.gradle：</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p><a href="https://www.jianshu.com/p/5588a6e2cbb0" target="_blank" rel="noopener">https://www.jianshu.com/p/5588a6e2cbb0</a></p><h3 id="1-创建被观察者（Observable）-amp-观察者（Observer）-方式的区别"><a href="#1-创建被观察者（Observable）-amp-观察者（Observer）-方式的区别" class="headerlink" title="1.创建被观察者（Observable） &amp; 观察者（Observer） 方式的区别"></a>1.创建被观察者（Observable） &amp; 观察者（Observer） 方式的区别</h3><ul><li>对于被观察者Observable</li></ul><pre class=" language-java"><code class="language-java"><span class="token operator">&lt;</span><span class="token operator">--</span> RxJava <span class="token number">1.0</span> 中 创建被观察者 <span class="token operator">--</span><span class="token operator">></span>Observable observable <span class="token operator">=</span> Observable<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Observable<span class="token punctuation">.</span>OnSubscribe</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">call</span><span class="token punctuation">(</span>Subscriber<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> String<span class="token operator">></span> subscriber<span class="token punctuation">)</span> <span class="token punctuation">{</span>        subscriber<span class="token punctuation">.</span><span class="token function">onNext</span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        subscriber<span class="token punctuation">.</span><span class="token function">onNext</span><span class="token punctuation">(</span><span class="token string">"Hi"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        subscriber<span class="token punctuation">.</span><span class="token function">onNext</span><span class="token punctuation">(</span><span class="token string">"Aloha"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        subscriber<span class="token punctuation">.</span><span class="token function">onCompleted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&lt;</span><span class="token operator">--</span> RxJava <span class="token number">2.0</span> 中 创建被观察者 <span class="token operator">--</span><span class="token operator">></span><span class="token comment" spellcheck="true">// 变化1：Observable.OnSubscribe接口名改成ObservableOnSubscribe </span>Observable<span class="token operator">&lt;</span>Integer<span class="token operator">></span> observable<span class="token operator">=</span>Observable<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ObservableOnSubscribe</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 变化2：复写的call（Subscriber）改成 subscribe （ObservableEmitter）    </span>            <span class="token comment" spellcheck="true">// 注：参数也发生了变化，即Subscriber -> ObservableEmitter = 发射器</span>           <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">subscribe</span><span class="token punctuation">(</span>ObservableEmitter<span class="token operator">&lt;</span>Integer<span class="token operator">></span> e<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 可发出三种类型的事件：next事件、complete事件&amp;error事件</span>                <span class="token comment" spellcheck="true">// 通过调用emitter.onNext(T value) 、onComplete()和onError(Throwable e)</span>                e<span class="token punctuation">.</span><span class="token function">onNext</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                e<span class="token punctuation">.</span><span class="token function">onNext</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                e<span class="token punctuation">.</span><span class="token function">onError</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Exception</span><span class="token punctuation">(</span><span class="token string">"发生错误了"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                e<span class="token punctuation">.</span><span class="token function">onComplete</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ul><li>对于观察者</li></ul><pre class=" language-java"><code class="language-java"><span class="token operator">&lt;</span><span class="token operator">--</span> RxJava <span class="token number">1.0</span> 中 创建观察者（Observer） <span class="token operator">--</span><span class="token operator">></span><span class="token comment" spellcheck="true">// 方法1：采用 Observer 接口</span>Observer<span class="token operator">&lt;</span>String<span class="token operator">></span> observer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Observer</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onNext</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Log<span class="token punctuation">.</span><span class="token function">d</span><span class="token punctuation">(</span>tag<span class="token punctuation">,</span> <span class="token string">"Item: "</span> <span class="token operator">+</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onCompleted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Log<span class="token punctuation">.</span><span class="token function">d</span><span class="token punctuation">(</span>tag<span class="token punctuation">,</span> <span class="token string">"Completed!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onError</span><span class="token punctuation">(</span>Throwable e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Log<span class="token punctuation">.</span><span class="token function">d</span><span class="token punctuation">(</span>tag<span class="token punctuation">,</span> <span class="token string">"Error!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 方法2：采用 Subscriber 接口（实现了Observer接口的抽象类）</span><span class="token comment" spellcheck="true">// 与Observer接口的区别：对 Observer接口进行了扩展：onStart()、unsubscribe()，但使用方式基本类似</span>Subscriber<span class="token operator">&lt;</span>String<span class="token operator">></span> subscriber <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Subscriber</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onNext</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Log<span class="token punctuation">.</span><span class="token function">d</span><span class="token punctuation">(</span>tag<span class="token punctuation">,</span> <span class="token string">"Item: "</span> <span class="token operator">+</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onCompleted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Log<span class="token punctuation">.</span><span class="token function">d</span><span class="token punctuation">(</span>tag<span class="token punctuation">,</span> <span class="token string">"Completed!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onError</span><span class="token punctuation">(</span>Throwable e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Log<span class="token punctuation">.</span><span class="token function">d</span><span class="token punctuation">(</span>tag<span class="token punctuation">,</span> <span class="token string">"Error!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token operator">&lt;</span><span class="token operator">--</span> RxJava <span class="token number">2.0</span> 中 创建观察者（Observer） <span class="token operator">--</span><span class="token operator">></span>        Observer<span class="token operator">&lt;</span>Integer<span class="token operator">></span> observer<span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Observer</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 变化1：增加回调方法onSubscribe()</span>            <span class="token comment" spellcheck="true">// 作用：最先调用该方法，即适合做初始化工作</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onSubscribe</span><span class="token punctuation">(</span>Disposable d<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 传入的参数Disposable作用 类似于 Subsciption</span>            <span class="token comment" spellcheck="true">// 即相当于订阅关系的开关，即可切断 观察者和被观察者的订阅关系</span>            <span class="token comment" spellcheck="true">// 注：调用dispose() = 观察者无法接收事件，但被观察者还是会继续发送事件</span>            <span class="token punctuation">}</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onNext</span><span class="token punctuation">(</span>Integer value<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token punctuation">}</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onError</span><span class="token punctuation">(</span>Throwable e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 变化2：onCompleted（）改成 onComplete（）</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onComplete</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span></code></pre><h3 id="2-compose（）操作符"><a href="#2-compose（）操作符" class="headerlink" title="2.compose（）操作符"></a>2.compose（）操作符</h3><p>主要变动在于：</p><ol><li><code>RxJava 1.0</code>实现的是：<code>rx.Observable.Transformer</code>接口</li></ol><blockquote><p>继承自<code>Func1, Observable&gt;</code></p></blockquote><pre class=" language-java"><code class="language-java"><span class="token operator">&lt;</span><span class="token operator">--</span> RxJava <span class="token number">1.0</span> 中的用法 <span class="token operator">--</span><span class="token operator">></span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> Observable<span class="token punctuation">.</span>Transformer<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> T<span class="token operator">></span> <span class="token function">createIOSchedulers</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Observable<span class="token punctuation">.</span>Transformer</span><span class="token operator">&lt;</span>T<span class="token punctuation">,</span> T<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> Observable<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">call</span><span class="token punctuation">(</span>Observable<span class="token operator">&lt;</span>T<span class="token operator">></span> tObservable<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> tObservable<span class="token punctuation">.</span><span class="token function">subscribeOn</span><span class="token punctuation">(</span>Schedulers<span class="token punctuation">.</span><span class="token function">io</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                        <span class="token punctuation">.</span><span class="token function">unsubscribeOn</span><span class="token punctuation">(</span>AndroidSchedulers<span class="token punctuation">.</span><span class="token function">mainThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                        <span class="token punctuation">.</span><span class="token function">observeOn</span><span class="token punctuation">(</span>AndroidSchedulers<span class="token punctuation">.</span><span class="token function">mainThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> Observable<span class="token punctuation">.</span>Transformer<span class="token operator">&lt;</span>JsonResult<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">,</span>T<span class="token operator">></span> <span class="token function">applySchedulers</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> createIOSchedulers（）<span class="token punctuation">;</span>    <span class="token punctuation">}</span>Action1<span class="token operator">&lt;</span>Integer<span class="token operator">></span> onNext <span class="token operator">=</span> null<span class="token punctuation">;</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> items <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token string">"item1"</span><span class="token punctuation">,</span> <span class="token string">"item2"</span><span class="token punctuation">,</span> <span class="token string">"item3"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>Subscription subscription <span class="token operator">=</span> Observable<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>items<span class="token punctuation">)</span>                                      <span class="token punctuation">.</span><span class="token function">compose</span><span class="token punctuation">(</span>RxUtil<span class="token punctuation">.</span>&lt;String<span class="token operator">></span><span class="token function">applySchedulers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                                      <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Func1</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                                                  <span class="token annotation punctuation">@Override</span> <span class="token keyword">public</span> Integer <span class="token function">call</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>                                                      <span class="token keyword">return</span> Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>                                                  <span class="token punctuation">}</span>                                              <span class="token punctuation">}</span><span class="token punctuation">)</span>                                      <span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span>onNext<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ol><li><code>RxJava 2.0</code> 实现的是<code>io.reactivex.ObservableTansformer</code></li></ol><blockquote><p>一个独立的接口</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token operator">&lt;</span><span class="token operator">--</span> RxJava <span class="token number">2.0</span> 中的用法 <span class="token operator">--</span><span class="token operator">></span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> ObservableTransformer<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> T<span class="token operator">></span> <span class="token function">io2MainObservable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ObservableTransformer</span><span class="token operator">&lt;</span>T<span class="token punctuation">,</span> T<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> ObservableSource<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">apply</span><span class="token punctuation">(</span>Observable<span class="token operator">&lt;</span>T<span class="token operator">></span> upstream<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> upstream<span class="token punctuation">.</span><span class="token function">subscribeOn</span><span class="token punctuation">(</span>Schedulers<span class="token punctuation">.</span><span class="token function">io</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">observeOn</span><span class="token punctuation">(</span>AndroidSchedulers<span class="token punctuation">.</span><span class="token function">mainThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> ObservableTransformer<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> T<span class="token operator">></span> <span class="token function">applySchedulers</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> io2MainObservable（）<span class="token punctuation">;</span>    <span class="token punctuation">}</span>Consumer<span class="token operator">&lt;</span>Integer<span class="token operator">></span> onNext <span class="token operator">=</span> null<span class="token punctuation">;</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> items <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token string">"item1"</span><span class="token punctuation">,</span> <span class="token string">"item2"</span><span class="token punctuation">,</span> <span class="token string">"item3"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>Disposable disposable <span class="token operator">=</span> Observable<span class="token punctuation">.</span><span class="token function">fromArray</span><span class="token punctuation">(</span>items<span class="token punctuation">)</span>                                  <span class="token punctuation">.</span><span class="token function">compose</span><span class="token punctuation">(</span>RxUtil<span class="token punctuation">.</span>&lt;String<span class="token operator">></span><span class="token function">applySchedulers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                                  <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Function</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                                              <span class="token annotation punctuation">@Override</span> <span class="token keyword">public</span> Integer <span class="token function">apply</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>                                                  <span class="token keyword">return</span> Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>                                              <span class="token punctuation">}</span>                                          <span class="token punctuation">}</span><span class="token punctuation">)</span>                                  <span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span>onNext<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>compose 操作符能够从数据流中得到原始的被观察者，当创建被观察者时，compose 操作符会立即执行，而不像其他的操作符需要在 onNext() 调用后才能执行。</p><p>可以用 compose 操作符来进行线程的切换，一般用在网络请求的地方。</p><p><strong>一.compose基本概念及使用</strong><br> 引入：</p><p>Obsrvable.just().map.map.map.filter.subscribeOn.observeOn.subscribe()</p><p>如果我们相对多个流重复利用一系列操作符该怎么办？</p><p>一种方式是，提取一个工具方法，把复用的地方抽取成一个方法applySchedulers。</p><p>applySchedulers(Observable.from(someSource)).subscribe</p><p>另外一种方法就是使用compose. compose常和Transformers。</p><p>buffer操作符</p><p>flatmap</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/Android/进阶解密/第二章</title>
      <link href="blog/1696425643.html"/>
      <url>blog/1696425643.html</url>
      
        <content type="html"><![CDATA[<h3 id="2-2-Zygote进程启动"><a href="#2-2-Zygote进程启动" class="headerlink" title="2.2 Zygote进程启动"></a>2.2 Zygote进程启动</h3><ol><li>Zygote是什么？</li></ol><p>DVM、ART、应用程序进程以及运行系统的关键服务的SystemServer进程都是有Zygote进程通过fork(复制进程)来创建的，我们称它为孵化器. 由于Zygote进程在启动时会创建DVM或者ART,因此通过fork而创建的应用程序进程和<strong>SystemServer进程</strong>可以在内部获取一个DVM或ART的实例副本。</p><ol start="2"><li>Zygote进程启动总结</li></ol><p>(1) 创建AppRuntime并调用其start方法，启动Zygote进程</p><p>(2) 创建Java虚拟机并为Java虚拟机注册JNI方法</p><p>(3) 通过JNI调用ZygoteInit的main函数(Java代码)进入Zygote的(从Native层到)Java框架层</p><p>(4) 通过registerZygoteSocket方法创建服务端Socket(name 为zygote),并通过runSelectLoop方法等待AMS的请求来创建新的应用程序进程。</p><p>(5) 启动SystemServer进程</p><h3 id="2-3SystemServer处理过程"><a href="#2-3SystemServer处理过程" class="headerlink" title="2.3SystemServer处理过程"></a>2.3SystemServer处理过程</h3><p>SystemServer进程作用：创建系统服务，AMS,WMS,PMS都是它创建的。</p><p>SystemServer进程复制了Zygote进程的地址空间，因此也会得到Zygote进程创建的Socket，这个对SystemServer进程没用，它需要关掉。</p><p>SystemServiceManager它会对<strong>系统服务</strong>进行创建、启动和生命周期管理。它自己是在SystemServer.java中的run方法中创建的，而run方法是由SystemServer.java的main方法调用的。</p><h4 id="部分系统服务"><a href="#部分系统服务" class="headerlink" title="部分系统服务"></a><strong>部分系统服务</strong></h4><p>Installer</p><p>ActivityManagerService</p><p>PowerManagerService</p><p>PackageManagerService</p><p>BatteryService</p><p>CameraService</p><h4 id="系统服务启动逻辑举例"><a href="#系统服务启动逻辑举例" class="headerlink" title="系统服务启动逻辑举例"></a><strong>系统服务启动逻辑举例</strong></h4><p>mPowerManagerService = mSystemServiceManager . startService(PowerManagerService</p><p>. class) ;</p><img src=".第二章_images/image-20200804125326531.png" alt="image-20200804125326531" style="zoom:50%;" /><ol><li><p>注册 将service存储到mServices中，mServices是一个存储SysterService的ArrayList.</p></li><li><p>启动service , 通过调用service&amp;onStart()方法</p></li></ol><p><strong>启动系统服务的第二种方法</strong>：直接调用PackageManagerService.main()方法</p><ul><li>直接创建PackageManagerService</li><li>将上面创建的注册到ServiceManager中</li></ul><p><strong>ServiceManger</strong> 用来管理系统中的各种Service,用于系统C/S架构中的Binder通信机制：</p><p>​    Client 端要使用某个 Service ，则需要先到 ServiceManager 查询 Service 的相关信息，然后根据 Service 的相关信息与 Service 所在的 Server 进程建立通信通 路，这样 Client 端就可以使用 Service 了。</p><h4 id="SystemServer进程总结"><a href="#SystemServer进程总结" class="headerlink" title="SystemServer进程总结:"></a>SystemServer进程总结:</h4><p>主要工作如下</p><ol><li>启动 Binder 线程池，这样就可以与其他进程进行通信 。</li><li>创建 SystemServiceManager ，其用于对系统的服务进行创建、启动和生命周期管理。</li><li>启动各种系统服务。</li></ol><h3 id="2-4-Launcher-Android-系统的桌面-启动过程"><a href="#2-4-Launcher-Android-系统的桌面-启动过程" class="headerlink" title="2.4 Launcher(Android 系统的桌面)启动过程"></a>2.4 Launcher(Android 系统的桌面)启动过程</h3><h4 id="2-4-1概述"><a href="#2-4-1概述" class="headerlink" title="2.4.1概述"></a>2.4.1概述</h4><p>系统启动的最后一步是启动一个应用程序用来显示系统中已经安装的应用程序，这个 应用程序就叫作 Launcher Launcher 在启动过程中会请求 PackageManagerService 返回系统 中已经安装的应用程序的信息，并将这些信息封装成一个快捷图标列表显示在系统屏幕上。</p><h4 id="2-4-2启动过程"><a href="#2-4-2启动过程" class="headerlink" title="2.4.2启动过程"></a>2.4.2启动过程</h4>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/面经/网易/1</title>
      <link href="blog/2193499461.html"/>
      <url>blog/2193499461.html</url>
      
        <content type="html"><![CDATA[<p>2020-07-27 12:10:47</p><p>1.下拉刷新怎么实现？</p><p>2.viewgroup  添加item ，插入到下一行的 判断条件</p><p>3.volitile关键字的作用，手写线程安全的单例</p><ol start="4"><li>asynctask的作用</li><li>图片加载要注意什么</li><li>glide的优点， glide 怎么处理图片抖动的</li><li>自定义的步骤</li></ol><p>8.启动模式 ， service中启动activity 怎么写</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/面经/百度/1</title>
      <link href="blog/546157879.html"/>
      <url>blog/546157879.html</url>
      
        <content type="html"><![CDATA[<p>设置圆角。</p><p>数组环形队列。</p><p>tcp应用 udp 应用，视频</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/Android/Context</title>
      <link href="blog/3815484017.html"/>
      <url>blog/3815484017.html</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>功能</th><th>Application</th><th>Service</th><th>Activity</th></tr></thead><tbody><tr><td>Start an Activity</td><td>NO1</td><td>NO1</td><td>YES</td></tr><tr><td>Show a Dialog</td><td>NO</td><td>NO</td><td>YES</td></tr><tr><td>LayoutInflation</td><td>YES</td><td>YES</td><td>YES</td></tr><tr><td>Start a Service</td><td>YES</td><td></td><td>YES</td></tr><tr><td>Bind to a Service</td><td></td><td>YES</td><td>YES</td></tr><tr><td></td><td></td><td></td><td></td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/Android/内存泄露和OOM</title>
      <link href="blog/24924584.html"/>
      <url>blog/24924584.html</url>
      
        <content type="html"><![CDATA[<h2 id="内存泄露检测工具"><a href="#内存泄露检测工具" class="headerlink" title="内存泄露检测工具"></a>内存泄露检测工具</h2><h3 id="MAT"><a href="#MAT" class="headerlink" title="MAT"></a>MAT</h3><p>Java堆分析器，可帮助您查找内存泄漏并减少内存消耗。使用Memory Analyzer分析具有数亿个对象的高效堆转储，快速计算对象的保留大小，查看谁阻止垃圾收集器收集对象，运行报告以自动提取泄漏嫌疑者。</p><h3 id="LeakCanary"><a href="#LeakCanary" class="headerlink" title="LeakCanary"></a>LeakCanary</h3><h2 id="什么是内存泄露"><a href="#什么是内存泄露" class="headerlink" title="什么是内存泄露"></a>什么是内存泄露</h2><p>就是系统回收不了分配出去了不使用的对象。</p><h2 id="内存泄露的分类"><a href="#内存泄露的分类" class="headerlink" title="内存泄露的分类"></a>内存泄露的分类</h2><p>常发性内存泄露</p><h2 id="内存泄露的场景"><a href="#内存泄露的场景" class="headerlink" title="内存泄露的场景"></a>内存泄露的场景</h2><h3 id="1-单例构造时传入的Context参数类型为Activity"><a href="#1-单例构造时传入的Context参数类型为Activity" class="headerlink" title="1.单例构造时传入的Context参数类型为Activity"></a>1.单例构造时传入的Context参数类型为Activity</h3><p>activity退出的时候，单例的生命周期为应用程序的生命周期，activity得不到释放。</p><p>正确的做法：用Application的Context</p><h3 id="2-Handler-延迟的消息"><a href="#2-Handler-延迟的消息" class="headerlink" title="2.Handler  延迟的消息"></a>2.Handler  延迟的消息</h3><p>延迟的消息Message持有Handler引用，handler为非静态内部类，持有外部activity类的引用，即持有activity的引用。</p><p>还应该在Activity的Stop 或者Destroy中移除消息队列的消息。</p><h3 id="3-匿名内部类持有外部类的引用，若是这个引用传入到一个异步线程"><a href="#3-匿名内部类持有外部类的引用，若是这个引用传入到一个异步线程" class="headerlink" title="3.匿名内部类持有外部类的引用，若是这个引用传入到一个异步线程"></a>3.匿名内部类持有外部类的引用，若是这个引用传入到一个异步线程</h3><p>而该线程的生命周期和activity不一致，也就造成了activity的泄露。</p><h3 id="怎样避免内存泄露？"><a href="#怎样避免内存泄露？" class="headerlink" title="怎样避免内存泄露？"></a>怎样避免内存泄露？</h3><h4 id="1-处理占用内存大并且生命周期较长的对象的时候，尽量使用软引用或弱引用。"><a href="#1-处理占用内存大并且生命周期较长的对象的时候，尽量使用软引用或弱引用。" class="headerlink" title="1.处理占用内存大并且生命周期较长的对象的时候，尽量使用软引用或弱引用。"></a>1.处理占用内存大并且生命周期较长的对象的时候，尽量使用软引用或弱引用。</h4><p>eg:保存Bitmap的软引用到HashMap</p><p>如果只是想避免OOM，使用软引用，如果对于性能更在意，想尽快回收一些占用内存比较大的对象，则可以使用弱引用。</p><h4 id="2-远离非静态内部类和匿名类，多用private-static-class"><a href="#2-远离非静态内部类和匿名类，多用private-static-class" class="headerlink" title="2.远离非静态内部类和匿名类，多用private static class"></a>2.远离非静态内部类和匿名类，多用private static class</h4><h4 id="3-集合对象在activity退出时，clear集合，置为null"><a href="#3-集合对象在activity退出时，clear集合，置为null" class="headerlink" title="3.集合对象在activity退出时，clear集合，置为null"></a>3.集合对象在activity退出时，clear集合，置为null</h4><h4 id="4-Bitmap对象不在使用时调用recycle-释放内存"><a href="#4-Bitmap对象不在使用时调用recycle-释放内存" class="headerlink" title="4.Bitmap对象不在使用时调用recycle()释放内存"></a>4.Bitmap对象不在使用时调用recycle()释放内存</h4><h4 id="5-Context使用不当造成内存泄露"><a href="#5-Context使用不当造成内存泄露" class="headerlink" title="5.Context使用不当造成内存泄露"></a>5.Context使用不当造成内存泄露</h4><p>不要对一个activity Context保持生命周期的引用。尽量在一切可以使用ApplicationContext代替Context的地方进行替换</p><h4 id="6-退出acitivty时切记结束线程"><a href="#6-退出acitivty时切记结束线程" class="headerlink" title="6.退出acitivty时切记结束线程"></a>6.退出acitivty时切记结束线程</h4><p>handlerThread的run是一个死循环，要在activity销毁中调用handlerTHread.getLooper().quit()</p><h4 id="7-对象的注册与反注册没有成对出现"><a href="#7-对象的注册与反注册没有成对出现" class="headerlink" title="7.对象的注册与反注册没有成对出现"></a>7.对象的注册与反注册没有成对出现</h4><p>譬如注册广播接收器，</p><h4 id="8-创建与关闭没有成对出现，比如Cursor资源必须手动关闭"><a href="#8-创建与关闭没有成对出现，比如Cursor资源必须手动关闭" class="headerlink" title="8.创建与关闭没有成对出现，比如Cursor资源必须手动关闭"></a>8.创建与关闭没有成对出现，比如Cursor资源必须手动关闭</h4><h2 id="BITMAP加载导致内存泄漏一般怎么优化"><a href="#BITMAP加载导致内存泄漏一般怎么优化" class="headerlink" title="BITMAP加载导致内存泄漏一般怎么优化"></a>BITMAP加载导致内存泄漏一般怎么优化</h2><ol><li><p>Bitmap对象不在使用时调用recycle()释放内存</p></li><li><p>图片压缩后再加载</p></li><li><p>软引用缓存bitmap对象</p></li><li><p>用框架</p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/Android/windwo和window manager</title>
      <link href="blog/3288367271.html"/>
      <url>blog/3288367271.html</url>
      
        <content type="html"><![CDATA[<p>除了View的三大流程以外，View常见的回调方法也是需要掌握的，比如构造方法，onAttach 、onAttach,onVisibilityChanged、onDetach等。</p><p>ViewRoot对应于ViewRootImpl类，它的连接WindowManager和DecorView的纽带，View的三大流程均是通过ViewRoot来完成的。</p><p>在ActivityThread中，当Activity对象被创建完后，会将DecorView添加到Window中，同时会创建ViewRootImpl对象，并将ViewRootImpl丢下和DecorView建立关联。</p><ul><li>Android中所有的视图都是通过Window来呈现的</li><li>不管是Activity,Dialog还是Toast，它们的视图实际上都是附加在Window上的</li><li>Window是View的直接管理者</li><li>Window并不是实际存在的，view是window存在的实体</li><li></li></ul><h3 id="Window的三种类型"><a href="#Window的三种类型" class="headerlink" title="Window的三种类型"></a>Window的三种类型</h3><h3 id="Window的内部机制"><a href="#Window的内部机制" class="headerlink" title="Window的内部机制"></a>Window的内部机制</h3><p>Window是一个抽象的概念，每个Window对应一个View和一个ViewRootImpl </p><h3 id="WindowManager"><a href="#WindowManager" class="headerlink" title="WindowManager"></a>WindowManager</h3><p>无法直接访问window,对window的访问必须通过windowmanager</p><p>WindowManager继承了ViewManager,常用的只有三个方法addview,updateViewLayout,removeView.</p><p>WindowManager操作window更像是在操作window中的view</p><p>Activity创建-&gt;window创建-&gt;DecorView创建-&gt;ViewRootImpl创建</p><p>activity的视图是怎么附属到window上的？</p><p>setContentView()  ,通过window添加到decorview中,回到activity的onContentChanged  ,回调activity的onResume ,  makeVisible()</p><p>makeVisible方法 中调用了</p><p>windowmanager的addview方法 ,并将decorview  visible。</p><p>WindowManagerGlobal内部的3个列表</p><ul><li>mViews 存所有Window对应的View</li><li>mRoots存所有Window对应的ViewRootImpl</li><li>mParams存所有Window对应的布局参数</li><li>mDyingViews存正在被删除的View对象(调用了removeView但删除操作还未完成的Window对象)</li></ul><p>ViewRootImpl</p><p>1.在哪创建的？</p><p>windowmanager&amp;addview()方法内部</p><p>2.存在哪</p><p>存在windowmanagerglobal的几个成员list</p><p>mRoots存储的是所有Window所对应的ViewRootImpl</p><p>![image-20200722004538052](.windwo和window manager_images/image-20200722004538052.png)</p><p>3.通过ViewRootImpl来更新界面并完成window的添加过程</p><p>ViewRootImpl&amp;setView方法完成，</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/Android/Android基础/HandlerThread</title>
      <link href="blog/703753920.html"/>
      <url>blog/703753920.html</url>
      
        <content type="html"><![CDATA[<p>开启Thread线程进行耗时操作</p><p>多次创建和销毁线程是很耗系统资源的</p><h2 id="一-handlerThread是什么"><a href="#一-handlerThread是什么" class="headerlink" title="一.handlerThread是什么"></a>一.handlerThread是什么</h2><p>handler+thread+looper,是一个thread</p><p>作用：子线程与子线程之间的通信</p><p>内部有looper</p><p>handlerThread本质上是一个线程类，它继承了Thread</p><p>handlerThread有自己的内部Looper对象，可以进行looper循环</p><p>通过获取handlerThread的looper对象传递给handler对象，可以在handleMessage方法中执行异步任务</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/Android/Android基础/AsyncTask</title>
      <link href="blog/400975792.html"/>
      <url>blog/400975792.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-什么是AsyncTask"><a href="#1-什么是AsyncTask" class="headerlink" title="1.什么是AsyncTask?"></a>1.什么是AsyncTask?</h2><p>是一个轻量级的异步任务类,封装了Handler和线程池</p><h2 id="2-关于Deprecated"><a href="#2-关于Deprecated" class="headerlink" title="2.关于Deprecated"></a>2.关于Deprecated</h2><p>当我准备开始阅读AsyncTask源码的时候，我在 <a href="https://www.colabug.com/goto/aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcmVmZXJlbmNlL2FuZHJvaWQvb3MvQXN5bmNUYXNr" target="_blank" rel="noopener">AsyncTask的官方文档</a> 发现了它在Android R（11.0）上已经被标记过时，官方更推荐开发者使用Kotlin的协程进行异步操作。</p><p>Google官方列举了以下把它标记为过时的原因，其实这也是AsyncTask一直以来都被诟病的地方：</p><ol><li><h3 id="容易导致内存泄漏"><a href="#容易导致内存泄漏" class="headerlink" title="容易导致内存泄漏"></a>容易导致内存泄漏</h3><p>由于AsyncTask的生命周期和Activity的生命周期不同步，并不会随着Activity的销毁而销毁，所以有时候会造成Activity的内存无法销毁，造成内存泄露</p></li><li><h3 id="忘记回调"><a href="#忘记回调" class="headerlink" title="忘记回调"></a>忘记回调</h3></li><li><h3 id="横竖屏切换导致崩溃"><a href="#横竖屏切换导致崩溃" class="headerlink" title="横竖屏切换导致崩溃"></a>横竖屏切换导致崩溃</h3></li></ol><p>使用AsyncTask的最初目的是希望为UI线程开启一个后台线程，用于与之进行交互。因为常见对AsyncTask的使用是去执行一个耗时操作，并在结束后（AsyncTask.onPostExecute()）更新UI。但是旋转屏幕，当前的Activity会被销毁然后重建，Activity重启后，此时AsyncTask对Actvity的引用是invalid，因为他指向的还是前一个没有转屏前的Activity，并不是重建后的Activity，So onPostExecute对重建后的Activity是没有意义的。这点尤其是在将AsyncTask作为Activity的内部类，AsyncTask会隐式应用当前Activity的时候给人制造困惑。<br>避免该问题的一个常规做法是，保留对AsyncTask的引用，该引用在配置更改之间持续，在重新启动时更新目标Activity。<br>因为AsyncTask的生命周期并不随着Activity的的销毁而销毁，导致在转屏的时候，转屏前AsyncTask的执行内容并没有传给转屏后的Activity，相当于AsyncTask的执行结果白白浪费了，</p><ol start="4"><li><h3 id="不同版本的AsyncTask的兼容问题"><a href="#不同版本的AsyncTask的兼容问题" class="headerlink" title="不同版本的AsyncTask的兼容问题"></a>不同版本的AsyncTask的兼容问题</h3></li></ol><h2 id="3-串行还是并行？"><a href="#3-串行还是并行？" class="headerlink" title="3.串行还是并行？"></a>3.串行还是并行？</h2><h3 id="10-0是串行执行"><a href="#10-0是串行执行" class="headerlink" title="10.0是串行执行"></a>10.0是串行执行</h3><p>线程run方法执行完后finally 中执行scheduleNext(取任务去执行)</p><h3 id="怎样实现并行？"><a href="#怎样实现并行？" class="headerlink" title="怎样实现并行？"></a>怎样实现并行？</h3><p>在AsyncTask内部创建了一个线程池，核心线程数是1，最大线程数是20，救急线程存活时间3s,这个线程池最终是进行异步任务执行的</p><p>execute()方法传入AsynTask的静态成员变量</p><h3 id="4-AsyncTask设置了一个备用的线程池"><a href="#4-AsyncTask设置了一个备用的线程池" class="headerlink" title="4.AsyncTask设置了一个备用的线程池"></a>4.AsyncTask设置了一个备用的线程池</h3><p>以便常规执行任务的线程池拒绝执行任务时，还能保证任务队列里面的任务正常执行。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/剑指offer leetcode/数组和矩阵</title>
      <link href="blog/2648272586.html"/>
      <url>blog/2648272586.html</url>
      
        <content type="html"><![CDATA[<p>T20 顺时针打印矩阵</p><p>算法思想：</p><ul><li><p>一圈一圈打印，左上角起点为一圈的开始，发现循环条件的规律 2 * start &lt; rows &amp;&amp; 2 * start &lt; cols；</p></li><li><p>打印一圈：</p><ul><li>左到右，肯定是要有的</li><li>上到下：前提是至少有2行</li><li>右到左：前提是至少有2行2列</li><li>下到上：前提是至少有3行2列</li></ul></li></ul><p>关键：画图举例法，找出规律，注意边界条件。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/剑指offer leetcode/二叉树</title>
      <link href="blog/1107600811.html"/>
      <url>blog/1107600811.html</url>
      
        <content type="html"><![CDATA[<h3 id="剑指offer题目"><a href="#剑指offer题目" class="headerlink" title="剑指offer题目"></a>剑指offer题目</h3><h4 id="7-重建二叉树-☆☆"><a href="#7-重建二叉树-☆☆" class="headerlink" title="7 重建二叉树(☆☆)"></a>7 重建二叉树(<font color='red'>☆☆</font>)</h4><p>题目：根据中序序列和先序序列构造一颗二叉树，二叉树结点的值都不相同。</p><p>算法步骤：</p><p>①判空（数组合法性检查）</p><p>②找到根节点的值，构造根节点</p><p>③在中序数组中找到根节点的位置，以求出左右子树的长度，并递归调用自己</p><p>​    存在左子树构造左子树，存在右子树构造右子树</p><blockquote><p> 注: 这里可以理解为用的先序去构造的这颗树，1个结点的左右子树都为空时，会直接返回这个结点。</p><p>看看，不用写，过。</p></blockquote><h4 id="8-二叉树的下一个结点：中序后继-☆☆"><a href="#8-二叉树的下一个结点：中序后继-☆☆" class="headerlink" title="8 二叉树的下一个结点：中序后继(☆☆)"></a>8 二叉树的下一个结点：中序后继(<font color='red'>☆☆</font>)</h4><p>给定一个二叉树，1个树中的结点，每个结点有parent指针</p><p>三种情况：</p><p>①有右子树：右子树的最左结点。</p><p>②没有右子树，是父节点的左孩子：所求即为父节点</p><p>③没有右子树，是父节点的右孩子：沿着parent指针向上遍历，直到一个是它父节点的左子结点的结点，如果这个结点存在，这个结点的父节点即为所求，都是右子节点的话，就为Null</p><p>④没有右子树，也没有parent，所求为Null</p><blockquote><p>注：记住这4种情况即可，不用过代码。</p></blockquote><h4 id="26-树的子结构"><a href="#26-树的子结构" class="headerlink" title="26 树的子结构"></a>26 树的子结构</h4><p>树的问题采用递归解法的关键在于：在左右子树各看成一个整体。</p><p>分2步：</p><p>①第一步在树中查找与根节点一样的结点，树的遍历</p><p>②第二步判断树A中以R为根节点的子树是不是和树B具有相同的结构</p><blockquote><p> 注 :1. 在面试的时候，我们一定要注意边界条件检查，即检查空指针。如果没有检查并进行相应的处理，程序非常容易崩溃，这是面试时非常忌讳的事情。</p><p> 2.在写遍历树的代码的时候一定要高度警惕，有没有可能是Null,null怎么处理.</p><p> 3.double类型的比较要注意。</p><p> 2020-09-21 12:18:50 注： ***4.当前仅当 A B都不空时  才有可能是true ，左子树有了 就直接返回，先判断左子树。</p><p> 5.*** 第2步是判断A中是否包含B ，而力扣572 另一颗树的子树是 要求A中有子树和B是一样的。</p><p> 6.*** 第2步判断，B null就返回true</p></blockquote><p><img src=".%E4%BA%8C%E5%8F%89%E6%A0%91_images/image-20200921122516624.png" alt="image-20200921122516624"></p><h4 id="27-二叉树的镜像"><a href="#27-二叉树的镜像" class="headerlink" title="27 二叉树的镜像"></a>27 二叉树的镜像</h4><h4 id="28-对称二叉树"><a href="#28-对称二叉树" class="headerlink" title="28 对称二叉树"></a>28 对称二叉树</h4><h4 id="32-从上到下打印二叉树"><a href="#32-从上到下打印二叉树" class="headerlink" title="32 从上到下打印二叉树"></a>32 从上到下打印二叉树</h4><h4 id="33-二叉搜索树的后序遍历序列"><a href="#33-二叉搜索树的后序遍历序列" class="headerlink" title="33 二叉搜索树的后序遍历序列"></a>33 二叉搜索树的后序遍历序列</h4><h4 id="34-二叉树中和为某一值的路径"><a href="#34-二叉树中和为某一值的路径" class="headerlink" title="34 二叉树中和为某一值的路径"></a>34 二叉树中和为某一值的路径</h4><h4 id="36-二叉搜索树与双向链表"><a href="#36-二叉搜索树与双向链表" class="headerlink" title="36 二叉搜索树与双向链表"></a>36 二叉搜索树与双向链表</h4><h4 id="37-序列化二叉树"><a href="#37-序列化二叉树" class="headerlink" title="37 序列化二叉树"></a>37 序列化二叉树</h4><h4 id="54-二叉树搜索树的第k大结点"><a href="#54-二叉树搜索树的第k大结点" class="headerlink" title="54 二叉树搜索树的第k大结点"></a>54 二叉树搜索树的第k大结点</h4><h4 id="55-二叉树的深度"><a href="#55-二叉树的深度" class="headerlink" title="55 二叉树的深度"></a>55 二叉树的深度</h4><h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><h4 id="1-非递归先序"><a href="#1-非递归先序" class="headerlink" title="1.非递归先序"></a>1.非递归先序</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//非递归先序遍历</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">preOrderUnCur</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"这是个空树"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        Stack<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            TreeNode node <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>以下背诵</p><ol><li>根节点入栈</li><li>当栈不空的时候，循环<ol><li>弹出栈顶结点，输出</li><li>右孩子不空，右孩子入栈</li><li>左孩子不空，左孩子入栈</li></ol></li></ol><h4 id="2-非递归中序"><a href="#2-非递归中序" class="headerlink" title="2.非递归中序"></a>2.非递归中序</h4><p>初始遍历结点p作为当前结点指向根。</p><pre><code> /**     * 非递归中序遍历     * 当栈为空 &amp;&amp; 当前结点为null时 才结束循环，否则循环执行下面2句     * 当前结点为空，从栈中弹出一个变成当前结点打印，并指向右孩子；     * 当前结点不空，当前结点入栈，当前结点并指向左孩子‘     * @param root 树根     */    public void inOrderUnCur(TreeNode root){        if (root == null){            System.out.println(&quot;这是个空树&quot;);            return;        }        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();        TreeNode p = root;        while (!stack.isEmpty() || p != null){            if(p != null){                stack.push(p);                p = p.left;            }else{                p = stack.pop();                System.out.print(p.val + &quot; &quot;);                p = p.right;            }        }        System.out.println(&quot;&quot;);    }</code></pre><h4 id="3-非递归后序"><a href="#3-非递归后序" class="headerlink" title="3.非递归后序"></a>3.非递归后序</h4><p>​    同先序差不多。</p><ol><li>根结点入普通栈</li><li>当普通栈不空的时候，循环<ol><li>弹出一个元素，压入到辅助栈</li><li>左孩子不空，左孩子入普通栈</li><li>右孩子不空，右孩子入普通栈</li></ol></li><li>循环结束，弹出辅助栈所有元素</li></ol><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//非递归后序遍历(实现输出左右中的顺序)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">postOrderUnCur</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"这是个空树"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        Stack<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Stack<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> helpStack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            TreeNode node <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            helpStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>helpStack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            TreeNode node <span class="token operator">=</span> helpStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h4 id="4-T32-层次遍历二叉树"><a href="#4-T32-层次遍历二叉树" class="headerlink" title="4.T32 层次遍历二叉树"></a>4.T32 层次遍历二叉树</h4><ul><li>通过具体的例子（画个表格逐步分析）找出其中的规律并想到基于队列的算法，是解决这个问题的关键所在。</li></ul><p>扩展</p><ul><li><p>还要掌握分行打印(字节跳动)</p><ul><li>简单，增加2个变量，当前层结点数量初始为1，下一层结点数量初始为0</li></ul></li><li><p>还要掌握之字形打印  </p><ul><li><p>分析知道用单个队列，不加其他额外操作不行（保证结点只遍历1次）</p></li><li><p>分析知道只用单个栈也不行</p></li><li><p>要用2个栈,1个栈用于暂存顺序输出的结点，1个栈用于逆序输出的结点，分奇偶层存入不同的stack;</p><p>同时分奇偶层去取出结点(有点难度的)</p></li></ul><p>序列化是将数据结构或对象转换为一系列位的过程，以便它可以存储在文件或内存缓冲区中，或通过网络连接链路传输，以便稍后在同一个或另一个计算机环境中重建。</p></li></ul><h3 id="面试题54-二叉搜索树的第k大结点"><a href="#面试题54-二叉搜索树的第k大结点" class="headerlink" title="面试题54:二叉搜索树的第k大结点"></a>面试题54:二叉搜索树的第k大结点</h3><ul><li>利用中序遍历，easy<ul><li>定一个成员变量，递增直到k</li><li>也可以不用定义成员变量，传参的时候，k–,直到1时就是所求结点</li></ul></li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    TreeNode <span class="token function">KthNode</span><span class="token punctuation">(</span>TreeNode pRoot<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span><span class="token punctuation">{</span>        TreeNode result <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pRoot <span class="token operator">==</span> null <span class="token operator">||</span> k <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        result <span class="token operator">=</span>  <span class="token function">KthNode</span><span class="token punctuation">(</span>pRoot<span class="token punctuation">.</span>left<span class="token punctuation">,</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>        count<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> k<span class="token punctuation">)</span><span class="token punctuation">{</span>            result <span class="token operator">=</span> pRoot<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>            result <span class="token operator">=</span> <span class="token function">KthNode</span><span class="token punctuation">(</span>pRoot<span class="token punctuation">.</span>right<span class="token punctuation">,</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h3 id="面试题55：二叉树的深度"><a href="#面试题55：二叉树的深度" class="headerlink" title="面试题55：二叉树的深度"></a>面试题55：二叉树的深度</h3><p>题目一：二叉树的深度</p><ul><li>递归</li></ul><p>题目二：判断是否是平衡二叉树</p><ul><li>后序遍历的递归形式</li></ul><h3 id="面试题37：二叉树的序列化"><a href="#面试题37：二叉树的序列化" class="headerlink" title="面试题37：二叉树的序列化"></a>面试题37：二叉树的序列化</h3><p>1，2，#，#，3，4，#，#，5，#，#，</p><p>先序</p><h5 id="序列化："><a href="#序列化：" class="headerlink" title="序列化："></a>序列化：</h5><ul><li>采用递归先序，当前结点为null时，返回null结点标记$,</li><li>访问根</li><li>递归访问左右子树（函数返回以当前结点为根序列化后的结果）</li><li>根 + 左子树序列化的结果 + 右子树序列化的结果</li></ul><h5 id="反序列化："><a href="#反序列化：" class="headerlink" title="反序列化："></a>反序列化：</h5><p>eg: 1，2，#，#，3，4，#，#，5，#，#， 这样一棵树。</p><ul><li><p>任然是递归去构造</p></li><li><p>将参数data  split(“,”)成字符串数组，并按入队的顺序(先序遍历的顺序)加入到队列中</p><ul><li>队列中弹出1个(取出队头)，是空标记(比如”null”)，则returnnull</li></ul></li><li><p>否则以当前value 构造TreeNode结点</p><ul><li>根节点左孩子 = 递归调用的返回值，参数为当前队列</li><li>根节点右孩子 = 递归调用的返回值，参数为当前队列</li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/剑指offer leetcode/动态规划</title>
      <link href="blog/1976945438.html"/>
      <url>blog/1976945438.html</url>
      
        <content type="html"><![CDATA[<h4 id="L198-大家劫舍"><a href="#L198-大家劫舍" class="headerlink" title="L198 大家劫舍"></a>L198 大家劫舍</h4><p>描述问题的最优子结构，递归定义最优解的值</p><h4 id="L53-最大子序和"><a href="#L53-最大子序和" class="headerlink" title="L53 最大子序和"></a>L53 <a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">最大子序和</a></h4><p>这题关键在于定义最优解，用 <em>f</em>(<em>i</em>) 代表以第 i个数结尾的「连续子数组的最大和」，找出最大的。  a(i) 表示数字第i个元素，要判断是否要加入前面的子序和。前面的大于0才加。</p><h4 id="L121121-买卖股票的最佳时机"><a href="#L121121-买卖股票的最佳时机" class="headerlink" title="L121121. 买卖股票的最佳时机"></a>L121<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">121. 买卖股票的最佳时机</a></h4><p>f(i)定义为数组前i个数的解，就是第i天的解，可能为负数，不是最优解。也就是找出每天的解，用1个max变量来记录最优解. 第i天的解第i天 - 前面最小的。</p><p>这个解法在暴力解(问题的所有子问题) 和纯动态规划之间.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/剑指offer leetcode/字符串</title>
      <link href="blog/1457010460.html"/>
      <url>blog/1457010460.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-有效的字母异位词"><a href="#1-有效的字母异位词" class="headerlink" title="1.有效的字母异位词"></a>1.有效的字母异位词</h3><h4 id="方法一：排序"><a href="#方法一：排序" class="headerlink" title="方法一：排序"></a>方法一：排序</h4><p>算法：<br>通过将 ss 的字母重新排列成 tt 来生成变位词。因此，如果 TT 是 SS 的变位词，对两个字符串进行排序将产生两个相同的字符串。此外，如果 ss 和 tt 的长度不同，tt 不能是 ss 的变位词，我们可以提前返回。</p><ul><li>时间复杂度：O(nlogn)，假设 n 是 s 的长度，排序成本O(nlogn) 和比较两个字符串的成本 O(n)。排序时间占主导地位，总体时间复杂度为 O(nlogn)。</li><li>空间复杂度：O(1)，空间取决于排序实现，如果使用 heapsort，通常需要 O(1) 辅助空间。注意，在 Java 中，toCharArray() 制作了一个字符串的拷贝，所以它花费 O(n) 额外的空间，但是我们忽略了这一复杂性分析，因为：<ul><li>这依赖于语言的细节。</li><li>这取决于函数的设计方式。例如，可以将函数参数类型更改为 char[]。</li></ul></li></ul><p>排序字符串 为什么用堆排序？</p><h3 id="2-字符串转换整数-atoi"><a href="#2-字符串转换整数-atoi" class="headerlink" title="2.字符串转换整数 (atoi)"></a>2.字符串转换整数 (atoi)</h3><h3 id="3-反转字符串"><a href="#3-反转字符串" class="headerlink" title="3.反转字符串"></a>3.反转字符串</h3><h3 id="4-Java字符串常用api"><a href="#4-Java字符串常用api" class="headerlink" title="4.Java字符串常用api"></a>4.Java字符串常用api</h3><p>（7）public int compareTo(String anotherString);  //按字典顺序逐个字符进行比较，返回的数即为字符间的差距（大小关系）。若字符大于anotherString的字符，则返回正数，小于则返回负数，等于则返回0。</p><p>（9）public boolean startsWith(String prefix);  //判断字符串是否以指定字符串prefix开头。</p><p>（12）public boolean contains(CharSequence s);  //判断当前字符串是否包含 给定的子字符串s。</p><p>（13）public String concat(String str) ;  //用于字符串的拼接。等价于 符号 “+”。</p><p>（14）public String trim(); //用于去除字符串首尾两端的空格。</p><p>（15）public String toLowerCase(); //将字符串全转成小写字符串。</p><p>（19）public String substring(int beginIndex, int endIndex); //从当前字符串中的beginIndex位置起，取出到endIndex-1位置的字符作为一个新的字符串返回。</p><p>（20）public String replace(char oldChar, char newChar)；  //用字符newChar替换当前字符串中所有的oldChar字符，并返回一个新的字符串。</p><p>（21）public String replaceAll(String regex, String replacement);将字符串中符合regex格式的子串替换成replacement，此时并未改变原始字符串。？？？</p><p>（22）public String[] split(String regex); //将字符串使用regex标记分割，并将分割后的单词存入字符串数组中。</p><p>（23）public boolean matches(String regex); //判断当前字符串对象是否与参数regex格式相匹配。</p><h2 id="二、java-lang-StringBuffer、java-lang-StringBuilder"><a href="#二、java-lang-StringBuffer、java-lang-StringBuilder" class="headerlink" title="二、java.lang.StringBuffer、java.lang.StringBuilder"></a>二、java.lang.StringBuffer、java.lang.StringBuilder</h2><p>1、当频繁修改字符串时，需要使用 StringBuffer 和 StringBuilder 类。与String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。</p><p>2、StringBuffer与StringBuilder大体上相似，只是StringBuffer属于线程安全的。对于单线程的程序，推荐使用StringBuilder。</p><p>3、常用构造方法：（以StringBuffer为例）</p><p>　　（1）public StringBuffer(); //默认构造一个不带字符的字符串缓冲区，初始容量为16个字符。</p><p>　　（2）public StringBuffer(String str); //构造一个str.length() + 16的字符串缓冲区。</p><p>4、常用方法：（以StringBuffer为例）</p><p>（1）追加：</p><p>​    public synchronized StringBuffer append(Object obj);  //将对象追加到字符串的末尾。</p><p>（2）插入：</p><p>　　　public StringBuffer insert(int dstOffset, CharSequence s) ; //将字符串s插入到指定位置 dstOffset。字符串范围为 0 ~ length()-1。 </p><p> （3）删除：</p><p>　　　　public synchronized StringBuffer delete(int start, int end); //删除start ~ end-1 范围的字符。</p><p>　　　　public synchronized StringBuffer deleteCharAt(int index); //删除指定位置的字符。</p><p> （4）替换：</p><p>　　    public synchronized StringBuffer replace(int start, int end, String str);  //用给定 <code>String</code> 中的字符替换此序列（start ~ end-1）的子字符串中的字符。</p><p>　　　public synchronized void setCharAt(int index, char ch); //用给定的字符ch，替换指定位置的字符。</p><p>　    　public synchronized void setLength(int newLength); // 将给定的字符串，裁剪成指定长度。</p><p>（5）获取子串：</p><p>　　public synchronized String substring(int start);  //返回从start位置开始 的所有字符。</p><p>public synchronized String substring(int start, int end);  //返回 start ~ end-1 位置的所有字符。</p><p> （6）字符串反转：</p><p>　public synchronized StringBuffer reverse();  //将字符串倒序输出。</p><p> （7）查找：</p><p>　public int indexOf(String str);  //正序查找（从前往后找），返回指定子字符串在此字符串第一次出现的索引，若没有，则返回-1。</p><p>　public synchronized int indexOf(String str, int fromIndex); //从 fromIndex 位置开始查找。返回指定子字符串在此字符串第一次出现的索引，若没有，则返回-1。</p><p>　public int lastIndexOf(String str); //倒序查找（从后往前找）返回指定子字符串在此字符串第一次出现的索引，若没有，则返回-1。</p><p>　public synchronized int lastIndexOf(String str, int fromIndex) ; //从 fromIndex 位置开始查找。返回指定子字符串在此字符串第一次出现的索引，若没有，则返回-1。</p><h2 id="三、String、StringBuffer、StringBuilder的区别"><a href="#三、String、StringBuffer、StringBuilder的区别" class="headerlink" title="三、String、StringBuffer、StringBuilder的区别"></a>三、String、StringBuffer、StringBuilder的区别</h2><p>1、String中由final修饰的字符数组来保存字符串，即private final char value[]，所以String不可变。</p><p>2、StringBuffer与StringBuilder继承 AbstractStringBuilder类，且其构造方法中调用AbstractStringBuilder类的构造方法，而AbstractStringBuilder类未使用final修饰字符数组来保存字符串，即char value[]， 故StringBuilder与StringBuilder可变。</p><p>3、线程安全？<br>　　　　（1）String对象不可变，所以是线程安全的。<br>　　　　（2）StringBuffer由于方法加入同步锁，所以是线程安全的。<br>　　　　（3）StringBuilder没有同步锁，所以是线程不安全的。</p><p>　4、对于String对象，给其赋值分两种情况：<br>　　　　（1）直接赋值，即String str = “123”;时，若常量池中存在”123”，则str指向这个字符串，若不存在，则创建一个”123”并置于常量池中，将其引用返回。<br>　　　　（2）使用new关键字，即String str = new String(“123”);如果常量池中没有”123”，则创建”123”并置于常量池中，然后new关键字会在堆中创建一个String对象，并将堆中的引用返回。</p><p>　　5、使用情况？<br>　　　　（1）操作少量数据，推荐使用String。<br>　　　　（2）单线程下操作大量数据，推荐使用StringBuilder。<br>　　　　（3）多线程下操作大量数据，推荐使用StringBuffer。</p><h2 id="四、java-util-StringTokenizer？"><a href="#四、java-util-StringTokenizer？" class="headerlink" title="四、java.util.StringTokenizer？"></a>四、java.util.StringTokenizer？</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/简历个人</title>
      <link href="blog/2960379773.html"/>
      <url>blog/2960379773.html</url>
      
        <content type="html"><![CDATA[<center><font size=5><b>郭子任</b></font></center><center><font size=4>男 | 18862396192 | guoziren@mail.ustc.edu.cn | 苏州</font></center><p>求职意向：Android开发实习生                    到岗时间：一周内                        可实习时间：&gt;=6个月</p><h4 id="教育经历"><a href="#教育经历" class="headerlink" title="教育经历"></a>教育经历</h4><hr><p><strong>2019.09~2022.03   中国科学技术大学</strong>                            <strong>软件工程                                          硕士(全日制)</strong> </p><p><strong>2010.09~2014.06   武汉科技大学城市学院</strong>                     <strong>会计学                                             本科(全日制)</strong> </p><h4 id="项目经历"><a href="#项目经历" class="headerlink" title="项目经历"></a>项目经历</h4><hr><h5 id="字节跳动训练营-本地图片查看器App-4人-2020-05-20-2020-06-25"><a href="#字节跳动训练营-本地图片查看器App-4人-2020-05-20-2020-06-25" class="headerlink" title="字节跳动训练营       本地图片查看器App (4人)                                   2020.05.20-2020.06.25"></a>字节跳动训练营       本地图片查看器App (4人)                                   2020.05.20-2020.06.25</h5><p>项目地址：<a href="https://github.com/guoziren/techtrainingcamp-client-5" target="_blank" rel="noopener">https://github.com/guoziren/techtrainingcamp-client-5</a></p><ul><li><p>通过recyclerview的嵌套，Glide加载实现按日期显示系统图库所有图片</p></li><li><p>通过socket + 线程池实现局域网设备间传图功能</p></li><li><p>通过自定义view,实现了简易的雷达扫描效果</p></li></ul><h5 id="浪潮集团-话费支付SDK开发Android端-2015-10-2017-07-广州"><a href="#浪潮集团-话费支付SDK开发Android端-2015-10-2017-07-广州" class="headerlink" title="浪潮集团          话费支付SDK开发Android端                          2015.10-2017.07              广州"></a>浪潮集团          话费支付SDK开发Android端                          2015.10-2017.07              广州</h5><ul><li><p>使用代码动态创建View实现包时长业务退订，历史记录模块的界面，而不用xml     </p></li><li><p>HandlerThread处理SDK主体逻辑，Ant工具进行打包</p></li><li><p>负责项目各部分功能的测试，开发者群提供接入支持，维护《集成开发指南》等项目文档</p></li></ul><h5 id="广州木铭网络科技有限公司-乐道-网络电话iOS端-2015-05-2015-09-广州"><a href="#广州木铭网络科技有限公司-乐道-网络电话iOS端-2015-05-2015-09-广州" class="headerlink" title="广州木铭网络科技有限公司   乐道(网络电话iOS端)                 2015.05-2015.09              广州"></a>广州木铭网络科技有限公司   乐道(网络电话iOS端)                 2015.05-2015.09              广州</h5><ul><li>基于APICLoud + html,css,jquery等网页技术实现联系人，通话记录，充值等界 面以及打网络电话的功能</li></ul><h4 id="专业技能"><a href="#专业技能" class="headerlink" title="专业技能"></a>专业技能</h4><hr><ul><li>语言相关：良好的Java语言基础；熟悉JVM内存分配与回收；熟悉Java集合中ArrayList、HashMap等源码；掌握多线程编程的能力</li><li>计算机基础：掌握操作系统中的进程管理、死锁等知识；熟悉网络中HTTP,TCP/IP等协议。</li><li>Android：能熟练应用SDK开发，熟悉Android四大组件，掌握OKHttp,Glide等第三方库的使用，熟悉View事件分发过程；了解IPC机制；熟悉消息机制</li><li>测试相关：熟悉黑盒测试，白盒测试，了解Appium。</li></ul><h4 id="个人介绍"><a href="#个人介绍" class="headerlink" title="个人介绍"></a>个人介绍</h4><hr><ul><li><p>希望成为贵公司的实习生，可一周内入职，全职实习，可实习6个月及以上。</p></li><li><p>个人学习态度认真，努力上进，不限制自己，2017.12考研一战复旦计算机失败，2018.12二战科大上岸，打破本科学校没有考上C9的记录；对软件开发充满兴趣。</p><p>感谢您花时间阅读我的简历，期待能有机会和您共事。</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/java/socket</title>
      <link href="blog/4138231491.html"/>
      <url>blog/4138231491.html</url>
      
        <content type="html"><![CDATA[<h2 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h2><h3 id="1-什么是socket套接字"><a href="#1-什么是socket套接字" class="headerlink" title="1.什么是socket套接字"></a>1.什么是socket套接字</h3><p><img src=".socket_images/image-20200716124339165.png" alt="image-20200716124339165"></p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>socket是应用层与传输层的一个抽象，将复杂的TCP/IP协议隐藏在Socket接口之后，只对应用层暴露简单的接口</p><p>2.</p><p>ServerSocket 类的作用是创建 Socket （套接字）的服务端， 而 Socket 类的作用是创建 Socket 的客户端。 在.</p><p>ServerSocket 类中的 public Socket accept（）方法的作用是侦昕并接收此套接字的连接。 此方法在连接传入之前一直阻塞。 public Socket accept（）方法的返回值是 Socket 类型 。</p><p>InputStream 类中的 read（）方法 也同样具有阻塞特性 。</p><pre><code>read（）方法阻塞的原因是客户端并未发送数据到服务端，服务端一直在尝试读取从客户 端传递过来的数据，因为客户端从未发送数据给服务端，所以服务端一直在阻塞。</code></pre><p>new ServerSocket (8088）；”中的 8088 是设置的服务器的 Socket 端口 号</p><p>构造方法 public Socket (String host, int port）的第 一个参数 host 可以写成 IP 地址或域 名 。</p><p>1.客户端向服务端传递字符串</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//服务端读</span><span class="token keyword">char</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> charArray <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">char</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>InputStream inputStream <span class="token operator">=</span> socket <span class="token function">getinputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>InputStre缸nReader inputStreamReader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span> <span class="token punctuation">(</span>inputStream<span class="token punctuation">)</span> <span class="token punctuation">;</span><span class="token keyword">int</span> readLength <span class="token operator">=</span> inputStreamReader <span class="token punctuation">.</span> <span class="token function">read</span><span class="token punctuation">(</span>charArray<span class="token punctuation">)</span> <span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>readLength <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//客户端通过outputStream写</span>OutputStream outputStream <span class="token operator">=</span> socket <span class="token punctuation">.</span> <span class="token function">getOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">;</span> outputStream <span class="token punctuation">.</span> write （ ” 我是外星人 ” <span class="token punctuation">.</span> <span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">;</span> outputStream<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">;</span></code></pre><p>2.允许多次调用 write（）方法进行写入操作</p><p>write（） 方法允许多次被调用 ，每执行一次就代表传递一次数据。(前提流没有关闭)</p><p>读的那一端while循环去读，直到写的那一端调用close，代表到达流的结尾，不再传输数据</p><ol start="3"><li>实现服务端与客户端多次的往来通信</li></ol><p>前面的 实验都是服务端与客户端只进行了 l 次 通信， 那么如何实现连续多次的长连接通信呢？</p><p>就是流不关，多写几次读写的代码，。</p><p>4.调用 Stream 的 close（）方法造成 Socket 关闭</p><p>inputStream . close();</p><p>此行代码的功能是将 InputStream 关闭 。 Stream 在 Socket 技术中进行应用时， 如果关闭 返回的 Stream ，将关闭关联的 Socket （套接字）</p><p>如果 Socket 关闭，则服务端与客户端不能进行通信。 因 此 ， 当执行代码 OutputStream outputStream = socket.getOutputStream（）取得输出流时，就会 出现异常。</p><p>5.使用 Socket 传递 PNG 图片文件（字节流）</p><p>读到缓存的字节数组中。</p><p>3 次“握手气的过程如下 。</p><p>1 ）客户端到服务端 ： 我要连接。 </p><p>2 ）服务端到客户端：好的， 已经连接上了 。 </p><p>3 ）客户端到服务端：收到， 确认已连接上了 。</p><p>4）4  次挥手过程  。见其他地方</p><p>6.“握手”的时机与立即传数据的特性</p><p>服务端与客户端进行“握手”的时机不是在执行 accpet（）方法时 ，而是在 ServerSocket 对象创建出来并且绑定到指定的地址与端口时。</p><ol start="7"><li>结合多线程 Thread 实现通信</li></ol><p>在 Socket 技术中，常用的实践方式就是 Socket 结合 Thread 多线程技术，客户端每发起 一次新的请求，就把这个请求交给新创建的线程来执行这次业务。当然，如果使用线程池技 术，则会更加高效。</p><pre><code>ServerSocket server Socket =new ServerSocket(8888) ; int runTag = 1 ;while (run Tag == 1) { Socket socket= serverSocket. a ccept() ; BeginThread beginThread = new BeginThread(socket); beginThread.start();}serverSocket . close();</code></pre><h2 id="2-ServerSocket类的使用"><a href="#2-ServerSocket类的使用" class="headerlink" title="2.ServerSocket类的使用"></a>2.ServerSocket类的使用</h2><h3 id="1-超时："><a href="#1-超时：" class="headerlink" title="1.超时："></a>1.超时：</h3><p>setSoTimeout (timeout） 方法 的作用是设置超时时 间 ，通过指定超 时 timeout 值启用／禁 用 SO TIMEOUT ，以 ms 为单位。</p><p>如 果超过超时值， 将 引 发 java.net. SocketTimeoutException ， 但 Se凹erSocket 仍旧有效， 在结合 try-catch 结构后 ， 还可 以 继续进 行 accept（）方法 的操作。 SO_TIMEOUT 选项必须在进入阻塞操作前被启用才能生效。</p><p>timeout 0 被解释为无穷大超时值,默认值是 0 ， 即永远等待</p><p>getSoTimeout（） 方法的作用是获取 SO TIMEOUT 的设置</p><h3 id="2-构造方法-public-ServerSocket-int-port-int-backlog"><a href="#2-构造方法-public-ServerSocket-int-port-int-backlog" class="headerlink" title="2.构造方法 public ServerSocket( int port,int backlog)"></a>2.构造方法 public ServerSocket( int port,int backlog)</h3><p>利用指定的 backlog 创建服务器套接字并将其绑定到指定的本地端口号 port。 对 port 端 口参数传递值为 0 ，意味着将自动分配空闲 的端口号。</p><p>传入 backlog 参数的作用是设置(允许接受客户端连 接请求的个数,默认是50)最大等待队列长度，如果队列己满，则拒绝该连接（抛出异常 Connection refused :connect）。</p><h3 id="3-构造方法-ServerSocket-int-port，-int-backlog-lnetAddress-bindAddr）的使用"><a href="#3-构造方法-ServerSocket-int-port，-int-backlog-lnetAddress-bindAddr）的使用" class="headerlink" title="3.构造方法 ServerSocket (int port， int backlog, lnetAddress bindAddr）的使用"></a>3.构造方法 ServerSocket (int port， int backlog, lnetAddress bindAddr）的使用</h3><p>使用指定的 port 和 backlog 将 Socket 绑定到本地 InetAddress bindAddr 来创建服务端.</p><p>如果 bindAddr 为 null ，则默认接受任 何 ／ 所有本地地址上的连接 。 注意， 端口号必须 0 ～ 65535 （包括两者） 。</p><blockquote><p> 注:多宿主主机代表一台计算机有两块网卡， 每个网卡有不同的 IP 地址， 也有可能出现一 台计算机有 l 块网卡， 但这块网卡有多个 IP 地址的情况。</p></blockquote><p>区别：</p><p>ServerSocket 类有 3 个构造方法， 在使用上还是有一些区别的 。</p><p>I ）使用构造方法 public ServerSocket (int port）和 public ServerSocket (int p。此， int backlog)</p><p>创建 ServerSocket 对象， 则客户端可以使用服务器任意的 IP 连接到 ServerSocket 对象中 。</p><p> 2 ）在使用 public ServerSocket (int port, int backlog, InetAddress bindAddr）构造方法中 的参数 bindAddr 创建 ServerSocket 对象后， 客户端想要连接到 服务端， 则客户端 Socket 的 构造方法的参数要写上与 ServerSocket 构造方法的参数 bindAddr 相同的 IP 地址， 不然就会 出现异常 。</p><h3 id="4-绑定到指定的-Socket-地址"><a href="#4-绑定到指定的-Socket-地址" class="headerlink" title="4.绑定到指定的 Socket 地址"></a>4.绑定到指定的 Socket 地址</h3><p>public void bind (SocketAddress endpoint）方法的主要作用是将 ServerSocket 绑定到特定的 Socket 地址 (Ip 地址和端口号），使用这个地址与客户端进行通信。 如果地址为 null ，则 系统将挑选一个临时端口和一个有效本地地址来绑定套接字。</p><p><font color="red"><strong>该方法的使用场景就是在使用 ServerSocket 类的无参构造方法后想指定本地端口 。</strong></font></p><p>SocketAddress 类是抽象类，有 1 个子类 InetSocketAddress，它提供不可变对象，供套接字用于绑定 、 连接或用作返回值。 注意：InetAddress 类代表 IP 地址，而 In etSocketAddress 类代表 Socket 地址。</p><p>InetSocketAddress 类有 3 个构造方法，说明如下 ：</p><p>1 ）构造方法 public InetSocketAddress (int port）的作用是创建套接字地址，<strong>其中 IP 地址 为通配符地址</strong>，端口号为指定值。 有效的端口值介于 0 ～ 65535 之间 。 <strong>端口号传人 0 代表在 bind 操作中随机挑选空闲的端口</strong>。</p><p>通配符是一个特殊的本地 IP 地址 。 它通常表示 “任何”，只能用于 bind 操作 。</p><p>2 ）构造方法 public InetSocketAddress (String hostname, int port）的作用是根据主机名和 端口号创建套接字地址。 有效的端口值介于 0 ～ 65535 作中随机挑选空闲的端口 。之间 。</p><p>3 ）构造方法 public InetSocketAddress (lnetAddress addr, int port）的作用根据 IP 地址和 端口号创建套接字地址。 有效的端口值介于 0 ～ 65535 之间 。</p><h4 id="InetSocketAddress的2个方法"><a href="#InetSocketAddress的2个方法" class="headerlink" title="InetSocketAddress的2个方法"></a>InetSocketAddress的2个方法</h4><p><code>getHostName（）</code>和 <code>getHostString （）</code>方法的区别</p><p> <code>public final String getHostName（）</code>方法的作用是获取主机名 。 注意，如果地址是用字面IP 地址创建 的，则 此方法可能触发名称服务反 向 查找， 也就是利用 DNS 服务通过 IP 找到 域名 。</p><p><code>public final String getHostString（）</code>方法的作用是返回主机名或地址的字符串形式，</p><p>如果它没有主机名 ，则返回 IP 地址。 这样做的好处是不尝试反 向查找 。</p><h3 id="5-获取本地SocketAdress-对象以及本地端口"><a href="#5-获取本地SocketAdress-对象以及本地端口" class="headerlink" title="5.获取本地SocketAdress 对象以及本地端口"></a>5.获取本地SocketAdress 对象以及本地端口</h3><p>getLoca!SocketAddress（）方法用来获取本地的 SocketAddress 对象 ，它返回此Socket 绑定的端点的地址， 如果尚未绑定， 则返回 null。 </p><p>getLoca!Port（）方法用来获取Socket 绑定到 本地的端 口 。</p><pre><code>ServerSocket serverSocket = new ServerSocket();System . out . println （&quot;new ServerSocket()无参构造的端口是”＋serverSocket. getLocalPort());//将输出-1</code></pre><h3 id="6-关闭与获取关闭状态-判断-Socket-绑定状态"><a href="#6-关闭与获取关闭状态-判断-Socket-绑定状态" class="headerlink" title="6.关闭与获取关闭状态 判断 Socket 绑定状态"></a>6.关闭与获取关闭状态 判断 Socket 绑定状态</h3><p>public void close（）方法的作用是关闭此套接字。</p><p>public boolean isClosed（）方法的作用是返回 ServerSocket 的关闭状态。</p><p>public boolean isBound（）方法的作用是返回 ServerSocket 的 绑定状态。</p><h3 id="7-获得-IP-地址信息"><a href="#7-获得-IP-地址信息" class="headerlink" title="7.获得 IP 地址信息"></a>7.获得 IP 地址信息</h3><p>getlnetAddress（）方法用来获取 Socket 绑定的本地 IP 地址信息 。 的，则该方法返回 null。</p><h3 id="8-Socket-选项-ReuseAddress"><a href="#8-Socket-选项-ReuseAddress" class="headerlink" title="8.Socket 选项 ReuseAddress"></a>8.Socket 选项 ReuseAddress</h3><p>public void setReuseAddress(boolean on）方法的作用是启用 ／禁用 SO_REUSEADDR 套 接字选项 ,实现端口复用。</p><p> 关闭 TCP 连接时 ，该连接可能在关闭后 的一段时间内 保持超时状态 （通常称为 TIME_ WAIT 状态或 2MSL 等待状态） 。 对于使用已知套接字地址或端口的应用程序而言，如果存在处于超时状态的连接（包括地址和端口），则应用程序可能不能将套接字绑定到所需的 SocketAddress 上 。</p><p>public boolean getReuseAddress（）方法的作用是测试是否启用 SO_REUSEADDR。</p><p>在调用 Socket 类的 close（）方法时·，会关闭当前连接，释放使用的端口，但在操作系统 层面，并不会马上释放当前使用的端口.</p><p>什么是 TIME WAIT 状态？</p><p>服务端（ Server）与客户端（ Client）建立 TCP 连接之后，主动关闭连接的一方就会进入 TIME WAIT 状态。 例如，客户端主动关闭连接时，会发送最后 一个 ACK ，然后客户端就会进入 TIME WAIT 状态，再“停留若干时间’，然后进入 CLOSED 状态 。 在 Linux 操作系统中，当在“停留若干时间”段时，应用程序是可以复用呈 TIME WAIT 状态的端口的，这样可提升端口利用率。</p><p><img src=".socket_images/image-20200716144345398.png" alt="image-20200716144345398"></p><p><img src=".socket_images/image-20200716144356677.png" alt="image-20200716144356677"></p><h3 id="9-Socket-选项-ReceiveBufferSize"><a href="#9-Socket-选项-ReceiveBufferSize" class="headerlink" title="9.Socket 选项 ReceiveBufferSize"></a>9.Socket 选项 ReceiveBufferSize</h3><p>每个套接口都有一个发送缓冲区和一个接收缓冲区.</p><p>SO RCVBBUF 的值用于设置内部套接字接收缓冲区的大小和设置公布到远程同位体的 TCP 接收窗 口的大小</p><p>在接受的套接字中，实际被采纳的值必须在accept（）方法返回套接字后通过调用 Socket.getReceiveBufferSize（）方法进行获取。</p><p>对于客户端， SO RCVBUF 选项必须在 connect 方法调用之前设置 ，对于服务端， SO_RCVBUF 选项必须在 bind（）前设置。</p><p><img src=".socket_images/image-20200716150058192.png" alt="image-20200716150058192"></p><p><img src=".socket_images/image-20200716150019208.png" alt="image-20200716150019208"></p><h2 id="3-Socket类的使用"><a href="#3-Socket类的使用" class="headerlink" title="3.Socket类的使用"></a>3.Socket类的使用</h2><h3 id="1-绑定-bind-与-con-nect-以及端口生成的时机"><a href="#1-绑定-bind-与-con-nect-以及端口生成的时机" class="headerlink" title="1.绑定 bind 与 con nect 以及端口生成的时机"></a>1.绑定 bind 与 con nect 以及端口生成的时机</h3><p>public void bind (SocketAddress bindpoint） 方法 的作用是将套接字绑定到本地地址。 如果地址为 null ，则系统将随机挑选一个空闲的端 口和一个有效的本地地址来绑定套接字。（是客户端自己的ip地址和端口号）</p><p><code>new Socket (）</code> 也会自动给自己这一端分配一个端口号，</p><p>代码  <code>new Socket (&quot;localhost”， 8888）</code> 来创建客户端的 Socket 井连接 服务端的 8888 端口， 客户端 的 端口并没有指定 ， 而是采用 自动分配端 口 号 的算法</p><p>客户端的 Socket 中是可以指定使用某个具体的端口的 ， 这个功能就 由 bind（） 方法提供</p><p>public void connect (SocketAddress endpoint）方法的作用就是将此套接字连接到服务端。</p><blockquote><p>注:bind要在connect之前调用</p></blockquote><h3 id="2-连接与超时"><a href="#2-连接与超时" class="headerlink" title="2.连接与超时"></a>2.连接与超时</h3><p><code>public void connect (SocketAddress endpoint, int timeout）</code> 方法的作用是将此套接宇连接到服务端， 并指定一个超时值。 超时值是 0 意味着无限超时 。</p><h3 id="3-获得远程端口与本地端口"><a href="#3-获得远程端口与本地端口" class="headerlink" title="3.获得远程端口与本地端口"></a>3.获得远程端口与本地端口</h3><p>public int getPort（）方法的作用是返回此套接宇连接到的远程端口 。</p><p>public int getLocalPort（）方法的作用是返回此套接字绑定到的本地端口。</p><h3 id="4-获得本地-lnetAddress-地址与本地-SocketAddress-地址"><a href="#4-获得本地-lnetAddress-地址与本地-SocketAddress-地址" class="headerlink" title="4.获得本地 lnetAddress 地址与本地 SocketAddress 地址"></a>4.获得本地 lnetAddress 地址与本地 SocketAddress 地址</h3><p><code>public InetAddress getLocalAddress（）</code>方法的作用是获取套接字绑定的本地 InetAddress 地址 信息 。</p><p><code>public SocketAddress getLocalSocketAddress()</code>方法的作用是返回此套接字绑定的端点的 Socket-Address 地址信息 。 如果尚未绑定， 则返回</p><p>null 。</p><h3 id="5-获得远程-lnetAddress-与远程-SocketAddress（）地址"><a href="#5-获得远程-lnetAddress-与远程-SocketAddress（）地址" class="headerlink" title="5.获得远程 lnetAddress 与远程 SocketAddress（）地址"></a>5.获得远程 lnetAddress 与远程 SocketAddress（）地址</h3><p>public InetAddress getlnetAddress（）方法的作用是返回此套接字连接到的远程 的 InetAddress 地址。 如果套接字是未连接的， 则返回 null。</p><p> public SocketAddress getRemoteSocketAddress（）方法的作用是返回此套接字远程 端点的SocketAddress 地址， 如果未连接 ， 则返回 null 。</p><h3 id="6-套接字状态的判断"><a href="#6-套接字状态的判断" class="headerlink" title="6.套接字状态的判断"></a>6.套接字状态的判断</h3><p>public boolean isBound（）方法的作用是返回套接字的绑定状态 。 如果将套接字成功地绑 定到一个地址，则返回 true。</p><p>public boolean isConnected（） 方法的作用是返 回套接字的连接状态 。 如果将套接字成功 地连接到服务端，则为 true。 </p><p>public boolean isClosed（）方法的作用是返回 套接字 的关闭状态 。 如果已经关闭了套接 字， 则返回 true </p><p>public synchronized void close（）方法的作用是关闭此套接字。 所有当前阻塞于此套接字上的 I/0 操作中的线程都将抛出 SocketException。 <strong>套接字被关闭后，便不可在以后的网络连接 中使用 （ 即无法重新连接或重新绑定），如果想再次使用套接字， 则需要创建新的套接字。</strong></p><p><strong>关闭此套接字也将会关闭该套接字 的 InputStream 和 OutputStream</strong>。 如果此套接字有一个与之关联的通道，则关闭该通道 。</p><h3 id="7-开启半读与半写状态、"><a href="#7-开启半读与半写状态、" class="headerlink" title="7.开启半读与半写状态、"></a>7.开启半读与半写状态、</h3><p><code>public void shutdownlnput（）</code>方法的作用是将套接字的输入流置于“流的末尾 EOF ”，也就是在套接字上调用 shutdownlnput（）方法后从套接字输入流读取内容，流将返回 EOF （文件结束符）.发送到套接字的输入流的任何数据都将在确认后被静默丢弃。 一端 能读，另 一端不能读，称为半读。</p><p><code>public void shutdownOutput（）</code>方法的作用是禁用此套接字的输出流。 对于 TCP 套接字 ， 任何以前写入的数据都将被发送，并且后跟 TCP 的正常连接终止序列 。调 用 shutdownOutput（）方法后,写入套接字输出流，则该流将抛出 IOException。 一 端能写，另一端不能写，称为半写 。</p><h3 id="8-判断半读半写状态"><a href="#8-判断半读半写状态" class="headerlink" title="8.判断半读半写状态"></a>8.判断半读半写状态</h3><p>public boolean islnputShutdown（）方法 的作用 是返回 是否关 闭 套接字 连接的半读状态 (read-half） 。 如果己关闭套接字 的输入， 则返回 true。</p><p>public boolean isOutputShutdown（）方法的作用是返回是否关闭 套接字连接的半写状态 (write-half） 。 如果已关闭套接字的输出，则返回 true。</p><h3 id="9-Socket-选项-TcpNoDelay-略"><a href="#9-Socket-选项-TcpNoDelay-略" class="headerlink" title="9 Socket 选项 TcpNoDelay(略)"></a>9 Socket 选项 TcpNoDelay(略)</h3><p>什么是 MSS 呢？ MSS (Maximum Segment Size ）即最大报文段长 度 。 在 TCP/IP 中，无论发送多少数据，总是要在数据前面加上协议头 ， 同时，对方接收到 数据，也需要发送回 ACK 以表示确认。 为了尽可能地利用网 络带宽， TCP 总是希望尽可能 一次发送足够大的数据，此时就可以使用 MSS 来进行设置。 MSS 选项是 TCP/IP 定义的一 个选项， 该选项用于在 TCP/IP 连接建立时 ， 收发双方协商通信时每一个报文段所能承载的 最大数据长度，它的计算方式如下 ： MSS = MTU - 20 字 节的 TCP 报头 － 20 字节的 IP 报头</p><p>在以太网环境下， MSS 值一般就是 1500 - 20 - 20 = 1460 字节 。 TCP/IP 希望每 次都能 够以 MSS （最大尺寸）的数据块来发送数据，以增加每次网络传输的数据量 。</p><h3 id="10-Socket-选项-Send-BufferSize"><a href="#10-Socket-选项-Send-BufferSize" class="headerlink" title="10.Socket 选项 Send BufferSize"></a>10.Socket 选项 Send BufferSize</h3><p>SO_SNDBUF 选项是设置发送缓冲区的大小的 。</p><h3 id="11-Socket选项-Linger"><a href="#11-Socket选项-Linger" class="headerlink" title="11.Socket选项 Linger"></a>11.Socket选项 Linger</h3><p>Socket 中的 SO_LINGER 选项用来控制 Socket 关闭 close（）方法时的行为 。 在默认情况 下，执行 Socket 的 close（）方法后， 该方法会立即返回， 但底层的 Socket 实际上并不会立即 关闭， 它会延迟一段时间 。 在延迟的时间里做什么呢？是将“发送缓冲区”中的剩余数 据在 延迟的时间内继续发送给对方， 然后才会真正地关闭 Socket 连接。</p><p>public void setSoLinger(boolean on, int linger）方法的作用是启用／禁用具有指定逗留时 间（以秒为单位）的 SO LINGER。该设置仅影响套接字关闭 。 参数 on 的含义为是否逗留， 参数 linger 的含义为逗留时间， 单位为秒。</p><p>1) on 传入 false,SO LINGER 功能被屏蔽</p><p>2) on 传人 true, linger 等于 0 ，当调用 Socket 的 close（）方法时，将立即中断连接，也 就是彻底丢弃在缓冲区中未发送完的数据，并且发送一个 RST 标记给对方。</p><p>3) on 传人 true , linger 大于 65535 时， linger 值就被赋值为 65535 。</p><p>4) on 传入 true , linger 不大于 65535 时， linger 值就是传人的值。</p><h3 id="12-Socket-选项-Timeout"><a href="#12-Socket-选项-Timeout" class="headerlink" title="12.Socket 选项 Timeout"></a>12.Socket 选项 Timeout</h3><h3 id="13-Socket-选项-OOBlnline"><a href="#13-Socket-选项-OOBlnline" class="headerlink" title="13.Socket 选项 OOBlnline"></a>13.Socket 选项 OOBlnline</h3><p>Socket 的选项 SO OOBINLINE 的作用是在套接字上接收的所有 TCP 紧 急数据都将通 过套接字输入流接收。 禁用该选项时（默认）， 将悄悄丢弃紧急数据。 OOB ( Out Of Bound,</p><p>带外数据）可以理解成是需要紧急发送的数据。</p><h3 id="14-Socket-选项-KeepAlive"><a href="#14-Socket-选项-KeepAlive" class="headerlink" title="14.Socket 选项 KeepAlive"></a>14.Socket 选项 KeepAlive</h3><p>Socket 选项 so 阻EPALIVE 的作用是在创建了服务端与客户端时，使客户端连接上服务 端。 当设置 so 阻EPALIVE 为阳e 时，若对方在某个时间（时间取决于操作系统内核的设置 ）内没有发送任何数据过来 那么端点都会发送一个 ACK 探测包到对方，探测双方的 TCP/IP 连 接是否有效（对方可能断电，断网） 。 如果不设置此选项，那么 当客户端着机时，服务端永远 也不知道客户端岩机了，仍然保存这个失效的连接。如果设置了 比选项，就会将此连接关闭 。</p><p>public boolean getKeepAlive（）方法的作用是判断是否启用 SO_KEEPALIVE 选项 。</p><p>public void setKeepAlive(boolean on）方法的作用是设置是否启用 SO_KEEPALIVE 选 项 。 参数 on 代表是否开启保持活动状态的套接字。</p><p><strong>该选项在 实际软件开发中并不是常用的技术</strong> ，判断连接是否正常时， 较常用的办法是启动 1 个线程， 在线程中使用轮询嗅探的方式来判断连接是否为正常 的状态 。</p><h3 id="15-Socket-选项-TrafficClass"><a href="#15-Socket-选项-TrafficClass" class="headerlink" title="15 Socket 选项 TrafficClass"></a>15 Socket 选项 TrafficClass</h3><p>IP 规定了以下 4 种服务类型，用来定性地描述服务的质量。</p><p> 1 ) IPTOS LOWCOST ( Ox0 2 ） ： 发送成本低。 </p><p>2 ) IPTOS R ELIAB ILITY ( Ox04 ） ： 高可靠性，保证把数据可靠地送到目的地。</p><p>3 ) IPTOS_THROUGHPUT ( Ox08 ） ： 最高吞吐量,一次可 以接收或者发送大批量的数据。</p><p> 4) IPTOS LOWDELAY ( OxlO ）： 最小延迟，传输数据的速度’快，把数据快速送达目的地。 这 4 种服务类型还可以使用 “或”运算进行相应 的组合 。</p><h2 id="4-基于-UDP-的-Socket-通信"><a href="#4-基于-UDP-的-Socket-通信" class="headerlink" title="4.基于 UDP 的 Socket 通信"></a>4.基于 UDP 的 Socket 通信</h2><p>注意， 在使用 UDP 实现 Socket 通信时一定要使用两台真机， 不要使用虚拟机， 不然会出现 UDP 包无法发送的情况 。</p><p>UDP (User Datagram Protocol ，用户数据报协议）是一种面向无连接的传输层协议， 提</p><p>供不可靠的信息传送服务 。 无连接是指通信时服务端与客户端不需要建立连接， 端，对方获取数据包再进行数据的处理。</p><p>直接把数据包从一端发送到另 一UDP 是“不可靠的”， 是指该协议在网络环境不好的情况下， 会丢失数据包， 因为没有 数据包重传的功能， 另外它也不提供对数据包进行分组 、 组装， 以及不能对数据包进行排 序，这些都是它和 TCP 最主要的区别 。 使用 UDP 发送报文后， 是无法得知其是否安全， 以 及是否完整地到达目的地的 。</p><p>UDP 将网络数据流量压缩成数据包的形式， 一个典型的数据包就是一个二进制的数据传输 单位， 每一个数据包的前 8 个字节用来包含报头信息， 剩余字节则用来包含具体的传输数据。</p><p>因为 UDP 报文没有可靠性保证 、 没有顺序保证， 以及没有流量控制等功能， 所以它可靠性较差 。 但是，正因为 UDP 的控制选项较少，在数据传输过程中延迟小 、数据传输效率 高，因而适合对可靠性要求不高的应用程序 。</p><p>在选择使用某种协议的时候，选择 UDP 必须要谨慎，因为在网络质量不好的情况下， UDP 的数据包丢失的情况会比较严重，但正是因为它是无连接型协议，因而具有资源消耗小、处理速度快的优点 。 通常音频 、 视频和普通数据在传送时使用 UDP 较多 ，因为它们 即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响，如视频聊天时，丢失某些帧对聊天效果影响不大。</p><p>TCP 中包含了专门的传递保证机制，来确保发送的数据能到达对端，并且是有序 的 。</p><p>UDP 与 TCP 不同， UDP 并不提供数据传送的保证机制，如果在从发送方到接收方的传递过 程中出现数据报的丢失，协议本身并不能做出任何检测或提示，因此，经常把 UDP 称为不可靠的传输协议。 另外，相对于 TCP, UDP 的另外一个不 同之处是不能确保数据的发送和接收的顺序 。</p><p>TCP 与 UDP 各有利弊，在不同的场景要使用不同的技术 。</p><h3 id="1-使用-UDP-实现-Socket-通信"><a href="#1-使用-UDP-实现-Socket-通信" class="headerlink" title="1.使用 UDP 实现 Socket 通信"></a>1.使用 UDP 实现 Socket 通信</h3><p>使用 UDP 实现 Socket 通信时，服务端与客户端都是使用 DatagramSocket 类，传输 的数据要存放在 DatagramPacket 类中 。</p><p>DatagramSocket 类表示用来发送和接收数据报包的 套接字 。数据报套接字是包投递 服务的发送或接收点 。</p><p>在 DatagramSocket 上总是启用 UDP 广播发送 。 为了接收广播包，应该将 DatagramSocket 绑定到<strong>通配符地址?</strong> 。 在某些实现中，将 DatagramSocket 绑定到一个更加具体的地址时广播包也 可以被接收。</p><p>DatagramPacket 类表示数据报包。数据报包用来实现无连接包投递服务 。</p><p>DatagramSocket 类中的 public synchronized void receive(DatagramPacket p）方法</p><ul><li>作用 是从此套接字接收数据报包 ,此方法在接收到数据报前 一直阻塞。</li><li>当此方法返回时， DatagramPacket 的 缓 冲区填充了接收的数 据 。</li><li>数据报包也包含发送方的 IP 地址和发送方机器上的端口号。</li><li>数据报包对象的 length 字段包含所接收信息的长度 。 如果发送 的信息比接收端 包关联的 byte［］长度长，该信息将被截短。 如果发送信息的长度大于 65507 ，则发送端出现 异常。</li></ul><p>DatagramSocket 类中的 public void send(DatagramPacket p）方法</p><ul><li>作用是从此套接字发 送数据报包。 </li><li>DatagramPacket 包含的信息有：将要发送的数据及其长度 、 远程主机的 IP 地 址和远程主机的端口号。</li></ul><p>DatagramPacket 类中的 public synchronized byte[] getData（）方法</p><ul><li>作用是返回数据缓冲 区 。 </li><li>接收到的或将要发送的数据从缓冲区中的偏移量 offset 处开始，持续 length 长度 。</li></ul><p>eg:实现的是客户端使用 UDP 将字符串 1234567890 传递到服务端。</p><pre><code></code></pre><h3 id="2-测试发送超大数据量的包导致数据截断的情况"><a href="#2-测试发送超大数据量的包导致数据截断的情况" class="headerlink" title="2.测试发送超大数据量的包导致数据截断的情况"></a>2.测试发送超大数据量的包导致数据截断的情况</h3><p>理论上， 一个 UDP 包最大的长度为 2^16^ - 1 ( 65536 一 1 = 65535 ），因此， IP 包最大的发 送长度为 65 535 。 但是， 在这 65535 之内包含 IP 协议头的 20 个字节， 还有 UDP 协议头的 8 个字节， 即 65535 一 20 - 8 = 65507 ，因此， UDP 传输用户数据最大的长度为 65507 。 如果 传输的数据大于 65507 ，则在发送端出现异常 。</p><h3 id="3-Datagram-Packet-类中常用-API-的使用"><a href="#3-Datagram-Packet-类中常用-API-的使用" class="headerlink" title="3.Datagram Packet 类中常用 API 的使用"></a>3.Datagram Packet 类中常用 API 的使用</h3><p>DatagramPacket 类中的 public synchronized void setData(byte[] but) 方法的作用是为此包 设置数据缓冲区 。 将此 DatagramPacket 的偏移量设置为 0 ，长度设置为 buf 的长度 。</p><p>DatagramPacket 类中的 public synchronized void setData(byte[] buf， int offset， int length) 方法的作用是为此包设置数据缓冲 区 。 此方法设置包的数据 、 长度和偏移量。</p><p>DatagramPacket 类中的 public synchronized int getOffset（）方法的作用是返回将要发送或 接收到的数据的偏移量。</p><p>DatagramPacket 类中的 public synchronized void setLength(int length）方法的作用是为此包设置长度 。 包的长度是指包数据缓 冲区中将要发送的字节数， 或用来接收数据的包数据缓 冲 区的字节数。 长度必须小于或等于偏移量与包缓冲区长度之和 。</p><h3 id="4-使用-UDP-实现单播"><a href="#4-使用-UDP-实现单播" class="headerlink" title="4 使用 UDP 实现单播"></a>4 使用 UDP 实现单播</h3><p>要已知对方的ip地址</p><h3 id="5-使用-UDP-实现广播"><a href="#5-使用-UDP-实现广播" class="headerlink" title="5 使用 UDP 实现广播"></a>5 使用 UDP 实现广播</h3><pre><code>DatagramSocket socket = new DatagramSocket() ;socket.setBroadcast( true ) ;socket.connect(InetAddress.getByName(”192.168.0.255”),7777) ;String newString = ” _ 12345 ”; byte [] byteArray = newString .getBytes() ; DatagramPacket myPacket = new DatagramPacket(byteArray, socket. send (my Packet) ; socket.close() ;</code></pre><p>和单播的区别就是connect方法的地址为广播地址</p><p><img src=".socket_images/image-20200716155654984.png" alt="image-20200716155654984"></p><p><img src=".socket_images/image-20200716155708422.png" alt="image-20200716155708422"></p><h3 id="6-使用-UDP-实现组擂"><a href="#6-使用-UDP-实现组擂" class="headerlink" title="6 使用 UDP 实现组擂"></a>6 使用 UDP 实现组擂</h3><p>“组播”就是将数据报文让指定的计算机知道。 组播也称为多播 。</p><p>如果是发送数据报包 ， 则可以不调用 joinGroup（） 方法加入多播组 ；如果是接收数据报</p><p>包 ， 则必须调用 joinGroup（） 方法加入多播组 。</p><pre><code>socket joinGroup(InetAddress . getByName ( ” 224.0.0.5 ” ));</code></pre><h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5 小结"></a>5 小结</h2><p>本章主要介绍了使用 ServerSocket 和 Socket 实现 TCP/IP 数据通信，使用 DatagramSocket 和 DatagramPacket 实现 UDP 数据通信，并详细介绍了这些类中 API 的使用，以及全部 Socket Option 选项的特性，同时，分析了 TCP/IP 通信时的“握手”与“挥手”，熟练掌握 这些知识有助于理解网络编程的特性，对学习 ServerSocketChannel 通道起到非常重要的铺 垫作用 。 那么在下一章就要学习选择器与 ServerSocketChannel 通道实现多路复用，深入到 NIO 高性能处理的核心 。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/面经/字节跳动/Untitled</title>
      <link href="blog/573137931.html"/>
      <url>blog/573137931.html</url>
      
        <content type="html"><![CDATA[<h2 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h2><p>synchronized</p><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>volatile可以实现同步吗？</p><h3 id="synchronized修饰静态方法的对象是什么？"><a href="#synchronized修饰静态方法的对象是什么？" class="headerlink" title="synchronized修饰静态方法的对象是什么？"></a>synchronized修饰静态方法的对象是什么？</h3><h3 id="什么时候锁类，什么时候锁对象？"><a href="#什么时候锁类，什么时候锁对象？" class="headerlink" title="什么时候锁类，什么时候锁对象？"></a>什么时候锁类，什么时候锁对象？</h3><p>实现同步？</p><p>实现原子性操作的有哪些方法？3个</p><p>看你写了，hashmap 和arrlist了解比较清楚？</p><p>插入后，如何进行扩容的？</p><p>头插法 尾插法 ，为什么改成尾插法</p><p>hashmap是线程不安全，线程安全的hashmap有哪几种？</p><p>​    hashtable  concurrenthashmap(分段锁？)</p><p>LinkedListHashmap  LRU   操作系统中的LRU</p><p>代码层通过什么样的数据结构实现的？</p><p>LinkedListHashmap可以实现LRU吗？可以通过，access变量</p><p>[18:00 ]  ThreadLocal原理</p><p>【22：00】问答？里有写HandlerThread，可以简单介绍一下吗？</p><p>【24：00】是如何跟主线程的handler通信的？</p><p>【25：00】HandlerThread发消息是一个串行的，有什么缺点？</p><p>【26：00】handler发送消息有哪几种方式？  消息怎么入队 怎么出队</p><p>【28:00】dispatatchmessage 有1个三种判断？ </p><p>sendmessagedelay ,post ,直接写一个消息的话，哪个消息会最先被分发到？</p><p>【29:30】 idle handler是什么？ 他的使用场景？</p><p>【31：50】如何实现一个圆角矩形的view ， 比如一个button，实现圆角矩形</p><p>可以理解为一个自定义view 或者用什么方式实现他？</p><ul><li>cardview</li><li>xml实现：/<shape>corner</li><li>自定义view 中的draw?</li></ul><p>【35:00】算法：合并两个有序数组为一个有序数组</p><p>先说思路  再写</p><p>【】从后往前合并</p><h2 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h2><p>【00:00】进程和线程</p><p>上下文切换， 进程切换 和线程切换的区别。</p><p>【02 : 15】进程间通信机制</p><p>【03：00】多线程可能会产生死锁，  死锁产生的原因和解决办法</p><p>【04:50】java里面 线程之间的同步怎么来实现的   多种方法</p><p>volite实现</p><p>【06:30】常见的http协议的状态码，http请求有哪些方式</p><p>​    get,post区别</p><p>​    get可以提交修改服务端数据吗？</p><p>【10:00】https</p><p>【12:00】fragment的生命周期和activity生命周期的映射关系</p><p>oncreteview是在activity哪个生命周期后调用的</p><p>oncrete 和onactivitycreate哪个先哪个后</p><p>【14:30】asynctask怎么实现的  知道吗</p><p>doinbackground 之后结果怎么抛出结果的</p><p>【18:00】new不同的asynctask 线程池是共用的吗?asynctask的缺点</p><p>【20：00】说下图片的三级缓存?</p><p>​        网络算缓存吗？</p><p>【22：50】mvc mvp mvvm说一下</p><p>【25:20】lru cache 说一下</p><p>最近最久未使用 怎么实现的？取的时候变吗？添加的时候才变？</p><p>是一个什么数据结构？ linkedhashmap里面是什么结构?</p><p>【29:30】bitmap压缩怎么实现的？</p><p>采样率？</p><p>图片压缩比例有什么限制吗？（都能说一下）</p><p>为什么只能是2的倍数？压缩3倍图片有问题吗？（思考良久，说不了解）</p><p>【32:30】可以说下你对设计模式的了解吗？</p><p>单例、代理、装饰、建造者</p><p>说下单例.</p><p>说下代理:比如安卓中的aidl ,说了aidl的过程</p><p>说下装饰者：</p><p>说下观察者:</p><p>还有吗,策略模式？</p><p>【38:25】设计原则：四大原则？</p><p>【39:30】 开始算法题</p><p>飞机场   起降时间， 最多有几趟时间在天上  书飞机</p><p><a href="https://blog.csdn.net/u012156116/article/details/80447982" target="_blank" rel="noopener">https://blog.csdn.net/u012156116/article/details/80447982</a></p><p>写二叉树的深度 应该能写出来？</p><p>【57:00】 有什么想问我的吗？</p><p>1.想请问一下，本次知识点欠缺的，需要去弥补的，能不能给点建议</p><p>2.算法这块是否不足，给下建议？</p><p>项目是开源的 自己练过的  。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/面经/华为/华为面经</title>
      <link href="blog/2590676041.html"/>
      <url>blog/2590676041.html</url>
      
        <content type="html"><![CDATA[<p>2018-01-25 </p><p>作者：单人旅途alan<br>链接：<a href="https://www.nowcoder.com/discuss/28272?type=2&amp;order=0&amp;pos=6&amp;page=1" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/28272?type=2&amp;order=0&amp;pos=6&amp;page=1</a><br>来源：牛客网</p><p><strong><em>华为初面：\</em></strong><br> 初面是一位感觉很有经验的面试官，上来让我自我介绍之后看着我的简历开始让我介绍项目。在问项目的过程中穿插着基础知识的提问。刚开始还是比较紧张的，但随着对问题的深入讨论，就忘记了紧张了。之后让我用笔纸画项目的框架图和算法流程。然后问了一些基础问题，整理如下：<br> 1.Android图片缓存的优化<br> 2.遇到的OOM场景如何解决，和SOF的区别；<br> 3.Android滑动冲突的处理；<br> 4.项目中遇到的问题，如何解决的；<br> 5.最有成就感的一次开发体验。<br> 还有一些问题不太记得了。面试过程挺顺利的。<br> <strong><em>华为综合面：\</em></strong><br> 二面是一位看起来比较有气场的面试官，后来得知是部门的主管。上来还是简单自我介绍后开始聊项目，对项目的深入程度很高，对很多细节进行了提问。问完项目之后聊了聊未来的规划啥的。面试官是很友好的，跟我握了两次手，直接告诉我通过了面试。就这样比较顺利的拿到了华为的实习Offer。</p><p>作者：很丧的小黄鸭<br>链接：<a href="https://www.nowcoder.com/discuss/168987?type=2" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/168987?type=2</a><br>来源：牛客网</p><h1 id="深圳华为暑期实习Android玄学一二面面经-offer"><a href="#深圳华为暑期实习Android玄学一二面面经-offer" class="headerlink" title="深圳华为暑期实习Android玄学一二面面经(offer)"></a>深圳华为暑期实习Android玄学一二面面经(offer)</h1><p>编辑于  2019-03-26 22:03:11 </p><p>5.6更新</p><p>时隔一个多月，收到了offer。</p><p>-——————————————————-</p><p>  由于是现场面，没有录音，还是连着面的，只能凭记忆写，可能会有遗漏。 </p><h2 id="一面-（3-26-现场面-30min）"><a href="#一面-（3-26-现场面-30min）" class="headerlink" title="一面 （3.26 现场面 30min）"></a><strong>一面 （3.26 现场面 30min）</strong></h2><ol><li><p>​    介绍项目，大概说了一下怎么实现的， 没有追问细节。【感觉面试官好像不是很懂android..】   </p></li><li><p>​    项目的难点是什么。   </p></li><li><p>​    有没有用过华为的产品。   </p></li><li><p>​    有哪个项目可以应用到他们的产品里的。   </p></li><li><p>​    项目有哪些不足。   </p><p>好像不止这些，但是我真的记不得了orz </p></li></ol><h2 id="二面-（3-26-现场面-45min）"><a href="#二面-（3-26-现场面-45min）" class="headerlink" title="二面 （3.26 现场面 45min）"></a><strong>二面 （3.26 现场面 45min）</strong></h2><ol><li><p>​    介绍项目，也是比较概括的介绍，没有追问android实现的细节。   </p></li><li><p>​    有没有想过把项目推广到市场上，有没有想过和别的公司合作之类的，有没有想过结合手环。   </p></li><li><p>​    项目有哪些缺陷。   </p></li><li><p>​    【 这里好像还问了一些项目相关的，可是金鱼脑的我又想不起来了。】   </p></li><li><p>​    是本地的吗，小学初中在哪上的，父母退休了吗，父母在哪上班，有兄弟姐妹吗。   </p></li><li><p>​    有什么兴趣爱好。   </p></li><li><p>​    觉得自己的缺点是什么。   </p></li><li><p>​    如果要在五百人面前介绍你的项目，你会怎么办。   </p></li><li><p>​    项目没有进展，很焦虑的时候怎么办，有没有想过寻求周围人的帮助。   </p></li><li><p>​    压力很大的时候怎么调整自己。   </p></li><li><p>​    最近让自己心烦的事情是什么，我说是找实习，他就问那怎么缓解这种情绪，周围人是什么状态的，他们怎么鼓励你之类的。   </p></li><li><p>​    愿不愿意去上海。【其实这个问题，面试官后来说了很多，大概意思就是，华为内部调整的很快，业务需求可能会让你经常出差，或者去上海广州工作几年，也不确定要多久；还说也可能你以后因为公司需求不能安卓开发，会做其他的，总之就是说变动会很多】   </p></li><li><p>​    有没有了解过华为的理念，为什么想来华为。   </p></li><li><p>​    如果工作节奏非常快，你可以接受吗，可能刚入职就会节奏很快。   </p><p>最后说，hr会在两周内通知结果。 </p></li></ol><p>  总之，二面大部分时间都在聊如何面对压力，如何解决。 </p><p>  其实我在面试之前，对华为没有太多的了解。但是在结束之后，去搜了华为狼性文化，才顿悟为什么面试一直在问这些，可能要确保能有比较强的心理承受能力吧。 </p><p>  两轮面试基本都没问技术的问题，就是聊项目，聊人生。 </p><p>  有个小建议，如果项目有demo/app/实物，最好都带去，因为两轮面试，面试官都有问我有没有把项目的成果带过来，刚好我有准备，就给他们看了我两个项目的demo。 </p><p>  可能比起语言描述，他们对这种可以直接看到的东西更感兴趣吧。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/剑指offer leetcode/刷题方法</title>
      <link href="blog/1764413349.html"/>
      <url>blog/1764413349.html</url>
      
        <content type="html"><![CDATA[<p><img src=".%E5%88%B7%E9%A2%98%E6%96%B9%E6%B3%95_images/image-20200709085250058.png" alt="image-20200709085250058"></p><ul><li><p>动态规划多多益善 &gt;= 20+ ，看个人时间</p></li><li><p>每个tag 10-20题  这是逃不掉的</p></li><li><p>每天2-3小时，很有必要的</p></li><li><p>尝试快速实现</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/网络/retrofit</title>
      <link href="blog/1105969165.html"/>
      <url>blog/1105969165.html</url>
      
        <content type="html"><![CDATA[<p><img src=".retrofit_images/image-20200628140247922.png" alt="image-20200628140247922"></p><ul><li>json字符串转JavaBean类的插件</li><li>json字符串转Json对象的转换器依赖</li><li>@Query注解 实现 带参数的get请求 </li><li>@QueryMap注解 实现超多参数的get请求</li><li>@POST注解 + @Url</li><li>@POST + @Query</li></ul><img src=".retrofit_images/image-20200628144406094.png" alt="image-20200628144406094" style="zoom:50%;" /><ul><li>参数类型BODY注解 ：用于提交内容</li><li>@Header @HeadersMap用于参数</li><li>@Headers用于方法</li></ul><p>准备工作</p><pre><code>compile &#39;com.squareup.retrofit2:retrofit:2.3.0&#39;compile &#39;com.squareup.retrofit2:converter-gson:2.0.0&#39;</code></pre><h5 id="标记类注解有-3-种"><a href="#标记类注解有-3-种" class="headerlink" title="标记类注解有 3 种:"></a><strong>标记类注解有 3 种</strong>:</h5><p>它们是FormUrlEncoded、Multipart、Streaming</p><p>Streaming代表响应的数据以流的形式返回，如果不使用它，则默认会把全部数据 加载到内存，所以下载大文件时需要加上这个注解</p><h5 id="参数类注解有"><a href="#参数类注解有" class="headerlink" title="参数类注解有"></a><strong>参数类注解有</strong></h5><p>Header、Headers、Body、Path、Field、 FieldMap、Part、PartMap、Query和QueryMap等</p><p>1.创建请求接口文件，定义请求方法返回值泛型</p><p>2.创建Retrofit（建造者）</p><p>3.用Retrofit动态代理获 取到之前定义的接口，并调用该接口定义的getIpMsg方法得到Call对象</p><p>4.接下来用Call请求网络并处理回 调，</p><p>//异步请求网络，回调的Callback是运行在UI线程的</p><p><code>addCallAdapterFactory(rxJavaCallAdapterFactory)</code> 方法指定使用<code>RxJava</code> 作为<code>CallAdapter</code> ，需要传入一个<code>RxJavaCallAdapterFactory</code>对象：</p><p><code>CallAdapter.Factory rxJavaCallAdapterFactory = RxJavaCallAdapterFactory.create()</code>；</p><p><code>addConverterFactory(gsonConverterFactory)</code> 方法指定 <code>Gson</code> 作为解析Json数据的<code>Converter</code>：<code>Converter.Factory gsonConverterFactory = GsonConverterFactory.create()</code>；</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/网络/okhttp</title>
      <link href="blog/1229378111.html"/>
      <url>blog/1229378111.html</url>
      
        <content type="html"><![CDATA[<p>使用前准备工作：</p><pre class=" language-groovy"><code class="language-groovy">implementation <span class="token string">'com.squareup.okhttp3:okhttp:3.2.0'</span>implementation <span class="token string">'com.squareup.okio:okio:1.7.0'</span></code></pre><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><h3 id="1-get用法"><a href="#1-get用法" class="headerlink" title="1.get用法"></a>1.get用法</h3><ol><li><p>要有一个客户端，类似于要有一个浏览器</p><pre class=" language-java"><code class="language-java">OkHttpClient client <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">OkHttpClient<span class="token punctuation">.</span>Builder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">connecTimeout</span><span class="token punctuation">(</span><span class="token number">10000</span><span class="token punctuation">,</span>TimeUnit<span class="token punctuation">.</span>MILLSECONDS<span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><p>创建请求内容</p><pre><code>Request request = new Request()        .get()        .url(BASE_URL + &quot;/get/text&quot;)        .build();</code></pre></li><li><p>用client去创建请求任务</p><pre class=" language-java"><code class="language-java">Call call <span class="token operator">=</span> client<span class="token punctuation">.</span><span class="token function">newCall</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><p>异步请求</p><pre><code>call.enqueue(new Callback(){    @Override    public void onFaile(Call call,IOException e){    }    @Override    public void onResponse(Call call,Response response) throws IOException{    }});//注意的是onResponse回调并非在UI线程</code></pre></li><li><p>同步请求调用Call的execute方法</p></li><li><p>基本步骤总结：创建OkHttpClient、Request和Call，最后调用Call的enqueue（）方法.</p></li></ol><h3 id="2-post请求"><a href="#2-post请求" class="headerlink" title="2.post请求"></a>2.post请求</h3><h3 id="3-异步下载文件"><a href="#3-异步下载文件" class="headerlink" title="3.异步下载文件"></a>3.异步下载文件</h3><h3 id="4-异步上传Multipart文件"><a href="#4-异步上传Multipart文件" class="headerlink" title="4.异步上传Multipart文件"></a>4.异步上传Multipart文件</h3><h3 id="5-拦截器"><a href="#5-拦截器" class="headerlink" title="5.拦截器"></a>5.拦截器</h3><h4 id="5-1HttpLoggingInterceptor用法"><a href="#5-1HttpLoggingInterceptor用法" class="headerlink" title="5.1HttpLoggingInterceptor用法"></a>5.1HttpLoggingInterceptor用法</h4><pre><code>//1.定义拦截器 + Loggerprivate static HttpLoggingInterceptor sInterceptor = new HttpLoggingInterceptor(new HttpLoggingInterceptor.Logger() {        @Override        public void log(String message) {            try {                String text = URLDecoder.decode(message, &quot;utf-8&quot;);                Log.e(&quot;OKHttp-----&quot;, text);            } catch (UnsupportedEncodingException e) {                e.printStackTrace();                Log.e(&quot;OKHttp-----&quot;, message);            }        }    });//2.设置打印级别//3.给client添加拦截器 sInterceptor.setLevel(HttpLoggingInterceptor.Level.BASIC);        OkHttpClient client = new OkHttpClient.Builder()                .addInterceptor(sInterceptor)                .connectTimeout(10000, TimeUnit.MILLISECONDS)                .build();</code></pre><h4 id="5-2应用场景"><a href="#5-2应用场景" class="headerlink" title="5.2应用场景"></a>5.2应用场景</h4>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/面经/字节跳动/字节Ios面经</title>
      <link href="blog/566997471.html"/>
      <url>blog/566997471.html</url>
      
        <content type="html"><![CDATA[<h1 id="字节iOS客户端实习-三次技术面面经"><a href="#字节iOS客户端实习-三次技术面面经" class="headerlink" title="字节iOS客户端实习 三次技术面面经"></a>字节iOS客户端实习 三次技术面面经</h1><p><a href=""><img src="https://images.nowcoder.com/head/123m.png?x-oss-process=image/resize,m_mfit,h_100,w_100" alt="头像"></a></p><h3 id="LeonZou-字节跳动实习"><a href="#LeonZou-字节跳动实习" class="headerlink" title="LeonZou  #字节跳动实习# "></a><a href="">LeonZou</a> <a href=""> #字节跳动实习# </a></h3><p>  一面：1h </p><ol><li><p>​    项目经历      </p></li><li><p>​    数据库事务      </p></li><li><p>​    写sql语句，group by      </p></li><li><p>​    为什么需要rollback      </p></li><li><p>​    MySQL不同引擎的区别      </p></li><li><p>​    不同引擎的索引区别      </p></li><li><p>​    索引的作用、特点、哪种数据加索引比较好      </p></li><li><p>​    什么时候索引失效      </p></li><li><p>​    存储过程      </p></li><li><p>说下ASCII和unicode的区别</p></li><li><p>unicode一个汉字占多少字节？字母呢？</p></li><li><p>utf-8的优势？</p></li><li><p>​    进程和线程的异同和联系      </p></li><li><p>​    进程通信的方法      </p></li><li><p>​    死锁的条件、解决方法      </p></li><li><p>​    什么是抢占      </p></li><li><p>​    堆栈的异同      </p></li><li><p>​    什么是虚拟内存、共享内存、物理内存      </p></li><li><p>​    什么是子网掩码、它的作用是什么      </p></li><li><p>​    什么是DNS      </p></li><li><p>​    说一下输入网址之后，浏览器怎么显示网页的      </p></li><li><p>​    抓包的原理      </p></li><li><p>​    TCP三次握手、四次挥手      </p></li><li><p>​    C++的特点      </p></li><li><p>​    什么是多态      </p></li><li><p>​    重载和重写      </p></li><li><p>​    并发和并行      </p></li><li><p>​    单CPU能实现多任务并行吗      </p></li><li><p>​    举一个死锁的例子      </p></li><li><p>​    什么是互斥锁/读写锁      </p></li><li><p>​    什么场景用互斥锁，什么场景用读写锁      </p></li><li><p>​    介绍一下C++11的智能指针      </p></li><li><p>​    循环引用      </p></li><li><p>​    做题：一次股票买卖所能获得的最大利润      </p></li><li><p>​    杂谈+反问     </p><p>二面：1h  </p></li><li><p>​    MySQL的多线程并发是怎么做的      </p></li><li><p>​    MySQL线程池怎么设计的      </p></li><li><p>​    乐观锁和悲观锁，各自的使用场景      </p></li><li><p>​    innodb和mylsam的异同      </p></li><li><p>​    两种引擎的索引异同      </p></li><li><p>​    索引的底层实现      </p></li><li><p>​    介绍下C++的引用<br>​      </p></li><li><p>​    说下左值和右值      </p></li><li><p>​    说下unique_ptr      </p></li><li><p>​    说下use_count机制      </p></li><li><p>​    use_count存在内存哪里      </p></li><li><p>​    C++实现严格的单例模式      </p></li><li><p>​    说下map和unordered_map      </p></li><li><p>​    哈希构造方法、哈希冲突解决方法      </p></li><li><p>​    说下AVL树和红黑树      </p></li><li><p>​    说下生产者-消费者模型，其中的同步机制是怎么样的      </p></li><li><p>​    什么是写优先和读写平衡      </p></li><li><p>​    什么是优先级反转，怎么解决      </p></li><li><p>​    说下vector是怎么做到动态变化的      </p></li><li><p>​    vector的扩张因子      </p></li><li><p>​    优先队列的底层实现是什么      </p></li><li><p>​    post和get的异同      </p></li><li><p>​    HTTP2.0相对1.0有什么改进      </p></li><li><p>​    如果一个服务器和客户端突然断开连接（只有握手没有挥手），这时会发生什么      </p></li><li><p>​    3升和5升的杯子，怎么得到4升水      </p></li><li><p>​    做题：二叉树，从根节点出发，输出节点之和等于给定目标值的全部路径      </p></li><li><p>​    杂谈+反问     </p><p>三面：1h </p></li><li><p>​    社团经历      </p></li><li><p>​    实现单例模式      </p></li><li><p>​    C++代码到程序的过程      </p></li><li><p>​    编译到汇编阶段，代码怎么变成汇编代码的      </p></li><li><p>​    HTTPS和HTTP的区别      </p></li><li><p>​    HTTPS的具体过程      </p></li><li><p>​    网络挟持的解决方法      </p></li><li><p>​    输入网址到显示网页的过程      </p></li><li><p>​    中间人攻击      </p></li><li><p>​    HTTP状态码      </p></li><li><p>​    断点续传怎么做的      </p></li><li><p>​    git的使用      </p></li><li><p>​    。。。忘了录音 记不太清了      </p></li><li><p>​    做题：反转单词序列，追问怎么优化，有没有更好的办法      </p></li><li><p>​    杂谈+反问     </p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/Java虚拟机/面试题</title>
      <link href="blog/1848684351.html"/>
      <url>blog/1848684351.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-JVM的启动过程？"><a href="#1-JVM的启动过程？" class="headerlink" title="1.JVM的启动过程？"></a>1.JVM的启动过程？</h2><h3 id="1-配置JVM装载环境"><a href="#1-配置JVM装载环境" class="headerlink" title="1.配置JVM装载环境"></a>1.配置JVM装载环境</h3><p>JVM.dll（libjvm.dylib）文件的查找和加载</p><h3 id="2、解析虚拟机参数"><a href="#2、解析虚拟机参数" class="headerlink" title="2、解析虚拟机参数"></a>2、解析虚拟机参数</h3><h3 id="3、设置线程栈大小"><a href="#3、设置线程栈大小" class="headerlink" title="3、设置线程栈大小"></a>3、设置线程栈大小</h3><h3 id="4、执行Java-main方法"><a href="#4、执行Java-main方法" class="headerlink" title="4、执行Java main方法"></a>4、执行Java main方法</h3><h4 id="4-1-新建JVM实例"><a href="#4-1-新建JVM实例" class="headerlink" title="4.1.新建JVM实例"></a>4.1.新建JVM实例</h4><p>​    调用JVM.dll函数JNI_CreateJavaVM，新建一个JVM实例</p><h4 id="4-2-加载主类的class"><a href="#4-2-加载主类的class" class="headerlink" title="4.2.加载主类的class"></a>4.2.加载主类的class</h4><p>​    1、调用GetMainClassName方法找到META-INF/MANIFEST.MF文件指定的Main-Class的主类名；<br>​            2、调用LoadClass方法加载主类的class文件；</p><h4 id="4-3-查找main方法"><a href="#4-3-查找main方法" class="headerlink" title="4.3.查找main方法"></a>4.3.查找main方法</h4><h4 id="4-4执行main方法"><a href="#4-4执行main方法" class="headerlink" title="4.4执行main方法"></a>4.4执行main方法</h4><blockquote><p>①JVM由随启动的：启动器</p><p>②启动器有哪些:典型的Java启动器有JRE/JDK自带的java[.exe]、javaw.exe，JDK自带的javac、javap等。        ③java.exe是windows平台上的，macos 上是java 可执行程序</p><p><a href="https://www.zhihu.com/question/32247563" target="_blank" rel="noopener">https://www.zhihu.com/question/32247563</a></p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/面经/腾讯面经/腾讯面经</title>
      <link href="blog/319463413.html"/>
      <url>blog/319463413.html</url>
      
        <content type="html"><![CDATA[<h2 id="腾讯日常实习Android面经"><a href="#腾讯日常实习Android面经" class="headerlink" title="腾讯日常实习Android面经"></a>腾讯日常实习Android面经</h2><p><a href=""><img src="https://images.nowcoder.com/images/20200603/542192629_1591176928686_A46D17EF3677D475EF0C80B211AF3FE5?x-oss-process=image/resize,m_mfit,h_100,w_100" alt="头像"></a></p><h3 id="穿过空的声音"><a href="#穿过空的声音" class="headerlink" title="穿过空的声音"></a><a href="">穿过空的声音</a></h3><p>编辑于  2020-06-03 17:55:03 APP内打开</p><h4 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h4><ul><li>一个APP完整的打包流程</li><li>OOM一般怎么优化，内存泄漏会导致OOM嘛，BITMAP加载导致内存泄漏一般怎么优化，假如优化后还是会出现OOM怎么防止APP崩溃</li><li>ANR一般会在什么情况出现，分别有什么事件导致ANR</li><li>AMS你的理解是什么，AMS是在另外一个线程的嘛，AMS在APP里面起什么作用，一个APP从点击启动到VIEW绘制完成是一个怎么样的过程</li><li>你对KOTLIN的理解</li><li>context你的理解他起到一个什么样的作用，生命周期和Context有关系嘛</li><li>讲讲HTTPS，非对称加密，对称加密</li><li>讲讲Retrofit，OkHttp，handler的源码</li><li>手写一个DCL，除了DCL还用过枚举去实现单例嘛</li><li>讲讲violate，synchronized，静态方法synchronized和普通方法synchronized有什么不同，你在哪些场景用过这些，你考虑应该有哪些场景使用</li><li>讲讲default方法</li><li>讲讲ViewRootImpl，Dialog有ViewRootImpl，还有什么UI视图也有ViewRootImpl，讲讲View完整的绘制流程</li><li>如果让你写APP你会在哪里去检测内存泄漏的问题</li><li>一般你们怎么向后台传输图片</li><li>讲讲JAVA几个访问权限关键字</li><li>讲讲什么东西会导致一个类被NEW出来的时候对象在堆里面的大小不同</li><li>讲讲ThreadLocal</li><li>讲讲JAVA四大引用</li><li>代码题是一道遍历View树</li></ul><h4 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h4><ul><li>讲讲APP的启动流程</li><li>讲讲APP的安装流程</li><li>讲讲Rxjava的源码</li><li>讲讲事件分发机制和多点触控</li><li>讲讲https和非对称加密</li><li>讲讲Retrofit的动态代理</li><li>讲讲几种IPC方式的优劣，以及Binder的原理</li><li>讲讲本地持久化储存的方法</li><li>讲讲parcelable和serializable</li></ul><h4 id="HR"><a href="#HR" class="headerlink" title="HR"></a>HR</h4><ul><li>自我介绍</li><li>讲讲你工作室工作</li><li>讲讲你未来的计划</li><li>讲讲你的优缺点</li><li>讲讲你在别人眼中是什么样的人</li><li>还有什么想问的</li></ul><p>来牛客还愿了，总共流程下来大概两周吧，许愿一个OC</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/java/并发编程/线程(池)总结</title>
      <link href="blog/3048030372.html"/>
      <url>blog/3048030372.html</url>
      
        <content type="html"><![CDATA[<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="1-什么是线程？"><a href="#1-什么是线程？" class="headerlink" title="1.什么是线程？"></a>1.什么是线程？</h3><p>进程：是程序的一次执行过程，是操作系统资源分配的基本单位</p><p>线程：是计算机中独立运行的最小单位，运行时占用很少的系统资源。</p><p>由于每个线程占用的CPU时间是系统分配的，因此可以把线程看成操作系统分配CPU时间的基本单位。</p><p>线程基本上不拥有系统资源，它与同属于一个进程的线程共享进程拥有的全部资源。</p><h3 id="2-线程的创建方式"><a href="#2-线程的创建方式" class="headerlink" title="2.线程的创建方式"></a>2.线程的创建方式</h3><p>①继承Thread类重写run方法②参数传递Runnable对象③参数传递Callable对象，返回FutureTask<T>对象</p><h3 id="3-线程常用方法"><a href="#3-线程常用方法" class="headerlink" title="3.线程常用方法"></a>3.线程常用方法</h3><h4 id="3-1-sleep-使当前线程睡眠一段时间"><a href="#3-1-sleep-使当前线程睡眠一段时间" class="headerlink" title="3.1 sleep:使当前线程睡眠一段时间"></a>3.1 sleep:使当前线程睡眠一段时间</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//1.，当前线程不会释放任何监视器的所有权(不释放对象锁)</span><span class="token comment" spellcheck="true">//2.被打断后，在抛出异常时，打断状态会被clear,也就是调用isInterrupted会返回fasle</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token keyword">long</span> millis<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException<span class="token punctuation">;</span></code></pre><h4 id="3-2-join-等待某个线程运行结束"><a href="#3-2-join-等待某个线程运行结束" class="headerlink" title="3.2 join:等待某个线程运行结束"></a>3.2 join:等待某个线程运行结束</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//（比如main线程中 调用t1线程的start(),join()后，则main线程需要等待t1线程运行完之后继续执行，main线程进入 WAITING态）</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre><ul><li>可以实现同步</li></ul><h4 id="3-3-yield-让出线程执行权"><a href="#3-3-yield-让出线程执行权" class="headerlink" title="3.3 yield :让出线程执行权"></a>3.3 yield :让出线程执行权</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//1.调用 yield 会让调用线程从 Running 进入 Runnable 就绪状态，然后调度执行其它线程</span><span class="token comment" spellcheck="true">//2.很少用，可能对调试和测试的目的有用</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="3-4-interrupt-打断某个-阻塞-线程"><a href="#3-4-interrupt-打断某个-阻塞-线程" class="headerlink" title="3.4 interrupt: 打断某个(阻塞)线程"></a>3.4 interrupt: 打断某个(阻塞)线程</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//1.打断由于调用了wait,join,sleep而陷入阻塞的线程时，会抛出InterruptedException，并且清除打断状态</span><span class="token comment" spellcheck="true">//2.如果一个线程阻塞在一个IO操作(InterruptibleChannel),调用此方法会关闭channel,并设置线程的打断状态,并且此线程会收到1个ClosedByInterruptException</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre><h4 id="3-5-setPriority："><a href="#3-5-setPriority：" class="headerlink" title="3.5 setPriority："></a>3.5 setPriority：</h4><pre class=" language-java"><code class="language-java">线程的切换是由线程调度控制的，我们无法通过代码来干涉，但是我们可以通过提高线程的优先级来最大程度的改善线程优先获取时间片的几率    Java中线程的优先级被划分为<span class="token number">10</span>级，值分别为<span class="token number">1</span><span class="token operator">-</span><span class="token number">10</span>，<span class="token number">1</span>最低，<span class="token number">10</span>最高。Thread类提供了<span class="token number">3</span>个常量来表示最低最高和默认优先级<span class="token punctuation">.</span>    Thread<span class="token punctuation">.</span>MIN_PRIORITY <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        Thread<span class="token punctuation">.</span>NORM_PRIORITY <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>        Thread<span class="token punctuation">.</span>MAX_PRIORITY <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">setPriority</span><span class="token punctuation">(</span><span class="token keyword">int</span> newPriority<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>        </code></pre><h4 id="3-6-setDaemon"><a href="#3-6-setDaemon" class="headerlink" title="3.6 setDaemon"></a>3.6 setDaemon</h4><pre class=" language-java"><code class="language-java">在Java中有两类线程：User <span class="token function">Thread</span><span class="token punctuation">(</span>用户线程<span class="token punctuation">)</span>、Daemon <span class="token function">Thread</span><span class="token punctuation">(</span>守护线程<span class="token punctuation">)</span> 只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。Daemon的作用是为其他线程的运行提供便利服务，守护线程最典型的应用就是 <span class="token function">GC</span> <span class="token punctuation">(</span>垃圾回收器<span class="token punctuation">)</span>，它就是一个很称职的守护者。<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">setDaemon</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> on<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre><h3 id="4-线程的状态"><a href="#4-线程的状态" class="headerlink" title="4. 线程的状态"></a>4. 线程的状态</h3><p>4.1 <code>NEW</code> : <code>new</code>出来后 <code>start</code>()前</p><p>4.2 <code>RUNNABLE</code>: 在Java虚拟机中执行但可能在等操作系统的某个资源，比如CPU</p><p>4.3 <code>BLOCKED</code>: 等一个monitor锁时以便进入同步块/方法中</p><p>4.4 <code>WAITING</code>: 调用了<code>Object</code>#<code>wait</code>()，<code>Thread</code>#<code>join</code>()，<code>LockSupport</code>#<code>park</code>()后, 在等待其他线程执行一个特殊的操作</p><p>4.5 <code>TIMED_WAITTING</code>: 调用了这些<code>Thread.sleep</code>，<code>Object</code>#wait(long)，<code>join</code>(long)，<code>LockSupport</code>#<code>parkNanos</code>，<code>LockSupport</code>#<code>parkUntil</code>  方法后。</p><p>4.6 <code>TERMINATED</code>：run方法执行完后。 </p><h3 id="5-线程安全问题的解决synchronized"><a href="#5-线程安全问题的解决synchronized" class="headerlink" title="5. 线程安全问题的解决synchronized"></a>5. 线程安全问题的解决<code>synchronized</code></h3><p>5.1同步与互斥</p><ul><li>互斥是保证临界区的竞态条件发生，同一时刻只能有一个线程执行临界区代码 </li><li>同步是由于线程执行的先后、顺序不同、需要一个线程等待其它线程运行到某个点</li></ul><p>5.2 <code>synchronized</code>用法，代码块和方法上，为什么需要类锁？</p><ul><li>锁静态方法，有些东西是属于一个类的。</li></ul><p>5.3 JDK1.6的优化 偏向锁和轻量级锁</p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="1-什么是线程池，为什么要有线程池？"><a href="#1-什么是线程池，为什么要有线程池？" class="headerlink" title="1.什么是线程池，为什么要有线程池？"></a>1.什么是线程池，为什么要有线程池？</h3><p>就是事先创建若干个可执行的线程放入一个池（容器）中，需要的时候从池中获取线程不用自行创建，使用完毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销.</p><p>JDK中用HashSet<Worker> workers 表示线程池执行器中的线程池。</p><h3 id="2-核心线程是如何保持不被销毁的？"><a href="#2-核心线程是如何保持不被销毁的？" class="headerlink" title="2.核心线程是如何保持不被销毁的？"></a>2.核心线程是如何保持不被销毁的？</h3><p>去任务时阻塞，<code>BlockQueue</code>#<code>getTask</code>(),如果没有任务会调用条件变量的await方法等待，直到有为止。</p><p>非核心线程不是阻塞获取，是超时获取的null，也就会任务结束，线程终止。</p><blockquote><p>核心方法getTask(),参加分析<a href="https://www.cnblogs.com/DDiamondd/p/11362164.html" target="_blank" rel="noopener">https://www.cnblogs.com/DDiamondd/p/11362164.html</a></p></blockquote><h3 id="3-Executors返回的4种线程池"><a href="#3-Executors返回的4种线程池" class="headerlink" title="3.Executors返回的4种线程池"></a>3.Executors返回的4种线程池</h3><h4 id="3-1-newFixedThreadPool"><a href="#3-1-newFixedThreadPool" class="headerlink" title="3.1 newFixedThreadPool"></a>3.1 newFixedThreadPool</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService <span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token keyword">int</span> nThreads<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>nThreads<span class="token punctuation">,</span> nThreads<span class="token punctuation">,</span> 0L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">,</span> <span class="token keyword">new</span>                 <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><p>特点</p><ul><li>核心线程数 == 最大线程数（没有救急线程被创建），因此也无需超时时间 </li><li>阻塞队列是无界的，可以放任意数量的任务</li></ul><blockquote><p>适用于任务量已知，相对耗时的任务</p></blockquote><h4 id="3-2-newCachedThreadPool"><a href="#3-2-newCachedThreadPool" class="headerlink" title="3.2 newCachedThreadPool"></a>3.2 newCachedThreadPool</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService <span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">,</span> 60L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span> <span class="token keyword">new</span>                                               <span class="token class-name">SynchronousQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><ul><li><p>核心线程数是 0， 最大线程数是 Integer.MAX_VALUE，救急线程的空闲生存时间是 60s，意味着</p><p>全部都是救急线程（60s 后可以回收）,救急线程可以无限创建</p></li><li><p>队列采用了 SynchronousQueue 实现特点是，它没有容量，没有线程来取是放不进去的（一手交钱、一手交 货）</p></li></ul><blockquote><p> 整个线程池表现为线程数会根据任务量不断增长，没有上限，当任务执行完毕，空闲 1分钟后释放线 程。 适合任务数比较密集，但每个任务执行时间较短的情况</p></blockquote><h4 id="3-3-newSingleThreadExecutor"><a href="#3-3-newSingleThreadExecutor" class="headerlink" title="3.3 newSingleThreadExecutor"></a>3.3 newSingleThreadExecutor</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService <span class="token function">newSingleThreadExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">new</span>         <span class="token class-name">FinalizableDelegatedExecutorService</span> <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> 0L<span class="token punctuation">,</span>                           TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><p>使用场景： 希望多个任务排队执行。线程数固定为 1，任务数多于 1 时，会放入无界队列排队。任务执行完毕，这唯一的线程 也不会被释放。 区别：</p><ul><li><p>自己创建一个单线程串行执行任务，如果任务执行失败而终止那么没有任何补救措施，而线程池还会新建一 个线程，保证池的正常工作</p></li><li><p><code>Executors.newSingleThreadExecutor</code>() 线程个数始终为1，不能修改</p><p><code>FinalizableDelegatedExecutorService</code> 应用的是装饰器模式，只对外暴露了 <code>ExecutorService</code> 接口，因此不能调用 <code>ThreadPoolExecutor</code> 中特有的方法 </p></li><li><p><code>Executors.newFixedThreadPool</code>(1) 初始时为1，以后还可以修改对外暴露的是 <code>ThreadPoolExecutor</code> 对象，可以强转后调用 <code>setCorePoolSize</code> 等方法进行修改</p></li></ul><h4 id="3-4-任务调度线程池"><a href="#3-4-任务调度线程池" class="headerlink" title="3.4 任务调度线程池"></a>3.4 任务调度线程池</h4><p>在『任务调度线程池』功能加入之前，可以使用 java.util.Timer 来实现定时功能，Timer 的优点在于简单易用，但 由于所有任务都是由同一个线程来调度，因此所有任务都是串行执行的，同一时间只能有一个任务在执行，前一个 任务的延迟或异常都将会影响到之后的任务。</p><pre class=" language-java"><code class="language-java">ScheduledExecutorService executor <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newScheduledThreadPool</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ul><li>可以延时执行任务 <code>executor.schedule</code>(）</li><li>也可以定时执行任务 <code>scheduleAtFixedRate</code>   <code>scheduleWithFixedDelay</code></li></ul><h3 id="4-线程池异常处理"><a href="#4-线程池异常处理" class="headerlink" title="4. 线程池异常处理"></a>4. 线程池异常处理</h3><ul><li>任务主动自己try catch</li><li>使用Future,Callable处理</li></ul><h3 id="5-一些概念的区分"><a href="#5-一些概念的区分" class="headerlink" title="5. 一些概念的区分"></a>5. 一些概念的区分</h3><h4 id="5-1-核心线程-和非核心线程？"><a href="#5-1-核心线程-和非核心线程？" class="headerlink" title="5.1 核心线程 和非核心线程？"></a>5.1 核心线程 和非核心线程？</h4><p>&gt;<code>=ThreadPoolExecutor</code>#<code>corePoolSize</code>后的线程是非核心线程(也叫救急线程)</p><h4 id="5-2-线程池当前pool-size-池子的大小-？"><a href="#5-2-线程池当前pool-size-池子的大小-？" class="headerlink" title="5.2 线程池当前pool size(池子的大小)？"></a>5.2 线程池当前pool size(池子的大小)？</h4><pre class=" language-java"><code class="language-java"> <span class="token keyword">private</span> <span class="token keyword">final</span> HashSet<span class="token operator">&lt;</span>Worker<span class="token operator">></span> workers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span>Worker<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// workers.size()表示</span></code></pre><h4 id="5-3-active-thread-数量-活动线程数量"><a href="#5-3-active-thread-数量-活动线程数量" class="headerlink" title="5.3 active thread 数量(活动线程数量)"></a>5.3 active thread 数量(活动线程数量)</h4><p>为正在执行任务的线程,通过遍历workers  ,  worker.isLocked()返回true的是active thread</p><h3 id="6-线程池机制的总结"><a href="#6-线程池机制的总结" class="headerlink" title="6.线程池机制的总结"></a>6.线程池机制的总结</h3><p>6.1</p><p><img src=".%E7%BA%BF%E7%A8%8B(%E6%B1%A0)%E6%80%BB%E7%BB%93_images/image-20200622224703446.png" alt="image-20200622224703446"></p><p>6.2 线程池不终止，核心线程启动后就不会主动终止，也就是说当<code>poolSize</code>超过<code>corePoolSize</code>时，线程池中没有任何任务时，<code>pool</code> size 为<code>corePoolSize</code>的大小 ，通过<code>ThreadPoolExecutor</code>#<code>toString</code>方法可以看</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">long</span> ncompleted<span class="token punctuation">;</span>        <span class="token keyword">int</span> nworkers<span class="token punctuation">,</span> nactive<span class="token punctuation">;</span>        <span class="token keyword">final</span> ReentrantLock mainLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mainLock<span class="token punctuation">;</span>        mainLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            ncompleted <span class="token operator">=</span> completedTaskCount<span class="token punctuation">;</span>            nactive <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            nworkers <span class="token operator">=</span> workers<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>Worker w <span class="token operator">:</span> workers<span class="token punctuation">)</span> <span class="token punctuation">{</span>                ncompleted <span class="token operator">+=</span> w<span class="token punctuation">.</span>completedTasks<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>w<span class="token punctuation">.</span><span class="token function">isLocked</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token operator">++</span>nactive<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            mainLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String rs <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token function">runStateLessThan</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> SHUTDOWN<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token string">"Running"</span> <span class="token operator">:</span>                     <span class="token punctuation">(</span><span class="token function">runStateAtLeast</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> TERMINATED<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token string">"Terminated"</span> <span class="token operator">:</span>                      <span class="token string">"Shutting down"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span>            <span class="token string">"["</span> <span class="token operator">+</span> rs <span class="token operator">+</span>            <span class="token string">", pool size = "</span> <span class="token operator">+</span> nworkers <span class="token operator">+</span>            <span class="token string">", active threads = "</span> <span class="token operator">+</span> nactive <span class="token operator">+</span>            <span class="token string">", queued tasks = "</span> <span class="token operator">+</span> workQueue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span>            <span class="token string">", completed tasks = "</span> <span class="token operator">+</span> ncompleted <span class="token operator">+</span>            <span class="token string">"]"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h3 id="7-阿里巴巴Android规范对于线程池的要求"><a href="#7-阿里巴巴Android规范对于线程池的要求" class="headerlink" title="7.阿里巴巴Android规范对于线程池的要求"></a>7.阿里巴巴Android规范对于线程池的要求</h3><p>【强制】线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方 式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</p><p><code>Executors</code> 返回的线程池对象的弊端如下：</p><p>1)<code>FixedThreadPool</code>和<code>SingleThreadPool</code>：允 许 的 请 求 队 列 长 度 为Integer.MAX_VALUE，可能会堆积大量的请求，从而导致；OOM</p><p>2)<code>CachedThreadPool</code>和<code>ScheduledThreadPool</code>：允许的创建线程数量为Integer.MAX_VALUE，可能会创建大量的线程，从而导致OOM。</p><p>正例</p><pre class=" language-java"><code class="language-java"><span class="token keyword">int</span> NUMBER_OF_CORES <span class="token operator">=</span> Runtime<span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">availableProcessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> KEEP_ALIVE_TIME <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>TimeUnit KEEP_ALIVE_TIME_UNIT <span class="token operator">=</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">;</span>BlockingQueue<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> taskQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ExecutorService executorService <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>NUMBER_OF_CORES<span class="token punctuation">,</span>NUMBER_OF_CORES<span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">,</span> KEEP_ALIVE_TIME<span class="token punctuation">,</span> KEEP_ALIVE_TIME_UNIT<span class="token punctuation">,</span>taskQueue<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">BackgroundThreadFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">DefaultRejectedExecutionHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>反例</p><pre><code>ExecutorService cachedThreadPool = Executors.newCachedThreadPool();</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/Android/UI/自定义View/自定义View-简易雷达扫描</title>
      <link href="blog/1035232716.html"/>
      <url>blog/1035232716.html</url>
      
        <content type="html"><![CDATA[<p>简易雷达扫描效果图，实际效果比这个要好，gif生成时或者网页渲染这个gif有点问题。</p><p>![Jun-20-2020 11-58-14](.自定义View-简易雷达扫描_images/Jun-20-2020 11-58-14.gif)</p><p>原理：</p><ul><li>drawCircle画2个同心圆 内圆和外圆</li><li>drawLine画2条直径，水平和垂直的</li><li>drawArc画弧<ul><li>起始角度每次增大4°，从0°开始。</li><li>每次画弧的起始角度相对于上一次增大4°，通过旋转坐标系来实现，开始为0°，360°后转为0°. 保存初始坐标系，旋转后恢复到开始的坐标系（3点钟为0°方向）</li><li>每次画弧的终点角度相对于上一次增大4°，直到360°后由重0°开始</li><li>弧的画笔通过SweepGradient设置渐变色</li></ul></li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> android<span class="token punctuation">.</span>content<span class="token punctuation">.</span>Context<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>content<span class="token punctuation">.</span>pm<span class="token punctuation">.</span>PackageManager<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>graphics<span class="token punctuation">.</span>Canvas<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>graphics<span class="token punctuation">.</span>Color<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>graphics<span class="token punctuation">.</span>Paint<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>graphics<span class="token punctuation">.</span>RectF<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>graphics<span class="token punctuation">.</span>SweepGradient<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>os<span class="token punctuation">.</span>Handler<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>os<span class="token punctuation">.</span>Message<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>util<span class="token punctuation">.</span>AttributeSet<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>view<span class="token punctuation">.</span>View<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>bytedance<span class="token punctuation">.</span>xly<span class="token punctuation">.</span>R<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RadarScanView</span> <span class="token keyword">extends</span> <span class="token class-name">View</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MSG_RUN <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> mCircleColor <span class="token operator">=</span> Color<span class="token punctuation">.</span>BLACK<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> mLineColor <span class="token operator">=</span> Color<span class="token punctuation">.</span>BLACK<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> mArcColor <span class="token operator">=</span> Color<span class="token punctuation">.</span>WHITE<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> mArcStartColor <span class="token operator">=</span> Color<span class="token punctuation">.</span>WHITE<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> mArcEndColor <span class="token operator">=</span> Color<span class="token punctuation">.</span>TRANSPARENT<span class="token punctuation">;</span>    <span class="token keyword">private</span> Paint mCirclePaint<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 绘制圆形画笔</span>    <span class="token keyword">private</span> Paint mArcPaint<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 绘制扇形画笔</span>    <span class="token keyword">private</span> Paint mLinePaint<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 绘制线条画笔</span>    <span class="token keyword">private</span> RectF mRectF<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> mSweep<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 扇形角度</span>    <span class="token keyword">public</span> <span class="token function">RadarScanView</span><span class="token punctuation">(</span>Context context<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">RadarScanView</span><span class="token punctuation">(</span>Context context<span class="token punctuation">,</span> AttributeSet attrs<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> attrs<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">RadarScanView</span><span class="token punctuation">(</span>Context context<span class="token punctuation">,</span> AttributeSet attrs<span class="token punctuation">,</span> <span class="token keyword">int</span> defStyleAttr<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> attrs<span class="token punctuation">,</span> defStyleAttr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">init</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 初始化     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span>Context context<span class="token punctuation">)</span><span class="token punctuation">{</span>        mCircleColor <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">getResources</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getColor</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>color<span class="token punctuation">.</span>radar_begin_color<span class="token punctuation">)</span><span class="token punctuation">;</span>        mArcColor <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">getResources</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getColor</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>color<span class="token punctuation">.</span>radar_begin_color<span class="token punctuation">)</span><span class="token punctuation">;</span>        mLineColor <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">getResources</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getColor</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>color<span class="token punctuation">.</span>radar_begin_color<span class="token punctuation">)</span><span class="token punctuation">;</span>        mArcStartColor <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">getResources</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getColor</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>color<span class="token punctuation">.</span>radar_begin_color<span class="token punctuation">)</span><span class="token punctuation">;</span>        mArcEndColor <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">getResources</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getColor</span><span class="token punctuation">(</span>android<span class="token punctuation">.</span>R<span class="token punctuation">.</span>color<span class="token punctuation">.</span>transparent<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//抗锯齿</span>        mCirclePaint <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Paint</span><span class="token punctuation">(</span>Paint<span class="token punctuation">.</span>ANTI_ALIAS_FLAG<span class="token punctuation">)</span><span class="token punctuation">;</span>        mArcPaint <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Paint</span><span class="token punctuation">(</span>Paint<span class="token punctuation">.</span>ANTI_ALIAS_FLAG<span class="token punctuation">)</span><span class="token punctuation">;</span>        mCirclePaint<span class="token punctuation">.</span><span class="token function">setColor</span><span class="token punctuation">(</span>mCircleColor<span class="token punctuation">)</span><span class="token punctuation">;</span>        mCirclePaint<span class="token punctuation">.</span><span class="token function">setStyle</span><span class="token punctuation">(</span>Paint<span class="token punctuation">.</span>Style<span class="token punctuation">.</span>STROKE<span class="token punctuation">)</span><span class="token punctuation">;</span>        mCirclePaint<span class="token punctuation">.</span><span class="token function">setStrokeWidth</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">.</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>        mArcPaint<span class="token punctuation">.</span><span class="token function">setColor</span><span class="token punctuation">(</span>mArcColor<span class="token punctuation">)</span><span class="token punctuation">;</span>        mArcPaint<span class="token punctuation">.</span><span class="token function">setStyle</span><span class="token punctuation">(</span>Paint<span class="token punctuation">.</span>Style<span class="token punctuation">.</span>FILL<span class="token punctuation">)</span><span class="token punctuation">;</span>        mLinePaint <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Paint</span><span class="token punctuation">(</span>Paint<span class="token punctuation">.</span>ANTI_ALIAS_FLAG<span class="token punctuation">)</span><span class="token punctuation">;</span>        mLinePaint<span class="token punctuation">.</span><span class="token function">setColor</span><span class="token punctuation">(</span>mLineColor<span class="token punctuation">)</span><span class="token punctuation">;</span>        mLinePaint<span class="token punctuation">.</span><span class="token function">setStrokeWidth</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">.</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>        mRectF <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RectF</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">onMeasure</span><span class="token punctuation">(</span><span class="token keyword">int</span> widthMeasureSpec<span class="token punctuation">,</span> <span class="token keyword">int</span> heightMeasureSpec<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onMeasure</span><span class="token punctuation">(</span>widthMeasureSpec<span class="token punctuation">,</span> heightMeasureSpec<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token function">getMeasuredWidth</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">setMeasuredDimension</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>        mRectF<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token function">getMeasuredWidth</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getMeasuredHeight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mArcPaint<span class="token punctuation">.</span><span class="token function">setShader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">SweepGradient</span><span class="token punctuation">(</span>size <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">,</span> size <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">,</span> mArcStartColor<span class="token punctuation">,</span> mArcEndColor<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">onDraw</span><span class="token punctuation">(</span>Canvas canvas<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> centerX <span class="token operator">=</span> <span class="token function">getMeasuredWidth</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> centerY <span class="token operator">=</span> <span class="token function">getMeasuredHeight</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//保存当前状态</span>        canvas<span class="token punctuation">.</span><span class="token function">save</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//选择坐标系</span>        canvas<span class="token punctuation">.</span><span class="token function">rotate</span><span class="token punctuation">(</span>mSweep<span class="token punctuation">,</span> centerX<span class="token punctuation">,</span> centerY<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//画圆弧</span>        canvas<span class="token punctuation">.</span><span class="token function">drawArc</span><span class="token punctuation">(</span>mRectF<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> mSweep<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> mArcPaint<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//恢复到上次保存的状态,这样的结果每次坐标系起点都是3点钟方向,因为mSweep初始为0</span>        canvas<span class="token punctuation">.</span><span class="token function">restore</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        canvas<span class="token punctuation">.</span><span class="token function">drawLine</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> centerY<span class="token punctuation">,</span> <span class="token function">getMeasuredWidth</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> centerY<span class="token punctuation">,</span> mLinePaint<span class="token punctuation">)</span><span class="token punctuation">;</span>        canvas<span class="token punctuation">.</span><span class="token function">drawLine</span><span class="token punctuation">(</span>centerX<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> centerX<span class="token punctuation">,</span> <span class="token function">getMeasuredHeight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> mLinePaint<span class="token punctuation">)</span><span class="token punctuation">;</span>        canvas<span class="token punctuation">.</span><span class="token function">drawCircle</span><span class="token punctuation">(</span>centerX<span class="token punctuation">,</span> centerY<span class="token punctuation">,</span> centerX <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">,</span> mCirclePaint<span class="token punctuation">)</span><span class="token punctuation">;</span>        canvas<span class="token punctuation">.</span><span class="token function">drawCircle</span><span class="token punctuation">(</span>centerX<span class="token punctuation">,</span> centerY<span class="token punctuation">,</span> centerX<span class="token punctuation">,</span> mCirclePaint<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> swicth <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> Handler mHandler <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleMessage</span><span class="token punctuation">(</span>Message msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span>what <span class="token operator">==</span> MSG_RUN<span class="token punctuation">)</span> <span class="token punctuation">{</span>                mSweep<span class="token operator">+=</span><span class="token number">4</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>mSweep <span class="token operator">></span> <span class="token number">360</span><span class="token punctuation">)</span> mSweep <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token function">postInvalidate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//                sendEmptyMessage(MSG_RUN);</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>swicth<span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token function">sendEmptyMessageDelayed</span><span class="token punctuation">(</span>MSG_RUN<span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 开始扫描的方法     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">startScan</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>mHandler <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>            swicth <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            mHandler<span class="token punctuation">.</span><span class="token function">obtainMessage</span><span class="token punctuation">(</span>MSG_RUN<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sendToTarget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>      <span class="token comment" spellcheck="true">/**     * 停止扫描     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">stopScan</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>mHandler <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>            swicth <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            mHandler<span class="token punctuation">.</span><span class="token function">obtainMessage</span><span class="token punctuation">(</span>MSG_RUN<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sendToTarget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/Android/UI/Android 绘图常用API(Canvas Paint)</title>
      <link href="blog/2075853753.html"/>
      <url>blog/2075853753.html</url>
      
        <content type="html"><![CDATA[<h2 id="Paint-画笔类，用于设置颜色和样式"><a href="#Paint-画笔类，用于设置颜色和样式" class="headerlink" title="Paint:画笔类，用于设置颜色和样式."></a>Paint:画笔类，用于设置颜色和样式.</h2><p>Paint.Style</p><ul><li><p>Paint.Style.FILL设置只绘制图形内容 </p><img src=".绘图_images/image-20200620080559134.png" alt="image-20200620080559134" style="zoom:50%;" /></li><li><p>Paint.Style.STROKE设置只绘制图形的边 </p><img src=".绘图_images/image-20200620080824043.png" alt="image-20200620080824043" style="zoom:50%;" /></li><li><p>Paint.Style.FILL_AND_STROKE设置都绘制</p></li></ul><img src=".绘图_images/image-20200620080641826.png" alt="image-20200620080641826" style="zoom:50%;" /><h2 id="Shader"><a href="#Shader" class="headerlink" title="Shader"></a>Shader</h2><p>​        Shader is the based class for objects that return horizontal spans of colors during drawing. A subclass of Shader is installed in a Paint calling paint.setShader(shader). After that any object (other than a bitmap) that is drawn with that paint will get its color(s) from the shader.<br>Shader(着色器)是绘制时水平方向颜色对象的基类。它的子类将作为paint.setShader(shader)方法的参数。</p><p>当调用了paint.setShader(shader)之后，除了任何对象(除了bitmap)在用那个paint绘制时，都会从shader(着色器)中获得它的颜色</p><h4 id="SweepGradient-扫描式渐变"><a href="#SweepGradient-扫描式渐变" class="headerlink" title="SweepGradient(扫描式渐变)"></a>SweepGradient(扫描式渐变)</h4><p>继承自Shader类.</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//构造函数</span><span class="token keyword">public</span> <span class="token function">SweepGradient</span><span class="token punctuation">(</span><span class="token keyword">float</span> cx<span class="token punctuation">,</span> <span class="token keyword">float</span> cy<span class="token punctuation">,</span> <span class="token annotation punctuation">@ColorInt</span> <span class="token keyword">int</span> color0<span class="token punctuation">,</span> <span class="token annotation punctuation">@ColorInt</span> <span class="token keyword">int</span> color1<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><ul><li>构造1个围绕中心点绘制扫描渐变的着色器。</li><li>参数cx,cy为中心点的坐标,后2个参数分别为扫描的起点与终点的颜色</li></ul><h2 id="Canvas-翻译为画布"><a href="#Canvas-翻译为画布" class="headerlink" title="Canvas(翻译为画布)"></a>Canvas(翻译为画布)</h2><h3 id="1-Canvas类的官方介绍："><a href="#1-Canvas类的官方介绍：" class="headerlink" title="1.Canvas类的官方介绍："></a>1.Canvas类的官方介绍：</h3><pre><code>The Canvas class holds the “draw” calls. To draw something, you need 4 basic components: A Bitmap to hold the pixels, a Canvas to host the draw calls (writing into the bitmap), a drawing primitive (e.g. Rect, Path, text, Bitmap), and a paint (to describe the colors and styles for the drawing).</code></pre><ul><li>Canvas类有很多以draw开头的方法，也就是他可以画各种各样的图形</li><li>要draw一个东西，需要4个基本的组件：<ul><li>要有1个Bitmap来保存像素</li><li>1个canvas对象来调用draw方法，写入到上面的bitmap中</li><li>要画的东西，比如矩形，路径，文本，Bitmap等</li><li>最后还有1个Paint对象，用于描述颜色和样式风格</li></ul></li></ul><h3 id="2-Canvas可以画哪些？"><a href="#2-Canvas可以画哪些？" class="headerlink" title="2.Canvas可以画哪些？"></a>2.Canvas可以画哪些？</h3><p>​        弧线(arcs)、填充颜色(argb和color)、 Bitmap、圆(circle和oval)、点(point)、线(line)、矩形(Rect)、图片(Picture)、圆角矩形 (RoundRect)、文本(text)、顶点(Vertices)、路径(path)</p><h4 id="2-1-drawArc"><a href="#2-1-drawArc" class="headerlink" title="2.1 drawArc()"></a>2.1 drawArc()</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">drawArc</span><span class="token punctuation">(</span><span class="token annotation punctuation">@NonNull</span> RectF oval<span class="token punctuation">,</span> <span class="token keyword">float</span> startAngle<span class="token punctuation">,</span> <span class="token keyword">float</span> sweepAngle<span class="token punctuation">,</span> <span class="token keyword">boolean</span> useCenter<span class="token punctuation">,</span><span class="token annotation punctuation">@NonNull</span> Paint paint <span class="token punctuation">)</span></code></pre><p>第一个参数：RectF类(以浮点坐标表示的矩形)</p><pre class=" language-java"><code class="language-java">RectF mRectF <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Rect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* * left和top为矩形左上顶点的x和y坐标 * right和bottom为矩形右下顶点的x坐标和y坐标 * 注意，原点是当前View的左上角顶点，而不一定是整个屏幕的左上角 */</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">float</span> left<span class="token punctuation">,</span> <span class="token keyword">float</span> top<span class="token punctuation">,</span> <span class="token keyword">float</span> right<span class="token punctuation">,</span> <span class="token keyword">float</span> bottom<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre><p>后面的参数</p><ul><li><p>oval: 椭圆的边界，用于定义圆弧的形状和大小</p></li><li><p>startAngle : 弧的起始角度（<strong>时钟3点方向为0°</strong>，顺时针方向开始画）</p></li><li><p>sweepAngle：扫过的角度</p></li><li><p>useCenter：true表示会与矩形的中心点连接成为扇形，否则不会。这</p></li><li><p>paint: 画笔。如果Paint的Style为Stroke则没有扇形效果，只有一条弧线。</p><p>举个栗子：</p><pre><code>canvas.drawArc(oval,-90,120,false,mPaint);</code></pre><p>设置Paint的Style为Stroke的效果</p><img src=".绘图_images/image-20200620100212937.png" alt="image-20200620100212937" style="zoom:30%;" /><p>设置Paint的Style为FILL的效果</p><img src=".绘图_images/image-20200620100322035.png" alt="image-20200620100322035" style="zoom:30%;" /><p>设置useCenter设置为true的效果：</p><img src=".绘图_images/image-20200620100415642.png" alt="image-20200620100415642" style="zoom:30%;" /></li></ul><blockquote><p>注：sweepAngle &gt;= 360时，效果都是画1个圆。</p></blockquote><h3 id="3-Canvas-save-和-restore-保存和还原"><a href="#3-Canvas-save-和-restore-保存和还原" class="headerlink" title="3.Canvas  save() 和 restore()(保存和还原)"></a>3.Canvas  save() 和 restore()(保存和还原)</h3><h4 id="save"><a href="#save" class="headerlink" title="save()"></a>save()</h4><ul><li>保存的是坐标系的原点，坐标轴的方向</li><li>随后的平移，缩放，旋转，倾斜，concat或clipRect，clipPath调用都将照常运行,当后面调用restore()后，将会恢复到上一次save()时的状态，save()和restore()中间的调用将会被忘记</li></ul><h4 id="restore"><a href="#restore" class="headerlink" title="restore()"></a>restore()</h4><ul><li>恢复到上一次save()时的状态，resotre()调用次数比调用save()多时，将会发生错误</li></ul><p>举个栗子：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//保存当前状态</span>canvas<span class="token punctuation">.</span><span class="token function">save</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//选择坐标系</span> canvas<span class="token punctuation">.</span><span class="token function">rotate</span><span class="token punctuation">(</span>mSweep<span class="token punctuation">,</span> centerX<span class="token punctuation">,</span> centerY<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//画圆弧</span> canvas<span class="token punctuation">.</span><span class="token function">drawArc</span><span class="token punctuation">(</span>mRectF<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> mSweep<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> mArcPaint<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//恢复到上次保存的状态</span> canvas<span class="token punctuation">.</span><span class="token function">restore</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="4-Canvas旋转"><a href="#4-Canvas旋转" class="headerlink" title="4.Canvas旋转"></a>4.Canvas旋转</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">rotate</span><span class="token punctuation">(</span><span class="token keyword">float</span> degrees<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre><ul><li>将坐标系选择指定角度，默认是View的左上角顶点水平正向为x轴正向，垂直下方向为y轴正向</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">rotate</span><span class="token punctuation">(</span><span class="token keyword">float</span> degrees<span class="token punctuation">,</span> <span class="token keyword">float</span> px<span class="token punctuation">,</span> <span class="token keyword">float</span> py<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre><ul><li>以（px,py）为坐标系中心，选择指定角度</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/Android/Android图库(系统相册)的数据库</title>
      <link href="blog/1591484925.html"/>
      <url>blog/1591484925.html</url>
      
        <content type="html"><![CDATA[<p>​        最近参加了一个训练营，要做一个本地图片查看器的App(Android端)，基础功能要支持图片列表的展示，参考了我的手机相册，它是按日期分类展示，于是我也想做成这样。</p><p>系统相册的样子：</p><img src=".图片数据库_images/image-20200619205537961.png" alt="image-20200619205537961" style="zoom:50%;" /><p>网上搜索了一番，数据库中主要有3个字段跟时间有关的</p><ul><li><p><code>date_added</code>：图片添加的时间</p></li><li><p><code>date_modify</code>：图片上一次修改的时间</p></li><li><p><code>date_taken</code>：图片拍摄时间（不确定是不是，暂且这么认为）</p></li></ul><p>分别用这3个字段按降序排序，最后发现<code>date_taken</code>的效果跟系统相册是一样的，于是只用了这个字段。</p><p>后来想看看数据库中的表长什么样，看有没有字段的定义，经过一番搜索，发现</p><p>图片数据库实际是 <code>/data/data/com.android.providers.media/external.db</code>中<code>files</code>表的视图</p><p><code>external.db</code>中的表和视图如下：</p><p><img src=".图片数据库_images/image-20200619210150507.png" alt="image-20200619210150507" style="zoom:50%;" /><img src=".图片数据库_images/image-20200619210220902.png" alt="image-20200619210220902" style="zoom:50%;" /></p><h3 id="1-该数据库文件从Android模拟器获取的方式："><a href="#1-该数据库文件从Android模拟器获取的方式：" class="headerlink" title="1.该数据库文件从Android模拟器获取的方式："></a>1.该数据库文件从Android模拟器获取的方式：</h3><p>①adb 命令</p><pre><code>adb shellsuadb pull 到 /sdcard/目录下再从/sdcard/ 导出到电脑硬盘上</code></pre><blockquote><p>注:android 7.0的系统模拟器没有访问data/data的权限，su的权限都没有</p></blockquote><p>②AndroidStudio(3.6.3) 中菜单栏View-&gt;Tool Windows-&gt;Device File Explorer</p><p><img src=".%E5%9B%BE%E7%89%87%E6%95%B0%E6%8D%AE%E5%BA%93_images/image-20200619150259701.png" alt="image-20200619150259701"></p><blockquote><p>注：拷出来的时候.db-shm  还有.db-wal一并拷出来</p></blockquote><h3 id="2-表结构"><a href="#2-表结构" class="headerlink" title="2.表结构"></a>2.表结构</h3><p>该视图创建语句：</p><pre class=" language-sqlite"><code class="language-sqlite">CREATE VIEW images AS SELECT _id,_data,_size,_display_name,mime_type,title,date_added,date_modified,description,picasa_id,isprivate,latitude,longitude,datetaken,orientation,mini_thumb_magic,bucket_id,bucket_display_name,width,height FROM files WHERE media_type=1</code></pre><p>files表 建表语句</p><pre class=" language-sqlite"><code class="language-sqlite">CREATE TABLE "files" (    "_id"    INTEGER,    "_data"    TEXT UNIQUE COLLATE NOCASE,    "_size"    INTEGER,    "format"    INTEGER,    "parent"    INTEGER,    "date_added"    INTEGER,    "date_modified"    INTEGER,    "mime_type"    TEXT,    "title"    TEXT,    "description"    TEXT,    "_display_name"    TEXT,    "picasa_id"    TEXT,    "orientation"    INTEGER,    "latitude"    DOUBLE,    "longitude"    DOUBLE,    "datetaken"    INTEGER,    "mini_thumb_magic"    INTEGER,    "bucket_id"    TEXT,    "bucket_display_name"    TEXT,    "isprivate"    INTEGER,    "title_key"    TEXT,    "artist_id"    INTEGER,    "album_id"    INTEGER,    "composer"    TEXT,    "track"    INTEGER,    "year"    INTEGER CHECK("year" != 0),    "is_ringtone"    INTEGER,    "is_music"    INTEGER,    "is_alarm"    INTEGER,    "is_notification"    INTEGER,    "is_podcast"    INTEGER,    "album_artist"    TEXT,    "duration"    INTEGER,    "bookmark"    INTEGER,    "artist"    TEXT,    "album"    TEXT,    "resolution"    TEXT,    "tags"    TEXT,    "category"    TEXT,    "language"    TEXT,    "mini_thumb_data"    TEXT,    "name"    TEXT,    "media_type"    INTEGER,    "old_id"    INTEGER,    "storage_id"    INTEGER,    "is_drm"    INTEGER,    "width"    INTEGER,    "height"    INTEGER,    PRIMARY KEY("_id" AUTOINCREMENT));</code></pre><h3 id="3-这个-db文件macOS的打开方法之一"><a href="#3-这个-db文件macOS的打开方法之一" class="headerlink" title="3.这个.db文件macOS的打开方法之一"></a>3.这个.db文件macOS的打开方法之一</h3><p>下载地址<a href="http://www.sqlitebrowser.org/" target="_blank" rel="noopener">http://www.sqlitebrowser.org/</a></p><p><img src=".%E5%9B%BE%E7%89%87%E6%95%B0%E6%8D%AE%E5%BA%93_images/image-20200619150438334.png" alt="image-20200619150438334"></p><h3 id="4-MediaStore-Images-Media-EXTERNAL-CONTENT-URI"><a href="#4-MediaStore-Images-Media-EXTERNAL-CONTENT-URI" class="headerlink" title="4.MediaStore.Images.Media.EXTERNAL_CONTENT_URI"></a>4.MediaStore.Images.Media.EXTERNAL_CONTENT_URI</h3><p>​        这个uri对象的getPath()方法返回的值是“/external/images/media”</p><p>5.更新图库</p><p>5.1不建议调用insertImage</p><pre><code>try {                        MediaStore.Images.Media.insertImage(getContentResolver(),                                croppedFile.getAbsolutePath(),croppedFile.getName() , null);                    } catch (FileNotFoundException e) {                        e.printStackTrace();                    }</code></pre><ul><li>insertImage中传的图片路径的话，系统会再拷贝一张放到Pictures里面，系统相册会更新，但是你自己的相册应用可能更新不了，更新时机可能在重启之后，我试了一下，自己的相册应用在重启之后才更新，我的手机是Android8.0的</li></ul><p>5.2发广播</p><pre><code>Intent intent = new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE);                    intent.setData(croppedUri);                    PreviewActivity.this.sendBroadcast(intent);</code></pre><p>这种方式你看源码会发现他只能更新 路径只能是 <code>Environment.getExternalStorageDirectory()</code> 方法的返回值开头才有效， 我试了保存在 getFilesDir  getCacheDir 都不能更新</p><blockquote><p><a href="https://blog.csdn.net/weixin_34072458/article/details/88836444?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase" target="_blank" rel="noopener">https://blog.csdn.net/weixin_34072458/article/details/88836444?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase</a></p></blockquote><p>5.3</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/Android/adb/adb命令</title>
      <link href="blog/2862019959.html"/>
      <url>blog/2862019959.html</url>
      
        <content type="html"><![CDATA[<ol><li><p>从模拟器/sdcard/中导出文件到电脑硬盘中</p></li><li><p>从模拟器/data/data中导出文件到电脑硬盘，直接pull 会提示权限不足:</p><pre><code>adb: error: failed to stat remote object &#39;/data/system/locksettings.db&#39;: Permission denied</code></pre><ol><li>需要先拷贝到/sdcard中</li></ol></li><li><p>获取当前界面的activity的名称  以及该应用的包名</p><pre><code> adb shell dumpsys window w |grep \/ |grep name=</code></pre></li></ol><p>android 7.0  </p><pre><code>generic_x86:/data $ su/system/bin/sh: su: not found</code></pre><ol start="4"><li>adb -s 设备名称</li></ol><h2 id="人人车"><a href="#人人车" class="headerlink" title="人人车"></a>人人车</h2><h3 id="导出日志文件"><a href="#导出日志文件" class="headerlink" title="导出日志文件"></a>导出日志文件</h3><p>adb pull /sdcard/renrenche/logs/  /Users/guoziren/renrenche/test</p><p>导出数据库文件</p><p>adb pull /data/data/com.renrenche.carpublish/databases/car_publish.db /Users/guoziren/renrenche/database/</p><p>adb pull /data/data/com.renrenche.carpublish/databases/car_publish.db-journal /Users/guoziren/renrenche/database/</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/Android/UI/Drawable与Bitmap</title>
      <link href="blog/757537265.html"/>
      <url>blog/757537265.html</url>
      
        <content type="html"><![CDATA[<h2 id="Drawable与Bitmap"><a href="#Drawable与Bitmap" class="headerlink" title="Drawable与Bitmap"></a>Drawable与Bitmap</h2><h3 id="1-什么是Drawable"><a href="#1-什么是Drawable" class="headerlink" title="1.什么是Drawable"></a>1.什么是Drawable</h3><p>Android中的Drawable(可绘制对象) 表示“可以绘制的东西”，是一个抽象类，是所有Drawable对象的基类。最常见的颜色和图片都可以是一个Drawable.  与View不同，可绘制对象不能接收事件，也不能与用户进行交互。</p><h3 id="2-Drawable的子类-类型"><a href="#2-Drawable的子类-类型" class="headerlink" title="2.Drawable的子类/类型"></a>2.Drawable的子类/类型</h3><h4 id="2-1位图文件"><a href="#2-1位图文件" class="headerlink" title="2.1位图文件"></a><a href="https://developer.android.google.cn/guide/topics/resources/drawable-resource#Bitmap" target="_blank" rel="noopener">2.1位图文件</a></h4><p>位图图形文件（<code>.png</code>、<code>.jpg</code> 或 <code>.gif</code>）。创建 <code>BitmapDrawable</code>。</p><p>BitmapDrawable表示一张图片，是一个包裹了位图(bitmap)的Drawable，可以平铺，拉伸或对齐。 可以从文件路径，输入流，inflate .xml, 从Bitmap对象创建BitmapDrawable对象。</p><ol><li><p>引用drawable文件夹下的图片时，系统实际是为这张图片创建了BitmapDrawable对象</p></li><li><p>可以使用<bitmap>元素在XML文件中定义它，并R.drawable.filename来引用。</p><p>比如bitmap_xml.xml和touxiang.png(200*200 PNG)存储在drawable文件夹下，文件的内容为</p><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8"?></span><span class="token comment" spellcheck="true">&lt;!--tileMode 平铺模式 用于background背景模式，src是前景 ，background和src属性可同时使用--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bitmap</span> <span class="token attr-name"><span class="token namespace">xmlns:</span>android</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://schemas.android.com/apk/res/android<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>antialias</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>dither</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>filter</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>gravity</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>center<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@drawable/touxiang<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>tileMode</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mirror<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bitmap</span><span class="token punctuation">></span></span></code></pre><p>然后在ImageView中像引用一张图片那样去使用</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ImageView</span>        <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@+id/imageView2<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>background</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@drawable/bitmap_xml<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">app:</span>srcCompat</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@drawable/bitmap_xml<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span></code></pre><p>效果是这样的：</p><img src=".Drawable与Bitmap_images/image-20200618223410222.png" alt="image-20200618223410222" style="zoom:50%;" /></li></ol><h4 id="2-2九宫格文件与NinePatchDrawable"><a href="#2-2九宫格文件与NinePatchDrawable" class="headerlink" title="2.2九宫格文件与NinePatchDrawable"></a><a href="https://developer.android.google.cn/guide/topics/resources/drawable-resource#NinePatch" target="_blank" rel="noopener">2.2九宫格文件与<code>NinePatchDrawable</code></a></h4><p>具有可伸缩区域的 PNG 文件，支持根据内容调整图像大小 (<code>.9.png</code>)。创建 。</p><h4 id="2-3图层列表"><a href="#2-3图层列表" class="headerlink" title="2.3图层列表"></a><a href="https://developer.android.google.cn/guide/topics/resources/drawable-resource#LayerList" target="_blank" rel="noopener">2.3图层列表</a></h4><p>管理其他可绘制对象阵列的可绘制对象。这些可绘制对象按阵列顺序绘制，因此索引最大的元素绘制于顶部。创建 <code>LayerDrawable</code>。</p><h4 id="2-4状态列表与StateListDrawable"><a href="#2-4状态列表与StateListDrawable" class="headerlink" title="2.4状态列表与StateListDrawable"></a><a href="https://developer.android.google.cn/guide/topics/resources/drawable-resource#StateList" target="_blank" rel="noopener">2.4状态列表与<code>StateListDrawable</code></a></h4><p>此 XML 文件用于为不同状态引用不同位图图形（例如，按下按钮时使用不同图像）。</p><p><code>StateListDrawable</code>对应于<selector>标签，<strong>表示Drawable的集合</strong>，每个drawable对应View的一种状态，系统会根据View的状态选择合适的Drawable，<strong>主要用于设置可单击的View的背景(background属性)</strong>,最常见的是Button.</p><p>示例：button_background.xml</p><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>selector</span> <span class="token attr-name"><span class="token namespace">xmlns:</span>android</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://schemas.android.com/apk/res/android<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>item</span> <span class="token attr-name"><span class="token namespace">android:</span>state_pressed</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">android:</span>drawable</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@drawable/btn_pressed<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>item</span> <span class="token attr-name"><span class="token namespace">android:</span>state_focused</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">android:</span>drawable</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@drawable/btn_focused<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>item</span> <span class="token attr-name"><span class="token namespace">android:</span>drawable</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@drawable/btn_normal<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>selector</span><span class="token punctuation">></span></span></code></pre><p>一个item对应一个具体的Drawable，系统按照从上到小的顺序查找，找到第一个匹配的就停止。一般来说，默认的item放在selector的最后一条且不附带任何状态，因为默认的item不附带任何状态，所以它可以匹配View的任何状态.</p><h4 id="2-5级别列表"><a href="#2-5级别列表" class="headerlink" title="2.5级别列表"></a><a href="https://developer.android.google.cn/guide/topics/resources/drawable-resource#LevelList" target="_blank" rel="noopener">2.5级别列表</a></h4><p>此 XML 文件用于定义管理大量备选可绘制对象的可绘制对象，每个可绘制对象都配有最大备选数量。创建 <code>LevelListDrawable</code>。</p><h4 id="2-6转换可绘制对象"><a href="#2-6转换可绘制对象" class="headerlink" title="2.6转换可绘制对象"></a><a href="https://developer.android.google.cn/guide/topics/resources/drawable-resource#Transition" target="_blank" rel="noopener">2.6转换可绘制对象</a></h4><p>此 XML 文件用于定义可在两种可绘制对象资源之间交错淡出的可绘制对象。创建 <code>TransitionDrawable</code>。</p><h4 id="2-7插入可绘制对象"><a href="#2-7插入可绘制对象" class="headerlink" title="2.7插入可绘制对象"></a><a href="https://developer.android.google.cn/guide/topics/resources/drawable-resource#Inset" target="_blank" rel="noopener">2.7插入可绘制对象</a></h4><p>此 XML 文件用于定义以指定距离插入其他可绘制对象的可绘制对象。当视图需要小于视图实际边界的背景可绘制对象时，此类可绘制对象非常有用。</p><h4 id="2-8裁剪可绘制对象"><a href="#2-8裁剪可绘制对象" class="headerlink" title="2.8裁剪可绘制对象"></a><a href="https://developer.android.google.cn/guide/topics/resources/drawable-resource#Clip" target="_blank" rel="noopener">2.8裁剪可绘制对象</a></h4><p>此 XML 文件用于定义对其他可绘制对象进行裁剪（根据其当前级别值）的可绘制对象。创建 <code>ClipDrawable</code>。</p><h4 id="2-9缩放可绘制对象"><a href="#2-9缩放可绘制对象" class="headerlink" title="2.9缩放可绘制对象"></a><a href="https://developer.android.google.cn/guide/topics/resources/drawable-resource#Scale" target="_blank" rel="noopener">2.9缩放可绘制对象</a></h4><p>此 XML 文件用于定义更改其他可绘制对象大小（根据其当前级别值）的可绘制对象。创建 <code>ScaleDrawable</code></p><h4 id="2-9形状可绘制对象与-GradientDrawable"><a href="#2-9形状可绘制对象与-GradientDrawable" class="headerlink" title="2.9形状可绘制对象与 GradientDrawable"></a><a href="https://developer.android.google.cn/guide/topics/resources/drawable-resource#Shape" target="_blank" rel="noopener">2.9形状可绘制对象与 <code>GradientDrawable</code></a></h4><p>此 XML 文件用于定义几何形状（包括颜色和渐变）。 <code>GradientDrawable</code>和ShapeDrawable对象都可以从xml文件中获得，且根标签都必须是<shape>,<code>GradientDrawable</code>支持渐变色，这俩可以理解为通过颜色来构造图形。</p><p><shape>实际创建的是GradientDrawable对象</p><p>用法示例：XML文件保存在 <code>res/drawable/gradient_box.xml</code> 中：</p><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>shape</span> <span class="token attr-name"><span class="token namespace">xmlns:</span>android</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://schemas.android.com/apk/res/android<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>shape</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>rectangle<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>gradient</span>        <span class="token attr-name"><span class="token namespace">android:</span>startColor</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>#FFFF0000<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>endColor</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>#80FF00FF<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>angle</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>45<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>padding</span> <span class="token attr-name"><span class="token namespace">android:</span>left</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>7dp<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>top</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>7dp<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>right</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>7dp<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>bottom</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>7dp<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>corners</span> <span class="token attr-name"><span class="token namespace">android:</span>radius</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>8dp<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>shape</span><span class="token punctuation">></span></span></code></pre><p>此布局 XML 会将形状可绘制对象应用到视图：</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>TextView</span>    <span class="token attr-name"><span class="token namespace">android:</span>background</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@drawable/gradient_box<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span></code></pre><p>代码中使用</p><pre class=" language-java"><code class="language-java">Resources res <span class="token operator">=</span> <span class="token function">getResources</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Drawable shape <span class="token operator">=</span> ResourcesCompat<span class="token punctuation">.</span><span class="token function">getDrawable</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> R<span class="token punctuation">.</span>drawable<span class="token punctuation">.</span>gradient_box<span class="token punctuation">,</span> <span class="token function">getTheme</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>TextView tv <span class="token operator">=</span> <span class="token punctuation">(</span>TextView<span class="token punctuation">)</span><span class="token function">findViewById</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>id<span class="token punctuation">.</span>textview<span class="token punctuation">)</span><span class="token punctuation">;</span>tv<span class="token punctuation">.</span><span class="token function">setBackground</span><span class="token punctuation">(</span>shape<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><p>各属性详细的解释参考<a href="https://developer.android.google.cn/guide/topics/resources/drawable-resource#corners-element" target="_blank" rel="noopener">https://developer.android.google.cn/guide/topics/resources/drawable-resource#corners-element</a></p></blockquote><h3 id="3-位图"><a href="#3-位图" class="headerlink" title="3.位图"></a>3.位图</h3><p>位图图像。Android 支持以下三种格式的位图文件：<code>.png</code>（首选）、<code>.jpg</code>（可接受）、<code>.gif</code>（不建议）。</p><p>您可以使用文件名作为资源 ID 直接引用位图文件，也可以在 XML 中创建别名资源 ID。</p><p><strong>注</strong>：在构建过程中，可通过 <code>aapt</code> 工具自动优化位图文件，对图像进行无损压缩。例如，不需要超过 256 色的真彩色 PNG 可通过调色板转换为 8 位 PNG。这样产生的图像质量相同，但所需内存更少。因此请注意，此目录中的图像二进制文件在构建时可能会发生变化。如果您打算以比特流的形式读取图像，进而将其转换为位图，请改为将图像放在 <code>res/raw/</code> 文件夹中，避免系统对其进行优化。</p><h4 id="位图文件"><a href="#位图文件" class="headerlink" title="位图文件"></a>位图文件</h4><p> <code>.png</code>、<code>.jpg</code> 或 <code>.gif</code>都是位图 文件。将一个位图文件保存到 <code>res/drawable/</code> 目录中时，Android系统 会为其创建一个指向<code>BitmapDrawable</code> 资源的指针。</p><ul><li><p>文件位置：</p><p><code>res/drawable/*filename*.png</code>（<code>.png</code>、<code>.jpg</code> 或 <code>.gif</code>） 文件名用作资源 ID。</p></li><li><p>资源引用：</p><p>在 Java 中：<code>R.drawable.*filename*</code> 在 XML 中：<code>@[*package*:]drawable/*filename*</code></p></li><li><p>示例：</p><p>当图像保存为 <code>res/drawable/myimage.png</code> 后，此布局 XML 会将该图像应用至ImageView</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ImageView</span>    <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@drawable/myimage<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span></code></pre><p>以下应用代码将通过资源id来获得图像的Drawable对象：</p><pre class=" language-java"><code class="language-java">Resources res <span class="token operator">=</span> <span class="token function">getResources</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Drawable drawable <span class="token operator">=</span> ResourcesCompat<span class="token punctuation">.</span><span class="token function">getDrawable</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> R<span class="token punctuation">.</span>drawable<span class="token punctuation">.</span>myimage<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ul><h4 id="系统是如何加载一张图片的？"><a href="#系统是如何加载一张图片的？" class="headerlink" title="系统是如何加载一张图片的？"></a>系统是如何加载一张图片的？</h4><p>​        Bitmap在Android系统中表示一张图片，可以是png  jpg 或gif . BitmapFactory类提供了4类方法：decodeFile，decodeResouce，decodeStream，和decodeByteArray，分别用于从文件，资源，输入流，以及字节数组中加载出一个Bitmap。其中decodeFile，decodeResouce又间接调用了decodeStream方法，这四类方法最终是在Android底层实现的，对应着BitmapFactory类的几个Native方法。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/Android/UI/bitmap</title>
      <link href="blog/654105896.html"/>
      <url>blog/654105896.html</url>
      
        <content type="html"><![CDATA[<p>bitmap:由像素组成</p><p>像素：由多个bit组成，图像中的1个小方格，有位置，有透明度，有通道。</p><p><strong>通道是什么？</strong></p><p>你可以简单理解成通道就是容器，一个可以储存色彩、选区、分类记录图片信息的容器。只不过通道是以黑色、白色、灰色、来存储这些颜色的，所以通道里面没有彩色信息，只有黑白灰。</p><p>灰度与透明度</p><p>1.灰度不是透明度,透明度是针对每种颜色,每种颜色都可以有0-100的透明度</p><p>2.灰度到底是什么呢,灰度只是一种表达方式,是介于黑色和白色之间</p><p>3.灰度靠近黑色就变成黑色,灰度靠近白色就变成白色</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/Android/Android面试高频</title>
      <link href="blog/4187603060.html"/>
      <url>blog/4187603060.html</url>
      
        <content type="html"><![CDATA[<ul><li>消息通信Handler机制，消息传递过程</li><li>进程间通信Binder</li><li>View的绘制 自定义View，ConstraintLayout，各种Layout特点，原理</li><li>事件分发 滑动冲突</li><li>四大组件</li><li>图片加载 ，内存溢出,LruCache</li><li>网络框架</li><li>性能优化</li></ul><p>设计模式</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/Android/UI/更新UI的方式</title>
      <link href="blog/2472173284.html"/>
      <url>blog/2472173284.html</url>
      
        <content type="html"><![CDATA[<ol><li><p>Handler的post()方法：实际调用了handler的sendMessageDelayed()</p></li><li><p>Handler的sendMessage方法</p></li><li><p>View的post()方法   实际调用了handler的post方法</p></li><li><p>Activity的runOnUiThread()方法</p><pre><code>如果当前的线程不等于UI线程(主线程)，就去调用Handler的post()方法，否则就直接调用Runnable对象的run()方法。还有什么会比这更清晰明了的吗？通过以上所有源码的分析，我们已经发现了，不管是使用哪种方法在子线程中更新UI，其实背后的原理都是相同的，必须都要借助异步消息处理的机制来实现，而我们又已经将这个机制的流程完全搞明白了，真是一件一本万利的事情啊。</code></pre></li></ol><h2 id="方法一：-view-post-Runnable-action"><a href="#方法一：-view-post-Runnable-action" class="headerlink" title="方法一： view.post(Runnable action)"></a>方法一： view.post(Runnable action)</h2><p>在子线程中更新UI</p><pre><code>  textView.post(new Runnable() {        @Override        public void run() {            textView.setText(&quot;更新textView&quot;);        }    });</code></pre><p>如果你的子线程里可以得到要更新的view的话，可以用此方法进行更新。<br>view还有一个方法view.postDelayed(Runnable action, long delayMillis)用来延迟发送</p><h2 id="方法二：runOnUiThread-Runnable-action"><a href="#方法二：runOnUiThread-Runnable-action" class="headerlink" title="方法二：runOnUiThread(Runnable action)"></a>方法二：runOnUiThread(Runnable action)</h2><p>假如该方法是在子线程中<br>注意：context 对象要是 主线程中的MainActivity，这样强转才可以。</p><pre><code>    runOnUiThread(new Runnable() {        @Override        public void run() {            //此时已在主线程中，更新UI        }    });</code></pre><h2 id="方法三：Handler机制"><a href="#方法三：Handler机制" class="headerlink" title="方法三：Handler机制"></a>方法三：Handler机制</h2><p>首先在主线程中定义Handler，Handler mainHandler = new Handler();（必须要在主线程中定义才能操作主线程，如果想在其他地方定义声明时要这样写Handler mainHandler = new Handler(Looper.getMainLooper())，来获取主线程的 Looper 和 Queue ）<br>获取到 Handler 后就很简单了，用handler.post(Runnable r)方法把消息处理放在该 handler 依附的消息队列中（也就是主线程消息队列）。</p><h3 id="（1）假如该方法是在子线程中"><a href="#（1）假如该方法是在子线程中" class="headerlink" title="（1）假如该方法是在子线程中"></a>（1）假如该方法是在子线程中</h3><pre><code>Handler mainHandler = new Handler(Looper.getMainLooper());    mainHandler.post(new Runnable() {        @Override        public void run() {            //已在主线程中，更新UI        }    });</code></pre><p>Handler还有下面的方法：<br>1.postAtTime(Runnable r, long uptimeMillis); //在某一时刻发送消息<br>2.postAtDelayed(Runnable r, long delayMillis); //延迟delayMillis毫秒再发送消息</p><h2 id="（2）-假设在主线程中"><a href="#（2）-假设在主线程中" class="headerlink" title="（2）: 假设在主线程中"></a>（2）: 假设在主线程中</h2><pre><code>Handler myHandler = new Handler() {        @Override        public void handleMessage(Message msg) {            switch(msg.what) {                case 0:                    //更新UI等                    break;                default:                    break;            }        }    }</code></pre><p>之后可以把 mainHandler 当做参数传递在各个类之间，当需要更新UI时，可以调用sendMessage一系列方法来执行handleMessage里的操作。<br>子线程中发送消息到主线程更新UI</p><p>之后可以把 mainHandler 当做参数传递在各个类之间，当需要更新UI时，可以调用sendMessage一系列方法来执行handleMessage里的操作。<br>子线程中发送消息到主线程更新UI</p><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/**  *获取消息，尽量用obtainMessage()方法，查看源码发现，该方法节省内存。  *不提倡用Messenger msg=new Messenger()这种方法，每次都去创建一个对象，肯定不节省内存啦！  *至于为什么该方法还存在，估计还是有存在的必要吧。（留作以后深入研究）  */</span><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token annotation punctuation">@Override</span>          <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token comment" spellcheck="true">//耗时操作，完成之后发送消息给Handler，完成UI更新；  </span>            mHandler<span class="token punctuation">.</span><span class="token function">sendEmptyMessage</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">//需要数据传递，用下面方法；  </span>            Message msg <span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Message</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              msg<span class="token punctuation">.</span>obj <span class="token operator">=</span> <span class="token string">"数据"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//可以是基本类型，可以是对象，可以是List、map等；  </span>            mHandler<span class="token punctuation">.</span><span class="token function">sendMessage</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>              myHandler<span class="token punctuation">.</span><span class="token function">sendEmptyMessage</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//其实内部实现还是和上面一样</span>            <span class="token function">endEmptyMessageAtTime</span><span class="token punctuation">(</span><span class="token keyword">int</span> what<span class="token punctuation">,</span> <span class="token keyword">long</span> uptimeMillis<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//定时发送空消息</span>            <span class="token function">sendEmptyMessageDelayed</span><span class="token punctuation">(</span><span class="token keyword">int</span> what<span class="token punctuation">,</span> <span class="token keyword">long</span> delayMillis<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//延时发送空消息</span>            <span class="token function">sendMessageAtTime</span><span class="token punctuation">(</span>Message msg<span class="token punctuation">,</span> <span class="token keyword">long</span> uptimeMillis<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//定时发送消息</span>            <span class="token function">sendMessageDelayed</span><span class="token punctuation">(</span>Message msg<span class="token punctuation">,</span> <span class="token keyword">long</span> delayMillis<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//延时发送消息</span>            <span class="token function">sendMessageAtFrontOfQueue</span><span class="token punctuation">(</span>Message msg<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//最先处理消息（慎用）    </span>        <span class="token punctuation">}</span>                   <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  </code></pre><h2 id="方法四：-AsyncTask"><a href="#方法四：-AsyncTask" class="headerlink" title="方法四： AsyncTask"></a>方法四： AsyncTask</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/Android/UI/Glide用法</title>
      <link href="blog/1964517792.html"/>
      <url>blog/1964517792.html</url>
      
        <content type="html"><![CDATA[<h2 id="Glide3"><a href="#Glide3" class="headerlink" title="Glide3"></a>Glide3</h2><h3 id="Glide最基本的使用方式："><a href="#Glide最基本的使用方式：" class="headerlink" title="Glide最基本的使用方式："></a>Glide最基本的使用方式：</h3><p>​        三步走：先with()，再load()，最后into()。</p><p>首先，调用Glide.with()方法用于创建一个加载图片的实例。with()方法可以接收Context、Activity或者Fragment类型的参数。也就是说我们选择的范围非常广，不管是在Activity还是Fragment中调用with()方法，都可以直接传this。那如果调用的地方既不在Activity中也不在Fragment中呢？也没关系，我们可以获取当前应用程序的ApplicationContext，传入到with()方法当中。</p><p>注意with()方法中传入的实例会决定Glide加载图片的生命周期，</p><ul><li>如果传入的是Activity或者Fragment的实例，那么当这个Activity或Fragment被销毁的时候，图片加载也会停止。</li><li>如果传入的是ApplicationContext，那么只有当应用程序被杀掉的时候，图片加载才会停止。</li></ul><h3 id="占位图"><a href="#占位图" class="headerlink" title="占位图"></a>占位图</h3><p>占位图placeholder()方法</p><p>异常占位图error()方法</p><h3 id="Glide缓存"><a href="#Glide缓存" class="headerlink" title="Glide缓存"></a>Glide缓存</h3><p> diskCacheStrategy(DiskCacheStrategy.NONE)</p><h3 id="asBitmap"><a href="#asBitmap" class="headerlink" title="asBitmap()"></a>asBitmap()</h3><p>​    Glide支持自动加载gif或者静态图片从1个url，要想只加载静态图片，用</p><h3 id="asGif"><a href="#asGif" class="headerlink" title="asGif()"></a>asGif()</h3><p>   加载动态图片,此时如果传入的是静态的图片，则加载失败.</p><h3 id="指定图片大小override-100-100"><a href="#指定图片大小override-100-100" class="headerlink" title="指定图片大小override(100, 100)"></a>指定图片大小override(100, 100)</h3><p>​        使用Glide，我们就完全不用担心图片内存浪费，甚至是内存溢出的问题。因为Glide从来都不会直接将图片的完整尺寸全部加载到内存中，而是用多少加载多少。Glide会自动判断ImageView的大小，然后只将这么大的图片像素加载到内存当中，帮助我们节省内存开支。</p><p>​        使用override()方法指定了一个图片的尺寸，也就是说，Glide现在只会将图片加载成100*100像素的尺寸，而不会管你的ImageView的大小是多少了。</p><h3 id="加载图片时的内存浪费"><a href="#加载图片时的内存浪费" class="headerlink" title="加载图片时的内存浪费"></a>加载图片时的内存浪费</h3><p>​        我们平时在加载图片的时候很容易会造成内存浪费。什么叫内存浪费呢？比如说一张图片的尺寸是1000<em>1000像素，但是我们界面上的ImageView可能只有200</em>200像素，这个时候如果你不对图片进行任何压缩就直接读取到内存中，这就属于内存浪费了，因为程序中根本就用不到这么高像素的图片。</p><h2 id="Glide4"><a href="#Glide4" class="headerlink" title="Glide4"></a>Glide4</h2><p>​    Glide 4中引入了一个RequestOptions对象，将这一系列的API都移动到了RequestOptions当中。这样做的好处是可以使我们摆脱冗长的Glide加载语句，而且还能进行自己的API封装，因为RequestOptions是可以作为参数传入到方法中的。</p><h3 id="占位图-1"><a href="#占位图-1" class="headerlink" title="占位图"></a>占位图</h3><pre><code>RequestOptions options = new RequestOptions()        .placeholder(R.drawable.ic_launcher_background)        .error(R.drawable.error)        .diskCacheStrategy(DiskCacheStrategy.NONE);Glide.with(this)     .load(url)     .apply(options)     .into(imageView);</code></pre><h3 id="指定图片大小"><a href="#指定图片大小" class="headerlink" title="指定图片大小"></a>指定图片大小</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//给图片指定一个固定的大小</span>RequestOptions options <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RequestOptions</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">override</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//如果你想加载一张图片的原始尺寸的话，可以使用Target.SIZE_ORIGINAL关键字</span> <span class="token comment" spellcheck="true">//.override(Target.SIZE_ORIGINAL);</span>Glide<span class="token punctuation">.</span><span class="token function">with</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>     <span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span>     <span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span>     <span class="token punctuation">.</span><span class="token function">into</span><span class="token punctuation">(</span>imageView<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>这个diskCacheStrategy()方法基本上就是Glide硬盘缓存功能的一切，它可以接收五种参数：</p><ul><li>DiskCacheStrategy.NONE： 表示不缓存任何内容。</li><li>DiskCacheStrategy.DATA： 表示只缓存原始图片。</li><li>DiskCacheStrategy.RESOURCE： 表示只缓存转换过后的图片。</li><li>DiskCacheStrategy.ALL ： 表示既缓存原始图片，也缓存转换过后的图片。</li><li>DiskCacheStrategy.AUTOMATIC： 表示让Glide根据图片资源智能地选择使用哪一种缓存策略（默认选项）。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/Android/热修复/DexPathList的构造</title>
      <link href="blog/64048785.html"/>
      <url>blog/64048785.html</url>
      
        <content type="html"><![CDATA[<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**     * Constructs an instance.     *     * dexFile must be an in-memory representation of a full dexFile.     *     * @param dexFiles the array of in-memory dex files containing classes.     * @param parent the parent class loader     *     * @hide     */</span>    <span class="token keyword">public</span> <span class="token function">BaseDexClassLoader</span><span class="token punctuation">(</span>ByteBuffer<span class="token punctuation">[</span><span class="token punctuation">]</span> dexFiles<span class="token punctuation">,</span> ClassLoader parent<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// TODO We should support giving this a library search path maybe.</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>pathList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DexPathList</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> dexFiles<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token function">DexPathList</span><span class="token punctuation">(</span>ClassLoader definingContext<span class="token punctuation">,</span> String dexPath<span class="token punctuation">,</span>            String librarySearchPath<span class="token punctuation">,</span> File optimizedDirectory<span class="token punctuation">,</span> <span class="token keyword">boolean</span> isTrusted<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>             <span class="token keyword">this</span><span class="token punctuation">.</span>dexElements <span class="token operator">=</span> <span class="token function">makeDexElements</span><span class="token punctuation">(</span><span class="token function">splitDexPath</span><span class="token punctuation">(</span>dexPath<span class="token punctuation">)</span><span class="token punctuation">,</span> optimizedDirectory<span class="token punctuation">,</span>suppressedExceptions<span class="token punctuation">,</span> definingContext<span class="token punctuation">,</span> isTrusted<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>            <span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"> <span class="token keyword">private</span> <span class="token keyword">static</span> Element<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">makeDexElements</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>File<span class="token operator">></span> files<span class="token punctuation">,</span> File optimizedDirectory<span class="token punctuation">,</span>            List<span class="token operator">&lt;</span>IOException<span class="token operator">></span> suppressedExceptions<span class="token punctuation">,</span> ClassLoader loader<span class="token punctuation">,</span> <span class="token keyword">boolean</span> isTrusted<span class="token punctuation">)</span> <span class="token punctuation">{</span>      Element<span class="token punctuation">[</span><span class="token punctuation">]</span> elements <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Element</span><span class="token punctuation">[</span>files<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token keyword">int</span> elementsPos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/*       * Open all files and load the (direct or contained) dex files up front.       */</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span>File file <span class="token operator">:</span> files<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>file<span class="token punctuation">.</span><span class="token function">isDirectory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token comment" spellcheck="true">// We support directories for looking up resources. Looking up resources in</span>              <span class="token comment" spellcheck="true">// directories is useful for running libcore tests.</span>              elements<span class="token punctuation">[</span>elementsPos<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Element</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>file<span class="token punctuation">.</span><span class="token function">isFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>              String name <span class="token operator">=</span> file<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              DexFile dex <span class="token operator">=</span> null<span class="token punctuation">;</span>              <span class="token keyword">if</span> <span class="token punctuation">(</span>name<span class="token punctuation">.</span><span class="token function">endsWith</span><span class="token punctuation">(</span>DEX_SUFFIX<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                  <span class="token comment" spellcheck="true">// Raw dex file (not inside a zip/jar).</span>                  <span class="token keyword">try</span> <span class="token punctuation">{</span>                      dex <span class="token operator">=</span> <span class="token function">loadDexFile</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span> optimizedDirectory<span class="token punctuation">,</span> loader<span class="token punctuation">,</span> elements<span class="token punctuation">)</span><span class="token punctuation">;</span>                      <span class="token keyword">if</span> <span class="token punctuation">(</span>dex <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                          elements<span class="token punctuation">[</span>elementsPos<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Element</span><span class="token punctuation">(</span>dex<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>                      <span class="token punctuation">}</span>                  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> suppressed<span class="token punctuation">)</span> <span class="token punctuation">{</span>                      System<span class="token punctuation">.</span><span class="token function">logE</span><span class="token punctuation">(</span><span class="token string">"Unable to load dex file: "</span> <span class="token operator">+</span> file<span class="token punctuation">,</span> suppressed<span class="token punctuation">)</span><span class="token punctuation">;</span>                      suppressedExceptions<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>suppressed<span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token punctuation">}</span>              <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                  <span class="token keyword">try</span> <span class="token punctuation">{</span>                      dex <span class="token operator">=</span> <span class="token function">loadDexFile</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span> optimizedDirectory<span class="token punctuation">,</span> loader<span class="token punctuation">,</span> elements<span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> suppressed<span class="token punctuation">)</span> <span class="token punctuation">{</span>                      <span class="token comment" spellcheck="true">/*                       * IOException might get thrown "legitimately" by the DexFile constructor if                       * the zip file turns out to be resource-only (that is, no classes.dex file                       * in it).                       * Let dex == null and hang on to the exception to add to the tea-leaves for                       * when findClass returns null.                       */</span>                      suppressedExceptions<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>suppressed<span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token punctuation">}</span>                  <span class="token keyword">if</span> <span class="token punctuation">(</span>dex <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                      elements<span class="token punctuation">[</span>elementsPos<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Element</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                      elements<span class="token punctuation">[</span>elementsPos<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Element</span><span class="token punctuation">(</span>dex<span class="token punctuation">,</span> file<span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token punctuation">}</span>              <span class="token punctuation">}</span>              <span class="token keyword">if</span> <span class="token punctuation">(</span>dex <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> isTrusted<span class="token punctuation">)</span> <span class="token punctuation">{</span>                dex<span class="token punctuation">.</span><span class="token function">setTrusted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token punctuation">}</span>          <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>              System<span class="token punctuation">.</span><span class="token function">logW</span><span class="token punctuation">(</span><span class="token string">"ClassLoader referenced unknown path: "</span> <span class="token operator">+</span> file<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>      <span class="token punctuation">}</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>elementsPos <span class="token operator">!=</span> elements<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>          elements <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elements<span class="token punctuation">,</span> elementsPos<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">return</span> elements<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**     * Constructs a {@code DexFile} instance, as appropriate depending on whether     * {@code optimizedDirectory} is {@code null}. An application image file may be associated with     * the {@code loader} if it is not null.     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> DexFile <span class="token function">loadDexFile</span><span class="token punctuation">(</span>File file<span class="token punctuation">,</span> File optimizedDirectory<span class="token punctuation">,</span> ClassLoader loader<span class="token punctuation">,</span>                                       Element<span class="token punctuation">[</span><span class="token punctuation">]</span> elements<span class="token punctuation">)</span>            <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>optimizedDirectory <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">DexFile</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span> loader<span class="token punctuation">,</span> elements<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            String optimizedPath <span class="token operator">=</span> <span class="token function">optimizedPathFor</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span> optimizedDirectory<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> DexFile<span class="token punctuation">.</span><span class="token function">loadDex</span><span class="token punctuation">(</span>file<span class="token punctuation">.</span><span class="token function">getPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> optimizedPath<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> loader<span class="token punctuation">,</span> elements<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Representation of an entire {@code .dex} (Dalvik EXecutable) * file, which itself consists of a set of Dalvik classes. */</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">DexFile</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><p>DexPathlist借助DexFile的native方法完成.dex文件的加载</p><p>一个Element对应一个DexFile.</p><h3 id="热修复怎么实现？"><a href="#热修复怎么实现？" class="headerlink" title="热修复怎么实现？"></a>热修复怎么实现？</h3><p>类加载器加载类其实是在dexElements中加载，将新的.dex插入到dexElements的数组起始位置。</p><p>为什么是前面？</p><p>前面找到了就不会往后面找同一个类。</p><p>热修复流派：</p><p>native:阿里</p><p>java:</p><p>​    mutidex: tinker(classloader修改elements) qzone超级补丁</p><p>​    instant-run（美团）：可以即时生效，不需要重启，重启是因为补丁加载是在Applicatiion类的启动过程中调用</p><p>tinker是怎么写的？</p><p>github上  systemclassloaderAdder类 installDex中</p><p>原理：修改Dexpathlist中的dexElements数组中.</p><pre><code>1.classloader拿到baseClassloder中的dexPathlist2.找dexElements,修改它  找到新的把新的插入到它的前面</code></pre><h3 id="讲工程代码：第二节：-【15：38】"><a href="#讲工程代码：第二节：-【15：38】" class="headerlink" title="讲工程代码：第二节： 【15：38】"></a>讲工程代码：第二节： 【15：38】</h3><h3 id="instant-run模式讲解-30-00"><a href="#instant-run模式讲解-30-00" class="headerlink" title="instant run模式讲解[30:00]"></a>instant run模式讲解[30:00]</h3><p>增量更新。</p><p>兼容的作业【45分】</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/Android/热修复/Untitled</title>
      <link href="blog/2120118988.html"/>
      <url>blog/2120118988.html</url>
      
        <content type="html"><![CDATA[<p>什么是JIT,什么是热点代码</p><p>dalvik是什么</p><p>什么是art</p><p>art兼容dalvik</p><p>OAT</p><h3 id="31-00"><a href="#31-00" class="headerlink" title="31:00"></a>31:00</h3><p><img src=".Untitled_images/image-20200529144834666.png" alt="image-20200529144834666"></p><p>ANDROID中的classloader</p><p>Activity.class的classloader是bootclassloader</p><p>MainActivity.class 的classloader是pathclassloader</p><h3 id="双亲委托机制-53-00"><a href="#双亲委托机制-53-00" class="headerlink" title="双亲委托机制[53:00]"></a>双亲委托机制[53:00]</h3><p>pathclassloader.loadclass源码分析</p><p>dexElements是什么？在DexPathList的构造方法中调用makePathElement(dex文件路径)创建出来的[82:51]</p><p>120min : 讲热修复，晕了，没看懂</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/面经/问面试官</title>
      <link href="blog/3463650872.html"/>
      <url>blog/3463650872.html</url>
      
        <content type="html"><![CDATA[<p><strong>职责篇</strong></p><p>针对新员工有哪些培训？</p><p>如果我入职了，可能会负责哪块，主要做什么？</p><p>你们现在主要是做什么的，主要负责哪块？</p><p><strong>技术篇</strong></p><p>你常用的堆栈是什么？</p><p>面试过程中遇到自己不会的问题或是技术点，但是不是那种网上能立马找到答案的或者说有固定答案的，也可以问问面试官，或者和面试官一起探讨。</p><p>如果可以，我想知道，您对我本次面试有什么评价或是建议么？</p><p>团队规模有多大，移动端有多少人、Android端有多少人、测试怎么测等？</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/设计模式/面向对象和面向过程</title>
      <link href="blog/1163373641.html"/>
      <url>blog/1163373641.html</url>
      
        <content type="html"><![CDATA[<p><strong>面向对象：</strong></p><p><strong>优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统 更加灵活、更加易于维护<br>缺点：性能比面向过程低</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/剑指offer leetcode/链表</title>
      <link href="blog/220315527.html"/>
      <url>blog/220315527.html</url>
      
        <content type="html"><![CDATA[<ul><li>链表问题的最优解往往是在空间复杂度上下功夫，就是怎样用最小的空间复杂度</li><li>快指针 慢指针</li></ul><h3 id="剑指Offer链表题目-9个-："><a href="#剑指Offer链表题目-9个-：" class="headerlink" title="剑指Offer链表题目(9个)："></a>剑指Offer链表题目(9个)：</h3><ul><li>6 从尾到头打印链表</li><li>18 在O(1)时间内删除链表结点</li><li>22 链表中倒数第k个结点</li><li>23 链表中环的入口结点</li><li>24 反转链表</li><li>25 合并两个排序的链表</li><li>35 复杂链表的复制</li><li>36 二叉搜索树与双向链表</li><li>52 两个链表的第一个公共结点</li><li>68</li></ul><h4 id="6-从尾到头打印链表-☆"><a href="#6-从尾到头打印链表-☆" class="headerlink" title="6 从尾到头打印链表(☆)"></a>6 从尾到头打印链表(☆)</h4><p>6.1 反转链表法（会改变链表结构，询问是否允许修改输入数据）</p><p>6.2 借助栈</p><p>6.3 递归（不时候链表很长的时候）</p><blockquote><p>easy，过。</p></blockquote><h4 id="18-在O-1-时间内删除链表结点-☆☆"><a href="#18-在O-1-时间内删除链表结点-☆☆" class="headerlink" title="18 在O(1)时间内删除链表结点(☆☆)"></a>18 在O(1)时间内删除链表结点(☆☆)</h4><p>18.1 顺序法，找到要删除的结点，如下图(b)。时间:O(n)</p><p>18.2 O(1)时间复杂度的值覆盖法:</p><p>​        <img src=".链表_images/image-20200919163944637.png" alt="image-20200919163944637" style="zoom:50%;" /></p><p>​        假设要删除结点i，把j的值赋值给结点i，删除j(i指向j的next) 。这种时间复杂度O(1) 。</p><blockquote><p>前提待删除结点在链表中。还有对链表只有1个结点 和 要删除的结点是尾结点做分别处理</p></blockquote><h4 id="22-链表中倒数第k个结点-☆☆"><a href="#22-链表中倒数第k个结点-☆☆" class="headerlink" title="22 链表中倒数第k个结点(☆☆)"></a>22 链表中倒数第k个结点(<font color='red'>☆☆</font>)</h4><p>双指针法:p1,p2指向投结点，快指针p1先走k步，后面一起走</p><pre><code>public ListNode getKthFromEnd(ListNode head, int k) {         ListNode p1 = head,p2 = head;         while(k &gt; 0){             p1 = p1.next;             k--;         }         while(p1 != null){             p1 = p1.next;             p2 = p2.next;         }            return p2;    }</code></pre><blockquote><p>快指针p1先走k步，后面一起走.</p><img src=".链表_images/image-20200919171148225.png" alt="image-20200919171148225" style="zoom:50%;" /></blockquote><h4 id="23-链表中环的入口结点-☆☆☆"><a href="#23-链表中环的入口结点-☆☆☆" class="headerlink" title="23 链表中环的入口结点(☆☆☆)"></a>23 链表中环的入口结点(<font color='red'>☆☆☆</font>)</h4><p>双指针法：快指针遍历到null时，则没有环。有环前提下2指针相遇后，快指针回到起点，循环同时往后面走一步，相遇时的结点即为环的入口结点。</p><blockquote><p>记住这个法则就可以，过。</p></blockquote><h4 id="24-链表反转-☆☆☆☆☆字节"><a href="#24-链表反转-☆☆☆☆☆字节" class="headerlink" title="24 链表反转(☆☆☆☆☆字节)"></a>24 链表反转(☆☆☆☆☆字节)</h4><ol><li><p>迭代法</p><p>采用头插法，定义3个指针:旧链表cur,新链表head,  临时指针temp指向cur的next</p></li><li><p>递归法</p><ul><li>因为最终结果是最后一个结点是反转后的根，我们就要返回根，递归直到最后一个结点，返回head,也就是递归最后1次返回的是最后一个结点</li><li>递归到倒第二个结点，让他的后一个结点指向他自己head.next.next = head</li><li>因为要求第一个结点的Next为null， 所以再加一句head.nxet = null;</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> ListNode <span class="token function">reverseList</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> null <span class="token operator">||</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> head<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        ListNode p <span class="token operator">=</span> <span class="token function">reverseList</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>        head<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>        head<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">return</span> p<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre></li></ol><h4 id="25-合并2个有序链表-☆☆☆☆☆字节"><a href="#25-合并2个有序链表-☆☆☆☆☆字节" class="headerlink" title="25 合并2个有序链表(☆☆☆☆☆字节)"></a>25 合并2个有序链表(<font color='red'>☆☆☆☆☆</font>字节)</h4><p>递归去做。</p><p><a href="https://leetcode-cn.com/explore/featured/card/top-interview-questions-easy/6/linked-list/44/" target="_blank" rel="noopener">https://leetcode-cn.com/explore/featured/card/top-interview-questions-easy/6/linked-list/44/</a></p><p>递归退出条件，l1空返回l2，l2空返回l1</p><p>1.比较l1,l2，值下的就是head</p><p>2.递归调用mergeTwoList函数返回给定参数l1,l2合并后链表的头结点。</p><p>3.head.next 指向上面返回的</p><h4 id="35-复杂链表的复制-☆☆☆"><a href="#35-复杂链表的复制-☆☆☆" class="headerlink" title="35 复杂链表的复制(☆☆☆)"></a>35 复杂链表的复制(<font color='red'>☆☆☆</font>)</h4><h5 id="法一：时间复杂度O-n-2-空间复杂度O-1"><a href="#法一：时间复杂度O-n-2-空间复杂度O-1" class="headerlink" title="法一：时间复杂度O(n^2^),空间复杂度O(1)"></a>法一：时间复杂度O(n^2^),空间复杂度O(1)</h5><p>①复制原始链表上的每个结点，并用next链接起来</p><p>②设置每个结点的sibling属性，需要遍历链表，每个结点需要O(n)</p><h5 id="法二：时间复杂度O-n-，空间复杂度O-n"><a href="#法二：时间复杂度O-n-，空间复杂度O-n" class="headerlink" title="法二：时间复杂度O(n)，空间复杂度O(n)"></a>法二：时间复杂度O(n)，空间复杂度O(n)</h5><p>针对第二步优化，空间换时间，要想每个结点sibling的查找 达到O(1)，自然想到哈希表</p><p>​        假设原始链表结点N的sibling指向结点S，那么复制链表N<code>指向S</code>,哈希表保存N,N`</p><h5 id="法三：时间复杂度O-n-，空间复杂度O-1"><a href="#法三：时间复杂度O-n-，空间复杂度O-1" class="headerlink" title="法三：时间复杂度O(n)，空间复杂度O(1)"></a>法三：时间复杂度O(n)，空间复杂度O(1)</h5><p>步骤①复制原始链表上的每个结点,把N`接在N的后面</p><p>​        <img src=".链表_images/image-20200919190749711.png" alt="image-20200919190749711" style="zoom:50%;" /></p><p>​    ②设置复制出来的节点的sibling属性</p><p>​    <img src=".链表_images/image-20200919190850584.png" alt="image-20200919190850584" style="zoom:40%;" /></p><p>​    ③拆分成2个链表:把奇数位置的结点用next连接起来就是原始链表，    把偶数位置的结点用next连接起来就是复制链表。</p><img src=".链表_images/image-20200919191018557.png" alt="image-20200919191018557" style="zoom:40%;" /><blockquote><p>注 ： 三种方法背住</p></blockquote><h4 id="36-二叉搜索树与双向链表-☆☆☆"><a href="#36-二叉搜索树与双向链表-☆☆☆" class="headerlink" title="36 二叉搜索树与双向链表(☆☆☆)"></a>36 二叉搜索树与双向链表(<font color='red'>☆☆☆</font>)</h4><p>任然采用递归（也写得出来）</p><ul><li><p>将二叉搜索树的左孩子指向前驱，右孩子指向后继，采用中序递归遍历来操作.</p></li><li><p>把二叉树看成三部分，根，左子树，右子树</p></li><li><p>把左右子树转换成双链表后和根节点接起来，根节点的前驱指向左子树中序遍历的最后一个结点；</p><p>根节点的后继指向右子树的最小结点，转换右子树前先存起来它的最小结点</p></li></ul><blockquote><p> 注：解决的关键在于把1个大问题分解成几个小问题，然后递归地处理.</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> TreeNode <span class="token function">convert</span><span class="token punctuation">(</span>TreeNode pRootOfTree<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pRootOfTree <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//1.转换左子树，返回中序遍历的最后一个结点</span>        TreeNode lastNode <span class="token operator">=</span> <span class="token function">convert</span><span class="token punctuation">(</span>pRootOfTree<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//根节点的左孩子指向左子树中序遍历的最后一个结点(转换双链表)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>lastNode <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>            lastNode<span class="token punctuation">.</span>right <span class="token operator">=</span> pRootOfTree<span class="token punctuation">;</span>            pRootOfTree<span class="token punctuation">.</span>left <span class="token operator">=</span> lastNode<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//2-pre把先右子树的最小结点存下来</span>        TreeNode successorNode <span class="token operator">=</span> <span class="token function">findSuccessorNode</span><span class="token punctuation">(</span>pRootOfTree<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//2.转换右子树</span>        TreeNode lastNode2 <span class="token operator">=</span> <span class="token function">convert</span><span class="token punctuation">(</span>pRootOfTree<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//根结点的右孩子指向右子树的最小结点(转换双链表)</span>        pRootOfTree<span class="token punctuation">.</span>right <span class="token operator">=</span> successorNode<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>successorNode <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>            successorNode<span class="token punctuation">.</span>left <span class="token operator">=</span> pRootOfTree<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//右子树为空，根节点就是中序遍历的最后1个结点,返回它</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>lastNode2 <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> pRootOfTree<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//返回以pRootOfTree为根结点的中序遍历的最后一个结点</span>        <span class="token keyword">return</span> lastNode2<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><blockquote><p> 注: 有点难</p></blockquote><h4 id="52-两个链表的第一个公共结点-☆☆"><a href="#52-两个链表的第一个公共结点-☆☆" class="headerlink" title="52 两个链表的第一个公共结点(☆☆)"></a>52 两个链表的第一个公共结点(<font color='red'>☆☆</font>)</h4><p>多种解法，用O(m+n)的，leetcode有做过2次.</p><p>特点：相交后是一条链表</p><blockquote><p> <a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/description/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/intersection-of-two-linked-lists/description/</a></p></blockquote><pre class=" language-java"><code class="language-java">方法一：常链表先走几步方法二：哈希表法（易理解）<span class="token punctuation">,</span>时间复杂度<span class="token function">O</span><span class="token punctuation">(</span>m<span class="token operator">+</span>n<span class="token punctuation">)</span><span class="token punctuation">,</span>空间复杂度<span class="token function">O</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span>或<span class="token function">O</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span>          基于相交以及后面的部分是一样的，是一条链表，比较引用<span class="token operator">/</span>地址是否在哈希表中方法三：双指针法（不易理解，参考题解有图示），时间复杂度<span class="token function">O</span><span class="token punctuation">(</span>m<span class="token operator">+</span>n<span class="token punctuation">)</span><span class="token punctuation">,</span>空间复杂度<span class="token function">O</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">public</span> ListNode <span class="token function">getIntersectionNode</span><span class="token punctuation">(</span>ListNode headA<span class="token punctuation">,</span> ListNode headB<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>headA <span class="token operator">==</span> null <span class="token operator">||</span> headB <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> null<span class="token punctuation">;</span>    ListNode pA <span class="token operator">=</span> headA<span class="token punctuation">,</span> pB <span class="token operator">=</span> headB<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>pA <span class="token operator">!=</span> pB<span class="token punctuation">)</span> <span class="token punctuation">{</span>        pA <span class="token operator">=</span> pA <span class="token operator">==</span> null <span class="token operator">?</span> headB <span class="token operator">:</span> pA<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        pB <span class="token operator">=</span> pB <span class="token operator">==</span> null <span class="token operator">?</span> headA <span class="token operator">:</span> pB<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> pA<span class="token punctuation">;</span><span class="token punctuation">}</span> 这个题跟结点的值val不太有关系，比较的是引用<span class="token punctuation">,</span>也就是当指向的是同一个对象时，即为交点</code></pre><h3 id="2-回文链表"><a href="#2-回文链表" class="headerlink" title="2.回文链表"></a>2.回文链表</h3><p>法一：将值复制到数组中后用双指针法判断是否为回文  时间复杂度：O(n)  空间复杂度：<em>O</em>(<em>n</em>)<br>        法三：时间复杂度：O(n)  空间复杂度：<em>O</em>(1)   快指针，慢指针 额外空间 需修改原结构</p><ol><li>找到前半部分链表的尾节点。</li><li>反转后半部分链表。</li><li>判断是否为回文。</li><li>恢复链表。</li><li>返回结果。</li></ol><p>（这个题最优解需要改结构，工程上不会让你这么做，面试上会）</p><h3 id="3-打印有序链表的公共部分？-过"><a href="#3-打印有序链表的公共部分？-过" class="headerlink" title="3.打印有序链表的公共部分？(过)"></a>3.打印有序链表的公共部分？(过)</h3><p>自己练</p><p>链表问题的最优解往往是在空间复杂度上下功夫，就是怎样用最小的空间复杂度<br>笔试过程中：尽快过掉，该用辅助空间就用辅助空间；<br>面试过程中：尽量时间复杂度O(n),空间复杂度O(1)</p><h3 id="4-【题目14-单链表最难】"><a href="#4-【题目14-单链表最难】" class="headerlink" title="4.【题目14 单链表最难】"></a>4.【题目14 单链表最难】</h3><p>1)如何判断单链表有环?</p><ul><li>用哈希表;</li><li>不用哈希表（很玄学，这里有个结论）分别怎么做 (双指针法)<ol><li>满指针走一步，快指针走2步（初始都从第一个结点开始走），循环直到快指针=慢指针</li><li>如果快指针为空，也退出循环，返回null</li><li>否则，快指针指向起点，循环快慢指针各走一步，直到2个指针指向同一个结点，那就是第一个入环结点</li></ol></li></ul><p>2)如何判断2个无环单链表相交，并返回交点；</p><ul><li>用哈希表;</li><li>不用哈希表,记录长度;</li><li>不用哈希表，也不用记录长度; </li></ul><p>3)如何判断2个有环单链表相交3种情况<br>4)一个有环和一个无环单链表是否相交：结论–&gt;不相交</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/教训/春招实习经验教训</title>
      <link href="blog/2321292217.html"/>
      <url>blog/2321292217.html</url>
      
        <content type="html"><![CDATA[<p>作者：胡攸<br>链接：<a href="https://www.nowcoder.com/discuss/190247?type=all&amp;order=time&amp;pos=&amp;page=2" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/190247?type=all&amp;order=time&amp;pos=&amp;page=2</a><br>来源：牛客网</p><h1 id="春招实习经验教训"><a href="#春招实习经验教训" class="headerlink" title="春招实习经验教训"></a>春招实习经验教训</h1><ul><li>楼主渣渣本科，拿到了阿里，腾讯，头条还有京东的后台开发实习生Offer。此句只是为了增强说服力，大佬请无视：）好吧，京东的目前还没到手，备胎中，可能把我鸽了。蘑菇街因为即将拿到几个他厂Offer了，就拒了二面。华为邀请参加面试，原因同上，就婉拒了</li><li>楼主无意收集Offer，因为面试节奏控制的比较好，加上运气也不错，所以这几家Offer大约是差不多一块到的，不瞒大佬们说，3月初投简历，知道4.24号之前我还是一无所获，菜的抠脚</li><li>多投几家，不要净瞅着BAT TMD，即使你有那个实力也得随时准备好拥抱变化。个人而言，投的不算多，光笔试也得做了近七八场了吧，这还不加免笔试的。</li><li>简历上学历，项目，竞赛总要有一个亮点。请突出你的亮点，把短板写的不起眼一点，比如学历差的就不要把学历二号加粗挂简历中间</li><li>请写好你的简历。简历是第一印象，找个靠谱的人来帮你把把关，别随便写写就提交了。具体关于简历应该怎么写，本文就不具体阐述了，那将是另一篇文章</li><li>能内推就走内推，现在内推还是挺好找的，别托大</li><li>能早投就早投，投的太晚了有可能就没HC了</li><li>投递岗位和地区要慎重，大公司的二线分部，一般是边缘业务，且招人少。但是可能会面试简单？一线招人多，但是可能也更难，寒冬时期尽可能避免去边缘吧。</li><li>面试之前一定要练练手，最好是同学之间模拟面试一下，真实面试就更好了</li><li>控制好不同公司面试节奏，别其他公司的意向书到了，而期望公司的还没来，迫于无奈先签了他家就很难受</li><li>毁约有被拉黑的风险，慎重</li><li>记得无论是拒Offer还是毁约，最好都亲自打电话表达遗憾和歉意。千万别等到Offer截止期默拒</li><li>请把你的项目准备好，起码基本项目介绍（10min），难点，技术选型，多大用户量，参与人员，是否上线这几个问题都准备好。</li><li>做好自我介绍，在自我介绍里着重介绍实践经历和个人技术，以便后面面试官提问有的放矢。你要知道有的面试官不太喜欢看你简历提问，我碰到很多</li><li>主动引导面试官提问，把握面试节奏。要是项目和自我介绍没做好，让面试官控制节奏，指不定能问出花来，反正我是被这个坑了一把</li><li>春招的时候不要光复习，要记得学一些新技术，有些面试官会问你最近正在学什么，了解哪些前沿技术，技术的广度要拓展，不要把眼光局限在那一亩三分地上</li><li>一般两场面试之间最多间隔一个周，一周之内没消息，基本凉了。此时你就不要把宝压这家上了，其他的面试还是要继续</li><li>无论面的咋样，记得面试完说谢谢您，表现的菜就说对不起，让您失望了。</li><li>不要再问算法和项目哪个重要，都重要。非要定个标准，那么研发岗，起码能手撕leetcode easy，IDE调leetcode medium吧，一道题最慢不超过20分钟。项目的话，起码要有一个出彩点，比如用了某些新技术，比如采用了一个比较精巧的设计。就楼主来说，并没有分布式项目的经验，普普通通的S***项目，但是我挖出了亮点，并把这个作为技术难点跟面试官解释。当然，你别拿”我有个注解不会用，然后查了查百度”这种水货当项目难点忽悠面试官</li><li>PS：腾讯一面手撕算法，阿里一二面手撕算法，头条全程手撕算法</li><li>简历上写的东西，一定要做到言无不尽，滔滔不绝。要么别写，要么赌面试官不问</li><li>项目经验不够，面试官可能会往死了怼你基础。如果可能的话，适当多写几个</li><li>面试是个玄学的过程，看运气，看面试官。就我而言，我阿里，腾讯提前批都被挂过，原因有很多，自己菜也是很重要的原因。重点是之后我投正式批，然后竟然过了，所以不要轻易放弃希望，想去的话，提前批挂了可以投正式批。</li><li>语速快的降下来，做到吐字清楚，逻辑清晰</li><li>面试不要轻易说不会，起码说个你的想法和大体思路</li><li>用词专业，通过你的用词水平可以知道你平时学的咋样，有没有认真读过一些书，看一些技术文章。</li><li>其他岗位不知道，后台研发岗的话，最好对分布式有一些了解，比如分布式理论，Spring Cloud，Dubbo，消息队列，ZooKeeper这一些框架和中间件等。不然跟面试官不好谈</li><li>盲猜一两个情景题作准备，比如说设计一个秒杀系统，微博等</li><li>请把你做笔试用的编程语言的输入输出练好，别连输入输出都记不住，指望从网上查。</li><li>面试官问问题A，请不要只谈表面，要有深度，同时适当自己做拓展，是为引导面试官</li><li>可以主动要面试官的联系方式，一二面面试官有可能是你未来同事和leader，也不一定，看公司。要到面试官的联系方式太有用了。</li><li>听说现场面试机会大一些？没验证过</li><li>可以主动联系内推人询问状态，好多人找内推人推完后连个联系方式都不留，以至于都忘了内推人是谁，这个态度就很迷。虽然对内推人来说内推不是啥麻烦事，可这个态度也太敷衍了</li><li>HR面一般不挂人，除了阿里HR，除了自己作死</li><li>HR一般会问实习时间，一般都是期望你实习久一点的。</li><li>面完HR面后，往往会有一个备胎的时间段，期间你可以拿其他厂的Offer去催（得实力差不多的Offer），操作好了，Offer可能立马到手。成功案例很多</li><li>意向城市和Offer实际給的城市可能不一样，包括岗位</li><li>多刷面经，多逛牛客。经常逛牛客可以让你少踩一些坑</li><li>加一些交流群，听听他们的经验，别单干，当然您要是实力超群，以力破万法当我没说。</li><li>Offer没到手之前，什么口头保证都是虚的，包括OC，信了你就输了。Offer没到手，该干啥干啥，该面试面试，随时准备好拥抱变化。</li><li>寒冬期间，没有足够实力的话，还是早上岸为妙</li><li>最后，不要怕，不要悔（划重点）<br>5/15更新</li><li>问通过概率（比如简历筛，转正率）可以，比如说问问一般有多少人通过，反复问，问太细了就没意义了，比如说通过率多少。这种我说90%你就信了吗？这种东西只能是个经验值，去年全通过了，今年就一定全通过吗，太纠结于这种东西没意义，其他人的话做多当参考</li><li>面试流程一般是技术面（可能会有交叉面，也就是说可能没有）  HR面。以阿里为例，一般是两面技术 一面交叉面 HR面，网上有两种说法，一种是有交叉面的评级会高，一种是HC不够了，给你加一面刷你。我个人是倾向于第一种说法的，毕竟交叉面一般是高P大佬，这种大佬闲的没事来刷你啊</li><li>老些人老觉得面试造飞机，工作拧螺丝不科学。可是假设面试的时候问的你很水，你会不会觉得去了就是干杂活的？面试其实也是个双向的过程，面试官在考察你，你也在通过面试考察你要去得公司和岗位</li></ul><p>先写这些，想到再更，欢迎楼下老哥们补充</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/介绍项目/介绍项目</title>
      <link href="blog/4027456022.html"/>
      <url>blog/4027456022.html</url>
      
        <content type="html"><![CDATA[<ul><li><p>请把你的项目准备好，起码基本项目介绍（10min），难点，技术选型，多大用户量，参与人员，是否上线这几个问题都准备好。</p></li><li><p>做好自我介绍，在自我介绍里着重介绍实践经历和个人技术，以便后面面试官提问有的放矢。你要知道有的面试官不太喜欢看你简历提问，我碰到很多</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/java/JAVA基础语法/泛型</title>
      <link href="blog/2776408385.html"/>
      <url>blog/2776408385.html</url>
      
        <content type="html"><![CDATA[<h2 id="5-1-5-JAVA-泛型"><a href="#5-1-5-JAVA-泛型" class="headerlink" title="5.1.5. JAVA 泛型"></a>5.1.5. JAVA 泛型</h2><p>泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本</p><p>质是参数化类型，也就是说所操作的数据类型被指定为一个参数。 比如我们要写一个排序方法，</p><p>能够对整型数组、字符串数组甚至其他任何类型的数组进行排序，我们就可以使用 Java 泛型。</p><h3 id="5-1-5-1-泛型方法（）"><a href="#5-1-5-1-泛型方法（）" class="headerlink" title="5.1.5.1. 泛型方法（）"></a>5.1.5.1. 泛型方法（<E>）</h3><p>你可以写一个泛型方法，该方法在调用时可以接收不同类型的参数。根据传递给泛型方法的参数</p><p>类型，编译器适当地处理每一个方法调用。</p><h3 id="5-1-5-2-泛型类"><a href="#5-1-5-2-泛型类" class="headerlink" title="5.1.5.2. 泛型类"></a>5.1.5.2. 泛型类<T></h3><p>泛型类的声明和非泛型类的声明类似，除了在类名后面添加了类型参数声明部分。和泛型方法一</p><p>样，泛型类的类型参数声明部分也包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，</p><p>也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。因为他们接受一个或多个参数 ，</p><p>这些类被称为参数化的类或参数化的类型。</p><h3 id="5-1-5-3-类型通配符"><a href="#5-1-5-3-类型通配符" class="headerlink" title="5.1.5.3. 类型通配符?"></a>5.1.5.3. 类型通配符?</h3><p>类型通配符一般是使用?代替具体的类型参数。例如：List&lt;?&gt; 在 逻 辑 上 是</p><p>List<String>,List<Integer> 等所有 List&lt;具体类型实参&gt;的父类。</p><h3 id="5-1-5-4-类型擦除"><a href="#5-1-5-4-类型擦除" class="headerlink" title="5.1.5.4. 类型擦除"></a>5.1.5.4. 类型擦除</h3><p>Java 中的泛型基本上都是在编译器这个层次来实现的。在生成的 Java 字节代码中是不包含泛</p><p>型中的类型信息的。使用泛型的时候加上的类型参数，会被编译器在编译的时候去掉。这个</p><p>过程就称为类型擦除。如在代码中定义的 List<Object>和 List<String>等类型，在编译之后</p><p>都会变成 List。JVM 看到的只是 List，而由泛型附加的类型信息对 JVM 来说是不可见的。</p><p>类型擦除的基本过程也比较简单，首先是找到用来替换类型参数的具体类。这个具体类一般</p><p>是 Object。如果指定了类型参数的上界的话，则使用这个上界。把代码中的类型参数都替换</p><p>成具体的类。</p><h3 id="5-1-5-5-为什么要用泛型"><a href="#5-1-5-5-为什么要用泛型" class="headerlink" title="5.1.5.5 为什么要用泛型"></a>5.1.5.5 为什么要用泛型</h3><ol><li><strong>类型安全。</strong> 泛型的主要目标是提高 Java 程序的类型安全。通过知道使用泛型定义的变量的类型限制，编译器可以在一个高得多的程度上验证类型假设。没有泛型，这些假设就只存在于程序员的头脑中（或者如果幸运的话，还存在于代码注释中）。</li><li><strong>消除强制类型转换。</strong></li></ol><p>泛型：类型限定。</p><p>类型参数化。</p><p>历史：JDK1.5加进来的</p><p>没有泛型的时候，不好的地方？</p><p>存100个，取的时候类型转换会出错。</p><p>泛型将运行期异常提到了 编译期 </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/java/JAVA基础语法/反射</title>
      <link href="blog/2851314326.html"/>
      <url>blog/2851314326.html</url>
      
        <content type="html"><![CDATA[<h2 id="5-1-2-JAVA-反射"><a href="#5-1-2-JAVA-反射" class="headerlink" title="5.1.2. JAVA 反射"></a>5.1.2. JAVA 反射</h2><h3 id="5-1-2-1"><a href="#5-1-2-1" class="headerlink" title="5.1.2.1."></a>5.1.2.1.</h3><h4 id="动态语言"><a href="#动态语言" class="headerlink" title="动态语言"></a>动态语言</h4><p>动态语言，是指程序在运行时可以改变其结构：新的函数可以引进，已有的函数可以被删除等结</p><p>构上的变化。比如常见的 JavaScript 就是动态语言，除此之外 Ruby,Python 等也属于动态语言，</p><p>而 C、C++则不属于动态语言。从反射角度说 JAVA 属于半动态语言。</p><h3 id="5-1-2-2"><a href="#5-1-2-2" class="headerlink" title="5.1.2.2."></a>5.1.2.2.</h3><h4 id="反射机制概念-（运行状态中知道类所有的属性和方法）"><a href="#反射机制概念-（运行状态中知道类所有的属性和方法）" class="headerlink" title="反射机制概念 （运行状态中知道类所有的属性和方法）"></a>反射机制概念 （运行状态中知道类所有的属性和方法）</h4><p>在 Java 中的反射机制是指在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法；</p><p>并且对于任意一个对象，都能够调用它的任意一个方法 ；这种动态获取信息以及动态调用对象方</p><p>法的功能成为 Java 语言的反射机制。</p><h3 id="5-1-2-3-反射的应用场合"><a href="#5-1-2-3-反射的应用场合" class="headerlink" title="5.1.2.3.反射的应用场合"></a>5.1.2.3.反射的应用场合</h3><p>编译时类型和运行时类型</p><p>在 Java 程序中许多对象在运行是都会出现两种类型：编译时类型和运行时类型。 编译时的类型由</p><p>声明对象时实用的类型来决定，运行时的类型由实际赋值给对象的类型决定 。如：</p><p>Person p=new Student();</p><p>其中编译时类型为 Person，运行时类型为 Student。</p><p>​    编译时类型无法获取具体方法</p><p>程序在运行时还可能接收到外部传入的对象，该对象的编译时类型为 Object,但是程序有需要调用</p><p>该对象的运行时类型的方法。为了解决这些问题， 程序需要在运行时发现对象和类的真实信息 。</p><p>然而，如果编译时根本无法预知该对象和类属于哪些类，程序只能依靠运行时信息来发现该对象</p><p>和类的真实信息，此时就必须使用到反射了。</p><h3 id="5-1-2-4-Java-反射-API"><a href="#5-1-2-4-Java-反射-API" class="headerlink" title="5.1.2.4.Java 反射 API"></a>5.1.2.4.Java 反射 API</h3><p>反射 API 用来生成 JVM 中的类、接口或则对象的信息。</p><p>1.Class 类：反射的核心类，可以获取类的属性，方法等信息。</p><p>2.Field 类：Java.lang.reflec 包中的类，表示类的成员变量，可以用来获取和设置类之中的属性</p><p>值。</p><p>3.Method 类： Java.lang.reflec 包中的类，表示类的方法，它可以用来获取类中的方法信息或</p><p>者执行方法。</p><p>4.Constructor 类： Java.lang.reflec 包中的类，表示类的构造方法。</p><h3 id="5-1-2-5-反射使用步骤（获取-Class-对象、调用对象方法）"><a href="#5-1-2-5-反射使用步骤（获取-Class-对象、调用对象方法）" class="headerlink" title="5.1.2.5.反射使用步骤（获取 Class 对象、调用对象方法）"></a>5.1.2.5.反射使用步骤（获取 Class 对象、调用对象方法）</h3><p>1.获取想要操作的类的 Class 对象，他是反射的核心，通过 Class 对象我们可以任意调用类的方</p><p>法。</p><p>2.调用 Class 类中的方法，既就是反射的使用阶段。</p><p>3.使用反射 API 来操作这些信息。</p><h3 id="5-1-2-6-获取-Class-对象的-3-种方法"><a href="#5-1-2-6-获取-Class-对象的-3-种方法" class="headerlink" title="5.1.2.6.获取 Class 对象的 3 种方法"></a>5.1.2.6.获取 Class 对象的 3 种方法</h3><ul><li>调用某个对象的 getClass()方法</li></ul><p>Person p=new Person();</p><p>Class clazz=p.getClass();</p><ul><li>调用某个类的 class 属性来获取该类对应的 Class 对象</li></ul><p>Class clazz=Person.class;</p><ul><li><p>使用 Class 类中的 forName()静态方法(最安全/性能最好)</p><p>Class clazz=Class.forName(“类的全路径”); (最常用)</p></li></ul><p>当我们获得了想要操作的类的 Class 对象后，可以通过 Class 类中的方法获取并查看该类中的方法</p><p>和属性。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/java/JAVA基础语法/序列化</title>
      <link href="blog/33122484.html"/>
      <url>blog/33122484.html</url>
      
        <content type="html"><![CDATA[<p>序列化是将数据结构或对象转换为一系列位的过程，以便它可以存储在文件或内存缓冲区中，或通过网络连接链路传输，以便稍后在同一个或另一个计算机环境中重建。</p><p>设计一个算法来序列化和反序列化二叉搜索树。 对序列化/反序列化算法的工作方式没有限制。 您只需确保二叉搜索树可以序列化为字符串，并且可以将该字符串反序列化为最初的二叉搜索树。</p><p>编码的字符串应尽可能紧凑。</p><p>注意：不要使用类成员/全局/静态变量来存储状态。 你的序列化和反序列化算法应该是无状态的。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/serialize-and-deserialize-bst" target="_blank" rel="noopener">https://leetcode-cn.com/problems/serialize-and-deserialize-bst</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/java/JAVA基础语法/回调</title>
      <link href="blog/3900921173.html"/>
      <url>blog/3900921173.html</url>
      
        <content type="html"><![CDATA[<p><img src=".%E5%9B%9E%E8%B0%83_images/image-20200521115434538.png" alt="image-20200521115434538"></p><p><img src=".%E5%9B%9E%E8%B0%83_images/image-20200521115443867.png" alt="image-20200521115443867"></p><p><img src=".%E5%9B%9E%E8%B0%83_images/image-20200521115450333.png" alt="image-20200521115450333"></p><p><img src=".%E5%9B%9E%E8%B0%83_images/image-20200521115457942.png" alt="image-20200521115457942"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/剑指offer leetcode/排序</title>
      <link href="blog/2315756357.html"/>
      <url>blog/2315756357.html</url>
      
        <content type="html"><![CDATA[<h3 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h3><ul><li>选主元<ul><li>经典快排：选数组最后一个元素</li><li>将数组第一个，中间位置，最后1个位置三个数交换达到排序的目的，将中间位置的和最后一个位置的交换</li><li>随机函数选择1个与最后一个位置的交换</li></ul></li><li>划分子集<ul><li>int i = left - 1, j = right</li><li>++i,–j . 2个指针左指针和右指针，和主元比较，相向行驶。2个while循环</li><li>i &lt; j 时 交换（交换时的arr[i] &gt;= 主元，交换时的arr[j] &lt;= 主元）,否则退出循环</li><li>i+1的位置即是本轮主元的最终位置</li></ul></li></ul><pre class=" language-java"><code class="language-java"> <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">partition2</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">//选主元</span>        <span class="token keyword">int</span> privot <span class="token operator">=</span> array<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//划分子集</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> left <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span>j <span class="token operator">=</span> right<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//大于等于的放右边</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span><span class="token operator">++</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> privot<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//红色警报</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>j<span class="token operator">--</span><span class="token punctuation">]</span> <span class="token operator">></span> privot<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//红色警报</span>            <span class="token comment" spellcheck="true">//和主元相等的时候也交换</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token function">swap</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span>i<span class="token punctuation">,</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token function">swap</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span>i<span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> i <span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">quickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> left<span class="token punctuation">,</span><span class="token keyword">int</span> right<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">int</span> q <span class="token operator">=</span> <span class="token function">partition2</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>left<span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">quickSort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>left<span class="token punctuation">,</span>q<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">quickSort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>q <span class="token operator">+</span><span class="token number">1</span> <span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">quick_sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span><span class="token keyword">int</span> length<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>平均情况下时间复杂度： O(nlogn),空间复杂度O(logn)</p><p>最快情况下时间复杂度: O(n^2^) ,空间复杂度O(n)</p><blockquote><p>注 :数组中元素全部相同时，不交换的情况下一轮就是O(n) ,整体就是O(n^2^)</p></blockquote><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>算法思想：采用分治的策略，选取中间位置，将数组划分为2，然后合并，递归的处理左边，递归的处理右边。</p><p> 合并是合并2个有序子数组，要1个辅助数组。</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr <span class="token operator">==</span> null <span class="token operator">||</span> arr<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">mergeSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">==</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> l <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>r <span class="token operator">-</span> l<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">mergeSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> l<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">mergeSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">merge</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> l<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> help <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>r <span class="token operator">-</span> l <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> p1 <span class="token operator">=</span> l<span class="token punctuation">;</span>        <span class="token keyword">int</span> p2 <span class="token operator">=</span> m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>p1 <span class="token operator">&lt;=</span> m <span class="token operator">&amp;&amp;</span> p2 <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>            help<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>p1<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>p2<span class="token punctuation">]</span> <span class="token operator">?</span> arr<span class="token punctuation">[</span>p1<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">:</span> arr<span class="token punctuation">[</span>p2<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>p1 <span class="token operator">&lt;=</span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>            help<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>p1<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>p2 <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>            help<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>p2<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> help<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            arr<span class="token punctuation">[</span>l <span class="token operator">+</span> i<span class="token punctuation">]</span> <span class="token operator">=</span> help<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p>快排和归并都是用分治的策略。</p><p>归并排序时间复杂度：O(nlogn),空间复杂度O(n)</p><p><img src=".%E6%8E%92%E5%BA%8F_images/image-20200520114634599.png" alt="image-20200520114634599"></p><ol start="3"><li><p>堆排序</p><p>①先理解堆结构，有一种O(n)的算法把一个数组调整成大根或者小根堆</p><p>②③</p></li></ol><p>堆结构非常重要，建堆O(n)，被火车撞了都不能忘记。最大的亮点是形成堆后，进来1个，O(Logn)可以搞定</p><p><img src=".%E6%8E%92%E5%BA%8F_images/image-20200522111135453.png" alt="image-20200522111135453"></p><p><img src=".%E6%8E%92%E5%BA%8F_images/image-20200718111809940.png" alt="image-20200718111809940"></p><h3 id="合并两个有序数组"><a href="#合并两个有序数组" class="headerlink" title="合并两个有序数组"></a>合并两个有序数组</h3><p><a href="https://leetcode-cn.com/problems/merge-sorted-array/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-sorted-array/</a></p><p>用归并的方法，从后往前扫描。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/java/并发编程/模式</title>
      <link href="blog/1192519460.html"/>
      <url>blog/1192519460.html</url>
      
        <content type="html"><![CDATA[<h2 id="保护性暂停模式"><a href="#保护性暂停模式" class="headerlink" title="保护性暂停模式"></a>保护性暂停模式</h2><p>GuardedObject可以在多个线程之间传递结果</p><p>优点：</p><ul><li>join得等另一个线程介绍，这种模式不用，另一个线程下载完结果传给你后还可以做其他的事情；</li><li>join传递得全局变量，这种可以是局部变量</li><li>join的源码分析就是用到了保护性暂停，且是基于wait实现的等待；</li><li>保护性暂停是指条件不满足时，实施wait等待</li></ul><p>保护性模式就是一对一的模式，生产结果的线程和消费结果的线程是一一对应的，生产者消费者不需要限定一对一。</p><p>Mailbox的作用就是解耦获取结果的和生产结果的，这种方式会在RPC中大量看到。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/面经/其他面经/牛客网面经</title>
      <link href="blog/1041195056.html"/>
      <url>blog/1041195056.html</url>
      
        <content type="html"><![CDATA[<p><img src=".Untitled_images/image-20200518194814260.png" alt="image-20200518194814260"></p><p><a href="https://www.nowcoder.com/discuss/426340?type=all&amp;order=time&amp;pos=&amp;page=1&amp;channel=&amp;source_id=1_all" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/426340?type=all&amp;order=time&amp;pos=&amp;page=1&amp;channel=&amp;source_id=1_all</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/剑指offer leetcode/刷题笔记</title>
      <link href="blog/2773048981.html"/>
      <url>blog/2773048981.html</url>
      
        <content type="html"><![CDATA[<h2 id="2-4-2-查找和排序"><a href="#2-4-2-查找和排序" class="headerlink" title="2.4.2 查找和排序"></a>2.4.2 查找和排序</h2><p>查找相对简单：不外乎顺序查找，二分查找，哈希查找和二叉排序树查找。</p><p>不管是循环还是递归，面试官都期待应聘者能信手拈来写出完整正确的二分查找代码。</p><p>一定要对各种排序算法的特点烂熟于胸。</p><blockquote><p>如果面试题要求在排序的数组（或者部分排序的 数组）中查找一个数字或者统计某个数字出现的次数，都可以尝试使用二分查找算法.</p></blockquote><h2 id="2020-05-18"><a href="#2020-05-18" class="headerlink" title="2020-05-18"></a>2020-05-18</h2><p>T13 机器人的运动范围</p><p>心得：和12题矩阵 相像。</p><p>①总结回溯法</p><p>②13题应该不是回溯法，</p><ul><li><input disabled="" type="checkbox"> ③递归的时间复杂度计算 后面要背下来 待分析这2道题</li></ul><h2 id="2-4-5位运算"><a href="#2-4-5位运算" class="headerlink" title="2.4.5位运算"></a>2.4.5位运算</h2><h3 id="面试题15：-二进制中1个的个数"><a href="#面试题15：-二进制中1个的个数" class="headerlink" title="面试题15： 二进制中1个的个数"></a>面试题15： 二进制中1个的个数</h3><p>①造成死循环的解法： 循环让数n与1相与，然后右移；当n为负数时，右移因为要左边补符号位1，会造成死循环。也就是这种方法只能适用于正数。</p><p>②常规解法：循环让n与2的0 一直到32次方做与运算，这样判断每一位是不是1. int型只需要32次</p><p>③给面试官带来惊喜的解法：把1个整数减去1之后再和原来的整数做与运算，得到的结果相当于把整数的二进制表示中最右边的1变成0.     1 的个数就是这个操作的次数。（很多二进制的问题可以用这种思路解决）</p><ul><li><input disabled="" type="checkbox"> <h3 id="第二章小结-描述了重点。"><a href="#第二章小结-描述了重点。" class="headerlink" title="第二章小结 描述了重点。"></a>第二章小结 描述了重点。</h3><p>数据结构</p></li><li><p>数组和字符串是两种最基本的数据结构</p></li><li><p>链表是面试题中使用频率最高的一种数据结构</p></li><li><p>如果面试官想加大难度，他很有可能会选用树相关的面试题</p></li><li><p>栈与递归调用密切相关，队列在图包括树的层次（宽度）优先遍历中需要用到，也哟啊掌握</p><p>算法</p></li><li><p>查找（特别是二分）和排序（特别是快排和归并）是面试中常考算法，一定要熟练掌握</p></li><li><p>回溯法很适合解决迷宫及其类似问题</p></li><li><p>如果面试题是求一个问题的最优解，可以尝试动态规划</p></li><li><p>如果在动态规划分析问题时发现每一步都存在一个能得到最优解的选择，那么考虑贪心算法</p></li><li><p>另外还要掌握分析时间复杂度的方法</p></li><li><p>很多时候会使用自上而下的递归思路分析问题，却会基于自下而上的循环实现代码</p></li></ul><h3 id="T53-在排序数组中查找数字"><a href="#T53-在排序数组中查找数字" class="headerlink" title="T53 在排序数组中查找数字"></a>T53 在排序数组中查找数字</h3><p>要点：</p><p>二分查找</p><p>①最好分大于小于和等于分别处理，逻辑清晰</p><p>②下一轮要Mid+1或者小于1比较好</p><p>③面试中能递归尽量递归</p><p>高质量代码：如何设计测试用例？</p><p>①功能测试②边界测试③特殊输入测试null</p><h3 id="T53-2-0-1中缺失的数字"><a href="#T53-2-0-1中缺失的数字" class="headerlink" title="T53-2 0-1中缺失的数字"></a>T53-2 0-1中缺失的数字</h3><ul><li>未发现规律：因为0~n-1在数组中排好序的，0在0的位置，缺失的m正好是数组中第一个数值和下标不想打的下标，问题转化为在排序数组中找出第一个值和下标不想打的元素。注意边界。</li></ul><h3 id="T33-二叉搜索树的后序遍历序列"><a href="#T33-二叉搜索树的后序遍历序列" class="headerlink" title="T33 二叉搜索树的后序遍历序列"></a>T33 二叉搜索树的后序遍历序列</h3><p>思路：递归的去处理，其实不难。</p><p>①先找到根，起始 &gt;根 则没有左子树</p><p>②右子树也只用检查 它是否每个值都大于根，当小于的的时候直接返回false</p><p>③题目保证数组中没有相同的元素》</p><h3 id="T36-二叉搜索树转为双向链表"><a href="#T36-二叉搜索树转为双向链表" class="headerlink" title="T36 二叉搜索树转为双向链表"></a>T36 二叉搜索树转为双向链表</h3><p>任然采用递归（也写得出来）</p><ul><li><p>将二叉搜索树的左孩子指向前驱，右孩子指向后继，采用中序递归遍历来操作.</p></li><li><p>把二叉树看成三部分，根，左子树，右子树</p></li><li><p>把左右子树转换成双链表后和根节点接起来，根节点的前驱指向左子树中序遍历的最后一个结点；</p><p>根节点的后继指向右子树的最小结点，转换右子树前先存起来它的最小结点</p></li></ul><blockquote><p> 注：解决的关键在于把1个大问题分解成几个小问题，然后递归地处理.</p></blockquote><h2 id="2020-05-19"><a href="#2020-05-19" class="headerlink" title="2020-05-19"></a>2020-05-19</h2><p>T9 用两个队列实现栈</p><p>Stack类的api要记住</p><h3 id="T16-数值的整数次方"><a href="#T16-数值的整数次方" class="headerlink" title="T16 数值的整数次方"></a>T16 数值的整数次方</h3><ul><li>书上用全局变量标识了求0的倒数这样一种错误情况</li><li>要考虑指数是负数和0的情况</li><li>求a的n次方的高效做法：分为奇数和偶数，（二分去乘）减少了很多的乘法次数，用递归来很容易实现；<ul><li>同时判断奇数和偶数用与运算实现，效率比求mod高很多</li></ul></li></ul><p>主要还是考察全面性，这题本身不难。</p><h3 id="T30-包含min函数的栈"><a href="#T30-包含min函数的栈" class="headerlink" title="T30 包含min函数的栈"></a>T30 包含min函数的栈</h3><blockquote><p>注：在面试的时候很多应聘者都止步于添加一个变量保存最小元素的思路。其实只要举个例子，多做几次入栈出栈的操作就能看出问题。用辅助栈也是一种办法，不要怕。</p></blockquote><ul><li>Stack的操作</li><li>LinkedList的操作</li><li>Queue的操作，offer和add的区别，poll,peek,pop,push,remove的区别</li></ul><h3 id="T32-层次遍历二叉树"><a href="#T32-层次遍历二叉树" class="headerlink" title="T32 层次遍历二叉树"></a>T32 层次遍历二叉树</h3><ul><li>通过具体的例子（画个表格逐步分析）找出其中的规律并想到基于队列的算法，是解决这个问题的关键所在。</li></ul><p>扩展</p><ul><li><p>还要掌握分行打印</p><ul><li>简单，增加2个变量，当前层结点数量初始为1，下一层结点数量初始为0</li></ul></li><li><p>还要掌握之字形打印  </p><ul><li><p>分析知道用单个队列，不加其他额外操作不行（保证结点只遍历1次）</p></li><li><p>分析知道只用单个栈也不行</p></li><li><p>要用2个栈,1个栈用于暂存顺序输出的结点，1个栈用于逆序输出的结点，分奇偶层存入不同的stack;</p><p>同时分奇偶层去取出结点(有点难度的)</p></li></ul><p>序列化是将数据结构或对象转换为一系列位的过程，以便它可以存储在文件或内存缓冲区中，或通过网络连接链路传输，以便稍后在同一个或另一个计算机环境中重建。</p></li></ul><h3 id="T31-栈的压入、弹出序列"><a href="#T31-栈的压入、弹出序列" class="headerlink" title="T31 栈的压入、弹出序列"></a>T31 栈的压入、弹出序列</h3><ul><li>关键在举例子一步步分析，压栈弹出的过程，从中找出规律</li><li>光看代码是写不出来的</li></ul><h2 id="2020-05-20"><a href="#2020-05-20" class="headerlink" title="2020-05-20"></a>2020-05-20</h2><h3 id="T26-树的子结构"><a href="#T26-树的子结构" class="headerlink" title="T26 树的子结构:"></a>T26 树的子结构:</h3><p>树的问题采用递归解法的关键在于：在左右子树各看成一个整体。</p><p>算法思想：</p><ul><li>以根节点为当前结点，当前结点的值与第二颗树的根节点的值不同时，返回false</li><li>当前结点相同时，判断以当前结点为根的子树是否符合题意（又是一个递归去判断），是的话返回true<ul><li>否则，递归去判断左子树是不是<ul><li>左子树不是的时候，递归去判断右子树是不是，返回结果</li></ul></li></ul></li></ul><blockquote><p> 注 : 在面试的时候，我们一定要注意边界条件检查，即检查空指针。如果没有检查并进行相应的处理，程序非常容易崩溃，这是面试时非常忌讳的事情。</p><p>在写遍历树的代码的时候一定要高度警惕，有没有可能是Null,null怎么处理.</p><p>double类型的比较要注意。</p></blockquote><h3 id="T20-顺时针打印矩阵"><a href="#T20-顺时针打印矩阵" class="headerlink" title="T20 顺时针打印矩阵"></a>T20 顺时针打印矩阵</h3><p>算法思想：</p><ul><li><p>一圈一圈打印，左上角起点为一圈的开始，发现循环条件的规律 2 * start &lt; rows &amp;&amp; 2 * start &lt; cols；</p></li><li><p>打印一圈：</p><ul><li>左到右，肯定是要有的</li><li>上到下：前提是至少有2行</li><li>右到左：前提是至少有2行2列</li><li>下到上：前提是至少有3行2列</li></ul></li></ul><p>关键：画图举例法，找出规律，注意边界条件。</p><h2 id="2020-06-04"><a href="#2020-06-04" class="headerlink" title="2020-06-04"></a>2020-06-04</h2><h3 id="面试题17-打印从1到最大的n位数"><a href="#面试题17-打印从1到最大的n位数" class="headerlink" title="面试题17   打印从1到最大的n位数"></a>面试题17   打印从1到最大的n位数</h3><p>要考虑大数问题。</p><p>①用字符数组模拟数字加法</p><p>②注意，判断是否到达最大的n位数，用compareto是O(n)调用n遍， 应该用个标志位</p><p>​     第1位产生进位即表示最大</p><p>③打印的话，碰到第1个不是0的才开始打印</p><h2 id="2020-06-07"><a href="#2020-06-07" class="headerlink" title="2020-06-07"></a>2020-06-07</h2><h3 id="面试题20"><a href="#面试题20" class="headerlink" title="面试题20"></a>面试题20</h3><p>将数值分为3部分整数，小数，指数，3部分都是可选的，但是没有整数时，一定有小数。</p><pre><code>解法同时也分为3步，每步返回一个结果，可覆盖前面的结果扫描前检查index是否已到边界,满足条件才往后扫描1.扫描整数部分:(如果是正负号，指针+1)扫描无符号整数2.扫描小数点后:扫描无符号整数 ;这步结果 与上步结果3.扫描e|E后:扫描无符号整数</code></pre><h2 id="2020-06-08-第五章"><a href="#2020-06-08-第五章" class="headerlink" title="2020-06-08(第五章)"></a>2020-06-08(第五章)</h2><h3 id="面试题39-数组中次数超过一半的数字"><a href="#面试题39-数组中次数超过一半的数字" class="headerlink" title="面试题39 数组中次数超过一半的数字"></a>面试题39 数组中次数超过一半的数字</h3><p>解法零：排序O(nlgn) 拿不到offer</p><p>解法一：基于partition函数的时间复杂度O(n)的算法(会改变原数组)</p><ul><li><p>排序后，待求数字必然在中间的位置上</p></li><li><p>那么根据随机快排的划分函数，1次划分后的位置若&gt; n/2，则在左边找， &lt; n/2右边找,=就找到了</p><p>算法导论中有证明，这样的时间复杂度是O(n)</p></li></ul><p>解法二：根据数组特点找出的O(n)的算法   暂时跳过</p><h3 id="面试题40：最小的k个数"><a href="#面试题40：最小的k个数" class="headerlink" title="面试题40：最小的k个数"></a>面试题40：最小的k个数</h3><p>解法零：最直观的，拍个序O(nlgn)，不是面试官想要的。</p><h4 id="解法一：【可以修改原数组时】平均时间复杂度O-n"><a href="#解法一：【可以修改原数组时】平均时间复杂度O-n" class="headerlink" title="解法一：【可以修改原数组时】平均时间复杂度O(n)"></a>解法一：【可以修改原数组时】平均时间复杂度O(n)</h4><ul><li>同样基于partition函数, partition()返回1个index</li><li>当index != k-1时，循环</li><li>index &gt; k - 1,往左边找，index &lt; k - 1，往右边找</li><li>循环退出时，输出0 - k-1的数</li></ul><h4 id="解法二：O-nlgk-的算法，特别适合处理海量数据-空间复杂度O-k"><a href="#解法二：O-nlgk-的算法，特别适合处理海量数据-空间复杂度O-k" class="headerlink" title="解法二：O(nlgk)的算法，特别适合处理海量数据;空间复杂度O(k)"></a>解法二：O(nlgk)的算法，特别适合处理海量数据;空间复杂度O(k)</h4><ul><li>创建大小为k的容器(treeset)</li><li>遍历数组，<ul><li>容器没满，直接插入</li><li>容器已满，找到容器中的最大值，若遍历到的数比最大值要小，则替换，否则跳过</li><li>遍历下一个</li></ul></li></ul><p>在容器中的操作：</p><p>①找到最大值②删除最大数③插入1个数字</p><p>最大堆：面试手写时间不够。</p><p>红黑树：JDK中的TreeSet问能不能用</p><h4 id="解法比较"><a href="#解法比较" class="headerlink" title="解法比较"></a>解法比较</h4><ul><li>基于partition的要快一些，但是修改了原数组</li><li>第二种虽然慢一点，但是没有修改原数组，第二个好处是适合海量数据的输入（很多公司喜欢与海量输入数据相关的问题）  适合n很大，k较小的问题。</li></ul><table><thead><tr><th></th><th>基于partition函数的解法</th><th>基于堆或者红黑树的解法</th></tr></thead><tbody><tr><td>时间复杂度</td><td>O(n)</td><td>O(nlgk)</td></tr><tr><td>是否需要修改输入数组</td><td>是</td><td>否</td></tr><tr><td>是否适用于海量数据</td><td>否</td><td>是</td></tr></tbody></table><p>总结：在一个没有排序的数组中利用partition函数找出数组第k个位置的数的平均时间复杂度是O(n)</p><h3 id="面试题41：数据流中的中位数"><a href="#面试题41：数据流中的中位数" class="headerlink" title="面试题41：数据流中的中位数"></a>面试题41：数据流中的中位数</h3><p>长度是奇数个时，就是排序后中间位置的数；偶数时，是排序后中间两个数的平均值。</p><p>排序的链表：增加2个指向中间位置的指针，奇数时指向同一个位置。</p><p>二叉搜索树：增加一个属性，子树结点数目。</p><p>AVL树：大部分编程语言没有实现。</p><table><thead><tr><th>数据结构</th><th>插入的时间复杂度</th><th>得到中位数的时间复杂度</th></tr></thead><tbody><tr><td>没有排序的数组</td><td>O(1)</td><td>O(n)</td></tr><tr><td>排序的数组</td><td>O(n)</td><td>O(1)</td></tr><tr><td>排序的链表</td><td>O(n)</td><td>O(1)</td></tr><tr><td>二叉搜索树</td><td>平均O(lgn)，最差O(n)</td><td>平均O(lgn)，最差O(n)</td></tr><tr><td>AVL树</td><td>O(lgn)</td><td>O(1)</td></tr><tr><td>最大堆和最小堆</td><td>O(lgn)</td><td>O(1)</td></tr></tbody></table><p>对于最后1个方法：</p><ul><li>排序后p1,p2为中间2个位置的指针，</li><li>p1是最大值，p2是右边部分的最小值，左边是最大堆，右边是最小堆。</li><li>首先读入的可以先放入最小堆</li><li>为了保持2个堆的大小不超过1，奇数位置的放入最大堆，从0开始。</li></ul><h3 id="面试题42：连续子数组的最大和"><a href="#面试题42：连续子数组的最大和" class="headerlink" title="面试题42：连续子数组的最大和"></a>面试题42：连续子数组的最大和</h3><p>题目：输入1个整型数组，里面有正有负。要求时间复杂度O(n)</p><h4 id="解法零：枚举所有子数组并求出他们的和"><a href="#解法零：枚举所有子数组并求出他们的和" class="headerlink" title="解法零：枚举所有子数组并求出他们的和"></a>解法零：枚举所有子数组并求出他们的和</h4><ul><li>有n(n+1)/2个子数组。最快要O(n^2^)</li></ul><h4 id="解法一：举例（一步一步来这个方法很有用）分析数组规律O-n"><a href="#解法一：举例（一步一步来这个方法很有用）分析数组规律O-n" class="headerlink" title="解法一：举例（一步一步来这个方法很有用）分析数组规律O(n)"></a>解法一：举例（一步一步来这个方法很有用）分析数组规律O(n)</h4><ul><li><p>记录之前的子数组的和，初始为0</p></li><li><p>遍历数组，当前位置i,如果preSum &lt;= 0,则以i开始的子数组的和比以前面开始的子数组的和要大，于是抛弃前面的，从i开始，preSum = array[i]</p></li><li><p>若preSum &gt; max 则更新max ,max 初始为整数最小值。</p></li><li><p>遍历下1个</p></li><li><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">FindGreatestSumOfSubArray</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>array <span class="token operator">==</span> null <span class="token operator">||</span> array<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> preSum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> max <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MIN_VALUE<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>preSum <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                preSum <span class="token operator">=</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                preSum <span class="token operator">+=</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>preSum <span class="token operator">></span> max<span class="token punctuation">)</span><span class="token punctuation">{</span>                max <span class="token operator">=</span> preSum<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> max<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre></li></ul><h4 id="解法二：动态规划"><a href="#解法二：动态规划" class="headerlink" title="解法二：动态规划"></a>解法二：动态规划</h4><ul><li>妙，代码跟上面的一样</li></ul><h3 id="面试题43：1-n整数中1出现的次数（难以理解）"><a href="#面试题43：1-n整数中1出现的次数（难以理解）" class="headerlink" title="面试题43：1-n整数中1出现的次数（难以理解）"></a>面试题43：1-n整数中1出现的次数（难以理解）</h3><p>解法零：最直观</p><ul><li>1-n有n个数，每个数有O(lgn)位，以10为底，时间复杂度O(nlgn)</li></ul><p>解法一：找规律，难以理解</p><h3 id="面试题44：数字序列中某一位的数字"><a href="#面试题44：数字序列中某一位的数字" class="headerlink" title="面试题44：数字序列中某一位的数字"></a>面试题44：数字序列中某一位的数字</h3><p>解法零：最直观</p><ul><li>当累加的位数和小于等于n时，从0开始枚举每一个数字，计算它是几位数，累加起来；</li><li>当大于n时，停止循环，第n位数字一定在这个数里，从这里面找</li></ul><p>解法一：优化，跳过一些数。</p><ul><li>1位的有10个，2位的90个，n位的 9 * 10^n^个</li><li>循环，每次跳过很多去查找</li></ul><p>43，44都是考察优化算法的激情，不能说不会，可以问能不能给提示。</p><h3 id="面试题45：把数组排成最小的数"><a href="#面试题45：把数组排成最小的数" class="headerlink" title="面试题45：把数组排成最小的数"></a>面试题45：把数组排成最小的数</h3><h4 id="解法零：最直观-O-n"><a href="#解法零：最直观-O-n" class="headerlink" title="解法零：最直观 O(n!)"></a>解法零：最直观 O(n!)</h4><ul><li>求所有数字的全排列，找出最小的（这里没有考虑大数，这方法有点问题）</li></ul><p>解法一：找1个排序规则(大数问题)</p><ul><li>转化成字符串数组，定义1个比较规则</li><li>将2个字符串连接后的字符串直接比较，String 已重写equals方法</li></ul><p>难点：要证明这种方法的正确性。（我这实习面试应该不会考）</p><h3 id="面试题46：把数字翻译成字符串"><a href="#面试题46：把数字翻译成字符串" class="headerlink" title="面试题46：把数字翻译成字符串"></a>面试题46：把数字翻译成字符串</h3><p>写出递归式，并用循环实现</p><h3 id="面试题47：礼物的最大价值（矩阵）"><a href="#面试题47：礼物的最大价值（矩阵）" class="headerlink" title="面试题47：礼物的最大价值（矩阵）"></a>面试题47：礼物的最大价值（矩阵）</h3><h4 id="解法一：典型的能用动态规划"><a href="#解法一：典型的能用动态规划" class="headerlink" title="解法一：典型的能用动态规划"></a>解法一：典型的能用动态规划</h4><ul><li>找最优子结构性质，递归分析写f(n)递归式</li><li>写成循环，递归代码不一定能拿到offer</li><li>借助2维辅助数组</li><li>写代码，按行遍历矩阵</li></ul><h4 id="解法二：优化空间复杂度"><a href="#解法二：优化空间复杂度" class="headerlink" title="解法二：优化空间复杂度"></a>解法二：优化空间复杂度</h4><ul><li>由于按行遍历矩阵，发现f(i,j)只跟f(i,j-1)和f(i-1,j)有关，因此没有必要保存i-2行及以上的</li><li>辅助数组保存第i行0，，，j-1位置的j个数和 第i-1行j,j+1,,,,n-1位置的n-j个数；相当于只用1个行的辅助空间。</li></ul><h3 id="面试题48-最长不含重复字符的子字符串"><a href="#面试题48-最长不含重复字符的子字符串" class="headerlink" title="面试题48:最长不含重复字符的子字符串"></a>面试题48:最长不含重复字符的子字符串</h3><h4 id="1-解法零：最直观"><a href="#1-解法零：最直观" class="headerlink" title="1.解法零：最直观"></a>1.解法零：最直观</h4><ul><li>子串有n(n+1)/2个，判断每个子串是否包含重复字符为O(n),总时间复杂度为O(n^3^)</li></ul><h4 id="2-解法一：举例分析规律-O-n-的时间复杂度"><a href="#2-解法一：举例分析规律-O-n-的时间复杂度" class="headerlink" title="2.解法一：举例分析规律(O(n) 的时间复杂度)"></a>2.解法一：举例分析规律(O(n) 的时间复杂度)</h4><h5 id="1）动态规划："><a href="#1）动态规划：" class="headerlink" title="1）动态规划："></a>1）动态规划：</h5><ul><li>f(i)表示以第i个字符结尾的不包含重复字符的子串的最长长度</li><li>如果第i个字符之前没出现过，则f(i) = f(i-1) + 1</li><li>如果出现过，记第i个字符与上次出现的位置的距离为d<ul><li>第i个字符上次出现在f(i-1)对应的最长子串中，d &lt;= f(i-1),此时f(i)  = d</li><li>第i个字符上次出现在f(i-1)对应的最长子串前，d &gt; f(i-1)  ，此时仍有f(i) = f(i-1) + 1</li></ul></li></ul><h5 id="2）算法代码："><a href="#2）算法代码：" class="headerlink" title="2）算法代码："></a>2）算法代码：</h5><ul><li><p>创建一个大小为26的数组，用于保存字符在原数组中的位置;curLength表示当前不含重复字符的最长子串的长度</p></li><li><p>遍历字符数组</p><ul><li>若以前该字符不存在，用preIndex = -1 表示，即当前字符以前没出现过，curLength++</li><li>当前字符以前出现过, curLength &gt; maxLength 则更新maxLength;curLength = 当前位置与当前字符上一次出现的位置的距离，即curLength = i - preIndex;</li><li>保存当前位置</li><li>遍历下一个</li></ul></li><li><p>退出循环时，再判断一次curLength 是否&gt; maxLength,是的话，则更新，return maxLength</p></li></ul><p>总结：熟练应用动态规划分析问题是解答此面试题的前提。</p><p>空间换时间</p><h3 id="面试题49：找出第N-1500-个丑数"><a href="#面试题49：找出第N-1500-个丑数" class="headerlink" title="面试题49：找出第N(1500)个丑数"></a>面试题49：找出第N(1500)个丑数</h3><p>什么是丑数：只包含因子2，3，5的数。习惯上把1当做第一个丑数.</p><p>怎样判断1个数是不是丑数?</p><ul><li>如果能被2整除，除以2，循环</li><li>如果能被3整除，除以3，循环</li><li>如果能被5整除，除以5，小混混</li><li>最后结果等于1则是丑数</li></ul><h4 id="解法一：逐个判断每个整数是不是丑数，直观但不够高效"><a href="#解法一：逐个判断每个整数是不是丑数，直观但不够高效" class="headerlink" title="解法一：逐个判断每个整数是不是丑数，直观但不够高效"></a>解法一：逐个判断每个整数是不是丑数，直观但不够高效</h4><ul><li>很多不是丑数的数也得做求余和除法操作去判断</li></ul><h4 id="解法二：创建数组保存已经找到的丑数，空间换时间"><a href="#解法二：创建数组保存已经找到的丑数，空间换时间" class="headerlink" title="解法二：创建数组保存已经找到的丑数，空间换时间"></a>解法二：创建数组保存已经找到的丑数，空间换时间</h4><p>数组中保存的丑数是有序的。</p><p>如何生成下个丑数？如何保证是有序的？</p><ul><li><p>丑数是另一个丑数 * 2，3或5的结果（1除外）</p></li><li><p>分别计算丑数数组中的数 * 2，3，5 得到第一个大于之前最大的丑数  3个</p></li><li><p>最小的即为所求</p></li></ul><p>优点：只计算丑数，用的还是乘法，省略了大量非丑数的计算。</p><blockquote><p> 考点：在碰到不熟悉的概念之后，要有主动积极的态度，大胆想面试官提问，思考在思考理解这个概念</p></blockquote><h3 id="面试题50-第一个只出现1次的字符"><a href="#面试题50-第一个只出现1次的字符" class="headerlink" title="面试题50:第一个只出现1次的字符"></a>面试题50:第一个只出现1次的字符</h3><h4 id="解法零：每个字符与后面所有的字符比较，O-n-2"><a href="#解法零：每个字符与后面所有的字符比较，O-n-2" class="headerlink" title="解法零：每个字符与后面所有的字符比较，O(n^2^)"></a>解法零：每个字符与后面所有的字符比较，O(n^2^)</h4><h4 id="解法一：用哈希表"><a href="#解法一：用哈希表" class="headerlink" title="解法一：用哈希表"></a>解法一：用哈希表</h4><ul><li>定义辅助数组，大小256,  *<u><strong>注意：这种的空间复杂度也是O(1) ,因为是常数的空间。</strong></u>*</li><li>扫描字符串2次</li></ul><p>扩展：如果是汉字，中文有几千个，怎么办？不知道</p><h3 id="面试题51：求数组中的逆序对-归并排序"><a href="#面试题51：求数组中的逆序对-归并排序" class="headerlink" title="面试题51：求数组中的逆序对(归并排序)"></a>面试题51：求数组中的逆序对(归并排序)</h3><h4 id="解法零：最直观"><a href="#解法零：最直观" class="headerlink" title="解法零：最直观"></a>解法零：最直观</h4><ul><li>对每一个数，都与他后面的数比较，时间复杂度O(n^2^)</li></ul><h4 id="解法一：利用归并排序-稍加修改"><a href="#解法一：利用归并排序-稍加修改" class="headerlink" title="解法一：利用归并排序(稍加修改)"></a>解法一：利用归并排序(稍加修改)</h4><p>时间复杂度O(nlogn),空间复杂度O(n)</p><h3 id="面试题52：两个单链表的第一个公共结点"><a href="#面试题52：两个单链表的第一个公共结点" class="headerlink" title="面试题52：两个单链表的第一个公共结点"></a>面试题52：两个单链表的第一个公共结点</h3><p>多种解法，用O(m+n)的，leetcode有做过2次.</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><h3 id="降低时间复杂度的方法"><a href="#降低时间复杂度的方法" class="headerlink" title="降低时间复杂度的方法"></a>降低时间复杂度的方法</h3><ul><li>改用更块的算法<ul><li>比如用动态规划解答面试题42 “连续子数组的最大和”,降到O(n)</li><li>利用快排partition在O(n)内解决面试题39 “数组中出现次数超过一半的数字”和40“最小的K个数”</li></ul></li><li>空间换时间（不一定都可行,嵌入式系统内存有限）<ul><li>动态规划的查表数组也是，避免重复计算</li><li>哈希表更是</li><li>缓存中间结果，避免重复计算</li></ul></li></ul><p>每做一道面试题的时候，更重要的是总结这道题的解法有什么特点，有哪些思路是可以应用到同类型中的题目去的。</p><h2 id="2020-06-08-第六章"><a href="#2020-06-08-第六章" class="headerlink" title="2020-06-08(第六章)"></a>2020-06-08(第六章)</h2><h3 id="面试题54-二叉搜索树的第k大结点"><a href="#面试题54-二叉搜索树的第k大结点" class="headerlink" title="面试题54:二叉搜索树的第k大结点"></a>面试题54:二叉搜索树的第k大结点</h3><ul><li>利用中序遍历，easy<ul><li>定一个成员变量，递增直到k</li><li>也可以不用定义成员变量，传参的时候，k–,直到1时就是所求结点</li></ul></li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    TreeNode <span class="token function">KthNode</span><span class="token punctuation">(</span>TreeNode pRoot<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span><span class="token punctuation">{</span>        TreeNode result <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pRoot <span class="token operator">==</span> null <span class="token operator">||</span> k <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        result <span class="token operator">=</span>  <span class="token function">KthNode</span><span class="token punctuation">(</span>pRoot<span class="token punctuation">.</span>left<span class="token punctuation">,</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>        count<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> k<span class="token punctuation">)</span><span class="token punctuation">{</span>            result <span class="token operator">=</span> pRoot<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>            result <span class="token operator">=</span> <span class="token function">KthNode</span><span class="token punctuation">(</span>pRoot<span class="token punctuation">.</span>right<span class="token punctuation">,</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h3 id="面试题55：二叉树的深度"><a href="#面试题55：二叉树的深度" class="headerlink" title="面试题55：二叉树的深度"></a>面试题55：二叉树的深度</h3><p>题目一：二叉树的深度</p><ul><li>递归</li></ul><p>题目二：判断是否是平衡二叉树</p><ul><li>后序遍历的递归形式</li></ul><h3 id="面试题56：考察位运算（略过）"><a href="#面试题56：考察位运算（略过）" class="headerlink" title="面试题56：考察位运算（略过）"></a>面试题56：考察位运算（略过）</h3><h3 id="面试题57-和为s的数字"><a href="#面试题57-和为s的数字" class="headerlink" title="面试题57: 和为s的数字"></a>面试题57: 和为s的数字</h3><h4 id="题目1：递增数组中找和为s的一对数。"><a href="#题目1：递增数组中找和为s的一对数。" class="headerlink" title="题目1：递增数组中找和为s的一对数。"></a>题目1：递增数组中找和为s的一对数。</h4><ul><li><p>解法一：C<del>n</del>^2^对，O(n^2^)</p></li><li><p>解法二：要快，用双指针法，左边往右扫描，右边往左扫描.时间复杂度O(n)</p></li></ul><h4 id="题目2：和为s的连续正数序列"><a href="#题目2：和为s的连续正数序列" class="headerlink" title="题目2：和为s的连续正数序列"></a>题目2：和为s的连续正数序列</h4><ul><li>也是双指针，但是从前面2个开始</li><li>小于给定和，则big指针增大；=输出；大于则small指针增大</li><li>增加的上届怎么来？(要求是连续序列)<ul><li>奇数时，比如为19;19/2 = 9  9+10 = 19; s / 2 + (s+1)/2 = s</li><li>所以增加到(s+1)/2停止</li></ul></li></ul><p>解法特点：都是用了双指针。</p><h3 id="面试题58-翻转字符串"><a href="#面试题58-翻转字符串" class="headerlink" title="面试题58: 翻转字符串"></a>面试题58: 翻转字符串</h3><h4 id="题目一：翻转单词顺序"><a href="#题目一：翻转单词顺序" class="headerlink" title="题目一：翻转单词顺序"></a>题目一：翻转单词顺序</h4><p>“I am a student.”  ==&gt; “student. a am I”</p><p>解法：二次翻转字符串的解法。（java中String类似乎是没有的）</p><p>要熟悉java字符串的操作. String StringBuilder</p><h4 id="题目二：左旋字符串"><a href="#题目二：左旋字符串" class="headerlink" title="题目二：左旋字符串"></a>题目二：左旋字符串</h4><p>相当于第一题的2个字符串的情况。</p><p>解法：调用三次字符串逆序函数. 思路巧妙.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/java/并发编程/第八章</title>
      <link href="blog/3060565884.html"/>
      <url>blog/3060565884.html</url>
      
        <content type="html"><![CDATA[<p>002</p><p>为什么要线程池？</p><p>阻塞队列  ：生产者 消费者</p><p>为什么要自定义线程池</p><p>007</p><p>在任务数多的时候，阻塞添加任务，主线程就卡住了，对主线程不友好。应该给主线程一个机会选择是否死等。</p><p>JDK线程池继承类图</p><p>基础实现类的构造方法相当重要。</p><p>救急线程的前提是配合有界队列使用。</p><p>JDK实现了4种拒绝策略。</p><p>拒绝策略第三方做了自己的扩展。</p><p>Executors.java中new的线程都是非守护线程，不会随着main线程的退出而退出。</p><p>匿名内部类可以写成员变量。</p><p>保护性暂停模式？08.017  callable</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/java/JAVA基础语法/注解</title>
      <link href="blog/1946894365.html"/>
      <url>blog/1946894365.html</url>
      
        <content type="html"><![CDATA[<p>Java 注解（Annotation）又称 Java 标注，是 JDK5.0 引入的一种注释机制。 注解是元数据的一种形式，提供有关 于程序但不属于程序本身的数据。注解对它们注解的代码的操作没有直接影响。</p><p>@interface 声明一个注解</p><p>@Target(ElementType.TYPE)  声明注解可以放在那里</p><p>@Retention : 保留级别:    源码  字节码  运行时   </p><p>声明一个元注解</p><p>源码级别的    APT   ide语法检查</p><p><img src=".%E6%B3%A8%E8%A7%A3_images/image-20200522140414611.png" alt="image-20200522140414611"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/编码</title>
      <link href="blog/114216123.html"/>
      <url>blog/114216123.html</url>
      
        <content type="html"><![CDATA[<p>都是2字节</p><p>GB2312：6000多个汉字</p><p>GBK：几万个汉字</p><p>GB18030：加入了少数民族的</p><p>ASCII:128个</p><p>Unicode</p><p>UCS-2: 2个字节表示</p><p>USC-4: 4个字节表示</p><p>UTF-8:可变的   中文字符和中文标点3个字节，英文字符和英文标点1个字节</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/java/常用类/String</title>
      <link href="blog/2286713642.html"/>
      <url>blog/2286713642.html</url>
      
        <content type="html"><![CDATA[<h2 id="Class-String"><a href="#Class-String" class="headerlink" title="Class String"></a>Class String</h2><ul><li><a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/lang/Object.html" target="_blank" rel="noopener">java.lang.Object</a></li><li><ul><li>java.lang.String</li></ul></li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">String</span> <span class="token keyword">extends</span> <span class="token class-name">Object</span><span class="token keyword">implements</span> <span class="token class-name">Serializable</span><span class="token punctuation">,</span> Comparable<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">,</span> CharSequence</code></pre><p>1.<code>public int compareTo(String anotherString)</code></p><ul><li><p>按字典顺序比较两个字符串。 比较是基于字符串中每个字符的Unicode值。 </p></li><li><p>长度不同，但是前面的字符串相同时<code>compareTo</code>返回字符串长度的差异 - 即值</p></li></ul><p>2.<code>public int indexOf(String str)</code></p><p>返回指定子字符串第一次出现的字符串内的索引。</p><p>3.<code>public String replace(char oldChar,char newChar)</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/网络/https</title>
      <link href="blog/1972474842.html"/>
      <url>blog/1972474842.html</url>
      
        <content type="html"><![CDATA[<h1 id="六、HTTPS"><a href="#六、HTTPS" class="headerlink" title="六、HTTPS"></a>六、HTTPS</h1><p>HTTP 有以下安全性问题：</p><ul><li>使用明文进行通信，内容可能会被窃听；</li><li>不验证通信方的身份，通信方的身份有可能遭遇伪装；</li><li>无法证明报文的完整性，报文有可能遭篡改。</li></ul><p>HTTPS 并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信，也就是说 HTTPS 使用了隧道进行通信。</p><p>通过使用 SSL，HTTPS 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。</p><p><a href="https://camo.githubusercontent.com/f30e48bd5f45d6ae0da32bcdafe9dad09fadd37e/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f73736c2d6f66666c6f6164696e672e6a7067" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/f30e48bd5f45d6ae0da32bcdafe9dad09fadd37e/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f73736c2d6f66666c6f6164696e672e6a7067" alt="img"></a></p><h2 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h2><h3 id="1-对称密钥加密"><a href="#1-对称密钥加密" class="headerlink" title="1. 对称密钥加密"></a>1. 对称密钥加密</h3><p>对称密钥加密（Symmetric-Key Encryption），加密和解密使用同一密钥。</p><ul><li>优点：运算速度快；</li><li>缺点：无法安全地将密钥传输给通信方。</li></ul><p><a href="https://camo.githubusercontent.com/c95f015d173dd0dd54208f377c5ee9ba9e0d735f/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f37666666613462382d623336642d343731662d616430632d6138386565373633626237362e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/c95f015d173dd0dd54208f377c5ee9ba9e0d735f/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f37666666613462382d623336642d343731662d616430632d6138386565373633626237362e706e67" alt="img"></a></p><h3 id="2-非对称密钥加密"><a href="#2-非对称密钥加密" class="headerlink" title="2.非对称密钥加密"></a>2.非对称密钥加密</h3><p>非对称密钥加密，又称公开密钥加密（Public-Key Encryption），加密和解密使用不同的密钥。</p><p>公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密。</p><p>非对称密钥除了用来加密，还可以用来进行签名。因为私有密钥无法被其他人获取，因此通信发送方使用其私有密钥进行签名，通信接收方使用发送方的公开密钥对签名进行解密，就能判断这个签名是否正确。</p><ul><li>优点：可以更安全地将公开密钥传输给通信发送方；</li><li>缺点：运算速度慢。</li></ul><p><a href="https://camo.githubusercontent.com/fe1d080a765b2285e0f91d882716c447ebf425f5/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f33396363623239392d656539392d346464312d623862342d3266396563393439356362342e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/fe1d080a765b2285e0f91d882716c447ebf425f5/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f33396363623239392d656539392d346464312d623862342d3266396563393439356362342e706e67" alt="img"></a></p><h3 id="3-HTTPS-采用的加密方式"><a href="#3-HTTPS-采用的加密方式" class="headerlink" title="3. HTTPS 采用的加密方式"></a>3. HTTPS 采用的加密方式</h3><p>上面提到对称密钥加密方式的传输效率更高，但是无法安全地将密钥 Secret Key 传输给通信方。而非对称密钥加密方式可以保证传输的安全性，因此我们可以利用非对称密钥加密方式将 Secret Key 传输给通信方。HTTPS 采用混合的加密机制，正是利用了上面提到的方案：</p><ul><li>使用非对称密钥加密方式，传输对称密钥加密方式所需要的 Secret Key，从而保证安全性;</li><li>获取到 Secret Key 后，再使用对称密钥加密方式进行通信，从而保证效率。（下图中的 Session Key 就是 Secret Key）</li></ul><p><a href="https://camo.githubusercontent.com/370d97acbc36633fdd170957bbdcf8f8c91230ff/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f486f772d48545450532d576f726b732e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/370d97acbc36633fdd170957bbdcf8f8c91230ff/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f486f772d48545450532d576f726b732e706e67" alt="img"></a></p><h2 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h2><p>通过使用 <strong>证书</strong> 来对通信方进行认证。</p><p>数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。</p><p>服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。</p><p>进行 HTTPS 通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过，就可以开始通信了。</p><p><a href="https://camo.githubusercontent.com/2901ef0e326dd93db4f6a815395fab9ff13225b2/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f323031372d30362d31312d63612e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/2901ef0e326dd93db4f6a815395fab9ff13225b2/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f323031372d30362d31312d63612e706e67" alt="img"></a></p><h2 id="完整性保护"><a href="#完整性保护" class="headerlink" title="完整性保护"></a>完整性保护</h2><p>SSL 提供报文摘要功能来进行完整性保护。</p><p>HTTP 也提供了 MD5 报文摘要功能，但不是安全的。例如报文内容被篡改之后，同时重新计算 MD5 的值，通信接收方是无法意识到发生了篡改。</p><p>HTTPS 的报文摘要功能之所以安全，是因为它结合了加密和认证这两个操作。试想一下，加密之后的报文，遭到篡改之后，也很难重新计算报文摘要，因为无法轻易获取明文。</p><h2 id="HTTPS-的缺点"><a href="#HTTPS-的缺点" class="headerlink" title="HTTPS 的缺点"></a>HTTPS 的缺点</h2><ul><li>因为需要进行加密解密等过程，因此速度会更慢；</li><li>需要支付证书授权的高额费用。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/Android/UI/ListView与RecyclerView</title>
      <link href="blog/3502889797.html"/>
      <url>blog/3502889797.html</url>
      
        <content type="html"><![CDATA[<p>1.[美团2020]listview和 recyclerview 的区别</p><p><a href="https://www.jianshu.com/p/cd8244d1c19a" target="_blank" rel="noopener">https://www.jianshu.com/p/cd8244d1c19a</a></p><p>ListView中的RecycleBin内部类保存了一个View[]数组mActiveViews，用来保存屏幕上正在显示的所有View</p><p>还保存了一个ArrayList<View>集合mScrapViews，用来保存所有滑出屏幕等待复用的View。</p><p>当用户滑动屏幕时，ListView会从mActiveViews中将滑出屏幕的view加入mScrapViews</p><p>并从后者取出view传给adapter的getView()方法供其复用<br>————————————————<br>版权声明：本文为CSDN博主「leo1302」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/leo1302/article/details/38680205" target="_blank" rel="noopener">https://blog.csdn.net/leo1302/article/details/38680205</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/Android/UI/View绘制背诵版</title>
      <link href="blog/520033894.html"/>
      <url>blog/520033894.html</url>
      
        <content type="html"><![CDATA[<p>1.概述：</p><p>View的绘制流程是从ViewRoot的performTraversals方法开始的，它经过measure,layout和draw三个过程才能最终将1个View绘制出来，其中mearsure用来测量View的宽和高，layout用来确定View在父容器中的放置位置，而draw则负责将View绘制在屏幕上。</p><p>performTraversals会依次调用performMearsure,performLayout和performDraw三个方法，它们分别完成顶级View的measure,layout,和draw三大流程。</p><p>mearsure中会调用onMearsure，onMearsure中会对所有子元素进行measure过程，这个时候measure流程就传到了子元素中，这就完成了一次measure过程，接着子元素重复父容器的measure过程，如此反复就完成了整个View树的遍历.。 performLaout和performDraw同理.</p><p>2.MeasureSpec</p><p>SpecMode: EXACTLY   AT_MOST _UNSPECIFIED</p><p>3.View测量的宽和高由View的MeasureSpec决定，而它的规格 由LayoutParams和父容器对子元素的要求决定（规格）</p><p>4.getMeasureWidth和getWidth的区别</p><p>前者在测量过程结束后可以获得；后者在layout过程结束后才能获得。</p><p>5.onMeasure可能会被调多次</p><p>6.View类的onMeasure方法做了什么？</p><p>自定义View：主要实现onMeasure + onDraw</p><p>自定义ViewGroup:主要实现onMeasure+onLayout</p><h1 id="android-自定义属性步骤"><a href="#android-自定义属性步骤" class="headerlink" title="android 自定义属性步骤"></a>android 自定义属性步骤</h1><p>1.在res/values目录下新建一个attrs.xml; 将之前规划好的属性定义在attrs.xml中。declare-styleable标签里的  <attr>子标签中</p><pre><code>&lt;declare-styleable name=&quot;MyTextView&quot;&gt;    &lt;attr name=&quot;textColor&quot; format=&quot;color&quot;/&gt;    &lt;attr name=&quot;textSize&quot; format=&quot;dimension&quot;/&gt;    &lt;attr name=&quot;text&quot; format=&quot;string&quot;/&gt;    &lt;attr name=&quot;background&quot; format=&quot;reference|color&quot;/&gt;&lt;/declare-styleable&gt;</code></pre><p>2.在自定义View中，主要是构造方法中获取自定义的属性的值 ，以供我们实现自定义view的需要。自定义属性使用R.styleable引用，获取里面的属性需要使用“名字_属性”的方式。TypeArray在使用完成后要进行recycle().</p><p>3.实现好自定义view，然后就是使用自定义view</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/java/集合框架/树</title>
      <link href="blog/3675834771.html"/>
      <url>blog/3675834771.html</url>
      
        <content type="html"><![CDATA[<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="1-二叉树的先序非递归遍历"><a href="#1-二叉树的先序非递归遍历" class="headerlink" title="1.二叉树的先序非递归遍历"></a>1.二叉树的先序非递归遍历</h3><ul><li>定义一个栈并将根节点入栈</li><li>当栈不空的时候循环执行<ul><li>从栈中弹出一个结点，并访问它</li><li>如果右孩子不空，右孩子入栈</li><li>如果左孩子不空，左孩子入栈</li></ul></li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">preOrderUnCur</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"这是个空树"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        Stack<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            TreeNode node <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h3 id="2-二叉树的中序非递归遍历"><a href="#2-二叉树的中序非递归遍历" class="headerlink" title="2.二叉树的中序非递归遍历"></a>2.二叉树的中序非递归遍历</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 非递归中序遍历 * 开始创建一个栈，创建一个指向根节点的变量 * 当栈为空 &amp;&amp; 当前结点为时 才结束循环，否则循环执行下面2句 * 当前结点为空，从栈中弹出一个变成当前结点打印，并指向右孩子； * 当前结点不空，当前结点入栈，当前结点并指向左孩子‘ * @param root 树根 */</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">inOrderUnCur</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"这是个空树"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    Stack<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    TreeNode p <span class="token operator">=</span> root<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> p <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>p <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>            stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>            p <span class="token operator">=</span> p<span class="token punctuation">.</span>left<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            p <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>val <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            p <span class="token operator">=</span> p<span class="token punctuation">.</span>right<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/java/并发编程/线程安全</title>
      <link href="blog/4065108673.html"/>
      <url>blog/4065108673.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-出现线程安全问题的原因："><a href="#1-出现线程安全问题的原因：" class="headerlink" title="1. 出现线程安全问题的原因："></a>1. 出现线程安全问题的原因：</h3><p>在、多个线程共同访问同一共享内存资源时，其中一个线程对资源进行写操作的中途(写⼊入已经开始，但还没 结束)，其他线程对这个写了一半的资源进⾏了读操作，或者对这个写了一半的资源进⾏了写操作，导致此资源出现数据错误。</p><h3 id="2-如何避免线程安全问题？"><a href="#2-如何避免线程安全问题？" class="headerlink" title="2. 如何避免线程安全问题？"></a>2. 如何避免线程安全问题？</h3><ul><li>保证共享资源在同一时间只能由一个线程进行操作(原子性，有序性)。</li><li>将线程操作的结果及时刷新，保证其他线程可以立即获取到修改后的最新数据（可见性）。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/网络/网络面试题</title>
      <link href="blog/2890460891.html"/>
      <url>blog/2890460891.html</url>
      
        <content type="html"><![CDATA[<p>秋招抖音一面：</p><p>HTTPS过程。</p><p>.http请求的全过程，顺带着问了http报文格式（字节）</p><h1 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h1><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/0fa6c237-a909-4e2a-a771-2c5485cd8ce0.png" alt="img"></p><h2 id="1-五层协议-https-cyc2018-github-io-CS-Notes-notes-计算机网络-概述-id-1-五层协议"><a href="#1-五层协议-https-cyc2018-github-io-CS-Notes-notes-计算机网络-概述-id-1-五层协议" class="headerlink" title="[1. 五层协议](https://cyc2018.github.io/CS-Notes/#/notes/计算机网络 - 概述?id=_1-五层协议)"></a>[1. 五层协议](<a href="https://cyc2018.github.io/CS-Notes/#/notes/计算机网络" target="_blank" rel="noopener">https://cyc2018.github.io/CS-Notes/#/notes/计算机网络</a> - 概述?id=_1-五层协议)</h2><ul><li><p><strong>应用层</strong> ：是用户与网络的界面，为特定应用程序提供数据传输服务，例如 HTTP、DNS 等协议。数据单位为报文。</p></li><li><p>表示层：主要用于处理2个通信系统中交换信息的表示方式(不同机器采用的编码和表示方法不同)。数据压缩，加密解密也是它的功能。</p></li><li><p>会话层：允许不同主机上各进程之间的会话</p></li><li><p><strong>传输层</strong> ：负责两个进程之间的通信。运输层包括两种协议： TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。</p></li><li><p><strong>网络层</strong> ：为不同主机提供通信服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组，不提供有序到达。</p></li><li><p><strong>数据链路层</strong> ：数据链路层是对<a href="https://baike.baidu.com/item/物理层" target="_blank" rel="noopener">物理层</a>传输原始<a href="https://baike.baidu.com/item/比特" target="_blank" rel="noopener">比特</a>流的功能的加强，将物理层提供的可能出错的物理连接改造成为逻辑上无差错的数据链路，使之对<a href="https://baike.baidu.com/item/网络层" target="_blank" rel="noopener">网络层</a>表现为一无差错的线路。</p></li><li><p><strong>物理层</strong> ：考虑的是怎样在传输媒体上传输比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。</p></li></ul><p>1.1七层模型,每一层是干什么的 </p><p>2.DNS解析过程，如果服务器ip地址改变了，客户端怎么知道呢</p><p>3.https和http的区别</p><p>4.tcp/ip</p><p>5.tcp 三次握手和四次挥手</p><h3 id="TCP的三次握手"><a href="#TCP的三次握手" class="headerlink" title="TCP的三次握手"></a>TCP的三次握手</h3><p>假设 A 为客户端，B 为服务器端。</p><ul><li>首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。</li><li>A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。</li><li>B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。</li><li>A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。</li><li>B 收到 A 的确认后，连接建立。</li></ul><p><strong>三次握手的原因</strong></p><p>第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。</p><p>客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。</p><p>假设是2次的话，服务端发出确认就建立连接，并一直等待客户端发送数据，服务端的资源就浪费了。</p><p>如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。</p><p><strong>四次挥手的原因</strong></p><p>客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。</p><p><strong>TIME_WAIT</strong></p><p>客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：</p><ul><li>确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。</li><li>等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。</li></ul><p>6.get和post区别</p><ul><li>GET 用于获取资源，而 POST 用于传输实体主体。</li><li>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息POST放在Request body中。</li></ul><p>GET在浏览器回退时是无害的，而POST会再次提交请求。</p><p>GET产生的URL地址可以被Bookmark，而POST不可以。</p><p>GET请求会被浏览器主动cache，而POST不会，除非手动设置。</p><p>GET请求只能进行url编码，而POST支持多种编码方式。</p><p>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</p><p>GET请求在URL中传送的参数是有长度限制的，而POST么有。</p><p>对参数的数据类型，GET只接受ASCII字符，而POST没有限制。</p><p>GET参数通过URL传递，</p><p>7.http</p><p>7.1http状态码</p><p>2020-08-03 16:57:29   504遇到，  技术部客户端网站打不开</p><p>8.tcp和udp</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/操作系统/面试题</title>
      <link href="blog/3975035276.html"/>
      <url>blog/3975035276.html</url>
      
        <content type="html"><![CDATA[<p>美团：</p><p>   链接：<a href="https://ac.nowcoder.com/discuss/418991?type=2" target="_blank" rel="noopener">https://ac.nowcoder.com/discuss/418991?type=2</a></p><p>​    线程和进程的区别（资源分配，调度，系统开销，通信方面，进程切换要中断陷入内核态）      </p><p>​    进程间是怎么通讯的（pipe，fifo，信号量，共享内存，socket）      </p><p>​    造成死锁的必要条件（互斥，占有和等待，不抢占，环路等待）       </p><p>​    操作系统虚拟内存和物理内存关系，内存分页算法（学了好久了，当时有点忘了，答得很不好）       </p><p>​    你是怎么认识操作系统的（我也不知道咋答，就结合上面说的总结理一下。。。）</p><p>腾讯(Android暑期实习)</p><p>进程通信(Android如何实现？)</p><p>了解操作系统吗？<br>进程和线程差别<br>线程安全<br>java如何实现线程安全</p><p>链接：<a href="https://www.nowcoder.com/questionTerminal/09b51b00891543d6b08ace80c0704b01" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/09b51b00891543d6b08ace80c0704b01</a><br>来源：牛客网</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p><strong>死锁</strong>        <strong>:</strong>是指多个进程在执行过程中,因争夺资源而造成的一种<strong>互相等待</strong>的现象,若无<strong>外力</strong>作用,它们都将无法推进下去</p><p>​    （1） 因为系统资源不足。  </p><p>​    （2） 进程运行推进顺序不合适。  </p><p>​    （3） 资源分配不当等。</p><h4 id="四个必要条件"><a href="#四个必要条件" class="headerlink" title="四个必要条件"></a>四个必要条件</h4><p>（1） <strong>互斥条件</strong>：一个资源每次只能被一个进程使用。  </p><p>（2） <strong>请求与保持条件</strong>：一个进程因请求资源而阻塞时，对已获得的资源保持不放。  </p><p>（3） <strong>不剥夺条件</strong>:进程已获得的资源，在末使用完之前，不能强行剥夺。  </p><p> （4） <strong>循环等待条件</strong>:若干进程之间形成一种头尾相接的循环等待资源关系。</p><h3 id="解决死锁的基本方法"><a href="#解决死锁的基本方法" class="headerlink" title="解决死锁的基本方法"></a>解决死锁的基本方法</h3><h4 id="预防死锁："><a href="#预防死锁：" class="headerlink" title="预防死锁："></a>预防死锁：</h4><p>资源一次性分配：一次性分配所有资源，这样就不会再有请求了：（破坏请求条件）<br>只要有一个资源得不到分配，也不给这个进程分配其他的资源：（破坏请保持条件）<br>可剥夺资源：即当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源（破坏不可剥夺条件）<br>资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）</p><h4 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁:"></a>避免死锁:</h4><p>预防死锁的几种策略，会严重地损害系统性能。因此在避免死锁时，要施加较弱的限制，从而获得 较满意的系统性能。由于在避免死锁的策略中，允许进程动态地申请资源。因而，系统在进行资源分配之前预先计算资源分配的安全性。若此次分配不会导致系统进入不安全的状态，则将资源分配给进程；否则，进程等待。其中最具有代表性的避免死锁算法是银行家算法。<br>银行家算法：首先需要定义状态和安全状态的概念。系统的状态是当前给进程分配的资源情况。因此，状态包含两个向量Resource（系统中每种资源的总量）和Available（未分配给进程的每种资源的总量）及两个矩阵Claim（表示进程对资源的需求）和Allocation（表示当前分配给进程的资源）。安全状态是指至少有一个资源分配序列不会导致死锁。当进程请求一组资源时，假设同意该请求，从而改变了系统的状态，然后确定其结果是否还处于安全状态。如果是，同意这个请求；如果不是，阻塞该进程知道同意该请求后系统状态仍然是安全的。</p><h4 id="检测死锁"><a href="#检测死锁" class="headerlink" title="检测死锁"></a>检测死锁</h4><p>首先为每个进程和每个资源指定一个唯一的号码；<br>然后建立资源分配表和进程等待表。</p><h4 id="解除死锁"><a href="#解除死锁" class="headerlink" title="解除死锁:"></a>解除死锁:</h4><p>当发现有进程死锁后，便应立即把它从死锁状态中解脱出来，常采用的方法有：</p><p>剥夺资源：从其它进程剥夺足够数量的资源给死锁进程，以解除死锁状态；<br>撤消进程：可以直接撤消死锁进程或撤消代价最小的进程，直至有足够的资源可用，死锁状态.消除为止；所谓代价是指优先级、运行代价、进程的重要性和价值等。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/java/JAVA基础语法/内部类</title>
      <link href="blog/4077037808.html"/>
      <url>blog/4077037808.html</url>
      
        <content type="html"><![CDATA[<h3 id="10-2"><a href="#10-2" class="headerlink" title="10.2"></a>10.2</h3><p>为什么内部类能访问外部类的方法和字段/属性(包括private成员)？</p><ul><li><p>非静态的才可以</p></li><li><p>当外部类对象创建了一个内部类对象时，编译器会在构造函数中传1个外部类对象的引用给内部类；</p><p>访问外部类的成员时，就是用那个引用来访问的</p></li></ul><h3 id="10-3-this-和-new的使用"><a href="#10-3-this-和-new的使用" class="headerlink" title="10.3 .this 和.new的使用"></a>10.3 .this 和.new的使用</h3><ul><li><p>.this</p><p>如果(在内部类方法中)需要生成外部类对象的引用，可以这样OutterClass.this</p></li><li><p>.new</p><p>如果需要告知某些其他对象，去创建其某个(非静态时)内部类的对象，需要在new表达式中提供对其他外部类对象的引用，就是必须使用外部类的对象来创建该内部类对象。</p><pre class=" language-java"><code class="language-java">Outter out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Outter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Outter<span class="token punctuation">.</span>Inner inner <span class="token operator">=</span> out<span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token class-name">Inner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ul><p>​       外部类的静态方法要想new内部类对象，也得使用.new</p><ul><li>成员内部类可以用访问修饰符修饰，可以把他当成外部类的成员来看。不同包的子类访问父类的protected 成员内部类时，不能new对象是因为，此时是访问一个不相干类(不同包，没继承关系)的protected的构造方法。</li></ul><h3 id="10-4内部类与向上转型"><a href="#10-4内部类与向上转型" class="headerlink" title="10.4内部类与向上转型"></a>10.4内部类与向上转型</h3><p>当取得了一个指向基类或接口的引用时，甚至可能无法找出它的确切类型：</p><ul><li>方法返回的是接口的引用，方法中new的是内部类对象.</li></ul><p>private内部类</p><ul><li>private内部类给类的设计者提供了一种途径，通过这种方式可以完全阻止任何依赖于类型的编码，并且完全隐藏了实现的细节（private 内部类完全不可见），</li><li>得到的只是基类或接口的引用，能够方便地隐藏实现细节.</li></ul><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//Contens.java</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Contents</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//Parcel4.java</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Parcel4</span> <span class="token punctuation">{</span>   <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">PContents</span> <span class="token keyword">implements</span> <span class="token class-name">Contents</span><span class="token punctuation">{</span>        <span class="token keyword">private</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">11</span><span class="token punctuation">;</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> PContents <span class="token function">contents</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">PContents</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//Test.java</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Parcel4 p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parcel4</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Contents c <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">contents</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//   p.new PContents();会报错</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>不同包的子类可以访问父类的protected成员，包括protected内部类，但是不能直接new protected修饰的内部类</p></blockquote><h3 id="10-5在方法和作用域内的内部类"><a href="#10-5在方法和作用域内的内部类" class="headerlink" title="10.5在方法和作用域内的内部类"></a>10.5在方法和作用域内的内部类</h3><ol><li><p><code>destination</code>方法中的内部类<strong>PDestination</strong> ,并不意味着一旦 <code>destination()</code> 方法执行完毕，<strong>PDestination</strong> 就不可用了。</p></li><li><p>类被嵌入在 <strong>if</strong> 语句的作用域内，这并不是说该类的创建是有条件的，它其实与别的类一起编译过了。然而，在定义 <strong>Trackingslip</strong> 的作用域之外，它是不可用的，除此之外，它与普通的类一样。</p></li></ol><p>这不是有矛盾吗？</p><h3 id="10-6-匿名内部类"><a href="#10-6-匿名内部类" class="headerlink" title="10.6 匿名内部类"></a>10.6 匿名内部类</h3><ol><li><p>在匿名类中定义字段时，还能够对其执行初始化操作</p></li><li><p>访问外部类的对象时，外部类对象需加final修饰(有时省略掉也没问题,即使不加 <strong>final</strong>, Java 8 的编译器也会为我们自动加上 <strong>final</strong>)</p></li><li><p>在匿名类中不可能有命名(自己的类名)构造器（因为它根本没名字！），但通过实例初始化(就是{}代码块)，就能够达到为匿名内部类创建一个构造器的效果，</p></li></ol><h3 id="10-7-嵌套类"><a href="#10-7-嵌套类" class="headerlink" title="10.7 嵌套类"></a>10.7 嵌套类</h3><h3 id="10-8-为什么需要内部类"><a href="#10-8-为什么需要内部类" class="headerlink" title="10.8 为什么需要内部类"></a>10.8 为什么需要内部类</h3><h3 id="10-9-继承内部类-略掉。"><a href="#10-9-继承内部类-略掉。" class="headerlink" title="10.9 继承内部类 略掉。"></a>10.9 继承内部类 略掉。</h3><h3 id="10-10-局部内部类"><a href="#10-10-局部内部类" class="headerlink" title="10.10 局部内部类"></a>10.10 局部内部类</h3><ol><li><p>局部内部类不能有访问说明符，因为它不是外围类的一部分；但是它可以访问当前代码块内的常量，以及此外围类的所有成员。</p></li><li><p>既然局部内部类的名字在方法外是不可见的，那为什么我们仍然使用局部内部类而不是匿名内部类呢？唯一的理由是，我们需要一个已命名的构造器，或者需要重载构造器，而匿名内部类只能用于实例初始化。</p></li></ol><p>所以使用局部内部类而不使用匿名内部类的另一个理由就是，需要不止一个该内部类的对象。</p><h3 id="2-局部内部类-用得少了解一下"><a href="#2-局部内部类-用得少了解一下" class="headerlink" title="2.局部内部类(用得少了解一下)"></a>2.局部内部类(用得少了解一下)</h3><p>局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。</p><p><strong>注意</strong>: 局部内部类就像是方法里面的一个局部变量一样，是不能有 public、protected、private 以及 static 修饰符的。</p><p><img src=".%E5%86%85%E9%83%A8%E7%B1%BB_images/image-20200521115544435.png" alt="image-20200521115544435"></p><h3 id="3-匿名内部类"><a href="#3-匿名内部类" class="headerlink" title="3.匿名内部类"></a>3.匿名内部类</h3><p>匿名内部类应该是平时我们编写代码时用得最多的，在编写事件监听的代码时使用匿名内部类不但方便，而且使代码更加容易维护。同样的，匿名内部类也是不能有访问修饰符和 static 修饰符的。</p><h3 id="4-静态内部类"><a href="#4-静态内部类" class="headerlink" title="4.静态内部类"></a>4.静态内部类</h3><p>静态内部类是不需要依赖于外部类的，这点和类的静态成员属性有点类似，并且它不能使用外部类的非static成员变量或者方法：</p><p>​    这点很好理解，因为在没有外部类的对象的情况下，可以创建静态内部类的对象，如果允许访问外部类的非    static成员就会产生矛盾，因为外部类的非static成员必须依附于具体的对象。</p><p>静态内部类就像一个静态方法。</p><h2 id="三-内部类的使用场景和好处"><a href="#三-内部类的使用场景和好处" class="headerlink" title="三.内部类的使用场景和好处"></a>三.内部类的使用场景和好处</h2><p>为什么在 Java 中需要内部类？总结一下主要有以下四点：</p><ul><li>1.每个内部类都能独立的继承一个接口的实现，所以无论外部类是否已经继承了某个(接口的)实现，对于内部类都没有影响。内部类使得多重继承的解决方案变得完整。</li><li>2.方便将存在一定逻辑关系的类组织在一起，又可以对外界隐藏。</li><li>3.方便编写事件驱动程序。</li><li>4.方便编写线程代码。</li></ul><p>静态(成员)内部类和成员内部类的区别：</p><ul><li>成员内部类不能有静态成员（属性和方法）;</li></ul><p>匿名内部类只能使用1次，只有1个引用。</p><h4 id="外部类可以直接-内部类的私有成员-这是为什么？"><a href="#外部类可以直接-内部类的私有成员-这是为什么？" class="headerlink" title="外部类可以直接.内部类的私有成员,这是为什么？"></a>外部类可以直接.内部类的私有成员,这是为什么？</h4><p>内部类不能有静态成员，static修饰的才可以有。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> test<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">C</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">father</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">printChild</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">class</span> <span class="token class-name">Child</span><span class="token punctuation">{</span>        <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">printChild</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre><code> 0 new #2 &lt;test/C$Child&gt; 3 dup 4 aload_0 5 invokespecial #3 &lt;test/C$Child.&lt;init&gt;&gt; 8 invokestatic #4 &lt;test/C$Child.access$000&gt;11 return</code></pre><pre><code>static /* synthetic */ int access$000(Outer$Inner self) {    return self.inProp;  }</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/java/集合框架/ArrayList</title>
      <link href="blog/3726974704.html"/>
      <url>blog/3726974704.html</url>
      
        <content type="html"><![CDATA[<p>ArrayList</p><p>1.Clonable接口</p><ul><li>浅拷贝只复制的对象的引用，无法做到完全复制</li><li>深拷贝如何实现：不简单复制引用，复制引用类型对象的新引用</li></ul><h4 id="Arrays-asList-T…t-返回的List不支持add操作"><a href="#Arrays-asList-T…t-返回的List不支持add操作" class="headerlink" title="Arrays.asList(T…t) 返回的List不支持add操作"></a>Arrays.asList(T…t) 返回的List不支持add操作</h4><p>Arrays.asList(T…t) 返回的List不支持add操作，因为它里面的ArrayList是Arrays的内部类 ，父类的add方法直接抛出了异常 UnsupportedOperationException。</p><h4 id="subList-方法"><a href="#subList-方法" class="headerlink" title="subList 方法"></a>subList 方法</h4><ol><li><p>ArrayList的subList方法返回的是SubList类的对象(ArrayList的内部类),转成ArrayList时会抛类型转换异常。</p></li><li><p>对subList(ArrayList中的方法)返回的结果List操作，实际修改的是原来的ArrayList.</p></li><li><p>ConcurrentModificationException:  </p><p>如果你使用 subList 方法获取了一个子列表，这之后又在原始列表上进行了新增或删除的操作，这是，你之前获取到的 subList 就已经废掉了，不能用了，不能用的意思就是你在 subList 上进行遍历、增加、删除操作都会抛出异常，没错，连遍历都不行了。</p></li></ol><h4 id="ArrayList和LinkedList"><a href="#ArrayList和LinkedList" class="headerlink" title="ArrayList和LinkedList"></a>ArrayList和LinkedList</h4><p>相同</p><ul><li><strong>1. 是否保证线程安全：</strong> ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；</li></ul><p>不同</p><ul><li><strong>2. 数据结构：</strong> Arraylist 使用的是Object数组；LinkedList 底层使用的是双向链表数据结构（JDK1.6之前为循环链表，JDK1.7取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）</li><li><strong>3. 插入和删除是否受元素位置的影响：</strong> ① <strong>ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。</strong> 比如：执行<code>add(E e)</code>方法的时候， ArrayList 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是O(1)。但是如果要在指定位置 i 插入和删除元素的话（<code>add(int index, E element)</code>）时间复杂度就为 O(n)。 ② <strong>LinkedList 采用链表存储，所以插入，删除元素时间复杂度不受元素位置的影响，都是近似 O（1）而数组为近似 O（n）。</strong></li><li><strong>4. 是否支持快速随机访问：</strong> LinkedList 不支持高效的随机元素访问，而 ArrayList 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于<code>get(int index)</code>方法)。</li><li><strong>5. 内存空间占用：</strong> ArrayList的空 间浪费主要体现在在list列表的结尾会预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗比ArrayList更多的空间（因为要存放直接后继和直接前驱以及数据）</li></ul><h3 id="构造方法："><a href="#构造方法：" class="headerlink" title="构造方法："></a>构造方法：</h3><p>1.通过空参构造方法创建集合对象并未构造一个初始容量为十的空列表，仅仅将 DEFAULTCAPACITY_EMPTY_ELEMENTDATA 的地址赋值给elementData</p><p>2.通过传入容量0作为参数，仅仅将EMPTY_ELEMENTDATA 的地址赋值给elementData</p><h3 id="ArrayList遍历方法"><a href="#ArrayList遍历方法" class="headerlink" title="ArrayList遍历方法"></a>ArrayList遍历方法</h3><p>因为它实现了RandomAccess接口，支持随机访问，用for循环比用迭代器块。</p><p>LinkedList采用迭代器遍历（是顺序访问）更快。</p><h3 id="ArrayList-插入方法源码"><a href="#ArrayList-插入方法源码" class="headerlink" title="ArrayList 插入方法源码"></a>ArrayList 插入方法源码</h3><p>先检查插入后是否溢出 ： size+1 - elementData.length &gt; 0，满足条件进行扩容为原来1.5倍，拷贝(Arrays.copyof()  - &gt; System.arraycopy(,,,,))原数组到新数字。</p><p>然后赋值，size++.</p><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><h3 id="1-ArrayList是如何扩容的？"><a href="#1-ArrayList是如何扩容的？" class="headerlink" title="1.ArrayList是如何扩容的？"></a>1.ArrayList是如何扩容的？</h3><p>new ArrayList()  创建的空数组（默认空容量），当add时，会调成默认容量10.</p><p>后面按1：1.5扩充。</p><h3 id="2-ArrayList插入或删除元素一定比LinkedList慢么"><a href="#2-ArrayList插入或删除元素一定比LinkedList慢么" class="headerlink" title="2.ArrayList插入或删除元素一定比LinkedList慢么?"></a>2.ArrayList插入或删除元素一定比LinkedList慢么?</h3><ol><li><p>数组删除元素确实要比链表慢，慢在需要创建新数组，还有比较麻烦的数据拷贝，但是在ArrayList 底层不是每次删除元素都需要扩容，因此在这个方面相对于链表来说数组的性能更好</p></li><li><p>LinkedList删除元素之所以效率并不高，其原理在于底层先需要对整个集合进行折半的动作，然后 又需要对集合进行遍历一次，这些操作导致效率变低</p></li></ol><h3 id="4-5-如何复制某个ArrayList到另一个ArrayList中去？"><a href="#4-5-如何复制某个ArrayList到另一个ArrayList中去？" class="headerlink" title="4.5 如何复制某个ArrayList到另一个ArrayList中去？"></a>4.5 如何复制某个ArrayList到另一个ArrayList中去？</h3><p>使用clone()方法 使用ArrayList构造方法 使用addAll方法</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/Android/Android基础/Intent</title>
      <link href="blog/3322297084.html"/>
      <url>blog/3322297084.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-什么是Intent"><a href="#1-什么是Intent" class="headerlink" title="1.什么是Intent?"></a>1.什么是Intent?</h2><p><code>Intent</code> 是一个消息传递对象，可以用来从其他<a href="https://developer.android.google.cn/guide/components/fundamentals#Components" target="_blank" rel="noopener">应用组件</a>请求action。尽管 Intent 可以通过多种方式促进组件之间的通信，但其基本用法主要包括以下三个：</p><h2 id="2-基本用法"><a href="#2-基本用法" class="headerlink" title="2.基本用法"></a>2.基本用法</h2><ul><li><p><strong>启动 Activity</strong></p><p>Intent` 用于描述要启动的 Activity，并携带任何必要的数据。</p></li><li><p><strong>启动服务</strong></p><p>通过将 <code>Intent</code> 传递给 <code>startService()</code>，您可以启动服务执行一次性操作（例如，下载文件）。<code>Intent</code> 用于描述要启动的服务，并携带任何必要的数据。    </p></li><li><p><strong>传递广播</strong></p><p>广播是任何应用均可接收的消息</p></li></ul><h2 id="3-分为两种类型"><a href="#3-分为两种类型" class="headerlink" title="3.分为两种类型"></a>3.分为两种类型</h2><ul><li><strong>显式 Intent</strong>：(提供目标应用的软件包名称或完全限定的组件类名)通常，会在自己的应用中使用显式 Intent 来启动组件，这是因为您知道要启动的 Activity 或服务的类名。</li><li><strong>隐式 Intent</strong> ：不会指定特定的组件，而是声明要执行的常规操作。比如：在浏览器中打开…</li></ul><p>使用隐式 Intent 时，Android 系统通过将 Intent 的内容与在设备上其他应用的<a href="https://developer.android.google.cn/guide/topics/manifest/manifest-intro" target="_blank" rel="noopener">清单文件</a>中声明的 <em>Intent 过滤器</em>进行比较，从而找到要启动的相应组件。如果 Intent 与 Intent 过滤器匹配，则系统将启动该组件，并向其传递 <code>Intent</code> 对象。如果多个 Intent 过滤器兼容，则系统会显示一个对话框，支持用户选取要使用的应用。</p><blockquote><p>注意：为了确保应用的安全性，<strong>启动 <code>Service</code> 时，请始终使用显式 Intent</strong>，且不要为服务声明 Intent 过滤器。使用隐式 Intent 启动服务存在安全隐患，因为您无法确定哪些服务将响应 Intent，且用户无法看到哪些服务已启动。从 Android 5.0（API 级别 21）开始，如果使用隐式 Intent 调用 <code>bindService()</code>，系统会抛出异常。</p></blockquote><h2 id="4-构建Intent"><a href="#4-构建Intent" class="headerlink" title="4.构建Intent"></a>4.构建Intent</h2><p><code>Intent</code> 中包含的主要信息如下：</p><p><strong>4.1组件名称ComponentName（可选）</strong></p><p>​        如果没有组件名称，则 Intent 则为<em>隐式</em>，且系统将根据其他 Intent 信息（例如，以下所述的操作、数据和类别）决定哪个组件应当接收 Intent。例如，<code>com.example.ExampleActivity</code>。您可以使用 <code>setComponent()</code>、<code>setClass()</code>、<code>setClassName()</code>，或 <code>Intent</code> 构造函数设置组件名称。</p><p><strong>4.2操作/动作ACTION</strong></p><p>​    指定要执行的通用操作（例如，<em>查看</em>或<em>选取</em>）的字符串。</p><p>​    对于广播 Intent，这是指已发生且正在报告的操作。操作会在很大程度上决定其余 Intent 的构成，特别是数据和 extra 中包含的内容。以下是一些用于启动 Activity 的常见操作：</p><p><code>ACTION_VIEW</code></p><p>如果您拥有一些某项 Activity 可向用户显示信息（例如，要使用图库应用查看的照片；或者要使用地图应用查看的地址），请通过 Intent 将此操作与 <code>startActivity()</code> 结合使用。</p><p><code>ACTION_SEND</code></p><p>这也称为<em>共享</em> Intent。如果您拥有一些用户可通过其他应用（例如，电子邮件应用或社交共享应用）共享的数据，则应使用 Intent 将此操作与 <code>startActivity()</code> 结合使用。有关更多定义通用操作的常量，请参阅 <code>Intent</code> 类参考文档。</p><p>可以使用 <code>setAction()</code> 或 <code>Intent</code> 构造函数为 Intent 指定操作。</p><p>如果定义自己的操作，请确保加入应用的软件包名称作为前缀：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> String ACTION_TIMETRAVEL <span class="token operator">=</span> <span class="token string">"com.example.action.TIMETRAVEL"</span><span class="token punctuation">;</span></code></pre><p><strong>4.3数据</strong></p><p>引用待 操作 数据和/或该数据 MIME 类型的 URI（<code>Uri</code> 对象）。提供的数据类型通常由 Intent 的操作决定。例如，如果操作是 <code>ACTION_EDIT</code>，则数据应包含待编辑文档的 URI。</p><p>引用待操作数据和/或该数据 MIME 类型的 URI（<code>Uri</code> 对象）。提供的数据类型通常由 Intent 的操作决定。例如，如果操作是 <code>ACTION_EDIT</code>，则数据应包含待编辑文档的 URI。</p><p>创建 Intent 时，除了指定 URI 以外，指定数据类型（其 MIME 类型）往往也很重要。例如，能够显示图像的 Activity 可能无法播放音频文件，即便 URI 格式十分类似时也是如此。因此，指定数据的 MIME 类型有助于 Android 系统找到接收 Intent 的最佳组件。但，有时 MIME 类型可以从 URI 中推断得出，特别当数据是 <code>content:</code> URI 时尤其如此。<code>content:</code> URI 表明数据位于设备中，且由 <code>ContentProvider</code> 控制，这使得数据 MIME 类型对系统可见。</p><p>要仅设置数据 URI，请调用 <code>setData()</code>。要仅设置 MIME 类型，请调用 <code>setType()</code>。如有必要，您可以使用 <code>setDataAndType()</code> 同时显式设置二者。</p><blockquote><p><strong>注意：</strong>若要同时设置 URI 和 MIME 类型，<em>请勿</em>调用 <code>setData()</code> 和 <code>setType()</code>，因为它们会互相抵消彼此的值。请始终使用 <code>setDataAndType()</code> 同时设置 URI 和 MIME 类型。</p></blockquote><p><strong>4.4类别</strong></p><p>一个包含应处理 Intent 组件类型的附加信息的字符串。您可以将任意数量的类别描述放入一个 Intent 中，但大多数 Intent 均不需要类别。以下是一些常见类别：</p><ul><li><p><code>CATEGORY_BROWSABLE</code></p><p>目标 Activity 允许本身通过网络浏览器启动，以显示链接引用的数据，如图像或电子邮件。</p></li><li><p><code>CATEGORY_LAUNCHER</code></p><p>该 Activity 是任务的初始 Activity，在系统的应用启动器中列出。</p></li></ul><p>有关类别的完整列表，请参阅 <code>Intent</code> 类描述。</p><p>您可以使用 <code>addCategory()</code> 指定类别。</p><p><strong>4.5Extra</strong></p><p>携带完成请求操作所需的附加信息的键值对。正如某些操作使用特定类型的数据 URI 一样，有些操作也使用特定的 extra。</p><p>您可以使用各种 <code>putExtra()</code> 方法添加 extra 数据，每种方法均接受两个参数：键名和值。您还可以创建一个包含所有 extra 数据的 <code>Bundle</code> 对象，然后使用 <code>putExtras()</code> 将 <code>Bundle</code> 插入 <code>Intent</code> 中。</p><p>例如，使用 <code>ACTION_SEND</code> 创建用于发送电子邮件的 Intent 时，可以使用 <code>EXTRA_EMAIL</code> 键指定<em>目标</em>收件人，并使用 <code>EXTRA_SUBJECT</code> 键指定<em>主题</em>。</p><p><code>Intent</code> 类将为标准化的数据类型指定多个 <code>EXTRA_*</code> 常量。如需声明自己的 extra 键（对于应用接收的 Intent），请确保将应用的软件包名称作为前缀，如下例所示：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> String EXTRA_GIGAWATTS <span class="token operator">=</span> <span class="token string">"com.example.EXTRA_GIGAWATTS"</span><span class="token punctuation">;</span></code></pre><blockquote><p><strong>注意</strong>：在发送您希望另一个应用接收的 Intent 时，请勿使用 <code>Parcelable</code> 或 <code>Serializable</code> 数据。如果某个应用尝试访问 <code>Bundle</code> 对象中的数据，但没有对打包或序列化类的访问权限，则系统将提出一个 <code>RuntimeException</code>。</p></blockquote><p><strong>4.6标志</strong>FLAG</p><p>​    标志在 <code>Intent</code> 类中定义，充当 Intent 的元数据。标志可以指示 Android 系统如何启动 Activity（例如，Activity 应属于哪个<a href="https://developer.android.google.cn/guide/components/tasks-and-back-stack" target="_blank" rel="noopener">任务</a>），以及启动之后如何处理（例如，Activity 是否属于最近的 Activity 列表）。</p><p>如需了解详细信息，请参阅 <code>setFlags()</code> 方法。</p><h3 id="隐式-Intent-示例"><a href="#隐式-Intent-示例" class="headerlink" title="隐式 Intent 示例"></a>隐式 Intent 示例</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// Create the text message with a string</span>Intent sendIntent <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Intent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>sendIntent<span class="token punctuation">.</span><span class="token function">setAction</span><span class="token punctuation">(</span>Intent<span class="token punctuation">.</span>ACTION_SEND<span class="token punctuation">)</span><span class="token punctuation">;</span>sendIntent<span class="token punctuation">.</span><span class="token function">putExtra</span><span class="token punctuation">(</span>Intent<span class="token punctuation">.</span>EXTRA_TEXT<span class="token punctuation">,</span> textMessage<span class="token punctuation">)</span><span class="token punctuation">;</span>sendIntent<span class="token punctuation">.</span><span class="token function">setType</span><span class="token punctuation">(</span><span class="token string">"text/plain"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Verify that the intent will resolve to an activity</span><span class="token keyword">if</span> <span class="token punctuation">(</span>sendIntent<span class="token punctuation">.</span><span class="token function">resolveActivity</span><span class="token punctuation">(</span><span class="token function">getPackageManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">startActivity</span><span class="token punctuation">(</span>sendIntent<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>调用 <code>startActivity()</code> 时，系统将检查已安装的所有应用，确定哪些应用能够处理这种 Intent（即：含 <code>ACTION_SEND</code> 操作并携带“text/plain”数据的 Intent）。如果只有一个应用能够处理，则该应用将立即打开并为其提供 Intent。如果多个 Activity 接受 Intent，则系统将显示一个对话框（如图 2 所示），使用户能够选取要使用的应用。</p><blockquote><p>intent到底发给哪个activity，需要进行三个匹配，一个是action，一个是category，一个是data。</p><p>理论上来说，如果intent不指定category，那么无论intent filter的内容是什么都应该是匹配的。但是，如果是implicit intent，android默认给加上一个CATEGORY_DEFAULT，这样的话如果intent filter中没有android.intent.category.DEFAULT这个category的话，匹配测试就会失败。所以，如果你的 activity支持接收implicit intent的话就一定要在intent filter中加入android.intent.category.DEFAULT。</p></blockquote><blockquote><p><a href="https://developer.android.google.cn/guide/components/intents-filters#ActionTest" target="_blank" rel="noopener">https://developer.android.google.cn/guide/components/intents-filters#ActionTest</a></p></blockquote><h2 id="5-Intent-解析"><a href="#5-Intent-解析" class="headerlink" title="5.Intent 解析"></a>5.Intent 解析</h2><p>当收到隐式 Intent 以启动 Activity 时，系统会根据以下三个方面将该 Intent 与 Intent 过滤器进行比较，搜索该 Intent 的最佳 Activity：</p><ul><li>操作。</li><li>数据（URI 和数据类型）。</li><li>类别。</li></ul><p>下文根据应用的清单文件中的 Intent 过滤器声明，描述 Intent 如何与相应的组件匹配。</p><h3 id="操作ACTION测试"><a href="#操作ACTION测试" class="headerlink" title="操作ACTION测试"></a>操作ACTION测试</h3><p>要指定接受的 Intent 操作，Intent 过滤器既可以不声明任何 <a href="https://developer.android.google.cn/guide/topics/manifest/action-element" target="_blank" rel="noopener">``</a> 元素，也可以声明多个此类元素，如下例所示：</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>intent-filter</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>action</span> <span class="token attr-name"><span class="token namespace">android:</span>name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>android.intent.action.EDIT<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>action</span> <span class="token attr-name"><span class="token namespace">android:</span>name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>android.intent.action.VIEW<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    ...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>intent-filter</span><span class="token punctuation">></span></span></code></pre><p>要通过此过滤器，您在 <code>Intent</code> 中指定的操作必须与过滤器中列出的某一操作匹配。</p><p>如果该过滤器未列出任何操作，则 Intent 没有任何匹配项，因此所有 Intent 均无法通过测试。但是，如果 <code>Intent</code> 未指定操作，则只要过滤器内包含至少一项操作，就可以通过测试。</p><h3 id="类别测试"><a href="#类别测试" class="headerlink" title="类别测试"></a>类别测试</h3><p>要指定接受的 Intent 类别，Intent 过滤器既可以不声明任何 <a href="https://developer.android.google.cn/guide/topics/manifest/category-element" target="_blank" rel="noopener">``</a> 元素，也可以声明多个此类元素，如下例所示：</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>intent-filter</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>category</span> <span class="token attr-name"><span class="token namespace">android:</span>name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>android.intent.category.DEFAULT<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>category</span> <span class="token attr-name"><span class="token namespace">android:</span>name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>android.intent.category.BROWSABLE<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    ...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>intent-filter</span><span class="token punctuation">></span></span></code></pre><p>若要使 Intent 通过类别测试，则 <code>Intent</code> 中的每个类别均必须与过滤器中的类别匹配。反之则未必然，Intent 过滤器声明的类别可以超出 <code>Intent</code> 中指定的数量，且 <code>Intent</code> 仍会通过测试。因此，不含类别的 Intent 应当始终会通过此测试，无论过滤器中声明何种类别均是如此。</p><p><strong>请注意：</strong>Android 会自动将 <code>CATEGORY_DEFAULT</code> 类别应用于传递给 <code>startActivity()</code> 和 <code>startActivityForResult()</code> 的所有隐式 Intent。如需 Activity 接收隐式 Intent，则必须将 <code>&quot;android.intent.category.DEFAULT&quot;</code> 的类别包括在其 Intent 过滤器中（如上文的 `` 示例所示）。</p><h3 id="数据测试"><a href="#数据测试" class="headerlink" title="数据测试"></a>数据测试</h3><p>要指定接受的 Intent 数据，Intent 过滤器既可以不声明任何 <a href="https://developer.android.google.cn/guide/topics/manifest/data-element" target="_blank" rel="noopener">``</a> 元素，也可以声明多个此类元素，如下例所示：</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>intent-filter</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>data</span> <span class="token attr-name"><span class="token namespace">android:</span>mimeType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>video/mpeg<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">android:</span>scheme</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http<span class="token punctuation">"</span></span> <span class="token attr-name">...</span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>data</span> <span class="token attr-name"><span class="token namespace">android:</span>mimeType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>audio/mpeg<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">android:</span>scheme</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http<span class="token punctuation">"</span></span> <span class="token attr-name">...</span> <span class="token punctuation">/></span></span>    ...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>intent-filter</span><span class="token punctuation">></span></span></code></pre><p>每个 `` 元素均可指定 URI 结构和数据类型（MIME 媒体类型）。URI 的每个部分都是一个单独的属性：<code>scheme</code>、<code>host</code>、<code>port</code> 和 <code>path</code>：</p><pre><code>://:/</code></pre><p>下例所示为这些属性的可能值：</p><pre><code>content://com.example.project:200/folder/subfolder/etc</code></pre><p>在此 URI 中，架构是 <code>content</code>，主机是 <code>com.example.project</code>，端口是 <code>200</code>，路径是 <code>folder/subfolder/etc</code>。</p><p>在 <a href="https://developer.android.google.cn/guide/topics/manifest/data-element" target="_blank" rel="noopener">``</a> 元素中，上述每个属性均为可选，但存在线性依赖关系：</p><ul><li>如果未指定架构，则会忽略主机。</li><li>如果未指定主机，则会忽略端口。</li><li>如果未指定架构和主机，则会忽略路径。</li></ul><p>将 Intent 中的 URI 与过滤器中的 URI 规范进行比较时，它仅与过滤器中包含的部分 URI 进行比较。例如：</p><ul><li>如果过滤器仅指定架构，则具有该架构的所有 URI 均与该过滤器匹配。</li><li>如果过滤器指定架构和权限，但未指定路径，则具有相同架构和权限的所有 URI 都会通过过滤器，无论其路径如何均是如此。</li><li>如果过滤器指定架构、权限和路径，则仅具有相同架构、权限和路径的 URI 才会通过过滤器。</li></ul><p><strong>请注意：</strong>路径规范可以包含星号通配符 (*)，因此仅需部分匹配路径名即可。</p><p>数据测试会将 Intent 中的 URI 和 MIME 类型与过滤器中指定的 URI 和 MIME 类型进行比较。规则如下：</p><ol><li>仅当过滤器未指定任何 URI 或 MIME 类型时，不含 URI 和 MIME 类型的 Intent 才会通过测试。</li><li>对于包含 URI 但不含 MIME 类型（既未显式声明，也无法通过 URI 推断得出）的 Intent，仅当其 URI 与过滤器的 URI 格式匹配、且过滤器同样未指定 MIME 类型时，才会通过测试。</li><li>仅当过滤器列出相同的 MIME 类型且未指定 URI 格式时，包含 MIME 类型但不含 URI 的 Intent 才会通过测试。</li><li>仅当 MIME 类型与过滤器中列出的类型匹配时，同时包含 URI 类型和 MIME 类型（通过显式声明，或可以通过 URI 推断得出）的 Intent 才会通过测试的 MIME 类型部分。如果 Intent 的 URI 与过滤器中的 URI 匹配，或者如果 Intent 具有 <code>content:</code> 或 <code>file:</code> URI 且过滤器未指定 URI，则 Intent 会通过测试的 URI 部分。换言之，如果过滤器<em>只是</em>列出 MIME 类型，则假定组件支持 <code>content:</code> 和 <code>file:</code> 数据。</li></ol><p><strong>请注意：</strong>如果 Intent 指定 URI 或 MIME 类型，则数据测试会在 <code>中没有</code> 元素时失败。</p><p>最后一条规则，即规则 (d)，反映出对组件能够从文件中或内容提供程序处获得本地数据的预期。因此，其过滤器只能列出数据类型，不需要显式命名 <code>content:</code> 和 <code>file:</code> 架构。以下是一个典型示例，说明 <a href="https://developer.android.google.cn/guide/topics/manifest/data-element" target="_blank" rel="noopener">``</a> 元素向 Android 指出，组件可从内容提供程序处获得并显示图像数据：</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>intent-filter</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>data</span> <span class="token attr-name"><span class="token namespace">android:</span>mimeType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>image/*<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    ...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>intent-filter</span><span class="token punctuation">></span></span></code></pre><p>由于大部分可用数据均由内容提供程序分发，因此指定数据类型（而非 URI）的过滤器也许最为常见。</p><p>另一常见的配置是具有架构和数据类型的过滤器。例如，下文中的 <a href="https://developer.android.google.cn/guide/topics/manifest/data-element" target="_blank" rel="noopener">``</a> 元素向 Android 指出，组件可从网络中检索视频数据以执行操作：</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>intent-filter</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>data</span> <span class="token attr-name"><span class="token namespace">android:</span>scheme</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">android:</span>mimeType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>video/*<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    ...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>intent-filter</span><span class="token punctuation">></span></span></code></pre><h3 id="Intent-匹配"><a href="#Intent-匹配" class="headerlink" title="Intent 匹配"></a>Intent 匹配</h3><p>通过 Intent 过滤器匹配 Intent，这不仅有助于发现要激活的目标组件，还有助于发现设备上组件集的相关信息。例如，主页应用通过使用指定 <code>ACTION_MAIN</code> 操作和 <code>CATEGORY_LAUNCHER</code> 类别的 Intent 过滤器查找所有 Activity，以此填充应用启动器。如 <code>IntentFilter</code> 类文档所述，只有当 Intent 中的操作和类别与过滤器匹配时，匹配才会成功。</p><p>您的应用可以使用类似于主页应用的方式使用 Intent 匹配。<code>PackageManager</code> 提供一整套 <code>query...()</code> 方法来返回所有能够接受特定 Intent 的组件。此外，还会提供一系列类似的 <code>resolve...()</code> 方法来确定响应 Intent 的最佳组件。例如，<code>queryIntentActivities()</code> 将返回能够执行作为参数传递的 Intent 中列出的所有 Activity，而 <code>queryIntentServices()</code> 则可返回类似的一系列服务。这两种方法均不会激活组件；而只是列出能够响应的组件。对于广播接收器，有一种类似的方法：<code>queryBroadcastReceivers()</code>。</p><h4 id="实践心得"><a href="#实践心得" class="headerlink" title="实践心得"></a>实践心得</h4><ol><li><p>intent可以打开别的应用的主Activity</p><p>启动别的应用的其他的Activity会报异常SecurityException。主Activity是指设置了</p></li></ol><p>​        <action android:name="android.intent.action.MAIN" />的Activity，</p><ol start="2"><li><p>浏览器列表要这样调用，否则只是用系统浏览器打开</p><p>startActivity(Intent.createChooser(intent,”hi”));</p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/Android/Android基础/序列化机制</title>
      <link href="blog/3061425171.html"/>
      <url>blog/3061425171.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-什么叫序列化，什么叫反序列化"><a href="#1-什么叫序列化，什么叫反序列化" class="headerlink" title="1.什么叫序列化，什么叫反序列化"></a>1.什么叫序列化，什么叫反序列化</h1><p>序列化： 将数据结构或对象转换成二进制串的过程。<br>反序列化：将在序列化过程中所生成的二进制串转换成数据结构或者对象的过程。</p><h1 id="2-Parcel-Parcelable-Bundle-Serializable"><a href="#2-Parcel-Parcelable-Bundle-Serializable" class="headerlink" title="2.Parcel.Parcelable,Bundle,Serializable"></a>2.Parcel.Parcelable,Bundle,Serializable</h1><h2 id="Parcel"><a href="#Parcel" class="headerlink" title="Parcel"></a>Parcel</h2><ul><li><p>可以通过IBinder发送的消息（数据和对象引用）的容器.</p></li><li><p>被设计为高性能IPC传输</p></li><li><p>不适合持久性存储</p></li></ul><p>Pacel包裹不是通用的序列化机制。 此类（以及用于将任意对象放入Parcel的相应的Parcelable API）被设计为高性能IPC传输。 因此，<strong>将任何Parcel数据放置到持久性存储中是不合适的</strong>：对Parcel中任何数据的基础实现的更改可能会使较旧的数据变得不可读。</p><h3 id="Parcelable"><a href="#Parcelable" class="headerlink" title="Parcelable"></a>Parcelable</h3><p>实现了该接口的实例可以从Parcel中写入和恢复</p><h2 id="3-在Activity之间发送数据"><a href="#3-在Activity之间发送数据" class="headerlink" title="3.在Activity之间发送数据"></a>3.在Activity之间发送数据</h2><p>对象推荐使用实现Parcelable，通过Intent和Bundle传递.</p><h2 id="4-在进程之间发送数据"><a href="#4-在进程之间发送数据" class="headerlink" title="4.在进程之间发送数据"></a>4.在进程之间发送数据</h2><p><strong>不建议使用自定义的Parceable.</strong></p><p>Binder 事务缓冲区的大小固定有限，目前为 1MB，由进程中正在处理的所有事务共享。由于此限制是进程级别而不是 Activity 级别的限制，因此这些事务包括应用中的所有 binder 事务，例如 onSaveInstanceState，startActivity 以及与系统的任何互动。超过大小限制时，将引发 TransactionTooLargeException。</p><p>对于 savedInstanceState 的具体情况，应将数据量保持在较小的规模，因为只要用户可以返回到该 Activity，系统进程就需要保留所提供的数据（即使 Activity 的进程已终止）。我们建议您将保存的状态保持在 50k 数据以下。</p><p>5.Parcelable和Serializable的区别</p><ul><li><p>虽然两者都是用于支持序列化、反序列化话操作，但是两者最大的区别在于存储媒介的不同</p><p>Serializable是将序列化后的对象存储在硬盘上，使用I/O读写的方式，而Parcelable是将其存储在内存中，是针对内存的读写，熟悉计算机组成原理的朋友都知道，内存的读写速度显然要远远大于I/O的读写速度，这也是为什么Android中推荐使用Parcelable这种方式来实现对象的序列化。**</p></li><li><p>Serializable 在序列化的时候会产生大量的临时变量，从而引起频繁的 GC。</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/面经/美团面经/美团</title>
      <link href="blog/2820112861.html"/>
      <url>blog/2820112861.html</url>
      
        <content type="html"><![CDATA[<h1 id="美团Android岗一面大概问题！"><a href="#美团Android岗一面大概问题！" class="headerlink" title="美团Android岗一面大概问题！"></a>美团Android岗一面大概问题！</h1><p>2017-09-09</p><p>java的8种数据类型 </p><p>重载和重写的区别 </p><p>抽象类和接口的区别 </p><p>final关键字可以修饰什么，作用什么 </p><p>java 权限的四种不同（public，private，protect，和默认的） </p><p>LinkedHashMap 和 HashMap的区别，还有实现原理 </p><p>编译时异常和运行时期异常区别，分别举个例子 </p><p>Android四大组件（就问了是什么，没具体问） </p><p>handler作用 </p><p>Activity生命周期 和四种启动方式 </p><p>Fragment的生命周期 </p><p>listView优化 </p><p>Android内存泄漏，举个例子</p><p><a href="https://www.nowcoder.com/discuss/39343" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/39343</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/设计模式/设计模式</title>
      <link href="blog/1044424175.html"/>
      <url>blog/1044424175.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、六大原则"><a href="#一、六大原则" class="headerlink" title="一、六大原则"></a>一、六大原则</h2><h2 id="二、创建型"><a href="#二、创建型" class="headerlink" title="二、创建型"></a>二、创建型</h2><p>单例模式有三种：懒汉式单例，饿汉式单例，登记式单例。</p><h3 id="1-懒汉式-synchronized单例"><a href="#1-懒汉式-synchronized单例" class="headerlink" title="1.懒汉式 + synchronized单例"></a>1.懒汉式 + synchronized单例</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> A instance <span class="token operator">=</span> null<span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">static</span> A <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>instance <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>      instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> instance<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>优点：只有在使用到该类时才会被实例化,一定程度节约了资源</p><p>缺点：每次调用都进行同步。 一般不建议使用 。 如果getInstance()的性能对应用程序不是很关键，也可以用。</p><h3 id="2-Double-check-lock"><a href="#2-Double-check-lock" class="headerlink" title="2.Double check lock"></a>2.Double check lock</h3><p>优点：需要时才实例化，又能保证线程安全（+ volatile），且初始化后调用不进行同步锁。</p><h3 id="3-饿汉式"><a href="#3-饿汉式" class="headerlink" title="3.饿汉式"></a>3.饿汉式</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> A instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> A <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">return</span> instance<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>优点：没有加synchronized,效率更高</p><p>缺点：类加载时就初始化，没有节约内存 。没有了延迟加载的好处。</p><h3 id="2-简单工厂"><a href="#2-简单工厂" class="headerlink" title="2.简单工厂"></a>2.简单工厂</h3><p><strong>Intent</strong></p><p>在创建一个对象时不向客户暴露内部细节，并提供一个创建对象的通用接口。</p><p><strong>Class Diagram</strong></p><p>简单工厂把实例化的操作单独放到一个类中，这个类就成为简单工厂类，让简单工厂类来决定应该用哪个具体子类来 实例化。</p><p>这样做能把客户类(类的使用者我们)和具体子类的实现解耦，客户类不再需要知道有哪些子类(多个条件判断)以及应当实例化哪个子类，只有传个参数进去。</p><p>客户类往往有 多个，如果不使用简单工厂，那么所有的客户类都要知道所有子类的细节。而且一旦子类发生改变，例如增加子类， 那么所有的客户类都要进行修改。</p><p><img src=".%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_images/image-20200722114020628.png" alt="image-20200722114020628"></p><h3 id="3-工厂方法（Factory-Method）"><a href="#3-工厂方法（Factory-Method）" class="headerlink" title="3. 工厂方法（Factory Method）"></a>3. 工厂方法（Factory Method）</h3><p><strong>Intent</strong></p><p>定义了一个创建对象的接口，但由子类决定要实例化哪个类。工厂方法把实例化操作推迟到子类。</p><p> Class Diagram </p><p>在简单工厂中（只有1个工厂），创建对象的是一个类，而在<strong>工厂方法中，是由子类来创建对象</strong>。 下图中，Factory 有一个 doSomething() 方法，这个方法需要用到一个产品对象，这个产品对象由 factoryMethod() 方法创建。该方法是抽象的，需要由子类去实现。</p><ul><li>简单工厂只有一个工厂来生产不同产品，工厂方法有个抽象工厂类，由不同的工厂生产不同的产品。</li></ul><p><img src=".%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_images/image-20200722114536772.png" alt="image-20200722114536772"></p><ol start="4"><li><h3 id="抽象工厂（Abstract-Factory）"><a href="#抽象工厂（Abstract-Factory）" class="headerlink" title="抽象工厂（Abstract Factory）"></a>抽象工厂（Abstract Factory）</h3></li></ol><p>Intent</p><p>提供一个接口，用于创建 相关的对象家族 。 </p><p>Class Diagram </p><p>抽象工厂模式创建的是对象家族，也就是很多对象而不是一个对象，并且这些对象是相关的，也就是说必须一起创建 出来。而工厂方法模式只是用于创建一个对象，这和抽象工厂模式有很大不同。</p><p> 抽象工厂模式用到了工厂方法模式来创建单一对象，AbstractFactory 中的 createProductA() 和 createProductB() 方 法都是让子类来实现，这两个方法单独来看就是在创建一个对象，这符合工厂方法模式的定义。 至于创建对象的家族这一概念是在 Client 体现，Client 要通过 AbstractFactory 同时调用两个方法来创建出两个对 象，在这里这两个对象就有很大的相关性，Client 需要同时创建出这两个对象。</p><p> 从高层次来看，抽象工厂使用了组合，即 Cilent 组合了 AbstractFactory，而工厂方法模式使用了继承。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/Android/UI/Untitled</title>
      <link href="blog/2070360560.html"/>
      <url>blog/2070360560.html</url>
      
        <content type="html"><![CDATA[<p>复选框</p><p>RadioGroup和RadioButton</p><p>计算孩子的规格时，padding是自己的属性，margin是孩子布局参数中的属性</p><pre><code>@padding  是父view的左右padding + 孩子的左右margin（计算宽度规格时）public static int getChildMeasureSpec(int spec, int padding  , int childDimension) {..}</code></pre><p>padding</p><p>width:</p><p>​    size:屏幕宽度</p><p>​    mode:EXACTLY</p><p>height:</p><p>​    size:屏幕高度</p><p>​    mode:EXACTLY</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/Android/Android基础/Fragment</title>
      <link href="blog/3424522753.html"/>
      <url>blog/3424522753.html</url>
      
        <content type="html"><![CDATA[<h1 id="Fragment"><a href="#Fragment" class="headerlink" title="Fragment"></a>Fragment</h1><h2 id="1-什么是Fragment"><a href="#1-什么是Fragment" class="headerlink" title="1.什么是Fragment"></a>1.什么是Fragment</h2><p>他就是为了解决不同屏幕不同大小，UI重用的一个部件，他将1个activity拆分成不同小的单元，在小的单元里面定义自己的UI，最后把他们组合一起 和包含他们的activity一起共同工作</p><p>为了更好地布局以及重用一些代码。</p><p>大多数情况有UI， 可以给<code>activity</code>提供没有UI的提供后台行为<code>Fragment</code>。</p><h4 id="1-2有点"><a href="#1-2有点" class="headerlink" title="1.2有点"></a>1.2有点</h4><p>模块化（Modularity）：我们不必把所有代码全部写在Activity中，而是把代码写在各自的Fragment中。</p><p>可重用（Reusability）：多个Activity可以重用一个Fragment。</p><h2 id="2-创建Fragment的方式："><a href="#2-创建Fragment的方式：" class="headerlink" title="2.创建Fragment的方式："></a>2.创建<code>Fragment</code>的方式：</h2><h3 id="1-静态-XML方式"><a href="#1-静态-XML方式" class="headerlink" title="1.静态 XML方式"></a>1.静态 <code>XML</code>方式</h3><p>①activity的布局xml中 添加fragment标签，并指定<code>name</code>属性为你创建的<code>Fragment</code>的子类</p><p>②在创建的<code>Fragment</code>中的重写<code>onCreatView</code>方法，返回一个从为<code>Fragment</code>写的布局<code>xml</code>中加载的<code>View</code></p><h3 id="2-动态：在代码中添加-更常用"><a href="#2-动态：在代码中添加-更常用" class="headerlink" title="2.动态：在代码中添加(更常用)"></a>2.动态：在代码中添加(更常用)</h3><p>①activity的布局xml中 添加Fragment的占位标签，比如用FrameLayout</p><p>②获取<code>FragmentManager</code> ,开启事务，添加你的Fragment到第一步写的占位布局中，提交事务</p><h2 id="3-Fragment的删除和替换"><a href="#3-Fragment的删除和替换" class="headerlink" title="3.Fragment的删除和替换"></a>3.<code>Fragment</code>的删除和替换</h2><p><code>FragmentTransaction</code> 的<code>remove</code>(<code>Fragment</code> <code>f</code>) 和<code>replace``(int resId,Fragment f)</code>方面</p><p>加入返回栈<code>addToBackStack</code>(null)</p><p><code>Fragment</code>被替换后调用<code>addToBackStack</code>(null)，按返回键，可以返回到前1个Fragment</p><h2 id="4-Fragment的生命周期"><a href="#4-Fragment的生命周期" class="headerlink" title="4.Fragment的生命周期"></a>4.Fragment的生命周期</h2><p><img src=".Fragment_images/image-20200508131501701.png" alt="image-20200508131501701"></p><pre><code>onAttach()</code></pre><p>在片段已与 Activity 关联时进行调用（<code>Activity</code> 传递到此方法内）。</p><pre><code>onCreateView()</code></pre><p>调用它可创建与片段关联的视图层次结构。</p><pre><code>onActivityCreated()</code></pre><p>当 Activity 的 <code>onCreate()</code> 方法已返回时进行调用。</p><pre><code>onDestroyView()</code></pre><p>在移除与片段关联的视图层次结构时进行调用。</p><pre><code>onDetach()</code></pre><p>在取消片段与 Activity 的关联时进行调用。</p><p>Fragment 的生命周期和 Activity 很相似，只是多了一下几个方法：<br><strong>onAttach()</strong> 在Fragment 和 Activity 建立关联是调用（Activity 传递到此方法内）<br><strong>onCreateView()</strong> 当Fragment 创建视图时调用<br><strong>onActivityCreated()</strong> 在相关联的 Activity 的 onCreate() 方法已返回时调用。<br><strong>onDestroyView()</strong> 当Fragment中的视图被移除时调用<br><strong>onDetach()</strong> 当Fragment 和 Activity 取消关联时调用。</p><p>可以看下几种操作情况下Fragment 的生命周期变化</p><p><img src=".Fragment_images/image-20200509143844383.png" alt="image-20200509143844383"></p><h2 id="5-系统内置的Fragment子类"><a href="#5-系统内置的Fragment子类" class="headerlink" title="5.系统内置的Fragment子类"></a>5.系统内置的Fragment子类</h2><h3 id="5-1DialogFragment"><a href="#5-1DialogFragment" class="headerlink" title="5.1DialogFragment"></a>5.1<code>DialogFragment</code></h3><p>1.继承<code>DialogFragment</code>，重写<code>onCreatDialog</code>返回一个<code>Dialog</code>对象</p><p>2.<code>Activity</code>种创建<code>DialogFrament</code>的子类对象，调用show()</p><p>3.演示了<code>AlertDialog</code>,设置日期和设置时间的<code>Dialog</code></p><h3 id="5-2ListFragment-封装了一个1个ListView"><a href="#5-2ListFragment-封装了一个1个ListView" class="headerlink" title="5.2ListFragment(封装了一个1个ListView)"></a>5.2<code>ListFragment</code>(封装了一个1个<code>ListView</code>)</h3><p><img src=".Fragment_images/image-20200508115949879.png" alt="image-20200508115949879"></p><h3 id="5-3PreferenceFragment-设置"><a href="#5-3PreferenceFragment-设置" class="headerlink" title="5.3PreferenceFragment(设置)"></a>5.3<code>PreferenceFragment</code>(设置)</h3><h2 id="6-Fragment之间的通信"><a href="#6-Fragment之间的通信" class="headerlink" title="6.Fragment之间的通信"></a>6.<code>Fragment</code>之间的通信</h2><p>fragment中要更新<code>activity</code>的Ui,通过<code>getActivity</code>().<code>findViewById</code>是不是最佳的方法？</p><p><img src=".Fragment_images/image-20200508105124412.png" alt="image-20200508105124412"></p><h3 id="1-Activity访问所属的Fragment的控件，成员变量"><a href="#1-Activity访问所属的Fragment的控件，成员变量" class="headerlink" title="1.Activity访问所属的Fragment的控件，成员变量"></a>1.Activity访问所属的Fragment的控件，成员变量</h3><p>①拿到<code>Fragment</code>对象：</p><p>​    静态的<code>Fragment</code>:<code>getFragmentManager</code>().<code>findFragmentBy</code>..()</p><p>​    动态的<code>Fragment</code>: 直接用在<code>activity</code>创建的Fragment的对象的引用</p><p>②拿到<code>Fragment</code>的根View后找子View：fragment.getView().findViewByid(..)</p><h3 id="2-Fragment中访问Activity的控件"><a href="#2-Fragment中访问Activity的控件" class="headerlink" title="2.Fragment中访问Activity的控件"></a>2.Fragment中访问Activity的控件</h3><ul><li>重写<code>onActivityCreated</code>()方法，在这里通过<code>getActivity().findViewById</code>获得并更新Activity的UI控件对象</li></ul><h3 id="3-Fragment与Fragment"><a href="#3-Fragment与Fragment" class="headerlink" title="3.Fragment与Fragment"></a>3.Fragment与Fragment</h3><h3 id="4-Fragment与Activity之间（或其他Fragment）的通信最佳方式"><a href="#4-Fragment与Activity之间（或其他Fragment）的通信最佳方式" class="headerlink" title="4.Fragment与Activity之间（或其他Fragment）的通信最佳方式:"></a>4.Fragment与Activity之间（或其他Fragment）的通信最佳方式:</h3><ul><li>不通过接口的直接在fragment中更新activity的控件这种方式和具体Actvitiy绑定较紧，高耦合，换1个activity就不能用了</li><li>在发起事件的Fragment中定义interface接口,并在onAttach()方法中初始化该接口的引用变量，让其附着的Activity实现这个接口</li></ul><h2 id="7-android-app-Fragment-和support-v4-Fragment的区别"><a href="#7-android-app-Fragment-和support-v4-Fragment的区别" class="headerlink" title="7.android.app.Fragment 和support.v4.Fragment的区别"></a>7.android.app.Fragment 和support.v4.Fragment的区别<img src=".Fragment_images/image-20200508120505608.png" alt="image-20200508120505608"></h2><h2 id="Fragment用法"><a href="#Fragment用法" class="headerlink" title="Fragment用法"></a>Fragment用法</h2><p>1.静态</p><p>2.动态</p><p>3.结合viewpager</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/面试题精编</title>
      <link href="blog/1027335175.html"/>
      <url>blog/1027335175.html</url>
      
        <content type="html"><![CDATA[<h1 id="第一章：Android-基础"><a href="#第一章：Android-基础" class="headerlink" title="第一章：Android 基础"></a>第一章：Android 基础</h1><h2 id="一、-Activity-更新-2019-5-5"><a href="#一、-Activity-更新-2019-5-5" class="headerlink" title="一、 Activity(更新 2019.5.5)"></a>一、 Activity(更新 2019.5.5)</h2><h3 id="1、什么是-Activity以及Activity的生命周期"><a href="#1、什么是-Activity以及Activity的生命周期" class="headerlink" title="1、什么是 Activity以及Activity的生命周期?"></a>1、什么是 Activity以及Activity的生命周期?</h3><p>四大组件之一,一般的,一个用户交互界面对应一个 activity setContentView() ,// 要显示的布局 button.setOnclickLinstener{ }, activity 是 Context 的子类,同时实现了 window.callback 和 keyevent.callback, 可以处理与窗体用户交互的事件. </p><ul><li><h3 id="onCreate"><a href="#onCreate" class="headerlink" title="onCreate()"></a>onCreate()</h3></li></ul><p>系统第一次创建该Activity实例时会回调该方法。该方法一般承担着一些初始化工作，比如调用setContentView去加载界面布局，初始化Activity所需的数据并绑定到对应的View上。</p><ul><li><h3 id="onRestart"><a href="#onRestart" class="headerlink" title="onRestart()"></a>onRestart()</h3></li></ul><p>Activity从onStop状态，将要重新进入前台（由不可见到可见）。</p><ul><li><h3 id="onStart"><a href="#onStart" class="headerlink" title="onStart()"></a>onStart()</h3></li></ul><p>Activity正在启动，已经时可见的了，但还没到前台，无法和用户交互。</p><ul><li><h3 id="onResume"><a href="#onResume" class="headerlink" title="onResume()"></a>onResume()</h3></li></ul><p>Activity获得焦点或者即将获得焦点.。</p><ul><li><h3 id="onPause"><a href="#onPause" class="headerlink" title="onPause()"></a>onPause()</h3></li></ul><p>Activity离开前台，不能与用户交互。这也是Activity接收到用户要离开该Activity指令时所回调的第一个方法。比如：</p><ol><li>有电话打进来</li><li>手机息屏</li><li>进入其他的Activity</li><li>打开一个新的半透明的Activity</li><li>在Android 7.0之后的multi-window模式下，失去焦点的Activity会调用onPause</li></ol><p>onPause适合做轻量级的回收工作，比如停止动画等，而不适合进行太耗时的操作，因为旧的onPause执行完后，新的Activity的onResume才会执行。</p><p>执行完onPause后并不意味着activity就离开了Paused 状态了，因为此时旧的activity仍然可见且新的activity还未进入resume状态。如果activity变得完全不可见了，回调onStop。</p><ul><li><h3 id="onStop"><a href="#onStop" class="headerlink" title="onStop()"></a>onStop()</h3></li></ul><p>Activity即将停止，不再可见。</p><p>onStop适合做稍微重量级的回收工作，比如释放导致内存泄漏的资源，保存数据到数据库中。</p><p>有时候由于高优先级的应用需要内存，系统不足以分配，就把拥有该Activity的进程杀死来释放内存，这样就不会调用onDestory。(It is possible for the system to kill the process hosting your activity without calling the activity’s final <code>onDestroy()</code> callback.)</p><ul><li><h3 id="onDestroy"><a href="#onDestroy" class="headerlink" title="onDestroy()"></a>onDestroy()</h3></li></ul><p>Activity即将被销毁，Activity生命周期中最后一个回调，适合做最终的资源释放与回收工作。</p><p>有两种情况下，系统回调此方法。一是Activity的finish()被调用，二是系统为了节约内存而把activity所在的进程杀死(the system is temporarily destroying the process containing the activity to save space)。这两种方式可以用 <code>isFinishing()</code> 来区分，前者 <code>isFinishing()</code> 返回true。</p><p><strong>小结</strong></p><p>onCreate与onDestroy是一对回调，标志一个Activity的诞生与消亡；</p><p>onStart与onStop是一对回调，标志一个Activity是否可见；</p><p>onResume与onPause是一对回调，标志一个Activity是否能与用户交互，是位于前台还是后台。</p><h3 id="4、如何保存-Activity-的状态或者-Activiy-重启怎么保存数据？）"><a href="#4、如何保存-Activity-的状态或者-Activiy-重启怎么保存数据？）" class="headerlink" title="4、如何保存 Activity 的状态或者(Activiy 重启怎么保存数据？）"></a>4、如何保存 Activity 的状态或者(Activiy 重启怎么保存数据？）</h3><ol><li>配置变更：横竖屏切换或者切换到多窗口模式(系统默认会销毁Activity并重建。)。用户期望界面状态在配置变更时保持不变。</li></ol><ul><li><p>异常情况下发生配置变更或者内存不够时而销毁Activity</p><p>实际的 <a href="https://developer.android.google.cn/reference/android/app/Activity" target="_blank" rel="noopener"><code>Activity</code></a> 实例已消失，但系统会记住它曾经存在过。如果用户尝试回退到该 Activity，则系统将使用之前通过bundle对象中的键值对保存的 Activity 销毁时的状态来新建该 Activity 的实例。但是，可能需要保存更多的状态信息，比如成员变量系统不会帮你保存，系统会帮你保存有id的控件的状态，保存edittext中的内容.</p></li><li><p>正常情况下（按了返回键）</p><p>  系统会销毁Activity,也是用户期望的，不需要有额外的工作</p></li></ul><ol start="2"><li><p>使用 <code>onSaveInstanceState()</code> 保存<strong>简单轻量的界面状态</strong></p><ul><li><code>onSaveInstanceState()</code> 不一定会调用，正常退出或者显示调用finish()时不会调用</li><li>异常情况下，onSaveInstanceState() 会在onPause()后调用</li><li>适合保存activity的成员变量,listview的滚动位置，edittext中的文本</li></ul></li><li><p><a href="https://developer.android.google.cn/reference/android/app/Activity#onRestoreInstanceState(android.os.Bundle)" target="_blank" rel="noopener"><code>onRestoreInstanceState()</code></a> 会在onStart()后调用</p></li><li><p>onCreate中的Bundle参数</p><ul><li>如果activity是新建的则他为Null,所以要进行非空判断</li></ul></li><li><p>持久化数据(sp或数据库),应在activity处于前台时或者onStop方法保存.</p></li></ol><h3 id="5、-两个-Activity-之间跳转时必然会执行的是哪几个方-法？"><a href="#5、-两个-Activity-之间跳转时必然会执行的是哪几个方-法？" class="headerlink" title="5、 两个 Activity 之间跳转时必然会执行的是哪几个方 法？"></a>5、 两个 Activity 之间跳转时必然会执行的是哪几个方 法？</h3><p>一般情况下比如说有两个activity,分别叫A,B,当在A里面激活B 组件的时候, A 会调用 onPause()方法,然后 B 调用 onCreate() ,onStart(), onResume()。</p><p>这个时候 B 覆盖了窗体, A 会调用 onStop()方法. 如果 B 是个透明的,或者 是对话框的样式, 就不会调用 A 的 onStop()方法。</p><h3 id="6、-横竖屏切换时-Activity-的生命周期（★★★★）"><a href="#6、-横竖屏切换时-Activity-的生命周期（★★★★）" class="headerlink" title="6、 横竖屏切换时 Activity 的生命周期（★★★★）"></a>6、 横竖屏切换时 Activity 的生命周期（★★★★）</h3><p>此时的生命周期跟清单文件里的配置有关系。 </p><ol><li><p>不设置 Activity 的 android:configChanges 时，切屏会重新调用各个生 命周期默认首先销毁当前 activity,然后重新加载。 </p></li><li><p>设置 Activity android:configChanges=”orientation|keyboardHidden|screenSize”时，切屏不会重新调用各个生命周期，而是会执行 onConfigurationChanged 方法。 </p></li><li><p>设置android:screenOrientation=“portrait”强制竖屏，此时旋转不会切换</p></li></ol><h3 id="7、-如何将一个-Activity-设置成窗口（对话框）的样式"><a href="#7、-如何将一个-Activity-设置成窗口（对话框）的样式" class="headerlink" title="7、 如何将一个 Activity 设置成窗口（对话框）的样式"></a>7、 如何将一个 Activity 设置成窗口（对话框）的样式</h3><p>只需要给我们的 Activity 配置如下属性即可。 android:theme=”@android:style/Theme.Dialog”</p><h3 id="8、-如何退-出-Activity？-如何-安-全退-出-已调-用-多个-Activity-的-Application？（★★★★）"><a href="#8、-如何退-出-Activity？-如何-安-全退-出-已调-用-多个-Activity-的-Application？（★★★★）" class="headerlink" title="8、 如何退 出 Activity？ 如何 安 全退 出 已调 用 多个 Activity 的 Application？（★★★★）"></a>8、 如何退 出 Activity？ 如何 安 全退 出 已调 用 多个 Activity 的 Application？（★★★★）</h3><ol><li><p>通常情况用户退出一个 Activity 只需按返回键，我们写代码想退出 activity 直接调用 finish()方法就行。 </p></li><li><p>记录打开的 Activity： 每打开一个 Activity，就记录下来。在需要退出时，关闭每一个 Activity 即可。</p></li></ol><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//伪代码 </span>List<span class="token operator">&lt;</span>Activity<span class="token operator">></span> lists <span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 在 application 全局的变量里面 </span>lists <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Activity<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> lists<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">for</span><span class="token punctuation">(</span>Activity activity<span class="token operator">:</span> lists<span class="token punctuation">)</span> <span class="token punctuation">{</span>     activity<span class="token punctuation">.</span><span class="token function">finish</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> lists<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ol start="3"><li>发送特定广播： 在需要结束应用时，发送一个特定的广播，每个 Activity 收到广播后，关闭 即可。</li></ol><pre class=" language-java"><code class="language-java"> <span class="token comment" spellcheck="true">//给某个 activity 注册接受接受广播的意图</span><span class="token function">registerReceiver</span><span class="token punctuation">(</span>receiver<span class="token punctuation">,</span> filter<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//如果过接受到的是 关闭 activity 的广播 activity finish()掉</span></code></pre><p> 4、递归退出</p><p>就调用 finish()方法 把当前的</p><p>在打开新的 Activity 时使用 startActivityForResult，然后自己加标志，在 onActivityResult 中处理，递归关闭。 5、其实 也可以通过 intent 的 flag 来实现 intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP)激活一个新的 activity。 此时如果该任务栈中已经有该 Activity，那么系统会把这个 Activity 上面的所有 Activity 干掉。其实相当于给 Activity 配置的启动模式为 SingleTop。</p><h3 id="9、-Activity-的-四-种-启-动-模-式-，-singleTop-和-singletask-区别是什么？一般书签的使用模式是-singleTop，那为什么不使用-singleTask"><a href="#9、-Activity-的-四-种-启-动-模-式-，-singleTop-和-singletask-区别是什么？一般书签的使用模式是-singleTop，那为什么不使用-singleTask" class="headerlink" title="9、 Activity 的 四 种 启 动 模 式 ， singleTop 和 singletask 区别是什么？一般书签的使用模式是 singleTop，那为什么不使用 singleTask?"></a>9、 Activity 的 四 种 启 动 模 式 ， singleTop 和 singletask 区别是什么？一般书签的使用模式是 singleTop，那为什么不使用 singleTask?</h3><p>任务是用户在执行某项工作时与之互动的一系列 Activity 的集合。这些 Activity 按照每个 Activity 打开的顺序排列在一个返回堆栈中。</p><ul><li><p>singleInsance:这种模式的activity会新开并独占一个task,  由该 Activity 启动的任何 Activity 都会在其他的任务中打开. 呼叫来电界面</p></li><li><p>singleTop:栈顶只能有1个，但栈内可以有多个。比如搜索activity，二维码扫描</p><ul><li>栈中已有该Activity的实例并且该实例位于栈顶时<strong>,启动他时，会复用，并将Intent对象传入，回调onNewIntent()方法；</strong></li><li>2、新闻详情页面。<br>假设主界面为 MainActivity，显示新闻的界面是 DetailActivity，显然显示任何一条新闻都会使用 DetailActivity，即把新闻内容通过 Intent 传给 DetailActivity 就可以了。 假设你正在看新闻1(即在 DetailActivity)，此时手机收到服务器的推送：收到一条通知(新闻2)，点击通知就会跳转到 DetailActivity 并显示新闻2，当你点击通知时，因为目前栈顶的 Activity 就是 DetailActivity，因此这里就是使用 SingleTop 的地方，即点击通知后以 SingleTop 加载模式打开 DetailActivity 并显示新闻2，因此新闻1的 DetailActivity 就被覆盖掉了。 此后你点击返回键会回到主界面。</li></ul></li><li><p>singleTask:</p><ul><li><p>task中只能有1个，启动他时，他上面的activity会全部清除。</p></li><li><p>设置了<code>singleTask</code>启动模式的<code>Activity</code>，它在启动的时候，会先在系统中查找属性值<code>affinity</code>等于它的属性值<code>taskAffinity</code>的任务存在；如果存在这样的任务，它就会在这个任务中启动，否则就会在新任务中启动。因此，如果我们想要设置了<code>singleTask</code>启动模式的<code>Activity</code>在新的任务中启动，就要为它设置一个独立的<code>taskAffinity</code>属性值。如果设置了<code>singleTask</code>启动模式的Activity不是在新的任务中启动时，它会在已有的任务中查看是否已经存在相应的<code>Activity</code>实例，如果存在，就会把位于这个<code>Activity</code>实例上面的Activity全部结束掉，即最终这个Activity实例会位于任务的堆栈顶端中。</p></li></ul></li></ul><pre><code>但是，如果另外的任务中已存在该 Activity 的实例，则系统会通过调用其 `onNewIntent()` 方法将 intent 转送到该现有实例，而不是创建新实例。Activity 一次只能有一个实例存在。比如应用的主界面</code></pre><ul><li>比如浏览器应用，览器 Activity 应始终在它自己的任务中打开。这意味着，如果您的应用发出打开 Android 浏览器的 intent，系统不会将其 Activity 置于您的应用所在的任务中，而是会为浏览器启动一个新任务，如果浏览器已经有任务在后台运行，则会将该任务转到前台来处理新 intent。</li></ul><ul><li>standard:调用startActivity都会创建实例</li></ul><p>默认情况下，新 Activity 会启动到调用 <code>startActivity()</code> 的 Activity 的任务中。它会被推送到调用方 Activity 所在的返回堆栈中。</p><h6 id="taskAffinity-属性-默认不设置为应用的报名，设置了非本应用的包名后，且是singleTask的情况下，会添加到该名称的task"><a href="#taskAffinity-属性-默认不设置为应用的报名，设置了非本应用的包名后，且是singleTask的情况下，会添加到该名称的task" class="headerlink" title="taskAffinity 属性 : 默认不设置为应用的报名，设置了非本应用的包名后，且是singleTask的情况下，会添加到该名称的task"></a>taskAffinity 属性 : 默认不设置为应用的报名，设置了非本应用的包名后，且是singleTask的情况下，会添加到该名称的task</h6><h3 id="10、Android-中的-Context-Activity，Appliction-有-什么区别？（★★）"><a href="#10、Android-中的-Context-Activity，Appliction-有-什么区别？（★★）" class="headerlink" title="10、Android 中的 Context, Activity，Appliction 有 什么区别？（★★）"></a>10、Android 中的 Context, Activity，Appliction 有 什么区别？（★★）</h3><ul><li><p>相同：Activity 和 Application 都是 Context 的子类。 Context 从字面上理解就是上下文的意思，在实际应用中它也确实是起到了管理 上下文环境中各个参数和变量的作用，方便我们可以简单的访问到各种资源。 </p></li><li><p>不同：维护的生命周期不同。 Context 维护的是当前的 Activity 的生命周期， Application 维护的是整个应用的生命周期。 使用 context 的时候，小心内存泄露，防止内存泄露，注意一下几个方面：</p></li></ul><ol><li><p>不要让生命周期长的对象引用 activity context，即保证引用 activity 的对象 要与 activity 本身生命周期是一样的。</p></li><li><p>对于生命周期长的对象，可以使用 application，context。</p></li><li><p>避免非静态的内部类，尽量使用静态类，避免生命周期问题，注意内部类对 外部对象引用导致的生命周期变化。</p></li></ol><h3 id="11、两个-Activity-之间传递数据，除了-intent，广播接-收者，content-provider-还有啥？"><a href="#11、两个-Activity-之间传递数据，除了-intent，广播接-收者，content-provider-还有啥？" class="headerlink" title="11、两个 Activity 之间传递数据，除了 intent，广播接 收者，content provider 还有啥？"></a>11、两个 Activity 之间传递数据，除了 intent，广播接 收者，content provider 还有啥？</h3><p>​    1）利用 static 静态数据，public static 成员变量 </p><p>​    2）利用外部存储的传输， 例如 File 文件存储</p><p>​    3)   SharedPreferences 首选项 Sqlite 数据库</p><h3 id="12、Context-是-什-么-？-一-个-应-用-有-多-少-个-Context-2019-5-5）（★★）"><a href="#12、Context-是-什-么-？-一-个-应-用-有-多-少-个-Context-2019-5-5）（★★）" class="headerlink" title="12、Context 是 什 么 ？ 一 个 应 用 有 多 少 个 Context(2019.5.5）（★★）"></a>12、Context 是 什 么 ？ 一 个 应 用 有 多 少 个 Context(2019.5.5）（★★）</h3><p>1、它描述的是一个应用程序环境的信息，即上下文。 </p><p>2、该类是一个抽象(abstract class)类，Android 提供了该抽象类的具体实 现类（ContextIml）。 </p><p>3、通过它我们可以获取应用程序的资源和类，也包括一些应用级别操作， 例如：启动一个 Activity，发送广播，接受 Intent，信息，等。</p><p> 4、一个应用 Context 数量 = Activity 个数+service 个数+1 个</p><h3 id="13-activity-之间还有-activity-和-service-之间如何传值，可以传图片吗？-2019-5-5）（上海）"><a href="#13-activity-之间还有-activity-和-service-之间如何传值，可以传图片吗？-2019-5-5）（上海）" class="headerlink" title="13.activity 之间还有 activity 和 service 之间如何传值，可以传图片吗？ (2019.5.5）（上海）"></a>13.activity 之间还有 activity 和 service 之间如何传值，可以传图片吗？ (2019.5.5）（上海）</h3><h4 id="Activity-之间的传值："><a href="#Activity-之间的传值：" class="headerlink" title="Activity 之间的传值："></a>Activity 之间的传值：</h4><p>​    startActivity，通过 Intent 对象的各种 putExtra 方法来 进行传递。在第二个 Activity 对象中，可以通过 getIntent() 方法来得到跳转 到这个 Activity 的 Intent 对象，然后通过 Intent 对象的各种 getXXExtra 方 法来得到我们的传过来的值。 </p><h4 id="Activity-和-Service-之间传值："><a href="#Activity-和-Service-之间传值：" class="headerlink" title="Activity 和 Service 之间传值："></a>Activity 和 Service 之间传值：</h4><p>​    1、service 可以从 <code>public int onStartCommand(Intent intent, int flags, int startId)</code>中取出从 activity 中传过来的值。intent.getExtra()获得 bundle 对象， 可从中取值。 </p><p>​    2、activity 也可以用 <code>bindService(intent, conn,BIND_AUTO_CREATE)</code>传 值，把要传的值绑定在 intent 里，在 service 的 <code>public IBinder onBind(Intent intent)</code> 方法里取得 intent。 </p><p>​    3、同时也可以在 reseiver 里面注册一个广播，在 activity 里 <code>sendbroadcast(intent)</code>传值。 可以传递图片，用 Intent 把图片的地址或者把图片对象用 Intent 传过去， 用 bitmap 对象。</p><h3 id="14-startActivityForResult-和-onActivityResult"><a href="#14-startActivityForResult-和-onActivityResult" class="headerlink" title="14. startActivityForResult() 和 onActivityResult()"></a>14. startActivityForResult() 和 onActivityResult()</h3><p>​    用于activity之间回传值</p><pre class=" language-java"><code class="language-java"><span class="token function">onActivityResult</span><span class="token punctuation">(</span><span class="token keyword">int</span> requestCode<span class="token punctuation">,</span> <span class="token keyword">int</span> resultCode<span class="token punctuation">,</span> Intent data<span class="token punctuation">)</span>    resultCode<span class="token operator">:</span>用于判断是否成功    requestCode<span class="token operator">:</span>用于判断是哪个activity</code></pre><h2 id="二、-Service"><a href="#二、-Service" class="headerlink" title="二、 Service"></a>二、 Service</h2><h3 id="0-什么是服务？"><a href="#0-什么是服务？" class="headerlink" title="0.什么是服务？"></a>0.什么是服务？</h3><p><code>Service</code> 是一种可在后台执行长时间运行操作而不提供界面的应用组件。服务可由其他应用组件启动，而且即使用户切换到其他应用，服务仍将在后台继续运行。此外，组件可通过绑定到服务与之进行交互，甚至是执行进程间通信 (IPC)。例如，服务可在后台处理网络事务、播放音乐，执行文件 I/O 或与内容提供程序进行交互。</p><h3 id="1-Service-是否在-main-thread-中执行-service-里面是否能执-行耗时的操作-（★★）"><a href="#1-Service-是否在-main-thread-中执行-service-里面是否能执-行耗时的操作-（★★）" class="headerlink" title="1.Service 是否在 main thread 中执行, service 里面是否能执 行耗时的操作?（★★）"></a>1.Service 是否在 main thread 中执行, service 里面是否能执 行耗时的操作?（★★）</h3><p>服务在其托管进程的主线程中运行，它既<strong>不</strong>创建自己的线程，也<strong>不</strong>在单独的进程中运行（除非另行指定）。如果服务将执行任何 CPU 密集型工作或阻止性/耗时操作（例如 MP3 播放或联网），则应通过在服务内创建新线程来完成这项工作。通过使用单独的线程，您可以降低发生“应用无响应”(ANR) 错误的风险，而应用的主线程仍可继续专注于运行用户与 Activity 之间的交互。</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>service</span> <span class="token attr-name"><span class="token namespace">android:</span>name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.baidu.location.f<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">android:</span>enabled</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span>          <span class="token attr-name"><span class="token namespace">android:</span>process</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>:player<span class="token punctuation">"</span></span> <span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>service</span><span class="token punctuation">></span></span></code></pre><h3 id="2-Activity-怎么和-Service-绑定，怎么在-Activity-中启动自己-对应的-Service？"><a href="#2-Activity-怎么和-Service-绑定，怎么在-Activity-中启动自己-对应的-Service？" class="headerlink" title="2.Activity 怎么和 Service 绑定，怎么在 Activity 中启动自己 对应的 Service？"></a>2.Activity 怎么和 Service 绑定，怎么在 Activity 中启动自己 对应的 Service？</h3><p>Activity 通过 <code>bindService(Intent service, ServiceConnection conn, int flags)</code>跟 Service 进行绑定，当绑定成功的时候 Service 会将代理对象通过回调的形式传给 conn，这样我们就拿到了 Service 提供的服务代理对象。</p><p>在 Activity 中可以通过 startService 和 bindService 方法启动 Service。一 般情况下如果想获取 Service 的服务对象那么肯定需要通过 bindService（）方 法，比如音乐播放器，第三方支付等。如果仅仅只是为了开启一个后台任务那么 可以使用 startService（）方法。</p><h3 id="3-请描述一下-Service-的生命周期（★★★）"><a href="#3-请描述一下-Service-的生命周期（★★★）" class="headerlink" title="3.请描述一下 Service 的生命周期（★★★）"></a>3.请描述一下 Service 的生命周期（★★★）</h3><p>Service 有绑定模式和非绑定模式，以及这两种模式的混合使用方式。不同 的使用方法生命周期方法也不同。</p><p>非 绑 定 模 式 ： 当 第 一 次 调 用 startService 的 时 候 执 行 的 方 法 依 次 为 onCreate()、</p><p>​                            onStartCommand()，当 Service 关闭的时候调用 onDestory 方 法。</p><p>绑定模式：第一次 bindService（）的时候， 执行的方法为 onCreate()、 onBind(）;</p><p>​                    解除绑定的时候会执行 onUnbind()、onDestory()。</p><p>上面的两种生命周期是在相对单纯的模式下的情形。注意如果当前要启动的 Service 已经存在了那么就不会再次创建该 Service 当然也不会调用 onCreate（）方法。 一个 Service 可以被多个客户进行绑定， 只有所有的绑定对象都执行了 unBind（）方法后该 Service 才会销毁，不过如果有一个客户执行了 onStart() 方法，那么这个时候如果所有的 bind 客户都执行了 unBind()该 Service 也不会 销毁。</p><p>Service 的生命周期图如下所示，帮助大家记忆。</p><p><img src=".%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B2%BE%E7%BC%96_images/image-20200508144319768.png" alt="image-20200508144319768"></p><h3 id="4-什么是-IntentService？有何优点？（★★★）"><a href="#4-什么是-IntentService？有何优点？（★★★）" class="headerlink" title="4.什么是 IntentService？有何优点？（★★★）"></a>4.什么是 IntentService？有何优点？（★★★）</h3><p>我们通常只会使用 Service。那么看了下面的介绍相信你就不再陌生了。如果你还是不了解那么在 面试的时候你就坦诚说没用过或者不了解等。并不是所有的问题都需要回答上来 的。 </p><p>一、IntentService 简介</p><p>​         IntentService 是 Service 的子类，比普通的 Service 增加了额外的功能。 先看 Service 本身存在两个问题： Service 不会专门启动一条单独的进程，Service 与它所在应用位于同一个进 程中； </p><p>Service 也不是专门一条新线程，因此不应该在 Service 中直接处理耗时的 任务； </p><p>二、IntentService 特征 </p><ul><li><p>会创建独立的 worker 线程来处理所有的 Intent 请求；</p></li><li><p>会创建独立的 worker 线程来处理 onHandleIntent()方法实现的代码，无需 处理多线程问题； </p></li><li><p>所有请求处理完成后，IntentService 会自动停止，无需调用 stopSelf()方法 停止 Service； </p></li><li><p>为 Service 的 onBind()提供默认实现，返回 null；</p></li><li><p>为 Service 的 onStartCommand 提供默认实现，将请求 Intent 添加到队列 中；</p></li></ul><p>使用 IntentService</p><p>​         一 个 IntentService 的 使 用 例 子 供 参 考 。 该 例 子 中 一 个 MainActivity 一个 MyIntentService，这两个类都是四大组件当然需要在清单 文件中注册。这里只给出核心代码：</p><pre class=" language-java"><code class="language-java">MainActivity<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">click</span><span class="token punctuation">(</span>View view<span class="token punctuation">)</span><span class="token punctuation">{</span>   Intent intent <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Intent</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> MyIntentService<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   intent<span class="token punctuation">.</span><span class="token function">putExtra</span><span class="token punctuation">(</span><span class="token string">"start"</span><span class="token punctuation">,</span> <span class="token string">"MyIntentService"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">startService</span><span class="token punctuation">(</span>intent<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>MyIntentService<span class="token punctuation">.</span>java<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyIntentService</span> <span class="token keyword">extends</span> <span class="token class-name">IntentService</span> <span class="token punctuation">{</span>   <span class="token keyword">private</span> String ex <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>   <span class="token keyword">private</span> Handler mHandler <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleMessage</span><span class="token punctuation">(</span>android<span class="token punctuation">.</span>os<span class="token punctuation">.</span>Message msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>                                                         Toast<span class="token punctuation">.</span><span class="token function">makeText</span><span class="token punctuation">(</span>MyIntentService<span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token string">"-e "</span> <span class="token operator">+</span> ex<span class="token punctuation">,</span> Toast<span class="token punctuation">.</span>LENGTH_LONG<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>   <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token function">MyIntentService</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token string">"MyIntentService"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>   <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">onStartCommand</span><span class="token punctuation">(</span>Intent intent<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span> <span class="token keyword">int</span> startId<span class="token punctuation">)</span> <span class="token punctuation">{</span>            ex <span class="token operator">=</span> intent<span class="token punctuation">.</span><span class="token function">getStringExtra</span><span class="token punctuation">(</span><span class="token string">"start"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onStartCommand</span><span class="token punctuation">(</span>intent<span class="token punctuation">,</span> flags<span class="token punctuation">,</span> startId<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>   <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">onHandleIntent</span><span class="token punctuation">(</span>Intent intent<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/** * 模拟执行耗时任务 * 该方法是在子线程中执行的，因此需要用到 handler 跟主线程进行通信 */</span>     <span class="token keyword">try</span> <span class="token punctuation">{</span>                Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     mHandler<span class="token punctuation">.</span><span class="token function">sendEmptyMessage</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">try</span> <span class="token punctuation">{</span>                Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p>运行后效果如下：</p><h3 id="5-说说-Activity、Intent、Service-是什么关系"><a href="#5-说说-Activity、Intent、Service-是什么关系" class="headerlink" title="5.说说 Activity、Intent、Service 是什么关系"></a>5.说说 Activity、Intent、Service 是什么关系</h3><p>他们都是 Android 开发中使用频率最高的类。其中 Activity 和 Service 都是 Android 四大组件之一。他俩都是 Context 类的子类 ContextWrapper 的子类， Activity 负责用户界面的显示和交互，Service 负责后台任务的处理。Activity 和 Service 之间可 以通过 Intent 传递数据，因此可以把 Intent 看作是通信使者。</p><h3 id="6-Service-和-Activity-在同一个线程吗，服务和线程的区别（★）"><a href="#6-Service-和-Activity-在同一个线程吗，服务和线程的区别（★）" class="headerlink" title="6.Service 和 Activity 在同一个线程吗，服务和线程的区别（★）"></a>6.Service 和 Activity 在同一个线程吗，服务和线程的区别（★）</h3><p>对于同一 app 来说默认情况下是在同一个线程中的， main Thread （UIThread）。</p><ul><li><p>服务是一种即使用户未与应用交互也可在后台运行的组件，因此，只有在需要服务时才应创建服务</p><p>比如微信中的播放的音乐，退出微信了，也在播放中。</p></li><li><p>如果您必须在主线程之外执行操作，但只在用户与您的应用交互时执行此操作，则应创建新线程。例如，如果您只是想在 Activity 运行的同时播放一些音乐，则可在 <code>onCreate()</code> 中创建线程，在 <code>onStart()</code> 中启动线程运行，然后在 <code>onStop()</code> 中停止线程。</p></li></ul><h3 id="7-Service-里面可以弹吐司么（★）"><a href="#7-Service-里面可以弹吐司么（★）" class="headerlink" title="7.Service 里面可以弹吐司么（★）"></a>7.Service 里面可以弹吐司么（★）</h3><p>可以的。弹吐司有个条件就是得有一个 Context 上下文，而 Service 本身就是 Context 的子类， 因此在 Service 里面弹吐司是完全可以的。 比如我们在Service 中完成下载任务后可以弹一个吐司通知用户。</p><h3 id="8-什么是-Service-以及描述下它的生命周期。Service-有哪些启动方"><a href="#8-什么是-Service-以及描述下它的生命周期。Service-有哪些启动方" class="headerlink" title="8.什么是 Service 以及描述下它的生命周期。Service 有哪些启动方"></a>8.什么是 Service 以及描述下它的生命周期。Service 有哪些启动方</h3><p>法，有什么区别，怎样停用 Service？（★★★）</p><p>1． 通过 startService</p><p>Service 会经历 onCreate 到 onStart，然后处于运行状态，stopService 的时候调用 onDestroy 方法。</p><p>如果是调用者自己直接退出而没有调用 stopService 的话，Service 会一直 在后台运行。</p><p>2． 通过 bindService</p><p>Service会运行onCreate，然后是调用onBind，这个时候调用者和Service 绑定在一起。调用者退出了，Srevice 就会调用 onUnbind-&gt;onDestroyed 方 法。</p><p>所谓绑定在一起就共存亡了。调用者也可以通过调用 unbindService 方法来</p><p>停止服务，这时候 Srevice 就会调用 onUnbind-&gt;onDestroyed 方法。 需要注意的是如果这几个方法交织在一起的话，会出现什么情况呢？ 一个原则是 Service 的 onCreate 的方法只会被调用一次，就是你无论多少次的 startService 又 bindService，Service 只被创建一次。</p><p>如果先是 bind 了，那么 start 的时候就直接运行 Service 的 onStart 方法， 如果先是 start，那么 bind 的时候就直接运行 onBind 方法。 如果 service 运行期间调用了 bindService，这时候再调用 stopService 的话， service 是不会调用 onDestroy 方法的，service 就 stop 不掉了，只能调用 UnbindService, service 就会被销毁</p><p>如果一个 service 通过 startService 被 start 之后，多次调用 startService 的话，service 会多次调用 onStart 方法。多次调用 stopService 的话，service 只会调用一次 onDestroyed 方法。</p><p>如果一个 service 通过 bindService 被 start 之后，多次调用 bindService 的话，service 只会调用一次 onBind 方法。 多次调用 unbindService 的话会抛出异常。</p><h2 id="三、Broadcast-Receiver"><a href="#三、Broadcast-Receiver" class="headerlink" title="三、Broadcast Receiver"></a>三、Broadcast Receiver</h2><h3 id="1-请描述一下-BroadcastReceiver（★★）"><a href="#1-请描述一下-BroadcastReceiver（★★）" class="headerlink" title="1.请描述一下 BroadcastReceiver（★★）"></a>1.请描述一下 BroadcastReceiver（★★）</h3><ul><li><p>BroadCastReceiver 是 Android 四大组件之一，主要用于接收系统或者 app 发送的广播通知，比如开机启动、sd 挂载、 低电量、外播电话、锁屏。如果我们做的是播放器，那么监听到用户锁屏后我们应该将我们的播放之暂停 等。</p></li><li><p>广播分两种：有序广播和无序广播。 </p></li></ul><p><strong>无序广播</strong>：完全异步，逻辑上可以被任何广播接收者接收到。优点是效率较高。 缺点是一个接收者不能将处理结果传递给下一个接收者，并无法终止广播 intent 的传播。 </p><p><strong>有序广播</strong>：按照被接收者的优先级顺序，在被接收者中依次传播。比如有三个广 播接收者 A，B，C，优先级是 A &gt; B &gt; C。那这个消息先传给 A，再传给 B，最 后传给 C。每个接收者有权终止广播，比如 B 终止广播，C 就无法接收到。此外 A 接收到广播后可以对结果对象进行操作，当广播传给 B 时，B 可以从结果对象 中取得 A 存入的数据。 </p><pre class=" language-java"><code class="language-java">Context<span class="token punctuation">.</span><span class="token function">sendOrderedBroadcast</span><span class="token punctuation">(</span>intent<span class="token punctuation">,</span> receiverPermission<span class="token punctuation">,</span> resultReceiver<span class="token punctuation">,</span> scheduler<span class="token punctuation">,</span> initialCode<span class="token punctuation">,</span> initialData<span class="token punctuation">,</span> initialExtras<span class="token punctuation">)</span></code></pre><p>我们可以 指定 resultReceiver 广播接收者，这个接收者我们可以认为是最终接收者，通 常情况下如果比他优先级更高的接收者如果没有终止广播，那么他的 onReceive 会被执行两次，第一次是正常的按照优先级顺序执行，<strong>第二次</strong>是作为最终接收者 接收。如果比他优先级高的接收者终止了广播，那么他<strong>依然能接收</strong>到广播。 </p><ul><li>内部通信实现机制：通过 Android 系统的 Binder 机制实现通信。 </li></ul><h3 id="2-在-manifest-和代码中如何注册和使用-BroadcastReceiver"><a href="#2-在-manifest-和代码中如何注册和使用-BroadcastReceiver" class="headerlink" title="2.在 manifest 和代码中如何注册和使用 BroadcastReceiver"></a>2.在 manifest 和代码中如何注册和使用 BroadcastReceiver</h3><p>在清单文件中注册广播接收者称为静态注册，在代码中注册称为动态注册。</p><p>静态注册的广播接收者只要 app 在系统中运行,则一直可以接收到广播消息，动</p><p>态注册的广播接收者当注册的 Activity 或者 Service 销毁了那么就接收不到广播</p><p>了。</p><p>静态注册：在清单文件中进行如下配置</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>receiver</span> <span class="token attr-name"><span class="token namespace">android:</span>name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>.BroadcastReceiver1<span class="token punctuation">"</span></span> <span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>intent-filter</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>action</span> <span class="token attr-name"><span class="token namespace">android:</span>name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>android.intent.action.CALL<span class="token punctuation">"</span></span> <span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>action</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>intent-filter</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>receiver</span><span class="token punctuation">></span></span></code></pre><p>动态注册：在代码中进行如下注册</p><pre class=" language-java"><code class="language-java">receiver <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BroadcastReceiver</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>IntentFilter intentFilter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IntentFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> intentFilter<span class="token punctuation">.</span><span class="token function">addAction</span><span class="token punctuation">(</span>CALL_ACTION<span class="token punctuation">)</span><span class="token punctuation">;</span> context<span class="token punctuation">.</span><span class="token function">registerReceiver</span><span class="token punctuation">(</span>receiver<span class="token punctuation">,</span> intentFilter<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="3-BroadCastReceiver-的生命周期"><a href="#3-BroadCastReceiver-的生命周期" class="headerlink" title="3.BroadCastReceiver 的生命周期"></a>3.BroadCastReceiver 的生命周期</h3><p>a. 广播接收者的生命周期非常短暂的， 在接收到广播的时候创建， onReceive()方法结束之后销毁；</p><p>b. 广播接收者中不要做一些耗时的工作， 否则会弹出 Application No Response 错误对话框；</p><p>c. 最好也不要在广播接收者中创建子线程做耗时的工作，因为广播接收者被 销毁后进程就成为了空进程，很容易被系统杀掉?；</p><p>d. 耗时的较长的工作最好放在服务中完成；</p><h3 id="4、Android-引入广播机制的用意"><a href="#4、Android-引入广播机制的用意" class="headerlink" title="4、Android 引入广播机制的用意"></a>4、Android 引入广播机制的用意</h3><p>a. 从 MVC 的角度考虑(应用程序内) 其实回答这个问题的时候还可以这样问， android 为什么要有那 4 大组件，现在的移动开发模型基本上也是照搬的 web 那一套 MVC 架构，只不过是改了点嫁妆而已。android 的四大组件本 质上就是为了实现移动或者说嵌入式设备上的 MVC 架构，它们之间有时候 是一种相互依存的关系，有时候又是一种补充关系，引入广播机制可以方便 几大组件的信息和数据交互。</p><p>b.程序间互通消息(例如在自己的应用程序内监听系统来电) </p><p>c. 效率上(参考 UDP 的广播协议在局域网的方便性) </p><p>d.设计模式上(反转控制的一种应用，类似监听者模式)</p><h2 id="四、-ContentProvider（更新-2019-6-14）"><a href="#四、-ContentProvider（更新-2019-6-14）" class="headerlink" title="四、 ContentProvider（更新 2019.6.14）"></a>四、 ContentProvider（更新 2019.6.14）</h2><h3 id="1-请介绍下-ContentProvider-是如何实现数据共享的（★★★）"><a href="#1-请介绍下-ContentProvider-是如何实现数据共享的（★★★）" class="headerlink" title="1.请介绍下 ContentProvider 是如何实现数据共享的（★★★）"></a>1.请介绍下 ContentProvider 是如何实现数据共享的（★★★）</h3><p>在 Android 中如果想将自己应用的数据（一般多为数据库中的数据）提供</p><p>给第三发应用，那么我们只能通过 ContentProvider 来实现了。</p><p>ContentProvider 是应用程序之间共享数据的接口。使用的时候首先自定义</p><p>一个类继承 ContentProvider，然后覆写 query、insert、update、delete 等</p><p>方法。因为其是四大组件之一因此必须在 AndroidManifest 文件中进行注册。</p><p>把自己的数据通过 uri 的形式共享出去，android</p><p>系统下 不同程序 数据默认</p><p>是不能共享访问，需要去实现一个类去继承 ContentProvider</p><p>public class PersonContentProvider extends ContentProvider{ public boolean onCreate(){</p><p>} query(Uri, String[], String, String[], String)</p><p>insert(Uri, ContentValues) update(Uri, ContentValues, String, String[]) delete(Uri, String, String[])</p><p>}</p><p>&lt;provider android:exported=”true” android:name=”com.itheima.contenProvider.provider.PersonContentPro vider”android:authorities=”com.itheima.person” /&gt;</p><p>第三方可以通过 ContentResolver 来访问该 Provider。</p><h3 id="2-为什么要用-ContentProvider？它和-sql-的实现上有什么差"><a href="#2-为什么要用-ContentProvider？它和-sql-的实现上有什么差" class="headerlink" title="2.为什么要用 ContentProvider？它和 sql 的实现上有什么差"></a>2.为什么要用 ContentProvider？它和 sql 的实现上有什么差</h3><p>别？（★★★）</p><p>ContentProvider 屏蔽了数据存储的细节,内部实现对用户完全透明,用户只 需要关心操作数据的 uri 就可以了，ContentProvider 可以实现不同 app 之间 共享。</p><p>Sql 也有增删改查的方法， 但是 sql 只能查询本应用下的数据库。 而 ContentProvider 还可以去增删改查本地文件. xml 文件的读取等。</p><h3 id="3-说说-ContentProvider、ContentResolver、ContentObserver"><a href="#3-说说-ContentProvider、ContentResolver、ContentObserver" class="headerlink" title="3.说说 ContentProvider、ContentResolver、ContentObserver"></a>3.说说 ContentProvider、ContentResolver、ContentObserver</h3><p>之间的关系（★★★★）</p><p>a. ContentProvider 内容提供者，用于对外提供数据</p><p>b. ContentResolver.notifyChange(uri)发出消息</p><p>c. ContentResolver 内容解析者，用于获取内容提供者提供的数据</p><p>d. ContentObserver 内容监听器，可以监听数据的改变状态</p><p>e. ContentResolver.registerContentObserver()监听消息。</p><h3 id="4-使用-contentProvider-获取本地所有的音频文件-上海）-更-新-2019-5-5-（★★★）"><a href="#4-使用-contentProvider-获取本地所有的音频文件-上海）-更-新-2019-5-5-（★★★）" class="headerlink" title="4.使用 contentProvider 获取本地所有的音频文件(上海） (更 新 2019.5.5)（★★★）"></a>4.使用 contentProvider 获取本地所有的音频文件(上海） (更 新 2019.5.5)（★★★）</h3><p>Android 中，系统为多媒体类型的文件（比如图片、音频、视频等）建立了 数据库(sqlite 数据库)，将文件的名称、大小等信息存储起来，从而完成多媒体 数据的维护工作；所以我们需要实现建立一个实体类。</p><p>可以根据 ContentResover 获取到一个 Cursor，然后根据这个游标，遍历所 有的歌曲的信息，设置给实体类，得到你想要的音频文件。因为是从本地读取数 据，所以需要添加权限</p><p>&lt;uses-permission</p><p>android:name=”android.permission.READ_EXTERNAL_STORAGE”/&gt;</p><h2 id="五、-ListView"><a href="#五、-ListView" class="headerlink" title="五、 ListView"></a>五、 ListView</h2><h3 id="1-ListView-如何提高其效率？（★★）"><a href="#1-ListView-如何提高其效率？（★★）" class="headerlink" title="1.ListView 如何提高其效率？（★★）"></a>1.ListView 如何提高其效率？（★★）</h3><p>当 convertView 为空时， 用 setTag()方法为每个 View 绑定一个存放控件的 ViewHolder 对象。当 convertView 不为空，重复利用已经创建的 view 的时候，使用 getTag()方法获取绑定的 ViewHolder 对象，这样就避免了 findViewById 对控件的层层查询，而是快速定位到控件。</p><p>① 复用 ConvertView，使用历史的 view，提升效率 200% </p><p>② 自定义静态类 ViewHolder，减少 findViewById 的次数。提 升效率 50% </p><p>③ 异步加载数据，分页加载数据。 </p><p>④ 使用 WeakRefrence 引用 ImageView 对象</p><h3 id="2-当-ListView-数据集改变后，如何更新-ListView"><a href="#2-当-ListView-数据集改变后，如何更新-ListView" class="headerlink" title="2.当 ListView 数据集改变后，如何更新 ListView"></a>2.当 ListView 数据集改变后，如何更新 ListView</h3><p>使用该 ListView 的 adapter 的 notifyDataSetChanged()方法。 该方法会 使 ListView 重新绘制。</p><h3 id="3-ListView-如何实现分页加载（★★★★★）"><a href="#3-ListView-如何实现分页加载（★★★★★）" class="headerlink" title="3.ListView 如何实现分页加载（★★★★★）"></a>3.ListView 如何实现分页加载（★★★★★）</h3><p>① 设 置 ListView 的 滚 动 监 听 器 ： setOnScrollListener(new OnScrollListener{….}) 在监听器中有两个方法： 滚动状态发生变化的方法(onScrollStateChanged)和 listView 被滚动时调用的方法(onScroll)</p><p>② 在滚动状态发生改变的方法中，有三种状态： 手指按下移动的状态：SCROLL_STATE_TOUCH_SCROLL: // 触摸滑动 惯性滚动（滑翔（flgin）状态）：SCROLL_STATE_FLING: // 滑翔</p><p>静止状态： SCROLL_STATE_IDLE: // 静止 对不同的状态进行处理： 分批加载数据，只关心静止状态：关心最后一个可见的条目，如果最后一个 可见条目就是数据适配器（集合）里的最后一个，此时可加载更多的数据。在每 次加载的时候，计算出滚动的数量，当滚动的数量大于等于总数量的时候，可以 提示用户无更多数据了。</p><h3 id="4-ListView-可以显示多种类型的条目吗（★★）"><a href="#4-ListView-可以显示多种类型的条目吗（★★）" class="headerlink" title="4.ListView 可以显示多种类型的条目吗（★★）"></a>4.ListView 可以显示多种类型的条目吗（★★）</h3><p>这个当然可以的， ListView 显示的每个条目都是通过 baseAdapter 的 getView(int position, View convertView, ViewGroup parent)来展示的， 理 论上我们完全可以让每个条目都是不同类型的 view。</p><p>比如：从服务器拿回一个标识为 id=1,那么当 id=1 的时候，我们就加载类 型一的条目，当 id=2 的时候，加载类型二的条目。常见布局在资讯类客户端中 可以经常看到。</p><p>除 此 之 外 adapter 还 提 供 了 getViewTypeCount （ ） 和 getItemViewType(int position)两个方法。在 getView 方法中我们可以根据不 同的 viewtype 加载不同的布局文件。</p><h3 id="5-ListView-如何定位到指定位置"><a href="#5-ListView-如何定位到指定位置" class="headerlink" title="5.ListView 如何定位到指定位置"></a>5.ListView 如何定位到指定位置</h3><p>可以通过 ListView 提供的 lv.setSelection(listView.getPosition());方法。</p><h3 id="6-如何在-ScrollView-中如何嵌入-ListView（★★★★）"><a href="#6-如何在-ScrollView-中如何嵌入-ListView（★★★★）" class="headerlink" title="6.如何在 ScrollView 中如何嵌入 ListView（★★★★）"></a>6.如何在 ScrollView 中如何嵌入 ListView（★★★★）</h3><p>通常情况下我们不会在 ScrollView 中嵌套 ListView，但是如果面试官非让 我嵌套的话也是可以的。</p><p>在 ScrollView 添加一个 ListView 会导致 listview 控件显示不全，通常只会 显示一条，这是因为两个控件的滚动事件冲突导致。所以需要通过 listview 中的 item 数量去计算 listview 的显示高度，从而使其完整展示，如下提供一个方法 供大家参考。</p><p>lv = (ListView) findViewById(R.id.lv); adapter = new MyAdapter(); lv.setAdapter(adapter); setListViewHeightBasedOnChildren(lv); —————————————————public void setListViewHeightBasedOnChildren(ListView listView) { ListAdapter listAdapter = listView.getAdapter(); if (listAdapter == null) { return; } int totalHeight = 0; for (int i = 0; i &lt; listAdapter.getCount(); i++) { View listItem = listAdapter.getView(i, null, listView); listItem.measure(0, 0); totalHeight += listItem.getMeasuredHeight();</p><p>} ViewGroup.LayoutParams params = listView.getLayoutParams(); params.height = totalHeight + (listView.getDividerHeight() * (listAdapter.getCount() - 1)); params.height += 5;// if without this statement,the listview will be // little short listView.setLayoutParams(params); }</p><p>现阶段最好的处理的方式是： 自定义 ListView，重载 onMeasure()方法，设置 全部显示。</p><p>package com.meiya.ui;</p><p>import android.widget.ListView;</p><p>/** * * @Description: scrollview 中内嵌 listview 的简单实现 * * @File: ScrollViewWithListView.java * * * @Version */ public class ScrollViewWithListView extends ListView {</p><p>public ScrollViewWithListView(android.content.Context context, android.util.AttributeSet attrs) { super(context, attrs); }</p><p>/** * Integer.MAX_VALUE &gt;&gt; 2,如果不设置，系统默认设置是显示两条 */ public void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { int expandSpec = MeasureSpec.makeMeasureSpec(Integer.MAX_VALUE &gt;&gt; 2, MeasureSpec.AT_MOST); super.onMeasure(widthMeasureSpec, expandSpec);</p><p>}</p><p>}</p><h3 id="7-ListView-中如何优化图片（★★）"><a href="#7-ListView-中如何优化图片（★★）" class="headerlink" title="7.ListView 中如何优化图片（★★）"></a>7.ListView 中如何优化图片（★★）</h3><p>图片的优化策略比较多。</p><p>1、处理图片的方式： 如果 ListView 中自定义的 Item 中有涉及到大量图片的，一定要对图片进行 细心的处理，因为图片占的内存是 ListView 项中最头疼的，处理图片的方法大 致有以下几种： ①、不要直接拿路径就去循环 BitmapFactory.decodeFile;使用 Options 保 存图片大小、不要加载图片到内存去。 ②、对图片一定要经过边界压缩尤其是比较大的图片，如果你的图片是后台 服务器处理好的那就不需要了 ③、在 ListView 中取图片时也不要直接拿个路径去取图片， 而是以 WeakReference （ 使 用 WeakReference 代 替 强 引 用 。 比 如 可 以 使 用 WeakReference mContextRef）、SoftReference、WeakHashMap 等的来存 储图片信息。 ④、在 getView 中做图片转换时，产生的中间变量一定及时释放 2、异步加载图片基本思想： 1）、 先从内存缓存中获取图片显示（内存缓冲） 2）、获取不到的话从 SD 卡里获取（SD 卡缓冲） 3）、都获取不到的话从网络下载图片并保存到 SD 卡同时加入内存并显示 （视情况看是否要显示） 原理： 优化一：先从内存中加载，没有则开启线程从 SD 卡或网络中获取，这里注</p><p>意从 SD 卡获取图片是放在子线程里执行的，否则快速滑屏的话会不够流畅。 优化二：于此同时，在 adapter 里有个 busy 变量，表示 listview 是否处于 滑动状态，如果是滑动状态则仅从内存中获取图片，没有的话无需再开启线程去 外存或网络获取图片。</p><p>优化三：ImageLoader 里的线程使用了线程池，从而避免了过多线程频繁 创建和销毁，如果每次总是 new 一个线程去执行这是非常不可取的，好一点的 用的 AsyncTask 类，其实内部也是用到了线程池。在从网络获取图片时，先是 将其保存到 sd 卡，然后再加载到内存，这么做的好处是在加载到内存时可以做 个压缩处理，以减少图片所占内存。</p><h3 id="8-ListView-中图片错位的问题是如何产生的（★★★）"><a href="#8-ListView-中图片错位的问题是如何产生的（★★★）" class="headerlink" title="8.ListView 中图片错位的问题是如何产生的（★★★）"></a>8.ListView 中图片错位的问题是如何产生的（★★★）</h3><p>图片错位问题的本质源于我们的 listview 使用了缓存 convertView，假设一 种场景，一个 listview 一屏显示九个 item，那么在拉出第十个 item 的时候，事 实上该 item 是重复使用了第一个 item，也就是说在第一个 item 从网络中下载 图片并最终要显示的时候，其实该 item 已经不在当前显示区域内了，此时显示 的后果将可能在第十个 item 上输出图像，这就导致了图片错位的问题。所以解 决之道在于可见则显示，不可见则不显示。</p><h3 id="10-如何刷新-ListView-中单个-item-的数据，-不刷新整个-ListView-的数据？"><a href="#10-如何刷新-ListView-中单个-item-的数据，-不刷新整个-ListView-的数据？" class="headerlink" title="10.如何刷新 ListView 中单个 item 的数据， 不刷新整个 ListView 的数据？"></a>10.如何刷新 ListView 中单个 item 的数据， 不刷新整个 ListView 的数据？</h3><p>修改单个 Item 的数据,然后调用适配器的 notifyDataSetChanged()方法</p><h2 id="六、Intent"><a href="#六、Intent" class="headerlink" title="六、Intent"></a>六、Intent</h2><h3 id="1-Intent-传递数据时，可以传递哪些类型数据？"><a href="#1-Intent-传递数据时，可以传递哪些类型数据？" class="headerlink" title="1.Intent 传递数据时，可以传递哪些类型数据？"></a>1.Intent 传递数据时，可以传递哪些类型数据？</h3><p>Intent 可以传递，java 的基本数据类型和 String 以 及他 们的 数组 形 式 都可 以 ， 除 此 之外还 可 以 传 递 实现 了 Serializable 和 Parcelable 接口的对象。通过 intent 发送数据时，应小心地将数据大小限制为几 KB。发送过多数据会导致系统抛出 <code>TransactionTooLargeException</code> 异常</p><h3 id="2-Serializable-和-Parcelable-的区别（★★★）"><a href="#2-Serializable-和-Parcelable-的区别（★★★）" class="headerlink" title="2.Serializable 和 Parcelable 的区别（★★★）"></a>2.Serializable 和 Parcelable 的区别（★★★）</h3><p>在使用内存的时候， Parcelable 类比 Serializable 性能高， 所以推荐使用 Parcelable 类。</p><p>1．Serializable 在序列化的时候会产生大量的临时变量，从而引起频繁的 GC。</p><p>2．Parcelable 不能使用在要将数据存储在磁盘上的情况。尽管 Serializable 效率低点，但在这种情况下，还是建议你用 Serializable 。</p><p>实现：</p><p>1．Serializable 的实现，只需要继承 Serializable 即可。这只是给对象打了一个标记，系统会自动将其序列化。 2．Parcelabel 的实现，需要在类中添加一个静态成员变量 CREATOR，这 个变量需要继承 Parcelable.Creator 接口。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyParcelable</span> <span class="token keyword">implements</span> <span class="token class-name">Parcelable</span> <span class="token punctuation">{</span>   <span class="token keyword">private</span> <span class="token keyword">int</span> mData<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">describeContents</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">writeToParcel</span><span class="token punctuation">(</span>Parcel out<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span> <span class="token punctuation">{</span>       out<span class="token punctuation">.</span><span class="token function">writeInt</span><span class="token punctuation">(</span>mData<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Parcelable<span class="token punctuation">.</span>Creator<span class="token operator">&lt;</span>MyParcelable<span class="token operator">></span> CREATOR <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parcelable<span class="token punctuation">.</span>Creator</span><span class="token operator">&lt;</span>MyParcelable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">public</span> MyParcelable <span class="token function">createFromParcel</span><span class="token punctuation">(</span>Parcel in<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">MyParcelable</span><span class="token punctuation">(</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>    <span class="token keyword">public</span> MyParcelable<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">newArray</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">MyParcelable</span><span class="token punctuation">[</span>size<span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">MyParcelable</span><span class="token punctuation">(</span>Parcel in<span class="token punctuation">)</span> <span class="token punctuation">{</span>       mData <span class="token operator">=</span> in<span class="token punctuation">.</span><span class="token function">readInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>注意：<code>Parcel</code> 不是通用序列化机制，您绝不能将任何 <code>Parcel</code> 数据存储在磁盘上或通过网络发送。</p></blockquote><h3 id="3-请描述一下-Intent-和-IntentFilter（★★★）"><a href="#3-请描述一下-Intent-和-IntentFilter（★★★）" class="headerlink" title="3.请描述一下 Intent 和 IntentFilter（★★★）"></a>3.请描述一下 Intent 和 IntentFilter（★★★）</h3><p><code>Intent</code> 是一个消息传递对象，您可以用来从其他<a href="https://developer.android.google.cn/guide/components/fundamentals#Components" target="_blank" rel="noopener">应用组件</a>请求操作</p><p>​        Android 中通过 Intent 对象来表示一条消息，一个 Intent 对象不仅包含有这个消息的目的地，还可以包含消息的内容，这好比一封 Email，其中不仅应 该包含收件地址，还可以包含具体的内容。对于一个 Intent 对象，消息“目的 地”是必须的，而内容则是可选项。 通过 Intent 可以实现各种系统组件的调用与激活.</p><p>​        IntentFilter: 可以理解为邮局或者是一个信笺的分拣系统… 这个分拣系统通过 3 个参数来识别 </p><p><code>Action</code>: 动作 view </p><p><code>Data</code>: 数据 uri uri </p><p><code>Category</code> : 额外的附加信息 </p><h5 id="Action-匹配"><a href="#Action-匹配" class="headerlink" title="Action 匹配"></a>Action 匹配</h5><p>​        Action 是一个用户定义的字符串，用于描述一个 Android 应用程序组件， 一 个 <code>IntentFilter</code> 可 以 包 含 多 个 Action 。 在 <code>AndroidManifest.xml</code> 的 <code>Activity</code> 定义时可以在其 <intent-filter>节点指定一个 Action 列表用于标 示 Activity 所能接受的“动作”，例如： </p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>intent-filter</span> <span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>action</span> <span class="token attr-name"><span class="token namespace">android:</span>name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>android.intent.action.MAIN<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>action</span> <span class="token attr-name"><span class="token namespace">android:</span>name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>cn.itheima.action<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>  ……<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>intent-filter</span><span class="token punctuation">></span></span> </code></pre><p>如果我们在启动一个 Activity 时使用这样的 Intent 对象：</p><pre><code>Intent intent =new Intent();intent.setAction(&quot;cn.itheima.action&quot;); </code></pre><p>那么所有的 Action 列表中包含了“cn.itheima”的 Activity 都将会匹配 成功。 Android 预定义了一系列的 Action 分别表示特定的系统动作。 这些 Action 通过常量的方式定义在 <code>android.content. Intent</code> 中，以“ACTION_” 开头。我们可以在 Android 提供的文档中找到它们的详细说明。 </p><h5 id="URI-数据匹配"><a href="#URI-数据匹配" class="headerlink" title="URI 数据匹配"></a>URI 数据匹配</h5><p>一个 Intent 可以通过 URI 携带外部数据给目标组件。在 <intent-filter > 节点中，通过 <data/>节点匹配外部数据。 mimeType 属性指定携带外部数据的数据类型，scheme 指定协议，host、 port、path 指定数据的位置、端口、和路径。如下： </p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>data</span> <span class="token attr-name"><span class="token namespace">android:</span>mimeType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mimeType<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">android:</span>scheme</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>scheme<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">android:</span>host</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>host<span class="token punctuation">"</span></span>             <span class="token attr-name"><span class="token namespace">android:</span>port</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>port<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">android:</span>path</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>path<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span></code></pre><p> 电话的 uri tel: 12345 </p><p><a href="http://www.baidu.com" target="_blank" rel="noopener">http://www.baidu.com</a> </p><p>自己定义的 uri itcast://cn.itcast/person/10 </p><p>如果在 Intent Filter 中指定了这些属性，那么只有所有的属性都匹配成功 时 URI 数据匹配才会成功。</p><h5 id="Category-类别匹配"><a href="#Category-类别匹配" class="headerlink" title="Category 类别匹配"></a>Category 类别匹配</h5><p>​        <intent-filter>节点中可以为组件定义一个 <code>Category</code> 类别列表， 当 Intent 中包含这个列表的所有项目时 <code>Category</code> 类别匹配才会成功。</p><h3 id="4-intent-的意义"><a href="#4-intent-的意义" class="headerlink" title="4.intent 的意义"></a>4.intent 的意义</h3><p>保证了组件之间的通信，在组件之间传递了数据。</p><h2 id="七、Fragment"><a href="#七、Fragment" class="headerlink" title="七、Fragment"></a>七、Fragment</h2><h3 id="1-Fragment-跟-Activity-之间是如何传值的"><a href="#1-Fragment-跟-Activity-之间是如何传值的" class="headerlink" title="1.Fragment 跟 Activity 之间是如何传值的"></a>1.Fragment 跟 Activity 之间是如何传值的</h3><p>当 Fragment 跟 Activity 绑 定 之 后 ， 在 Fragment 中 可 以 直 接 通 过 getActivity（）方法获取到其绑定的 Activity 对象， 这样就可以调用 Activity 的方法了。在 Activity 中可以通过如下方法获取到 Fragment 实例</p><p>FragmentManager fragmentManager = getFragmentManager(); Fragment fragment = fragmentManager.findFragmentByTag(tag); Fragment fragment = fragmentManager.findFragmentById(id);</p><p>获取到 Fragment 之后就可以调用 Fragment 的方法。也就实现了通信功能。</p><h3 id="2-描述一下-Fragment-的生命周期"><a href="#2-描述一下-Fragment-的生命周期" class="headerlink" title="2.描述一下 Fragment 的生命周期"></a>2.描述一下 Fragment 的生命周期</h3><h3 id="3-Fragment-的-replace-和-add-方法的区别"><a href="#3-Fragment-的-replace-和-add-方法的区别" class="headerlink" title="3.Fragment 的 replace 和 add 方法的区别"></a>3.Fragment 的 replace 和 add 方法的区别</h3><p>Fragment 本 身 并 没 有 replace 和 add 方 法 ， 这 里 的 理 解 应 该 为 使 用</p><p>FragmentManager 的 replace 和 add 两种方法切换 Fragment 时有什么不同。 我 们 经 常 使 用 的 一 个 架 构 就 是 通 过 RadioGroup 切 换 Fragment ， 每 个 Fragment 就是一个功能模块。</p><p>case R.id.rb_1:</p><p>//</p><p>//</p><p>//</p><p>rb_1.setBackgroundColor(Color.RED); transaction.show(fragment1); transaction.replace(R.id.fl, fragment1, “Fragment1”); break; case R.id.rb_2:</p><p>rb_2.setBackgroundColor(Color.YELLOW); transaction.replace(R.id.fl, fragment2, “Fragment2”); transaction.show(fragment2); break; case R.id.rb_3:</p><p>rb_3.setBackgroundColor(Color.BLUE); transaction.replace(R.id.fl, fragment3, “Fragment3”); transaction.show(fragment3); break;</p><p>实现这个功能可以通过 replace 和 add 两种方法。 Fragment 的容器一个 FrameLayout，add 的时候是把所有的 Fragment 一层 一层的叠加到了 FrameLayout 上了， 而 replace 的话首先将该容器中的其他 Fragment 去除掉然后将当前 Fragment 添加到容器中。 一个 Fragment 容器中只能添加一个 Fragment 种类，如果多次添加则会报异 常，导致程序终止，而 replace 则无所谓，随便切换。 因为通过 add 的方法添加的 Fragment，每个 Fragment 只能添加一次，因此 如果要想达到切换效果需要通过 Fragment 的的hide 和 show 方法结合者使用。 将要显示的 show 出来，将其他 hide 起来。这个过程 Fragment 的生命周期没</p><p>有变化。 通 过 replace 切 换 Fragment ， 每 次 都 会 执 行 上 一 个 Fragment 的 onDestroyView，新 Fragment 的 onCreateView、onStart、onResume 方法。 基于以上不同的特点我们在使用的使用一定要结合着生命周期操作我们的视图 和数据。</p><h3 id="4-Fragment-如何实现类似-Activity-栈的压栈和出栈效果的？"><a href="#4-Fragment-如何实现类似-Activity-栈的压栈和出栈效果的？" class="headerlink" title="4.Fragment 如何实现类似 Activity 栈的压栈和出栈效果的？"></a>4.Fragment 如何实现类似 Activity 栈的压栈和出栈效果的？</h3><p>Fragment 的事物管理器内部维持了一个双向链表结构，该结构可以记录我 们每次 add 的 Fragment 和 replace 的 Fragment，然后当我们点击 back 按钮 的时候会自动帮我们实现退栈操作。</p><p>Add this transaction to the back stack. This means that the transaction will be remembered after it is com and will reverse its operation when later popped off the stack.</p><p>Parameters:</p><p>name An optional name for this back stack state, or null.</p><p>transaction.addToBackStack(“name”);</p><p>//实现源码 在 BackStackRecord 中 public FragmentTransaction addToBackStack(String name) {</p><p>if (!mAllowAddToBackStack) { throw new IllegalStateException( “This FragmentTransaction is not allowed to be added to th stack.”);</p><p>}</p><p>mAddToBackStack = true;</p><p>mName = name;</p><p>return this;</p><p>} //上面的源码仅仅做了一个标记</p><p>除此之外因为我们要使用 FragmentManger 用的是 FragmentActivity，因 此 FragmentActivity 的 onBackPress 方法必定重新覆写了。打开看一下，发现 确实如此。</p><p>/**</p><ul><li>Take care of popping the fragment back stack or finishing the activit * as appropriate.</li></ul><p>*/ public void onBackPressed() { if (!mFragments.popBackStackImmediate()) { finish(); } } //mFragments 的原型是 FragmentManagerImpl，看看这个方法都干嘛了</p><p>@Override</p><p>public boolean popBackStackImmediate() { checkStateLoss(); executePendingTransactions(); return popBackStackState(mActivity.mHandler, null, -1, 0); }</p><p>//看看 popBackStackState 方法都干了啥，其实通过名称也能大概了解 只给几个片段吧，代 了</p><p>while (index &gt;= 0) { //从后退栈中取出当前记录对象 BackStackRecord bss = mBackStack.get(index); if (name != null &amp;&amp; name.equals(bss.getName())) { break; } if (id &gt;= 0 &amp;&amp; id == bss.mIndex) { break; } index–;</p><p>}</p><h3 id="5-Fragment-在你们项目中的使用"><a href="#5-Fragment-在你们项目中的使用" class="headerlink" title="5.Fragment 在你们项目中的使用"></a>5.Fragment 在你们项目中的使用</h3><p>Fragment 是 android3.0 以后引入的的概念，做局部内容更新更方便，原</p><p>来为了到达这一点要把多个布局放到一个 activity 里面， 现在可以用多 Fragment 来代替，只有在需要的时候才加载 Fragment，提高性能。 Fragment 的好处： </p><p>（1）Fragment 可以使你能够将 activity 分离成多个可重用的组件，每个都有 它自己的生命周期和 UI。 （2）Fragment 可以轻松得创建动态灵活的 UI 设计，可以适应于不同的屏幕尺 寸。从手机到平板电脑。 </p><p>（3）Fragment 是一个独立的模块,紧紧地与 activity 绑定在一起。可以运行中 动态地移除、加入、交换等。 （4）Fragment 提供一个新的方式让你在不同的安卓设备上统一你的 UI。 （5）Fragment 解决 Activity 间的切换不流畅，轻量切换。 （6）Fragment 替代 TabActivity 做导航，性能更好。 （7）Fragment 在 4.2.版本中新增嵌套 fragment 使用方法，能够生成更好的 界面效果。</p><h3 id="6-如何切换-fragement-不重新实例化"><a href="#6-如何切换-fragement-不重新实例化" class="headerlink" title="6.如何切换 fragement,不重新实例化"></a>6.如何切换 fragement,不重新实例化</h3><p>翻看了 Android 官方 Doc，和一些组件的源代码，发现 replace()这个方法只是 在上一个 Fragment 不再需要时采用的简便方法.</p><p>正确的切换方式是 add()，切换时 hide()，add()另一个 Fragment；再次切换时， 只需 hide()当前，show()另一个。</p><p>这样就能做到多个 Fragment 切换不重新实例化：</p><p>public void switchContent(Fragment from, Fragment to) {</p><p>if (mContent != to) {</p><p>mContent = to;</p><p>FragmentTransaction transaction =mFragmentMan.beginTransaction().setCustomAnimations(android.R.anim.fad e_in, R.anim.slide_out);</p><p>if (!to.isAdded()) { // 先判断是否被 add 过 transaction.hide(from).add(R.id.content_frame, to).commit(); // 隐藏 当前的 fragment，add 下一个到 Activity 中</p><p>} else { transaction.hide(from).show(to).commit(); // 隐藏当前的 fragment，显示下一个 }</p><p>}</p><h2 id="UI"><a href="#UI" class="headerlink" title="UI"></a>UI</h2><p>setContentView的内部过程(字节跳动)</p><h3 id="一、View绘制及自定义View"><a href="#一、View绘制及自定义View" class="headerlink" title="一、View绘制及自定义View"></a>一、View绘制及自定义View</h3><h4 id="1-View的总体绘制过程："><a href="#1-View的总体绘制过程：" class="headerlink" title="1. View的总体绘制过程："></a><strong>1. View</strong>的总体绘制过程：</h4><p>①当Activity对象被创建完成，会将DecorView添加到Window中（显示），同时创建ViewRoot的实现对象ViewRootImpl与之关联。ViewRootImpl会调用performTraversals来进行View的绘制过程。</p><p>②经过测量measure,布局layout,绘制draw三个主要阶段才能完成一个View的绘制过程，分别是用于测量宽、高；确定在父容器中的位置；绘制在屏幕上三个过程。而measure方法会调用onMeasure函数，这其中又会调用子元素的measure函数，如此反复就能完成整个View树的遍历过程。其他两个流程也同样如此。</p><h5 id="1-1测量阶段"><a href="#1-1测量阶段" class="headerlink" title="1.1测量阶段"></a>1.1测量阶段</h5><p>在 View 的测量阶段会执行两个方法，measure() 和onMeasure()。</p><p><strong>measure()</strong> ： 调度方法，主要做一些前置和优化工作，并最终会调用 onMeasure() 方法执行实际的测量工作；</p><p><strong>onMeasure()</strong> ： 实际执行测量任务的方法，主要用与测量 View 尺寸和位置(宽高和左右上下)。在自定义 View 的 onMeasure() 方法中，View 根据自己的特性和父 View 给的参考的测量规格算出自己的期望尺寸(测量尺寸)，并通过 setMeasuredDimension() 方法告知父 View 自己的期望(想要的)尺寸。</p><blockquote><p><strong>注意：</strong><br> 多数情况下，这里的期望尺寸就是 View 的最终尺寸。不过最终 View 的期望尺寸和实际尺寸是不是一样还要看它的父 View 会不会同意。View 的父 View 最终会通过调用 View 的 layout() 方法告知 View 的实际尺寸，并且在 layout() 方法中 View 需要将这个实际尺寸保存下来，以便绘制阶段和触摸反馈阶段使用，</p></blockquote><h5 id="1-2布局阶段"><a href="#1-2布局阶段" class="headerlink" title="1.2布局阶段"></a>1.2布局阶段</h5><p>在 View 的布局阶段确定视图的位置，会执行两个方法layout()和onLayout().</p><ul><li><p><strong>layout(int l, int t, int r, int b)</strong> ： 四个参数，分别代表着左、上、右、下的坐标，当然这个坐标是相对于当前视图的父视图而言的。保存 View 的实际尺寸（测量出的高度和宽度）。调用 setFrame() 方法保存 View 的实际尺寸，调用 onSizeChanged() 通知开发者 View 的尺寸更改了，并最终会调用 onLayout() 方法让子 View 布局（如果有子 View 的话。因为自定义 View 中没有子 View，所以自定义 View 的 onLayout() 方法是一个空实现）；</p></li><li><p><strong>onLayout(boolean changed, int l, int t, int r, int b)</strong> ： View的这个方法是1个空方法，因为它没有子 View。ViewGroup中的onLayout()是一个抽象方法。如果是 ViewGroup 的话，在 onLayout() 方法中需要调用子 View 的 layout() 方法，将子 View 的实际尺寸传给它们，让子 View 保存自己的实际尺寸。因此，在自定义 View 中，不需重写此方法，在自定义 ViewGroup 中，需重写此方法。完成之后可以根据getTop,getBottom,getLeft,getRight来获得4个属性值，完成之后可以调用getWidth和getHeight来获取View实际的宽和高；</p></li></ul><h5 id="1-3绘制阶段"><a href="#1-3绘制阶段" class="headerlink" title="1.3绘制阶段"></a>1.3绘制阶段</h5><p>在 View 的绘制阶段就决定了View的显示，完成draw才能真正显示出来，会执行一个方法——draw()。</p><p>draw() 是绘制阶段的总调度方法，在其中会调用绘制背景的方法 drawBackground()、绘制主体的方法 onDraw()、绘制子 View 的方法 dispatchDraw() 和 绘制前景的方法 onDrawForeground()：</p><ul><li>draw()</li></ul><p><strong>draw()</strong> ： 绘制阶段的总调度方法，在其中会调用绘制背景的方法 drawBackground()、绘制主体的方法 onDraw()、绘制子 View 的方法 dispatchDraw() 和 绘制前景的方法 onDrawForeground()；</p><p><strong>drawBackground()</strong> ： 绘制背景的方法，不能重写，只能通过 xml 布局文件或者 setBackground() 来设置或修改背景；</p><p><strong>onDraw()</strong> ： 绘制 View 主体内容的方法，通常情况下，在自定义 View 的时候，只用实现该方法即可；</p><p><strong>dispatchDraw()</strong> ： 绘制子 View 的方法。同 onLayout() 方法一样，在自定义 View 中它是空实现，什么也不做。但在自定义 ViewGroup 中，它会调用 ViewGroup.drawChild() 方法，在 ViewGroup.drawChild() 方法中又会调用每一个子 View 的 View.draw() 让子 View 进行自我绘制；</p><p><strong>onDrawForeground()</strong> ： 绘制 View 前景的方法，也就是说，想要在主体内容之上绘制东西的时候就可以在该方法中实现。</p><blockquote><p><a href="https://juejin.im/post/5d6c8f7cf265da03d42fbe58#heading-15" target="_blank" rel="noopener">https://juejin.im/post/5d6c8f7cf265da03d42fbe58#heading-15</a></p></blockquote><h6 id="getMeasureWidth-和getWidth-的区别？"><a href="#getMeasureWidth-和getWidth-的区别？" class="headerlink" title="getMeasureWidth()和getWidth()的区别？"></a>getMeasureWidth()和getWidth()的区别？</h6><pre><code>- 首先getMeasureWidth()方法在measure()过程结束后就可以获取到了，而getWidth()方法要在layout()过程结束后才能获取到。</code></pre><ul><li>另外，getMeasureWidth()方法中的值是通过setMeasuredDimension()方法来进行设置的，而getWidth()方法中的值则是通过视图右边的坐标减去左边的坐标计算出来的。</li></ul><h4 id="2-自定义-View-步骤"><a href="#2-自定义-View-步骤" class="headerlink" title="2. 自定义 View 步骤"></a>2. 自定义 View 步骤</h4><ol><li>自定义属性的声明与获取；</li><li>重写测量阶段相关方法（onMeasure()）；</li><li>重写布局阶段相关方法（onLayout()（仅 ViewGroup 需要重写））；</li><li>重写绘制阶段相关方法（onDraw() 绘制主体、dispatchDraw() 绘制子 View 和 onDrawForeground() 绘制前景）；</li><li>onTouchEvent()；</li><li>onInterceptTouchEvent()（仅 ViewGroup 有此方法）；</li></ol><h4 id="3-View的刷新机制"><a href="#3-View的刷新机制" class="headerlink" title="3. View的刷新机制"></a>3. View的刷新机制</h4><h3 id="二、事件分发以及滑动冲突的解决"><a href="#二、事件分发以及滑动冲突的解决" class="headerlink" title="二、事件分发以及滑动冲突的解决"></a>二、事件分发以及滑动冲突的解决</h3><p>1、View<strong>的事件分发机制</strong></p><p>事件分发机制传递的就是MotionEvent，也就是点击事件，这个传递过程就是分发的过程。</p><p>（1）点击事件的传递规则</p><p>三大函数：</p><p><strong>public boolean dispatchTouchEvent(MotionEvent ev)</strong></p><p>这个函数用于进行事件的分发，如果这个时间能够传递给当前的View，那么这个方法一定会调用，返回的结果表示是否消耗当前事件，返回的结果受onInterceptTouchEvent和下级View的影响。</p><p><strong>public boolean onInterceptTouchEvent(MotionEvent ev)</strong></p><p>这个函数内部调用，用于判断是否拦截某个事件，如果当前View拦截了某个事件，那么同一事件序列中，此方法不会被再次调用。</p><p><strong>public boolean onTouchEvent(MotionEvent ev)</strong></p><p>在<strong>dispatchTouchEvent</strong>中调用，用于处理点击事件，其返回结果表示是否消耗当前事件，如果不消耗，那么同一事件序列中，当前View无法再接收到事件。</p><p> 伪代码：</p><p>public boolean dispatchTouchEvent(MotionEvent ev){</p><p>​    boolean consume = false;</p><p>​    if(<strong>onInterceptTouchEvent(ev)</strong>){</p><p>​       consume = <strong>onTouchEvent</strong>(ev);</p><p>} else {</p><p>​    consume = child. <strong>dispatchTouchEvent(ev);</strong></p><p>}</p><p>return consume;</p><p>}</p><p>通过上述伪代码，我们可以大致得出传递的规则：</p><p>（1）对于一个根ViewGroup来说，点击事件产生后，首先会传递给它自己，如果它的<strong>onInterceptTouchEvent</strong>返回true，那么就表示它要拦截当前事件，那么它的<strong>onTouchEvent</strong>函数就会被调用；如果返回false，那么就传递给子元素，直到事件被处理。</p><p>（2）当一个View需要进行事件处理时，如果它设置了OnTouchListener，那么它的onTouch方法就会被调用，<strong>这时事件如何处理还要看**</strong>onTouch<strong><strong>的返回值，如果返回false</strong></strong>，那么当前View<strong><strong>的onTouchEvent</strong></strong>就会被调用；如果返回true<strong><strong>，那么onTouchEvent</strong></strong>方法将不会调用！！！！！！。**由此可见，OnTouchListener的优先级高于onTouchEvent。在onTouchEvent方法中，如果当前设置有OnClickListener，那么它的onClick会被调用，其优先级最低，处于调用的末端。</p><p>（3）如果一个事件传递到View，如果此View的onTouchEvent返回false，就是不消耗事件，那么此View的父容器的onTouchEvent就会被调用，也就是说如果事件最终没有View处理，那么处理的人就是Activity，也就是责任链模式。</p><p> 一些结论：</p><p>（1）同一个事件序列指的是从手指接触屏幕开始，到手指离开屏幕的过程，也就是DOWN—MOVE…MOVE—UP，这是一个事件序列。</p><p>（2）同一个事件序列只能被同一个View所消耗，因为一旦一个View拦截了某个事件，那么同一序列内的所有事件都会直接交给他处理。但是要注意，如果事件在之前又被别人拦截，根本不交给它处理的情况也会发生——事件拦截。</p><p>（3）某个View一旦开始处理事件，如果它不消耗ACTION_DOWN事件（onTouchEvent返回了false），那么同一事件序列中的其他事件都不会再交给他处理，即父元素的onTouchEvent会被调用，交给父元素来处理（责任链模式）。</p><p>如果某个View不处理除了ACTION_DOWN之外的其他事件，那么这个点击事件就会消失，并且当前View可以持续接收到后续事件（无论你选择不选择处理），最终消失的会被Activity处理。</p><p>（4）ViewGroup的onInterceptTouchEvent方法默认返回false，即不拦截任何事件，而View没有onInterceptTouchEvent函数，即不能选择是否拦截，必须拦截，但可以不处理。</p><p>（5）View的onTouchEvent默认都会消耗事件，返回true，除非它是不可点击的。</p><p>（6）对于onTouch和onClick的总结</p><p><strong>规律（总结）：</strong></p><p>（1）首先没有设置OnClickListener的情况下，onTouch的返回值表示的就是View对点击事件是否消耗，如果在DOWN事件传递过来时返回false，那么剩下的MOVE直到UP的事件都不会被onTouch接收到；如果在DOWN事件返回true，那么剩下的直到UP的事件都会接受到，无论你之后的返回值。<br> （2）在同时设置了OnTouchListener与OnClickListener之后，情况就有些复杂了：<br> <strong>情况1**</strong>：<strong>如果onTouch在DOWN时返回了true，那么onTouch就和（1）一样收到剩下的所有事件，但onClick就不会被执行；<br> <strong>情况2</strong></strong>：**如果onTouch在DOWN时返回了false，与（1）不同的是，onTouch尽管在DOWN时返回了false，但之后的所有事件仍能接受到，并且onClick会在之后被调用。</p><p>public boolean dispatchTouchEvent(MotionEvent event){ </p><p>  … … </p><p>  if(onFilterTouchEventForSecurity(event)){ </p><p>​    ListenerInfo li = mListenerInfo; </p><p>​    if(li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED </p><p>​      &amp;&amp; li.mOnTouchListener.onTouch(this, event)) { //（1）onTouch调用</p><p>​      return true; </p><p>​    } </p><p>​    if(onTouchEvent(event)){ //（2）onTouchEvent调用</p><p>​      return true; </p><p>​    } </p><p>  } </p><p>  … … </p><p>  return false; </p><p>} </p><p>分析：</p><p>（1）如果没有设置OnClickListener，只设置了OnTouchListener，那么在代码（1）处就会调用onTouch，如果DOWN事件时返回了true，那么剩下的事件都会交由此View进行处理；如果返回了false，那么就会执行代码（2）处的onTouchEvent函数，如果设置了OnClickListener，就会在其中进行调用，如果没有设置，dispatchTouchEvent就会返回false，那么剩下的事件都不会交由此View进行处理；<br> （2）如果同时设置了OnTouchListener与OnClickListener，那么我们再按上面的两种情况进行分析：<br> <strong>情况1**</strong>：<strong>onTouch在DOWN时返回了true，那么代码（1）处就得到了真的结果，直接就返回了true，可以知道后面代码（2）处的onTouchEvent函数不会被执行，那么自然你的OnClickListener就不起作用了，onClick就不会被执行； **<br>** <strong>情况2</strong></strong>：**onTouch在DOWN时返回了false，那么当DOWN事件传递来的时候，代码（1）处就不会得到真的结果，也就是说onTouch中你表示自己不会处理这个事件序列了，后面代码（2）处的onTouchEvent函数就会得到执行，而如果你设置了OnClickListener，View就会处于CLICKABLE状态，那么onTouchEvent函数就会返回true，又表示你可以处理这个点击事件序列了，dispatchTouchEvent就会返回true，那么这时后面的事件由于DOWN时返回true，就会统统交由此View进行处理，自然你的onTouch中也能够监听到后面的所有事件！这样上面的情况就能够得到解释了。</p><p><strong>二、滑动冲突的解决方法</strong></p><p>（1）滑动冲突的类型</p><p>滑动冲突分为三种类型，第一类是外部和内部滑动方向不一致，第二类是外部和内部滑动方向一致，第三类是前两种嵌套的模式。</p><p>处理这三种类型的规则分为两类，对于第一种类型，我们可以根据滑动方向来处理，符合处理方向的分配给对应的控件；对于2、3种类型，必须根据业务上的区别来处理，某种状态的处理时间分发给对应的控件来处理。</p><p>（2）滑动冲突的解决方式</p><p><strong>解决方式一：外部拦截法</strong></p><p>外部拦截法指点击事件首先都会经过父容器的拦截处理，父容器如果需要此事件就进行拦截，如果不需要此事件就不进行拦截，这样就可以解决滑动冲突问题。外部拦截法主要就是重写父容器的onInterceptTouchEvent方法，但是要注意，父容器拦截不能在ACTION_DOWN中返回true，否则之后的所有事件序列都会交给它处理，无论返回什么，因为不会再调用它的onInterceptTouchEvent函数了。所以父控件应该在ACTION_MOVE中选择是否拦截。但是这种拦截的问题是，如果拦截了，那么子控件的onClick事件将无法再出发了。</p><p>伪代码如下：</p><p>public boolean onInterceptTouchEvent(MotionEvent ev) {<br>   boolean intercepted = false;<br>   switch (ev.getAction()){<br>     case MotionEvent.<em>ACTION_DOWN</em>:<br>       intercepted = false;<br>       break;<br>     case MotionEvent.<em>ACTION_MOVE</em>:<br>       if(父控件需要处理){<br>         intercepted = true;<br>       } else{<br>         intercepted = false;<br>       }<br>       break;<br>     case MotionEvent.<em>ACTION_UP</em>:<br>       intercepted = false;<br>       break;<br>   }</p><p>   return intercepted;<br> }</p><p><strong>解决方法二：内部拦截法</strong></p><p>​    内部拦截法指的是父容器不拦截任何事件，所有事件全部传递给子元素，如果子元素需要就进行消耗，否则交由父容器进行处理。这种方式需要配合ViewGroup的FLAG_DISALLOW_INTERCEPT标志位来使用。设置此标志为可以通过requestDisallowIntercept TouchEvent函数来设置，如果设置了此标志位，那么ViewGroup就无法拦截除了ACTION_DOWN之外的任何事件。这样首先我们保证ViewGroup的onInterceptTouchEvent方法除了DOWN其他都返回true，DOWN返回false，这样保证了不会拦截DOWN事件，交给它的子View进行处理；重写View的dispatchTouchEvent函数，在DOWN中设置parent.requestDisallowInterceptTouchEvent(true)，这样父控件在默认的情况下DOWN之后的所有事件它都拦截不到，交由子View来处理，View在MOVE中判断父控件需要时，调用parent.requestDisallow InterceptTouchEvent(false)，这样父控件的拦截又起作用了，相应的事件交给了父控件进行处理。伪代码如下：</p><p><strong>父控件中：</strong></p><p>@Override<br> public boolean onInterceptTouchEvent(MotionEvent ev) {<br>   int action = ev.getAction();<br>   if(action == MotionEvent.<em>ACTION_DOWN</em>){<br>     return false;<br>   } else {<br>     return true;<br>   }<br> }</p><p><strong>子View**</strong>中：**</p><p>@Override<br> public boolean dispatchTouchEvent(MotionEvent ev) {</p><p>   switch (ev.getAction()){<br>     case MotionEvent.<em>ACTION_DOWN</em>:<br>       getParent().requestDisallowInterceptTouchEvent(true);<br>       break;<br>     case MotionEvent.<em>ACTION_MOVE</em>:<br>       if(父控件需要此点击事件){<br>         getParent().requestDisallowInterceptTouchEvent(false);<br>       }<br>       break;<br>     case MotionEvent.<em>ACTION_UP</em>:<br>       break;<br>   }<br> }</p><p><strong>滑动冲突处理案例：下拉刷新实现原理。</strong></p><h1 id="第二章-高频"><a href="#第二章-高频" class="headerlink" title="第二章 高频"></a>第二章 高频</h1><ul><li>handler</li><li>图片处理</li><li>网络httpclient okhttp  httpurlconnection</li><li>性能优化</li><li>内存泄露原因LeakCanary</li><li>四种引用</li><li>自定义View, 滑动冲突解决</li></ul><h2 id="Binder"><a href="#Binder" class="headerlink" title="Binder"></a>Binder</h2><p>1.Binder原理</p><p><img src=".%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B2%BE%E7%BC%96_images/image-20200513151345495.png" alt="image-20200513151345495"></p><p><img src=".%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B2%BE%E7%BC%96_images/image-20200513150605562.png" alt="image-20200513150605562"></p><ul><li>Binder通信采用C/S架构</li><li>service引用</li></ul><h5 id="为什么要使用Binder？"><a href="#为什么要使用Binder？" class="headerlink" title="为什么要使用Binder？"></a>为什么要使用Binder？</h5><ol><li><strong>管道：</strong>在创建时分配一个page大小的内存，缓存区大小比较有限；</li><li><strong>消息队列</strong>：信息复制两次，额外的CPU消耗；不合适频繁或信息量大的通信；</li><li><strong>共享内存</strong>：无须复制，共享缓冲区直接付附加到进程虚拟地址空间，速度快；但进程间的同步问题操作系统无法实现，必须各进程利用同步工具解决；</li><li><strong>套接字</strong>：作为更通用的接口，传输效率低，主要用于不通机器或跨网络的通信；</li></ol><p><strong>性能方面</strong></p><p>Binder数据拷贝只需要一次，而管道、消息队列、Socket都需要2次，共享内存方式一次内存拷贝都不需要，但实现方式又比较复杂。</p><p><strong>安全方面</strong></p><p>传统的进程通信方式对于通信双方的身份并没有做出严格的验证，</p><p>传统Linux IPC的接收方无法获得对方进程可靠的UID/PID，从而无法鉴别对方身份；而Android作为一个开放的开源体系，拥有非常多的开发平台，App来源甚广，因此手机的安全显得额外重要；对于普通用户，绝不希望从App商店下载偷窥隐射数据、后台造成手机耗电等等问题，传统Linux IPC无任何保护措施，完全由上层协议来确保。</p><p>而Binder机制从协议本身就支持对通信双方做身份校检，因而大大提升了安全性。</p><p>、</p><p>作者：Ruheng<br>链接：<a href="https://www.jianshu.com/p/4920c7781afe" target="_blank" rel="noopener">https://www.jianshu.com/p/4920c7781afe</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h2 id="图片处理"><a href="#图片处理" class="headerlink" title="图片处理"></a>图片处理</h2><h3 id="加载图片"><a href="#加载图片" class="headerlink" title="加载图片"></a>加载图片</h3><h4 id="1-如何加载一张图片"><a href="#1-如何加载一张图片" class="headerlink" title="1.如何加载一张图片"></a>1.如何加载一张图片</h4><p>BitmapFactory类提供了4类方法：<code>decodeFile</code>，<code>decodeResouce</code>，<code>decodeStream</code>，和<code>decodeByteArray</code>，分别用于支持从文件系统，资源，输入流以及字节数组中加载出一个<code>Bitmap</code>对象    ，其中<code>decodeFile</code>和<code>decodeResource</code>又间接调用了<code>decodeStream</code>方法，这四类方法最终是在<code>Android</code>底层实现的，对应<code>BitmapFactory</code>类的几个native方法</p><h4 id="2-ImageVIew是如何加载图片的"><a href="#2-ImageVIew是如何加载图片的" class="headerlink" title="2.ImageVIew是如何加载图片的"></a>2.ImageVIew是如何加载图片的</h4><ul><li><p>通过<code>BitmapFactory</code>的<code>decodeStream</code>生成Bitmap对象</p></li><li><p>再构造<code>BitmapDrawable</code>对象</p></li><li><p>再把这个<code>Drawable</code>设置给<code>ImageView</code></p></li><li><p>后续就是<code>ImageView</code>自己对Drawable进行缩放，绘制的逻辑，继而变成了一张显示在手机上的图片</p></li></ul><p>缩放比例：</p><p>图片所在文件夹：drawable（160dpi）、drawable-xhdpi（320dpi）、drawable-xxhdpi（480dpi）、drawable-xxxhdpi（720dpi）</p><p>你手机是480dpi的，图片放在drawable文件夹下，则比例 = 480/ 160 会放大3倍</p><h4 id="3-如何高效加载一张图片-压缩图片"><a href="#3-如何高效加载一张图片-压缩图片" class="headerlink" title="3.如何高效加载一张图片(压缩图片)"></a>3.如何高效加载一张图片(压缩图片)</h4><p>通过<code>BitmapFactory.Options</code>对图片进行采样缩放，主要用到了它的inSampleSize参数,及采样率。</p><ul><li>inSampleSize为&lt;=1，采用后的图片为原始大小</li><li>inSampleSize为4,缩小为原来的1/16</li><li>inSampleSize不为2的指数，系统会向下取整选择一个最接近的的指数来代替，比如3，系统会选择2，但并非所有Android版本都成立</li></ul><p>如何获取采用率?</p><p>(1)将<code>BitmapFactory.Options</code>的inJustDecodeBounds参数设置为true并加载图片</p><p>(2)从<code>BitmapFactory.Options</code>中取出图片的原始宽高信息，它们对应于outWidth和outHeight参数</p><p>(3)根据采样率的规则并结合目标View的所需大小计算出采样率inSampleSize</p><p>(4)将<code>BitmapFactory.Options</code>的inJustDecodeBounds参数设为false,然后重新加载图片</p><h3 id="4-利用矩阵放大Bitmap"><a href="#4-利用矩阵放大Bitmap" class="headerlink" title="4.利用矩阵放大Bitmap"></a>4.利用矩阵放大Bitmap</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> Bitmap <span class="token function">bitMapScale</span><span class="token punctuation">(</span>Bitmap bitmap<span class="token punctuation">,</span><span class="token keyword">float</span> scale<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Matrix matrix <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Matrix</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        matrix<span class="token punctuation">.</span><span class="token function">postScale</span><span class="token punctuation">(</span>scale<span class="token punctuation">,</span>scale<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//长和宽放大缩小的比例</span>        Bitmap resizeBmp <span class="token operator">=</span> Bitmap<span class="token punctuation">.</span><span class="token function">createBitmap</span><span class="token punctuation">(</span>bitmap<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>bitmap<span class="token punctuation">.</span><span class="token function">getWidth</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>bitmap<span class="token punctuation">.</span><span class="token function">getHeight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>matrix<span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> resizeBmp<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/Android/Untitled 1</title>
      <link href="blog/3431503302.html"/>
      <url>blog/3431503302.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、Android基础"><a href="#一、Android基础" class="headerlink" title="一、Android基础"></a>一、Android基础</h1><ol><li>⭐️⭐️⭐️⭐️⭐️四大组件<ol><li>知道activity生命生命周期 启动模式</li><li>intent用法不熟</li><li>其他几个组件也熟</li></ol></li><li>⭐️⭐️⭐️⭐️⭐️UI及VIew绘制和事件分发<ol><li>了解，正在学</li></ol></li><li>⭐️⭐️⭐️⭐️⭐️Handler消息机制<ol><li>熟一些，看过课</li></ol></li><li>序列化<ol><li>没懂 原理，面试有背问到</li></ol></li><li>⭐️⭐️⭐️⭐️图片相关bitmap,drawable,mipmap<ol><li>这几个没搞清楚</li></ol></li><li>⭐️⭐️动画<ol><li>原来学过，忘记了</li></ol></li><li>⭐️⭐️⭐️⭐️⭐️android中的进程和线程<ol><li>进程间通信搞不清楚，Binder没看懂</li></ol></li><li>android中的资源dimen,color,attrs,styles(dp,sp,px)<ol><li>有一些</li></ol></li><li>⭐️⭐️⭐️持久化存储sqlite等<ol><li>sqlite 原来学过一些基本用法，忘了</li></ol></li><li>架构设计MVP等<ol><li>知道MVC MVP 还有个mvvm没了解过</li></ol></li><li>Android 10 的新特性<ol><li>目前还没了解过</li></ol></li></ol><h1 id="二、Android高级"><a href="#二、Android高级" class="headerlink" title="二、Android高级"></a>二、Android高级</h1><ol><li>⭐️⭐️⭐️⭐️性能优化<ol><li>没有什么实战</li></ol></li><li>⭐️⭐️⭐️⭐️网络框架okhttp<ol><li>不熟悉，面试可能会问源码</li></ol></li><li>⭐️⭐️⭐️⭐️图片处理框架picasso,glide<ol><li>picasso最近有用，源码没研究过，图片处理面试可能会问吧</li></ol></li><li>⭐️⭐️⭐️⭐️NDK jni</li><li>⭐️kotlin</li><li>音视频</li><li>⭐React Native</li><li>⭐RxJava</li><li>⭐️EventBus</li><li>⭐️热修复插件化</li><li>读过哪些(Framework)源码</li><li>Gradle</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/Android/Android基础/四大组件</title>
      <link href="blog/1499881742.html"/>
      <url>blog/1499881742.html</url>
      
        <content type="html"><![CDATA[<h2 id="广播接收者"><a href="#广播接收者" class="headerlink" title="广播接收者"></a>广播接收者</h2><h3 id="1-本地广播和全局广播的差别"><a href="#1-本地广播和全局广播的差别" class="headerlink" title="1.本地广播和全局广播的差别"></a>1.本地广播和全局广播的差别</h3><p>BroadcastReceiver是针对应用间、应用与系统间、应用内部进行通信的一种方式<br> LocalBroadcastReceiver仅在自己的应用内发送接收广播，也就是只有自己的应用能收到，数据更加安全广播只在这个程序里，而且效率更高。</p><h2 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h2><h4 id="2-1BroadcastReceiver-使用"><a href="#2-1BroadcastReceiver-使用" class="headerlink" title="2.1BroadcastReceiver 使用"></a>2.1BroadcastReceiver 使用</h4><p>1.制作intent（可以携带参数）<br> 2.使用sendBroadcast()传入intent;<br> 3.制作广播接收器类继承BroadcastReceiver重写onReceive方法（或者可以匿名内部类啥的）<br> 4.在java中（动态注册）或者直接在Manifest中注册广播接收器（静态注册）使用registerReceiver()传入接收器和intentFilter<br> 5.取消注册可以在OnDestroy()函数中，unregisterReceiver()传入接收器</p><h4 id="2-2LocalBroadcastReceiver-使用"><a href="#2-2LocalBroadcastReceiver-使用" class="headerlink" title="2.2LocalBroadcastReceiver 使用"></a>2.2LocalBroadcastReceiver 使用</h4><p>LocalBroadcastReceiver不能静态注册，只能采用动态注册的方式。<br> 在发送和注册的时候采用，LocalBroadcastManager的sendBroadcast方法和registerReceiver方法</p><h3 id="3-生命周期"><a href="#3-生命周期" class="headerlink" title="3.生命周期"></a>3.生命周期</h3><h4 id="3-1-动态注册的生命周期，在activity生命周期内，应在activity销毁前注销广播"><a href="#3-1-动态注册的生命周期，在activity生命周期内，应在activity销毁前注销广播" class="headerlink" title="3.1 动态注册的生命周期，在activity生命周期内，应在activity销毁前注销广播"></a>3.1 动态注册的生命周期，在activity生命周期内，应在activity销毁前注销广播</h4><p>3.2 静态注册的生命周期，全局。但是只有onReceive的10s</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/Android/任何和返回栈</title>
      <link href="blog/1885873851.html"/>
      <url>blog/1885873851.html</url>
      
        <content type="html"><![CDATA[<h3 id="任务和activity-back-stack"><a href="#任务和activity-back-stack" class="headerlink" title="任务和activity back stack"></a>任务和activity back stack</h3><p>任务是用户在执行某项工作时与之互动的一系列 Activity 的集合。这些 Activity 按照每个 Activity 打开的顺序排列在一个返回堆栈中。</p><ul><li>singleInsance:这种模式的activity会新开并独占一个task,  多个app可能都会调浏览器，这种模式适合浏览器应用。一般用得很少</li><li>singleTop:栈顶只能有1个，但栈内可以有多个。比如搜索activity，二维码扫描</li><li>singleTask:task中只能有1个，上面的会全部清除。比如应用的主界面</li><li>standard:调用startActivity都会创建实例</li></ul><p>默认情况下，新 Activity 会启动到调用 <code>startActivity()</code> 的 Activity 的任务中。它会被推送到调用方 Activity 所在的返回堆栈中。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/java/Untitled</title>
      <link href="blog/1348951296.html"/>
      <url>blog/1348951296.html</url>
      
        <content type="html"><![CDATA[<p>结构体干嘛的：用来规划一块内存的作用</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/java/ThreadLocal</title>
      <link href="blog/2075210878.html"/>
      <url>blog/2075210878.html</url>
      
        <content type="html"><![CDATA[<h2 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h2><p>1.对象回收是可以跟踪的，finallize()方法</p><p>对象被回收时，会调用finallize方法</p><p>2.System.in.read()//阻塞main线程，给垃圾回收线程时间执行</p><p>①main线程退出，垃圾回收线程也随即退出，可能对象未回收玩，就已退出</p><p>②③</p><p>3.变量只能是强引用，要想软引用，得变量–&gt;软(逻辑中的软)引用对象–&gt;堆中对象</p><pre class=" language-java"><code class="language-java">SoftReference<span class="token operator">&lt;</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> m <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SoftReference</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span> </code></pre><p>4.软引用其实非常简单（堆总共20M，先new 10M软 ,再new 15M强）</p><p>内存不够时，会被回收，内存够时会回收。（垃圾回收一次后，任然不够，回收软引用指向的内存）</p><p>5.强引用，宁可溢出，也不会回收你</p><p>6.软引用有什么用：非常适合来做缓存（内存够的话先在里面呆着）</p><h2 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h2><pre class=" language-java"><code class="language-java">WeakReference<span class="token operator">&lt;</span>M<span class="token operator">></span> m <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakReference</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">M</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="虚引用（NIO-NETTY）"><a href="#虚引用（NIO-NETTY）" class="headerlink" title="虚引用（NIO NETTY）"></a>虚引用（NIO NETTY）</h2><p>作用：管理直接内存</p><p>直接内存：JVM可以通过一个指针访问操作系统内存，如果从网络来的数据，就不用再拷贝一份了。</p><h2 id="ThradLocal"><a href="#ThradLocal" class="headerlink" title="ThradLocal"></a>ThradLocal</h2><p>1.Spring中多个方法嵌套调用，都要支持事务，那么数据库连接对象得是同一个</p><p>数据库连接对象不能是不同的，不能是全局的，全局的话就只有1个连接了。</p><p>Spring怎么传连接对象的，通过ThreadLocal</p><p>2.demo不同线程访问共享的静态变量  ThreadLocal，1个线程放入的，另一个线程取不出来</p><p>和线程绑定的，不同线程间隔离。</p><p>3.上面的原理，分析源码</p><p>每1个线程对象中都有1个ThreadLocalMap类的成员变量，指向一个map</p><p>ThreadLocal的set方法是以自己的引用为key,参数为value，存入当前线程的ThreadLocalMap中</p><p>Entry是理解的关键，是ThreadLocal的静态内部类，是WeakReference的子类  </p><p><img src=".ThreadLocal_images/image-20200503123723708.png" alt="image-20200503123723708"></p><p> ThreadLocalMap的get 和set 会remove所有key为null的Entry,还需要手动remove  Entry吗？</p><p>要的，因为有服务器线程7 * 24 运行，可能不执行get,set方法，这样做可以防止Entry内存泄露。</p><ul><li>如果是线程池的话，线程用完，要清除threadlocal. 以防下次用时，可能用的是旧值。</li></ul><p><img src=".ThreadLocal_images/image-20200503124758577.png" alt="image-20200503124758577"></p><p>强引用：默认的。</p><p>软引用：缓存；</p><p>弱引用：防内存泄露</p><p>虚引用：jvm管理直接内存用的</p><p>ThreadLocal如何使得一个线程只有1个Looper?</p><p>1.Looper是如何创建的？</p><p>Looper.prepare();</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Looper</span> <span class="token punctuation">{</span>  <span class="token keyword">static</span> <span class="token keyword">final</span> ThreadLocal<span class="token operator">&lt;</span>Looper<span class="token operator">></span> sThreadLocal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token operator">&lt;</span>Looper<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">prepare</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> quitAllowed<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>sThreadLocal<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"Only one Looper may be created per thread"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        sThreadLocal<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Looper</span><span class="token punctuation">(</span>quitAllowed<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>2.不同线程访问共享静态变量sThreadLocal，调用set方法，以共享的<code>ThreadLocal</code>类的对象的引用为key,以new的Looper对象对Value。它是往当前线程的<code>ThreadLocalMap</code>中存入key,value的；</p><p>不同线程通过get取时，拿到的是自己线程的Looper</p><p>3.多线程访问共享静态变量sThreadLocal, 1个线程存的东西，另一个线程取不到，起到了线程隔离的作用。</p><p>4.ThreadLocalMap中有一个Entry数组，key为什么要继承自弱引用呢？</p><p>因为sThreadLocal至空之后，线程Entry的属性key任然持有ThreadLocal的引用，value也不能释放。会有内存泄露的问题</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/Android/UI/自定义view</title>
      <link href="blog/2288148669.html"/>
      <url>blog/2288148669.html</url>
      
        <content type="html"><![CDATA[<p><img src=".Untitled_images/image-20200501100941411.png" alt="image-20200501100941411"></p><p> <img src=".Untitled_images/image-20200501102424295.png" alt="image-20200501102424295">)<img src=".Untitled_images/image-20200501101022256.png" alt="image-20200501101022256"></p><p><img src=".Untitled_images/image-20200501101814766.png" alt="image-20200501101814766"></p><p>viewGroup不需要draw自己</p><p><img src=".Untitled_images/image-20200501101854285.png" alt="image-20200501101854285"></p><p><img src=".Untitled_images/image-20200501102003897.png" alt="image-20200501102003897"></p><ul><li>每一个viewgroup的大小跟他的父和孩子都相关，match_parent跟父一样，wrap_content表示取决于孩子</li><li>父给子参考大小，子测试自己，告诉父，父测出自身大小</li></ul><h3 id="怎么度量"><a href="#怎么度量" class="headerlink" title="怎么度量"></a>怎么度量</h3><p>1.度量孩子大小</p><p>2.度量自己大小</p><h4 id="onMeaseure-中的参数widthMeasureSpec"><a href="#onMeaseure-中的参数widthMeasureSpec" class="headerlink" title="onMeaseure()中的参数widthMeasureSpec"></a>onMeaseure()中的参数widthMeasureSpec</h4><ol><li><p>是怎么来的</p><p>父给的。</p></li><li><p>和xml中的android:layout_width=”wrap_content”有什么关系</p></li></ol><h4 id="LayoutParams是什么东西？"><a href="#LayoutParams是什么东西？" class="headerlink" title="LayoutParams是什么东西？"></a>LayoutParams是什么东西？</h4><p>就是xml中的布局参数xml中的android:layout_width=”wrap_content”</p><h4 id="MeasureSpec是什么，它的意义，一般怎样计算MeasureSpec？与LayoutParams有什么关系？【今日头条面试题】"><a href="#MeasureSpec是什么，它的意义，一般怎样计算MeasureSpec？与LayoutParams有什么关系？【今日头条面试题】" class="headerlink" title="MeasureSpec是什么，它的意义，一般怎样计算MeasureSpec？与LayoutParams有什么关系？【今日头条面试题】"></a>MeasureSpec是什么，它的意义，一般怎样计算MeasureSpec？与LayoutParams有什么关系？【今日头条面试题】</h4><ol><li><p><img src=".%E8%87%AA%E5%AE%9A%E4%B9%89view_images/image-20200501110613699.png" alt="image-20200501110613699"></p></li></ol><p><img src=".%E8%87%AA%E5%AE%9A%E4%B9%89view_images/image-20200501110654784.png" alt="image-20200501110654784"></p><ol start="2"><li><p>MeasureSpec是给孩子用的  </p></li><li><p><img src=".%E8%87%AA%E5%AE%9A%E4%B9%89view_images/image-20200501111241724.png" alt="image-20200501111241724"></p></li><li><p><img src=".%E8%87%AA%E5%AE%9A%E4%B9%89view_images/image-20200501111317090.png" alt="image-20200501111317090"></p><p><img src=".%E8%87%AA%E5%AE%9A%E4%B9%89view_images/image-20200501111807867.png" alt="image-20200501111807867"></p></li></ol><p>分别对应。</p><p><img src=".%E8%87%AA%E5%AE%9A%E4%B9%89view_images/image-20200501111955248.png" alt="image-20200501111955248"></p><ul><li>对应有一个亿钱-&gt;&gt;&gt;</li></ul><p><img src=".%E8%87%AA%E5%AE%9A%E4%B9%89view_images/image-20200501112231920.png" alt="image-20200501112231920"></p><p><img src=".%E8%87%AA%E5%AE%9A%E4%B9%89view_images/image-20200501112356051.png" alt="image-20200501112356051"></p><p><img src=".%E8%87%AA%E5%AE%9A%E4%B9%89view_images/image-20200501113814787.png" alt="image-20200501113814787"></p><h3 id="测量完了之后，开始布局"><a href="#测量完了之后，开始布局" class="headerlink" title="测量完了之后，开始布局"></a>测量完了之后，开始布局</h3><p>首先要知道</p><p><img src=".%E8%87%AA%E5%AE%9A%E4%B9%89view_images/image-20200501114003537.png" alt="image-20200501114003537"></p><h5 id="view-getWidth-和view-getMeasuredWidth-有什么区别？"><a href="#view-getWidth-和view-getMeasuredWidth-有什么区别？" class="headerlink" title="view.getWidth()和view.getMeasuredWidth()有什么区别？"></a>view.getWidth()和view.getMeasuredWidth()有什么区别？</h5><p><img src=".%E8%87%AA%E5%AE%9A%E4%B9%89view_images/image-20200501115452357.png" alt="image-20200501115452357"></p><p>它这个类的初始化的代码放在构造函数中没有，因为onMeasure和onLayout会调用多次  </p><p><img src=".%E8%87%AA%E5%AE%9A%E4%B9%89view_images/image-20200501120219663.png" alt="image-20200501120219663"></p><p><img src=".%E8%87%AA%E5%AE%9A%E4%B9%89view_images/image-20200501120519977.png" alt="image-20200501120519977"></p><h5 id="为什么有三个构造函数？"><a href="#为什么有三个构造函数？" class="headerlink" title="为什么有三个构造函数？"></a>为什么有三个构造函数？</h5><p><img src=".%E8%87%AA%E5%AE%9A%E4%B9%89view_images/image-20200501120737414.png" alt="image-20200501120737414"></p><p>FlowLayout是 自定义ViewGroup</p><p>1.自定义VIew是什么  其实很简单：就布局-&gt;draw()-&gt;touch触发  </p><p>2.draw:animation,canvas,painter,crop,path,matrix,贝塞尔曲线</p><p>3.事件分发  </p><p><img src=".%E8%87%AA%E5%AE%9A%E4%B9%89view_images/image-20200501121234324.png" alt="image-20200501121234324"></p><p><img src=".%E8%87%AA%E5%AE%9A%E4%B9%89view_images/image-20200501131854568.png" alt="image-20200501131854568"></p><p><img src=".%E8%87%AA%E5%AE%9A%E4%B9%89view_images/image-20200501131903575.png" alt="image-20200501131903575"></p><p>//这个方法必须在onMeasure()中调用，用于保存测量的宽度和高度</p><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">setMeasuredDimension</span><span class="token punctuation">(</span><span class="token keyword">int</span> measuredWidth<span class="token punctuation">,</span> <span class="token keyword">int</span> measuredHeight<span class="token punctuation">)</span></code></pre><h2 id="View绘制-我的总结"><a href="#View绘制-我的总结" class="headerlink" title="View绘制 我的总结"></a>View绘制 我的总结</h2><p>View的内部类MeasureSpec</p><p>ViewGroup的getChildMeasureSpec()方法</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">getChildMeasureSpec</span><span class="token punctuation">(</span><span class="token keyword">int</span> spec<span class="token punctuation">,</span> <span class="token keyword">int</span> padding<span class="token punctuation">,</span> <span class="token keyword">int</span> childDimension<span class="token punctuation">)</span></code></pre><p>MeasureSpec提供了三个方法</p><p>  1)makeMeasureSpec(int size,int mode):size参数由程序员自己设定，mode必须是specMode的三个值中的一个</p><p>  2)getMode(int measureSpec):见名知意，方法返回specMode的三个值中的一个，注意方法参数measureSpec，这个参数的值是怎么得来的呢？正是由makeMeasureSpec方法计算出来的</p><p>  3)getSize(int measureSpec):获取View的大小，方法参数的值同样是由makeMeasureSpec计算的出来的。</p><h4 id="一-MeasureSpec的构成"><a href="#一-MeasureSpec的构成" class="headerlink" title="一.MeasureSpec的构成"></a>一.MeasureSpec的构成</h4><p>MeasureSpec代表一个32位的int值，前俩位代表SpecMode，后30位代表SpecSize.其中：SpecMode代表测量的模式，SpecSize值在某种测量模式下的规格大小。</p><p>共有三种测量模式：</p><ol><li>EXACTLY: 父容器已经检测出子View所需要的精确大小，这个时候view的大小即为SpecSize的大小，他对应于布局参数中的MATCH_PARENT,或者精确大小值</li></ol><p>2.AT_MOST: 父容器指定了一个大小，即SpecSize，子view的大小不能超过这个SpecSize的大小</p><p>3.UNSPECIFIED: 表示子View想多大都可以</p><p>DecorView的MeasureSpec创建过程如下:</p><pre class=" language-java"><code class="language-java"> <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">getRootMeasureSpec</span><span class="token punctuation">(</span><span class="token keyword">int</span> windowSize<span class="token punctuation">,</span> <span class="token keyword">int</span> rootDimension<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> measureSpec<span class="token punctuation">;</span>        <span class="token keyword">switch</span> <span class="token punctuation">(</span>rootDimension<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">case</span> ViewGroup<span class="token punctuation">.</span>LayoutParams<span class="token punctuation">.</span>MATCH_PARENT<span class="token operator">:</span>            <span class="token comment" spellcheck="true">// Window can't resize. Force root view to be windowSize.</span>            measureSpec <span class="token operator">=</span> MeasureSpec<span class="token punctuation">.</span><span class="token function">makeMeasureSpec</span><span class="token punctuation">(</span>windowSize<span class="token punctuation">,</span> MeasureSpec<span class="token punctuation">.</span>EXACTLY<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> ViewGroup<span class="token punctuation">.</span>LayoutParams<span class="token punctuation">.</span>WRAP_CONTENT<span class="token operator">:</span>            <span class="token comment" spellcheck="true">// Window can resize. Set max size for root view.</span>            measureSpec <span class="token operator">=</span> MeasureSpec<span class="token punctuation">.</span><span class="token function">makeMeasureSpec</span><span class="token punctuation">(</span>windowSize<span class="token punctuation">,</span> MeasureSpec<span class="token punctuation">.</span>AT_MOST<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">default</span><span class="token operator">:</span>            <span class="token comment" spellcheck="true">// Window wants to be an exact size. Force root view to be that size.</span>            measureSpec <span class="token operator">=</span> MeasureSpec<span class="token punctuation">.</span><span class="token function">makeMeasureSpec</span><span class="token punctuation">(</span>rootDimension<span class="token punctuation">,</span> MeasureSpec<span class="token punctuation">.</span>EXACTLY<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> measureSpec<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>其中windowSize为窗口的大小，即屏幕大小，rootDimension在DecorView中为MATCH_PARENT.故DecorView的MeasureSpec中的SpecSize为窗口大小，SpecMode的EXACTLY.</p><p>对于普通的子View来说，通过传入fu容器的MeasureSpec，来计算字View的MeasureSpec。</p><p>通过measureChildWithMargins(View child,int parentWidthMeasureSpec, int widthUsed,int parentHeightMeasureSpec, int heightUsed);<br>在其内部在调用getChildMeasureSpec()方法来得到MeasureSpec.//那张1个亿的图</p><pre><code></code></pre><h4 id="三-默认View的OnMeasure过程中对MeasureSpec的处理"><a href="#三-默认View的OnMeasure过程中对MeasureSpec的处理" class="headerlink" title="三. 默认View的OnMeasure过程中对MeasureSpec的处理"></a>三. 默认View的OnMeasure过程中对MeasureSpec的处理</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">onMeasure</span><span class="token punctuation">(</span><span class="token keyword">int</span> widthMeasureSpec<span class="token punctuation">,</span> <span class="token keyword">int</span> heightMeasureSpec<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">setMeasuredDimension</span><span class="token punctuation">(</span><span class="token function">getDefaultSize</span><span class="token punctuation">(</span><span class="token function">getSuggestedMinimumWidth</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> widthMeasureSpec<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token function">getDefaultSize</span><span class="token punctuation">(</span><span class="token function">getSuggestedMinimumHeight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> heightMeasureSpec<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">getDefaultSize</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">,</span> <span class="token keyword">int</span> measureSpec<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> result <span class="token operator">=</span> size<span class="token punctuation">;</span>        <span class="token keyword">int</span> specMode <span class="token operator">=</span> MeasureSpec<span class="token punctuation">.</span><span class="token function">getMode</span><span class="token punctuation">(</span>measureSpec<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> specSize <span class="token operator">=</span> MeasureSpec<span class="token punctuation">.</span><span class="token function">getSize</span><span class="token punctuation">(</span>measureSpec<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">switch</span> <span class="token punctuation">(</span>specMode<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">case</span> MeasureSpec<span class="token punctuation">.</span>UNSPECIFIED<span class="token operator">:</span>            result <span class="token operator">=</span> size<span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> MeasureSpec<span class="token punctuation">.</span>AT_MOST<span class="token operator">:</span>        <span class="token keyword">case</span> MeasureSpec<span class="token punctuation">.</span>EXACTLY<span class="token operator">:</span>            result <span class="token operator">=</span> specSize<span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>View系统的绘制流程会从ViewRoot的performTraversals()方法中开始，在其内部调用View的measure()方法。measure()方法接收两个参数，widthMeasureSpec和heightMeasureSpec，这两个值分别用于确定视图的宽度和高度的规格和大小。</p><p>父布局的给的参考大小中的模式是MeasureSpec.EXACTLY的情况下：</p><ul><li>孩子在xml中定义的layout_width 是确定值时，算出的孩子的规格是 MeasureSpec.EXACTLY模式，size会确定的值；</li><li>孩子在xml中定义的layout_width 是match_parent时，算出的孩子的规格是MeasureSpec.EXACTLY,size就是父的size(width) - padding</li><li>孩子在xml中定义的layout_width 是match_parent时,算出的孩子的规格是MeasureSpec.AT_MOST,size就是父的size(width)-padding，但这里表示孩子的大小最多是规格中的大小</li></ul><h2 id="DecorView的MeasureSpec"><a href="#DecorView的MeasureSpec" class="headerlink" title="DecorView的MeasureSpec"></a>DecorView的MeasureSpec</h2><p>1.DecorView是最顶层view,会由viewrootimpl添加到window中</p><p>2.他的MeasureSpec 宽高模式都为MeasureSpec.EXACTLY,大小分为别为屏幕宽高</p><p>ViewGroup的measureChildWithMargins</p><p>getChildMeasureSpec</p><p>3.ViewGroup中没有onMeasure方法</p><p>4.MarginLayoutParams是什么</p><p>dimension就是宽高</p><h5 id="getSuggestedMinmumWidth-是什么？"><a href="#getSuggestedMinmumWidth-是什么？" class="headerlink" title="getSuggestedMinmumWidth 是什么？"></a>getSuggestedMinmumWidth 是什么？</h5><p>就是xml中设置的，默认是0.</p><h5 id="layout-marginStart-和layout-marginLeft有什么区别"><a href="#layout-marginStart-和layout-marginLeft有什么区别" class="headerlink" title="layout_marginStart 和layout_marginLeft有什么区别"></a>layout_marginStart 和layout_marginLeft有什么区别</h5><h5 id="View的onMeasure方法做了什么"><a href="#View的onMeasure方法做了什么" class="headerlink" title="View的onMeasure方法做了什么"></a>View的onMeasure方法做了什么</h5><ul><li>保存了测量的宽高</li><li>保存策略getDefaultSize(int size, int measureSpec): <ul><li>第一个参数是通过getSuggestedMinmumWidth()传的</li><li>只有specMode是UNSPECIFIED时，才用的第一个参数</li><li>也就是说保存的测量的宽高就是MeasureSpec中的宽高</li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/java/集合框架/List</title>
      <link href="blog/1012352351.html"/>
      <url>blog/1012352351.html</url>
      
        <content type="html"><![CDATA[<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">List</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">Collection</span><span class="token operator">&lt;</span>E<span class="token operator">></span></code></pre><p>有序的 collection（也称为<em>序列</em>）。此接口的用户可以对列表中每个元素的插入位置进行精确地控制。用户可以根据元素的整数索引（在列表中的位置）访问元素，并搜索列表中的元素。</p><p>与 set 不同，列表通常允许重复的元素。更确切地讲，列表通常允许满足 <code>e1.equals(e2)</code> 的元素对 <code>e1</code> 和 <code>e2</code>，并且如果列表本身允许 null 元素的话，通常它们允许多个 null 元素。难免有人希望通过在用户尝试插入重复元素时抛出运行时异常的方法来禁止重复的列表，但我们希望这种用法越少越好。</p><h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><p>1.默认构造函数：构造一个空的列表，初始容量为10.但是没有马上就创建容量为10的，直到add方法时才会构造。</p><p>2.Arrays.copyof(原数组，新的长度)</p><pre><code>public static &lt;T&gt; T[] copyOf(T[] original, int newLength)</code></pre><p>内部new了一个新的数组，并调用System.copy完成拷贝，返回新的数组的引用</p><p>3.add(E e)方法</p><ul><li><p>插入之前会先检查容量是否足够minCpacity=size + 1, 看size + 1 是否比elementData.length 要大，</p><p>是的话，进行扩容，否则直接插入</p></li><li><p>扩容之前modCount++, 指修改集合的次数</p></li><li><p>add的本质就是数组赋值</p></li><li><p>扩容是调用Arrays.copyof完成</p></li></ul><p>4.成员变量<code>EMPTY_ELEMENTDATA</code>与<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code></p><pre><code> /**     * Shared empty array instance used for empty instances.     */    private static final Object[] EMPTY_ELEMENTDATA = {};    /**     * Shared empty array instance used for default sized empty instances. We     * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when     * first element is added.     */    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};</code></pre><p>后者用于区别前者，若构造函数传入参数0，则每次扩容后的容量为0,1,2,3,4,6,9…</p><h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>LinkedList是一个以双向链表实现的List，它除了作为List使用，还可以作为队列或者堆栈使用。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/java/集合框架/Set</title>
      <link href="blog/2120269972.html"/>
      <url>blog/2120269972.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/java/JAVA基础语法/面向对象</title>
      <link href="blog/220005370.html"/>
      <url>blog/220005370.html</url>
      
        <content type="html"><![CDATA[<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Set</span>  <span class="token keyword">extends</span> <span class="token class-name">Collection</span>     `</code></pre><p>一个不包含重复元素的 collection。更确切地讲，set 不包含满足 <code>e1.equals(e2)</code> 的元素对 <code>e1</code> 和 <code>e2</code>，并且最多包含一个 null 元素。正如其名称所暗示的，此接口模仿了数学上的 <em>set</em> 抽象。</p><h2 id="2-多态"><a href="#2-多态" class="headerlink" title="2. 多态"></a>2. 多态</h2><p>多态（Polymorphism）：使用父类对象的地方都可以使用子类对象，这就是多态。简单来说，多态意味着父类型的变量可以引用子类型的对象。</p><p>java中当子类拥有和父类同样的函数，当通过这个父类对象的引用调用这个函数的时候，调用到的是子类中的函数。</p><p>多态也称动态绑定，运行时绑定。</p><h3 id="多态的优点"><a href="#多态的优点" class="headerlink" title="多态的优点"></a>多态的优点</h3><ol><li><p>改善代码的组织结构和可读性。</p></li><li><p>消除类型之间的耦合关系</p></li></ol><h2 id="3-Java-接口"><a href="#3-Java-接口" class="headerlink" title="3. Java 接口"></a>3. Java 接口</h2><p>接口（英文：Interface），在JAVA语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。</p><p>接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。</p><p>除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。</p><p>接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。</p><h3 id="接口与类相似点："><a href="#接口与类相似点：" class="headerlink" title="接口与类相似点："></a>接口与类相似点：</h3><ul><li>一个接口可以有多个方法。</li><li>接口文件保存在 .java 结尾的文件中，文件名使用接口名。</li><li>接口的字节码文件保存在 .class 结尾的文件中。</li><li>接口相应的字节码文件必须在与包名称相匹配的目录结构中。</li></ul><h3 id="接口与类的区别："><a href="#接口与类的区别：" class="headerlink" title="接口与类的区别："></a>接口与类的区别：</h3><ul><li>接口不能用于实例化对象。</li><li>接口没有构造方法。</li><li>接口中所有的方法必须是抽象方法。</li><li>接口不能包含成员变量，除了 static 和 final 变量。</li><li>接口不是被类继承了，而是要被类实现。</li><li>接口支持多继承。</li></ul><h3 id="接口特性"><a href="#接口特性" class="headerlink" title="接口特性"></a>接口特性</h3><ul><li>接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 <strong>public abstract</strong>（只能是 public abstract，其他修饰符都会报错）。</li><li>接口中可以含有变量，但是接口中的变量会被隐式的指定为 <strong>public static final</strong> 变量（并且只能是 public，用 private 修饰会报编译错误）。</li><li>接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。</li></ul><h3 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h3><ul><li>\1. 抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。</li><li>\2. 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 <strong>public static final</strong> 类型的。</li><li>\3. 接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。</li><li>\4. 一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li></ul><blockquote><p><strong>注</strong>：JDK 1.8 以后，接口里可以有静态方法和方法体了。</p></blockquote><h3 id="重写和重载"><a href="#重写和重载" class="headerlink" title="重写和重载"></a>重写和重载</h3><p>方法签名：方法名+参数列表</p><p>方法重写：要求和父类一样的签名及一样的返回值类型。</p><p>方法重载：方法名相同，参数列表不同</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/java/集合框架/Map</title>
      <link href="blog/198791155.html"/>
      <url>blog/198791155.html</url>
      
        <content type="html"><![CDATA[<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>键值对的结构，将键映射到值。一个映射不能包含重复的键；每个键最多只能映射到一个值。</p><ul><li><p>HashMap,HashTable,ConCurrentHashMap的区别和实现原理？</p></li><li><p>如何实现线程同步？</p></li></ul><p>a- rraymap和<em>hashmap</em>的区别？</p><p>HashMap介绍</p><p>HashMap是JDK对于数据结构中哈希表的实现，用于保存键值对这样的一个结构。</p><p>//平均来看，哈希表的增删查改都是O(1)的时间复杂度。</p><ul><li><p>有2个影响性能的参数：初始容量默认16和负载因子默认为0.75，</p></li><li><p>不是同步的，允许null键和null。(最大容量是2的30次方)</p></li></ul><p>原理：</p><p>内部采用数组 + 链表 + 红黑树，数组也就是桶，默认大小为16；</p><ul><li><p>首先计算索引/数组的下标：</p><ul><li>通过hash函数(key的hashcode()  ^ key的hashcode右移16位)计算key的hash值,并 &amp; 数组的length - 1（相当于求模）</li></ul></li><li><p>如果没有发生冲突，直接插入</p></li><li><p>发送冲突时首先采用拉链法解决：</p><ul><li><p>当链表长度&gt;=8,数组容量&lt;64时，数组扩容，重新哈希；</p></li><li><p>当链表长度&gt;=阈值8，数组容量大于等于64时，链表转化为红黑树。</p></li></ul></li><li><p>链表长度&lt;阈值 6时，红黑树转化为链表</p></li><li><p>插入后，会将size++,检查是否超过 容量 * 负载因子，超过则进行扩容。</p></li></ul><p>1.面试题：HashMap中hash函数是怎么实现的？还有哪些hash函数的实现方式？</p><pre><code>对于key的hashCode做hash操作，无符号右移16位然后做异或运算。还有平方取中法，伪随机数法和取余数法。这三种效率都比较低。而无符号右移16位异或运算效率是最高的。至于底层是如何计算的我们下面看源码时给大家讲解。</code></pre><p>2.面试题：当两个对象的hashCode（实际是hash这个field）相等时会怎么样？</p><pre><code>会产生冲突，若key值内容(或者地址相同，或者地址不同equals返回ture内容相同)相同则替换旧的value.不然连接到链表后面，链表长度超过阈值8就转换为红黑树存储。</code></pre><p>3.面试题：何时发生哈希碰撞和什么是哈希碰撞,如何解决哈希碰撞？</p><pre><code>只要两个元素的key计算的哈希码值相同就会发生哈希碰撞。jdk8前使用链表解决哈希碰撞。jdk8之后使用链表+红黑树解决哈希碰撞。</code></pre><p>4.面试题：如果两个键的hashcode相同，如何存储键值对？</p><pre><code>hashcode相同，通过equals比较内容是否相同。相同：则新的value覆盖之前的value不相同：则将新的键值对添加到哈希表中</code></pre><p>5.在不断的添加数据的过程中，会涉及到扩容问题，当超出临界值(且要存放的位置非空)时，扩容。默认的扩容方式：扩容为原来容量的2倍，并将原有的数据复制过来。</p><p>6.JDK1.8和1.7中的HashMap有什么不同</p><ul><li><p>底层数据结构不一样，1.7是<strong>数组+链表</strong>，1.8则是<strong>数组+链表+红黑树结构（当链表长度大于8，转为红黑树）</strong></p></li><li><p>1.7中新增节点采用头插法，1.8中新增节点采用尾插法。这也是为什么1.8不容易出现环型链表的原因。</p></li><li><p>1.8rehash时保证原链表的顺序，而1.7中rehash时有可能改变链表的顺序（头插法导致）。</p></li></ul><p>LinkedHashMap（HashMap + 双链表,实现了1个存取有序的HashMap）</p><p>1.继承HashMap，其中n内部类Entry继承HashMap的内部类Node，并增加了2个属性，一个befor，1个after,用于指示结点的前1个结点和下一个结点，保持顺序用</p><p>2.同时自己有2个属性head,tail,分别用于指示双链表的头和尾</p><p>3.另外还有1个重要的属性accessOrder，默认为false时，表示插入顺序；为true时表示访问顺序。</p><p><img src=".Map_images/image-20200719215209568.png" alt="image-20200719215209568"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/java/集合框架/Collection</title>
      <link href="blog/3112590169.html"/>
      <url>blog/3112590169.html</url>
      
        <content type="html"><![CDATA[<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Collection</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">Iterable</span><span class="token operator">&lt;</span>E<span class="token operator">></span></code></pre><p><em>Collection 层次结构</em> 中的根接口。Collection 表示一组对象，这些对象也称为 collection 的<em>元素</em></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/面经/字节跳动/快手</title>
      <link href="blog/108427893.html"/>
      <url>blog/108427893.html</url>
      
        <content type="html"><![CDATA[<h2 id="快手android开发实习生面经（已拿offer）"><a href="#快手android开发实习生面经（已拿offer）" class="headerlink" title="快手android开发实习生面经（已拿offer）"></a>快手android开发实习生面经（已拿offer）</h2><p>作者：coder_hezi<br>链接：<a href="https://ac.nowcoder.com/discuss/405966" target="_blank" rel="noopener">https://ac.nowcoder.com/discuss/405966</a><br>来源：牛客网 编辑于 2020-04-13 15:04:23</p><p>先说下笔试情况，2.8/4。 </p><p>  面试的话是下午2点到4点面试连着两面，然后hr最后说结果会在几天之内反馈。 </p><p>  这个面经不全，因为现在有的问题已经想不起来了，尤其是没答好的问题可能更记不住了hhhhh </p><p>  更新下：4.11面试，4.13拿offer </p><h2 id="一面（一小时）"><a href="#一面（一小时）" class="headerlink" title="一面（一小时）"></a>一面（一小时）</h2><p>  Android问题： </p><p>  1.详细的讲下View的绘制过程 </p><p>  2.使用过哪些动画，属性动画和View动画的区别在哪里，View动画的原理（ValueAnimator和ObjectAnimator的区别） </p><p>  3.Activity的生命周期，启动模式，区别在哪，讲下各自的应用场景。 </p><p>  4.Fragment的生命周期 </p><p>  5.Service的生命周期 </p><p>  6.进程与线程的区别 </p><p>  7.在项目中使用过多线程么 </p><p>  Java问题： </p><p>  1.HashMap（因为我写过相关文章，这个问题答了蛮长的一段时间） </p><p>  2.java gc算法 </p><p>  3.常用的线程池，以及线程池的各个属性的含义 </p><p>  4.四种引用类型的区别(可以结合内存泄漏去聊) </p><p>  代码题 </p><p>  1.手写二分查找 </p><h2 id="二面（一小时）"><a href="#二面（一小时）" class="headerlink" title="二面（一小时）"></a>二面（一小时）</h2><p>  Android问题： </p><p>  1.事件分发详细的讲（三个核心函数以及整体过程），详细的讲下dispatchTouchEvent，子View如何阻止父View拦截事件，Action_Cancel什么时候会发生，一个应用场景：两个并排Button，点击button之后，又移动到另一个button，但不点击滑动到外面会经过发生哪些事件。 </p><p>  2.OkHttp </p><p>  \3. Message.obtain()有什么好处，为什么不使用new Message（防止多次Gc）  </p><p>  4.LinearLayout和RelativeLayout的区别，优缺点，层级嵌套等等等  </p><p>  5.ConstrantLayout讲讲特点  </p><p>  6.性能优化在项目中做过哪些  </p><p>  7.读过哪些Android的源码  </p><p>  8.BroadCastReceiver的源码看过么？  </p><p>  9.FrameLayout了解么？  </p><p>  代码题： </p><p>  1.场景题，实现一个ActionMangager，其中包括registerAction(String action, IActionCallback callback)，unregisterAction(IActionCallback callback);notifyChange(string action)三个方法。类似于BroadCastReceiver，一个action可能对应多个Callback，notifyChange中要回调action对应的所有Callback对象的方法。同时还问了怎么满足线程安全的问题等等，会根据代码继续问问题。  </p><p>  2.之字形遍历二叉树</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/面经/字节跳动/字节跳动</title>
      <link href="blog/2775131548.html"/>
      <url>blog/2775131548.html</url>
      
        <content type="html"><![CDATA[<h2 id="字节跳动Android实习面经-西南交通大学"><a href="#字节跳动Android实习面经-西南交通大学" class="headerlink" title="字节跳动Android实习面经(西南交通大学)"></a>字节跳动Android实习面经(西南交通大学)</h2><h3 id="作者：一只挣扎的咸鱼"><a href="#作者：一只挣扎的咸鱼" class="headerlink" title="作者：一只挣扎的咸鱼"></a>作者：一只挣扎的咸鱼</h3><p>链接：<a href="https://www.nowcoder.com/discuss/170262?type=0&amp;order=0&amp;pos=14&amp;page=1" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/170262?type=0&amp;order=0&amp;pos=14&amp;page=1</a></p><p>3.29 一面 1h </p><p>  说说四大组件 </p><p>  onpause和onstop方法 </p><p>  Android中多线程实现方法(提到handler) </p><p>  线程message queue关系 </p><p>  handler如何切换线程(handler聊了挺久) </p><p>  handler如何回调 </p><p>  handler注意事项(预防内存泄漏) </p><p>  四种引用 </p><p>  String s=new String(“123”);建立了几个对象 </p><p>  ArrayList<String> 删除空字符串(“”)对象 </p><p>  算法 0123_456_769变成3210_654_967(只有数字加下划线) 其中出了个bug，重写后就正常(汗) </p><p>  过几分钟后二面 </p><p>  3.29 二面45min </p><p>  算法 二叉树中两个结点的距离(通过公共祖先结点的距离和) </p><p>  先说出思路，回溯获得根到子节点的路径 </p><p>  git rebase 和merge </p><p>  git 作用 </p><p>  问框架 </p><p>  https ssl 加密等 </p><p>  handler封装使用(handlerThread IntentService) </p><p>  retrofit如何跨线程 </p><p>  synchronized和lock区别 </p><p>  锁原理 </p><p>  stack实现o(1)获得最小值，手写基于数组的栈，leetcode上有 </p><p>  表达能力太差，很多东西说不出来，希望没凉 </p><p>  4.1 三面40min </p><p>  问我上次面试哪里答得不好，我说算法题没做出来 </p><p>  然后再做一次。。 </p><p>  之后就问些实习时间等非技术的事情了</p><h2 id="字节Android实习：3-1"><a href="#字节Android实习：3-1" class="headerlink" title="字节Android实习：3+1"></a>字节Android实习：3+1</h2><h3 id="作者：小啊潇Ambition"><a href="#作者：小啊潇Ambition" class="headerlink" title="作者：小啊潇Ambition"></a>作者：小啊潇Ambition</h3><p>链接：<a href="https://ac.nowcoder.com/discuss/361776?type=2" target="_blank" rel="noopener">https://ac.nowcoder.com/discuss/361776?type=2</a><br>来源：牛客网(编辑于 2020-01-12 13:04:58）</p><p>字节面试都是在牛客网上进行视频面试 </p><p>  第1面（技术，50min） </p><p>  TCP与UDP的区别</p><p>  三次握手四次挥手</p><p>  TCP核心机制（滑动窗口，快速重传机制，拥塞控制…可以参考我的博客：<a href="https://blog.csdn.net/weixin_43490440/article/details/103237102）" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43490440/article/details/103237102）</a></p><p>  HTTP和HTTPS及其区别</p><p>  HTTP请求格式（首行，协议头，空行，正文）</p><p>  GET与POST的区别</p><p>  若建立连接时间比较长，HTTP是怎么优化的（注意是HTTP不是TCP，可以参考下：<a href="https://blog.csdn.net/weixin_34056162/article/details/85880162）" target="_blank" rel="noopener">https://blog.csdn.net/weixin_34056162/article/details/85880162）</a></p><p>  （网络怼到我哑口无言，问了三个问题都答不上来，这才换了一个方面）</p><p>  Java中public，protected，default（什么也不写），private的区别</p><p>  子类可以继承父类哪些访问限定符修饰的方法（public，protected，default（什么也不写））</p><p>  如何使得一个函数不被覆写（final）</p><p>  静态内部类和匿名内部类的区别</p><p>  内部类如何调用外部类的方法（Outter.this.方法名）</p><p>  内存泄漏与内存溢出关系 </p><p>  判断对象是否已死（两次标记：可达性分析+finalize方法）</p><p>  四种引用（强引用，软引用，弱引用，虚引用）</p><p>  算法题：两数之和（leetcode第一题，<a href="https://leetcode-cn.com/problems/two-sum/，要求时间复杂度O(n)）" target="_blank" rel="noopener">https://leetcode-cn.com/problems/two-sum/，要求时间复杂度O(n)）</a></p><p>  （太紧张了，没优化到O(n)，竟然给了2面）</p><p>  第2面（技术，70min）</p><p>  项目（10min）</p><p>  算法题：判断一个字符串是否是一个IPV4</p><p>  算法题：连续子数组的最大和(剑指Offer上的题)</p><p>  Java异常体系（运行时与非运行时异常的区别）</p><p>  HashCode与equals的区别</p><p>  JVM内存区域划分（程序计数器，虚拟机栈，本地方法栈，堆，方法区，运行时常量池）</p><p>  JVM内存回收方法（判断对象是否已死&lt;1面那个问题&gt;，新生代老年代的垃圾回收算法&lt;复制算法，标记-整理&gt;）</p><p>  哪些对象可以作为GC Roots</p><p>  数据库中delete和drop的区别</p><p>  数据库事务的使用场景</p><p>  数据库三大范式</p><p>  数据库索引的创建原则 </p><p>  数据库索引底层实现（B+树）</p><p>  线程，进程，程序的区别</p><p>  死锁的产生条件</p><p>  ***模式</p><p>  继承与***模式的优劣势 </p><p>  第3面（技术，40min） </p><p>  项目</p><p>  算法题：打印1-n之间的素数</p><p>  智力题：25匹马，5个赛道，最少多少次可以知道跑的最快的5匹马（运气爆棚，和百度一模一样）  </p><p>  设计题：设计一个下载器的接口 </p><p>  职业规划 </p><p>  第4面（电话hr面，15min） </p><p>  问了些基本问题</p><h2 id="字节跳动安卓Android实习，秋招面经，附内推链接"><a href="#字节跳动安卓Android实习，秋招面经，附内推链接" class="headerlink" title="字节跳动安卓Android实习，秋招面经，附内推链接~"></a>字节跳动安卓Android实习，秋招面经，附内推链接~</h2><h3 id="作者：终于可以改名字了"><a href="#作者：终于可以改名字了" class="headerlink" title="作者：终于可以改名字了"></a>作者：终于可以改名字了</h3><p>链接：<a href="https://ac.nowcoder.com/discuss/386713" target="_blank" rel="noopener">https://ac.nowcoder.com/discuss/386713</a><br>来源：牛客网（编辑于 2020-03-24 21:38:00）</p><p>本来不想发了，但是感觉安卓的面经实在太少了，，就拿出来做点贡献哈哈 </p><p>  秋招抖音部门： </p><p>  一面：（1hour) </p><p>  自我介绍 </p><p>  java泛型，反射 </p><p>  进程间通信的方式，安卓中有哪些方式，为什么是基于Binder的，不用传统的操作系统进程间通信方式呢 </p><p>  一个app可以开启多个进程嘛，怎么做呢，每个进程都是在独立的虚拟机上嘛 </p><p>  异步消息处理流程，如果发送一个延时消息，messagequeue里面怎么个顺序，messagequeue是个什么数据结构 </p><p>  广播的种类，注册的方式，以及不同注册方式的生命周期。 </p><p>  局部广播和全局广播的区别分别用什么实现的。 </p><p>  activity和service的通信方式 </p><p>  进程和线程的区别 </p><p>  并发和并行分别是什么意思，多线程是并发还是并行 </p><p>  安卓10有什么新的特性。 </p><p>  HTTPS过程。 </p><p>  DNS解析过程，如果服务器ip地址改变了，客户端怎么知道呢 </p><p>  算法：二叉树的右视图。 </p><p>  二面：(1hour） </p><p>  介绍一下所有的map，以及他们之间的对比，适用场景。 </p><p>  一个按钮，手抖了连续点了两次，会跳转两次页面，怎么让这种情况不发生。 </p><p>  一个商品页一个商详页，点击商详页的一个关注按钮，希望回到商品页也能够显示关注的状态，怎么做 </p><p>  项目中定时为什么用AlarmManager，不用postDelayed </p><p>  项目中后台网络请求为什么用service不用线程 </p><p>  也问了一些安卓的新特性。 </p><p>  内部类会有内存泄漏问题吗 内部类为什么能访问外部类的变量，为什么还能访问外部类的私有变量。 </p><p>  算法:单链表判断有无环。 </p><p>  三面：（35min) </p><p>  介绍项目用到了contentprovider,然后问ContentProvider的生命周期，application,activity，service,contentprovider他们的context有什么区别。 </p><p>  内存溢出和内存泄漏，提到了bitmap </p><p>  然后问下载一个图片的时候直接下载了一个5g的图片，不压缩一定会产生OOM问题，那么怎么去获取这个图片的长宽呢，或者说这个图片的大小在你没下载之前如何得到。不会。 </p><p>  实习期间遇到的最大的问题，如何解决问题。 </p><p>  后面就是聊天，，为什么选择上海啊互联网行业的信息从哪里获取啊什么的。 </p><p>  因为可能是看到前面的面试记录了，没有太多的问题要问了，，会的都问的差不多了，不会的问了也不会，所以大佬没太为难我了，感恩。 </p><p>  hr面：（15分钟左右） </p><p>  微信视频，都是常规问题. </p><p>  看面试记录，之前也有面过，部门不一样面试体验如何呢 </p><p>  优缺点 </p><p>  投递过哪些公司。 </p><p>  男朋友在哪个部门，做啥的 </p><p>  怎么想到学安卓的。 </p><p>  了解字节跳动嘛等问题。 </p><p>  春招实习北京效率工程部门： </p><p>  一面： </p><p>  安卓： </p><p>  事件分发 </p><p>  子View如何让父view不拦截触摸事件，requestDisAllowIntercept啥的。 </p><p>  启动模式 </p><p>  okhttp怎么实现的 </p><p>  服务的启动方式，生命周期 </p><p>  如何保证service不被杀死 </p><p>  listview的item复用和recyclerview的区别 </p><p>  java: </p><p>  HashMap扩容机制 </p><p>  计算机基础： </p><p>  https http </p><p>  数据库范式，不会。 </p><p>  算法： </p><p>  单例 </p><p>  二叉树每层最大值 </p><p>  二面： </p><p>  内存泄漏，以及使用过哪些工具 </p><p>  AS里面有哪些常用的工具，第三方的也行。我竟然不知道，。。 </p><p>  一个app如何管理线程 </p><p>  什么情况会导致内存抖动，举个例子 </p><p>  怎么创建线程池，类名说一下，线程 池类型 </p><p>  countdownLatch </p><p>  synchronized reetrantlock </p><p>  reentrantReadWriteLock </p><p>  过渡绘制的查看工具有哪些 </p><p>  约束layout和线性layout有什么区别和优势 </p><p>  红黑树。 </p><p>  LRU*** </p><p>  ConcurrentHashMap和HashMap底层实现 </p><p>  加载图片需要注意什么，怎么缩放图片，三级缓存啥的 </p><p>  parcelable serializable </p><p>  连接手机的时候开发者选项里面那些开关都有什么，用过哪些 </p><p>  三面： </p><p>  http知道多少分别介绍，然后根据介绍的来问，很详细的那种 </p><p>  写代码： </p><p>  生产者消费者，实现 </p><p>  判断一个数是偶数的方法有哪些 </p><p>  还有一个跟lark场景相关的编程题，，忘记了。。 </p><p>  我的秋招之旅基本结束啦，字节是我面试次数最多的一家公司了，虽然我很菜，依然感谢字节收了我~~ </p><p>  祝大家都有好的结果~~offer+1  </p><h2 id="2019年字节跳动Android暑期实习面经"><a href="#2019年字节跳动Android暑期实习面经" class="headerlink" title="2019年字节跳动Android暑期实习面经"></a>2019年字节跳动Android暑期实习面经</h2><h3 id="作者：HoqiheChen"><a href="#作者：HoqiheChen" class="headerlink" title="作者：HoqiheChen"></a>作者：HoqiheChen</h3><p>链接：<a href="https://www.nowcoder.com/discuss/172762" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/172762</a><br>来源：牛客网编辑于 2019-04-03 16:44:21</p><p><strong>一面（技术面**</strong>）：**  </p><p>  介绍一下自己。。。 </p><p>  手撕代码：Top K ，二叉树的路径和。略略略。 </p><p>  TOPK问题的这两种思路使用于哪种条件？ </p><p>  介绍一下项目。 </p><p>  Spring 和 Spring MVC的区别。 </p><p>  介绍一下Spring。 </p><p>  IOC具体指的是什么？IOC有哪些优势？ </p><p>  AOP包含动态<strong><em>还是动态</em></strong>包含AOP？ </p><p>  AOP和OOP有什么区别？ </p><p>  实现接口和继承有什么关系？ </p><p>  LinkedList和ArrayList的区别。 </p><p>  HashMap安全吗？如何改进使其安全？ </p><p>  具体介绍一下ConcurrentHashMap。 </p><p>  分段锁是怎么实现的？ </p><p>  进程通信有哪些方式？ </p><p>  Activity的生命周期介绍一下。还问了一下几种操作之下，activity的生命周期是什么样的。 </p><p>  Android中进程通信用的是什么？ </p><p>  介绍一下GC。 </p><p>  可能是我的项目经历里面的项目都是Java Web的，所以面试中问了一些框架的东西。通过这次面试，有几点经验跟大家分享一下： </p><p>  ①基础还是很重要的，所以一定要好好准备基础。 </p><p>  ②简历中的项目一定要烂熟于心。</p><p>  ③不要紧张，好好发挥。 </p><h4 id="祝各位成功上岸！"><a href="#祝各位成功上岸！" class="headerlink" title="祝各位成功上岸！"></a>祝各位成功上岸！</h4><h2 id="字节跳动暑期实习Android一二三hr面经-offer"><a href="#字节跳动暑期实习Android一二三hr面经-offer" class="headerlink" title="字节跳动暑期实习Android一二三hr面经(offer)"></a>字节跳动暑期实习Android一二三hr面经(offer)</h2><h3 id="作者：很丧的小黄鸭"><a href="#作者：很丧的小黄鸭" class="headerlink" title="作者：很丧的小黄鸭"></a>作者：很丧的小黄鸭</h3><p>链接：<a href="https://www.nowcoder.com/discuss/167261?type=0&amp;order=0&amp;pos=16&amp;page=1" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/167261?type=0&amp;order=0&amp;pos=16&amp;page=1</a><br>来源：牛客网编辑于 2019-03-27 22:43:18</p><p>3.27，hr说offer已经审批下来了～</p><p>——————————————————————</p><p>3.14晚上投的简历，第二天打电话约3.18一面，以下是一二三hr面面经。由于三次都忘记录音了，只能凭记忆写，可能会有遗漏。</p><h3 id="一面-（3-18-视频面-30min）"><a href="#一面-（3-18-视频面-30min）" class="headerlink" title="一面 （3.18 视频面 30min）"></a><strong>一面 （3.18 视频面 30min）</strong></h3><ol><li>（敲代码）给定一个数组，求第k小的数。</li><li>TCP和UDP的区别，UDP如何实现可靠传输。</li><li>工作内存和主内存。（这里是给了一个例子，主线程有一个变量a，子线程里用到了这个变量，问这两处的变量是不是一个东西）</li><li>GC讲一下。</li><li>线程安全。</li><li>volatile， volatile和synchronized的区别。</li><li>LruCache。</li><li>一般我们调试的时候，会用到断点，断点在底层是怎么实现的，为什么还可以看到一些变量的值。</li><li>地址对齐。（这里是先问我学过c没有，我说学过，他就给了我一段代码： struct A{ short a; int b;short c;}; struct B{ short a; int b; short c;}; 问这两个结构体在内存里分配的空间一样大吗。如果把B里面的 int b 和 short c调整一下顺序，还一样大吗，为什么。）</li><li>Linux是用c/c++写的，为什么可以运行(或加载？) js、html。 （这个问题我不是很懂，所以也不太记得具体怎么问的了。。）</li><li>重写和重载的区别。</li><li>HTTP如何实现断点续传的。</li><li>问了一下项目。</li></ol><p>结束后，面试官让我不要退，让我十五分钟后二面。一面小哥哥人很nice的，让我等会二面不要这么紧张，放松一点。</p><h3 id="二面-（3-18-视频面-45min）"><a href="#二面-（3-18-视频面-45min）" class="headerlink" title="二面 （3.18 视频面 45min）"></a><strong>二面 （3.18 视频面 45min）</strong></h3><ol><li>ArrayList和LinkedList的区别。</li><li>List如何删除。（为什么用iterator的不用List的删除方法，讲了一下ConcurrentModificationException）</li><li>重写和重载的区别。</li><li>如何实现多态，多态的底层实现原理是什么（方法表）</li><li>Handler原理。 （讲完后，问了一下取出message之后怎么知道要给哪个handler分发）</li><li>HandlerThread原理。</li><li>Looper。（大致就是想让回答 Android是依靠事件驱动的，通过Looper.loop()不断进行消息循环之类的）</li><li>事件分发机制。（ 讲完后问 如果注册了onTouchListener会发生什么）</li><li>项目的难点是什么，收获最大的是什么，现在回看项目，有哪些需要改进的地方。</li><li>还问了我愿不愿意去北京实习，我拒绝了…</li><li>算法：给定一个有序数组和target，判断target是否在数组里重复出现，如果有，输出第一次出现的下标。</li></ol><h3 id="三面-（3-22-视频面-1h）"><a href="#三面-（3-22-视频面-1h）" class="headerlink" title="三面 （3.22 视频面 1h）"></a><strong>三面 （3.22 视频面 1h）</strong></h3><p>其实3.18下午hr给我打电话，约3.20下午三面，结果到点后，面试官迟迟没出现，我问hr后，hr说面试官有事，让我改一个时间（……..）</p><ol><li>Object有哪些公有方法。</li><li>讲一下equals()。</li><li>讲一下hashCode()。（这里提到了hashmap的原理）</li><li>wait()的用法，notifyAll()的用法，notify()唤醒的是哪一个线程。</li><li>讲一下clone()，深拷贝和浅拷贝的区别。</li><li>讲一下jmm。</li><li>如何在栈上开辟空间。</li><li>如何在堆里开辟空间。</li><li>怎么会造成栈溢出，堆溢出。</li><li>类加载机制，什么时候需要对类进行初始化。</li><li>静态变量，实例变量，构造函数的初始化顺序。</li><li>如何减少GC，有哪些高频方***经常创建对象（好像是这个意思…） 【这里他问我擅长什么，我说gc（因为关于回收算法和垃圾收集器我记得比较熟），然后他说分代收集算法那些就不用讲了，就一直在问一些我不懂的东西，我真是搬起石头砸自己的脚….】</li><li>AsyncTask的原理。</li><li>Listview的复用机制，Listview和Recyclerview的区别。</li><li>一般怎么学习新技术（这里一定要你举个具体的例子，你通过什么渠道学习到了什么新的东西，我扯了半天说到jdk 1.7到jdk 1.8的变化，他问我具体有什么，我说haspmap从数组+链表变成了数组+链表+红黑树，他这时才说可以了…）</li><li>用过哪些数据结构。</li><li>数组和链表的区别，适用场景，为什么数组查找快，链表插入块。hashmap查找的时间复杂度，最好和最坏情况下是多少。</li><li>会什么算法。</li><li>快速排序思想讲一下， 复杂度是多少，最优和最坏情况复杂度是多少，怎么算出来的。</li><li>找出数组里重复次数最多的数（我这里了讲一种要排序的，一种不用排序然后用hashmap，他问我时间复杂度各是多少）</li><li>HTTP的报文格式是什么。</li><li>get和post的区别。</li><li>你在访问一个网站的时候，发生了什么，涉及到什么协议，讲传输层里的。</li><li>给了我一段代码，让我讲一下这个函数的作用是什么，大概是：</li></ol><p>int isPair(int a,int b){</p><p>int sum=a+b;</p><p>return sum&gt;100? 1:(sum&lt;100?-1:0);</p><p>}</p><p>int countPair(int []array){</p><p>//Todo…</p><p>}</p><p>讲完后，让我实现下面那个函数，让我求出数组里有多少对相加等于100的，我想的是排序后，用头尾指针，我写完代码后，他说你这就结束了？让我想一下哪里有问题，还让我想一想如果不排序怎么做。</p><p>然后说今天面试结束了，面试官就下线了（也没让我提问….）</p><p>问题应该不止这些，尤其是三面，不停的问我，也不让我介绍项目，而且面试官气场超强，你无论说什么他面部表情都没什么变化的，让我压力倍大。。</p><p>大致就是这些啦，感觉三面有点凉的…</p><h3 id="hr面-（3-25-电话面-15min）"><a href="#hr面-（3-25-电话面-15min）" class="headerlink" title="hr面 （3.25 电话面 15min）"></a><strong>hr面 （3.25 电话面 15min）</strong></h3><ol><li>问了我其中一个比赛，一个队伍里有多少人，担任什么职责。</li><li>大学做过的最骄傲的事情是什么。</li><li>说下自己的三个特质。（我说了一个自己的缺点，问我为什么会这么觉得）</li><li>大学最遗憾的事情是什么。</li><li>希望自己的leader是什么样的人。</li><li>希望在什么样的环境/氛围中工作。</li><li>还有面什么公司，如果那个公司也给你offer，你会怎么选。</li><li>什么时候可以开始实习，可以实习多久，有转正的意向吗。</li></ol><p>最后hr说他那边应该没什么问题了，但是offer还要走几天的流程。</p><h2 id="字节跳动android实习生一面二面"><a href="#字节跳动android实习生一面二面" class="headerlink" title="字节跳动android实习生一面二面"></a>字节跳动android实习生一面二面</h2><p><a href=""><img src="https://images.nowcoder.com/images/20190801/730852429_1564634677812_786221A2A5F38A0CB9E8944F4CD9D670?x-oss-process=image/resize,m_mfit,h_100,w_100" alt="头像"></a></p><h3 id="JFLIN"><a href="#JFLIN" class="headerlink" title="JFLIN"></a><a href="">JFLIN</a></h3><p>编辑于  2020-02-14 11:49:04 APP内打开</p><p>​    本人大三，在暑假的时候参加过学校与字节跳动合作的android夏令营，得到了android实习生面试的机会，刷了leetcode，看了看android和java的复习资料，就参加面试了。</p><p>​    一面 </p><p>​    1. Parcelable和Serializable是什么，做什么用，谁更高效 </p><p>​    2. 数据库中的事务 </p><p>​    3. 假如手机只有10M内存，想要申请1M的内存是否一定成功 </p><p>​    4. 讲一下时间片 </p><p>​    5. 对线程池的理解 </p><p>​    6. 想要在一个图片右上角实现一个圆角怎么实现 </p><p>​    7. Java的四种引用 </p><p>​    8. 抖音无限上滑怎么实现 </p><p>​    9. 什么时候会发生内存泄漏 </p><p>​    10. 算法题 两数之和 时间复杂度 </p><p>​    二面 </p><p>​    1. 自我介绍，做过的项目 </p><p>​    2. 数据库频繁读数据，可以用什么方式来优化（索引） </p><p>​    3. 死锁的四个条件，开发过程中什么情况容易造成死锁 </p><p>​    4. 手机端应该和电脑端应用的注意事项和区别。（机型适配） </p><p>​    5. C++和java如何实现多态性，public的父类中子类重写能不能用protected？反过来呢？ </p><p>​    6. Mini抖音中做了哪些？遇到的困难以及如何解决。 </p><p>​    7. 场景题 抖音开屏广告如何实现（包括倒计时和要播放的视频），倒计时点击跳过的时候应该如何实现？倒计时用Handler，播放的视频url打开时存在本地文件 </p><p>​    8. 算法题 二叉树的最长路径（DP） </p><p>总体来说面的情况不是很好，也通知了我二面没有通过，但是自己的第一次面试经历，还是值得记录下来的。个人觉得算法还是非常重要的，准备的还不够充分，抱着侥幸心理只刷了常见的算法题型。而且大学教的内容实在太局限了，需要多学一些额外的知识。</p><p>作者：夜老虎<br>链接：<a href="https://www.nowcoder.com/discuss/388317" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/388317</a><br>来源：牛客网</p><h2 id="字节跳动Android暑期实习5面面经"><a href="#字节跳动Android暑期实习5面面经" class="headerlink" title="字节跳动Android暑期实习5面面经"></a>字节跳动Android暑期实习5面面经</h2><p><a href=""><img src="https://images.nowcoder.com/images/20181209/563694157_1544346495974_605475850F555A9A1D76953CFB3E39A6?x-oss-process=image/resize,m_mfit,h_100,w_100" alt="头像"></a></p><h3 id="夜老虎"><a href="#夜老虎" class="headerlink" title="夜老虎"></a>夜老虎</h3><p>发布于  2020-03-21 21:32:56 APP内打开</p><p>  昨天hr打电话来，已确认offer~ </p><p>  <strong>一面</strong> </p><p>  一个超级像吴恩达的大佬，不论是发型还是气质。听他介绍说是字节跳动helo部门的安卓架构师（果然是大佬）。然后我也简单自我介绍后就开始问问题了。 </p><p>  l 谈谈Activity的生命周期。假设有两个activity，分别是A和B，请你讲讲从A到B，再从B返回到A的生命周期。A和B的切换动画发生在哪个周期中？怎么想让B销毁时告知A？（我说了可以通过在Application定义一个静态变量，但其实用广播或EventBus也可以） </p><p>  l 怎样保存Activity的状态（saveInatanceState（））,发生在哪个生命周期？想要恢复状态呢？ </p><p>  l 刚刚你谈到静态变量，静态变量和普通变量有什么区别？普通内部类和静态内部类有什么区别？怎样在main方法新建普通内部类对象？怎么新建静态内部类对象？写一下。（一紧张没把新建普通内部类对象写出来，尴尬） </p><p>  l 类的访问权限（public,protect,default,private） </p><p>  l 抽象类和接口的区别。 </p><p>  l 重写和重载的区别？然后问了一个有关重写的问题，如下。 </p><p>​           class   A{                public void method1(){                …….                }                }                                class   B extends A{                @override                public   void method1(){                …….                }                                public   static void main(String[] args){                A   b=new B();                b.method1();                }                }                问调用的是A的method1还是B的method1.         </p><p>  l 算法题：两数之和（求和为Target的所有数对，数对可重复） </p><p>  l 有什么想问我的吗？ </p><p>  <strong>二面</strong> </p><p>  和一面连着面的，让等了20分钟左右。是个比较年轻的小哥哥，带着口罩，非常和善。先是问Java的问题，然后是Android的问题。 </p><p>  l 已知int i=123,问”i==new Integer(123)”返回true还是false?（装箱拆箱） </p><p>  l ==和equals的区别。 </p><p>  l 知道String.intern()方法吗？（不知道…） </p><p>  l 谈谈反射机制。 </p><p>  l 什么是多态？动态绑定是什么？ </p><p>  l 有哪些进程间通信机制？共享内存是怎么实现的？ </p><p>  l Activity的启动模式？taskAffinity属性用什么用？假设有两个activity，分别是A和B，请你讲讲从A到B，再从B返回到A的生命周期（四种启动模式情况下都说一遍） </p><p>  l 算法题：两数之和（没错，又是这个，只不过这次要求不能有重复数对） </p><p>  l 有什么想问我的吗？ </p><p>  <strong>三面：</strong> </p><p>  上来连自我介绍都不用，直接开始问问题。 </p><p>  l context是什么？application和activity的context的区别。 </p><p>  l Android有哪几种广播?怎么声明广播，有什么区别？ </p><p>  l Binder是什么？ </p><p>  l final关键字的作用，用final修饰的变量可以改变吗？（通过反射） </p><p>  l 手写有参数传入的单例。（双重校验模式） </p><p>  l https是什么？证书下发过程是怎么样的？ </p><p>  l 算法题：反转链表 </p><p>  l 有什么问题想问我吗？ </p><p>  <strong>HR**</strong>面：** </p><p>  l 为什么想来字节？ </p><p>  l 准备在哪发展？ </p><p>  l 在学校成绩排名怎么样？为什么排名中等，原因是什么？ </p><p>  l 哪件事你觉得最有成就感？ </p><p>  l 如果大学再来一次，你觉得结果会怎么样？ </p><p>  l 有什么爱好？ </p><p>  l 有同时投其他公司的简历吗？ </p><p>  l 什么时候能来实习？ </p><p>  <strong>加面–部门leader面：</strong> </p><p>  在等hr的offer确认通知时，等来的却是加面通知，说这是部门Leader面，一定要认真对待，和我预约个时间。当时心里就像尼克杨那个黑人问号图，我能怎么办，我也很绝望啊，但只能乖乖复习。 </p><p>  Leader一上来就开始让我写算法题，然后再是自我介绍。 </p><p>  l 有一个树，大概长这个样子。问从根节点在n步之内走到某个值为x的节点的概率。（当时听题目就听了半天，然后一脸懵逼硬着头皮开始写，自然是没写出来，只能大概说说思路维持生活这样子） </p><p>  l 实验室的研究方向是什么？你做的是哪部分，你觉得你实验效果没有别人好是什么原因？（这部分问得很细，深感leader就是leader，什么都懂，不论是开发还是算法） </p><p>  l 设计一个图片加载库，从网络，缓存，展示这几个方面分别说说。 </p><p>  l 设计一个视频播放库，怎么实现边下边播？（都问得很细，考察你的问题解决能力） </p><p>  <strong>总结</strong>：算法一定要多练，现在公司针对越来越注重算法了。然后字节比较注重基础，多看看基础知识（操作系统，数据库，网络），不要光是背，多看看原理。还有就是，要提前熟悉牛客的OJ，牛OJ是要手动导包的，然后要手动编写测试用例，我一面就是在这吃了大亏，以为是和leetcode一样的，写完就运行，却发现一直报错..</p><p>作者：上岸不想淹死<br>链接：<a href="https://www.nowcoder.com/discuss/376333?type=0&amp;order=0&amp;pos=31&amp;page=1" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/376333?type=0&amp;order=0&amp;pos=31&amp;page=1</a><br>来源：牛客网</p><h2 id="字节跳动安卓客户端一二面凉经"><a href="#字节跳动安卓客户端一二面凉经" class="headerlink" title="字节跳动安卓客户端一二面凉经"></a>字节跳动安卓客户端一二面凉经</h2><p><a href=""><img src="https://images.nowcoder.com/images/20200424/2682868_1587726845973_30E4DBA120F1E6B4FE4D748EC5F80F3D?x-oss-process=image/resize,m_mfit,h_100,w_100" alt="头像"></a></p><h3 id="上岸不想淹死"><a href="#上岸不想淹死" class="headerlink" title="上岸不想淹死"></a><a href="">上岸不想淹死</a></h3><p>编辑于  2020-03-06 19:09:43 APP内打开</p><h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><h4 id="如果之前没有接触过多线程编程的，最好学好了再去面试。毕竟面试官都是有开发经验的，很喜欢问并发编程多线程问题。有一说一，字节跳动的面试官实力和态度都很好，人生第一次面试也算收获不小。"><a href="#如果之前没有接触过多线程编程的，最好学好了再去面试。毕竟面试官都是有开发经验的，很喜欢问并发编程多线程问题。有一说一，字节跳动的面试官实力和态度都很好，人生第一次面试也算收获不小。" class="headerlink" title="如果之前没有接触过多线程编程的，最好学好了再去面试。毕竟面试官都是有开发经验的，很喜欢问并发编程多线程问题。有一说一，字节跳动的面试官实力和态度都很好，人生第一次面试也算收获不小。"></a>如果之前没有接触过多线程编程的，最好学好了再去面试。毕竟面试官都是有开发经验的，很喜欢问并发编程多线程问题。有一说一，字节跳动的面试官实力和态度都很好，人生第一次面试也算收获不小。</h4><h4 id="流程是：找人内推，最快一天不到就会HR打电话过来约面试时间。时间以自己和面试官都有时间为准，我2-15约了半个月后，以为好好准备一下，没想到。。。。。"><a href="#流程是：找人内推，最快一天不到就会HR打电话过来约面试时间。时间以自己和面试官都有时间为准，我2-15约了半个月后，以为好好准备一下，没想到。。。。。" class="headerlink" title="流程是：找人内推，最快一天不到就会HR打电话过来约面试时间。时间以自己和面试官都有时间为准，我2/15约了半个月后，以为好好准备一下，没想到。。。。。"></a>流程是：找人内推，最快一天不到就会HR打电话过来约面试时间。时间以自己和面试官都有时间为准，我2/15约了半个月后，以为好好准备一下，没想到。。。。。</h4><h4 id="一面-3-3-，其实答完以为挂了的，毕竟异常和代码都没弄好，最后面试官的说法又很像是挂了，所以没抱希望，第二天还收到了调查问卷。但是过了26小时左右，收到了HR电话约二面，意外之喜。"><a href="#一面-3-3-，其实答完以为挂了的，毕竟异常和代码都没弄好，最后面试官的说法又很像是挂了，所以没抱希望，第二天还收到了调查问卷。但是过了26小时左右，收到了HR电话约二面，意外之喜。" class="headerlink" title="一面(3/3)，其实答完以为挂了的，毕竟异常和代码都没弄好，最后面试官的说法又很像是挂了，所以没抱希望，第二天还收到了调查问卷。但是过了26小时左右，收到了HR电话约二面，意外之喜。"></a>一面(3/3)，其实答完以为挂了的，毕竟异常和代码都没弄好，最后面试官的说法又很像是挂了，所以没抱希望，第二天还收到了调查问卷。但是过了26小时左右，收到了HR电话约二面，意外之喜。</h4><ul><li><p>自我介绍</p></li><li><p>线程的并发并行区别</p></li><li><p>讲讲HashMap</p></li><li><p>了解数据库？答：在学校有这门课，做过实验。  讲讲索引</p></li><li><p>java异常体系</p></li><li><p>撕代码：无序数组的中位数，O(n)复杂度。我答的堆排序，直接排序什么的，复杂度都是O(nlogn),后面提示快速排序的思想，还是没想出来，就过了。</p></li><li><p>手撕快排。秒了，不过他说有点问题，不过我跑的自己写的测试用例没问题。</p></li><li><p>今天面试就到这里，</p><p><em>**二面</em></p><p>。我没听清，以为说有二面，就问有二面吗？他说有没有HR会通知。</p><h1 id="二面-3-6-。这次是肯定凉了，整个答的非常菜"><a href="#二面-3-6-。这次是肯定凉了，整个答的非常菜" class="headerlink" title="二面(3/6)。这次是肯定凉了，整个答的非常菜"></a>二面(3/6)。这次是肯定凉了，整个答的非常菜</h1></li><li><p>没自我介绍直接撕题目。Dijkstra算法（迪杰斯特拉）实现，没做出来</p></li><li><p>手撕double check单例模式。没写好，我以为网上看的那个是对的，面试官说要用voltile关键字</p></li><li><p>voltile关键字与synchronized关键字区别，没答好，背的面经，没用过，禁不起问</p></li><li><p>垃圾回收机制。A，B互相引用会不会被回收。一样没答好</p></li><li><p>问我计算机网络熟嘛？我说还可以。那get的请求报文格式。就答出一部分，哎，是我太菜，以为问我三次握手四次挥手呢。。。</p></li><li><p>你有什么想问我的吗？我说希望后面继续努力，还是很想进字节的。</p></li></ul><p>作者：别怕别怕<br>链接：<a href="https://www.nowcoder.com/discuss/439455?type=2&amp;order=0&amp;pos=9&amp;page=1&amp;channel=666&amp;source_id=discuss_tag" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/439455?type=2&amp;order=0&amp;pos=9&amp;page=1&amp;channel=666&amp;source_id=discuss_tag</a><br>来源：牛客网</p><h2 id="移动客户端开发（抖音）面经"><a href="#移动客户端开发（抖音）面经" class="headerlink" title="移动客户端开发（抖音）面经"></a>移动客户端开发（抖音）面经</h2><p><a href=""><img src="https://images.nowcoder.com/images/20200211/957197526_1581436371827_98C668A6514FF84FF0FE23AEF2685BF7?x-oss-process=image/resize,m_mfit,h_100,w_100" alt="头像"></a></p><h3 id="别怕别怕"><a href="#别怕别怕" class="headerlink" title="别怕别怕"></a><a href="">别怕别怕</a></h3><p>一面<br> java：<br> 1、jvm启动过程? 验证是验证什么</p><p> 2、强引用、软引用、弱引用、虚引用，是什么？分别在什么时候用</p><p> 3、反序列和序列化 为什么要？ 什么情况下要？</p><p> 4、反射 为什么要反射？ 什么时候用？ 缺点？ </p><p> 5、hashcode 为什么出现、是什么、equals关系<br> c语言：<br> 6、include 作用、import作用</p><p> 7、static关键字：c跟java</p><p> 8、动态编译、静态编译</p><p> 9、线程通信</p><p>​    10、设计模式：生产者消费者、工厂模式、单例模式（3种实现、为什么双验证）你会怎么设计</p><p>​    11、tcp和udp区别</p><p>​    11、做一道题topk的题，指定用快排的思路</p><p> 二面</p><p> 1、项目及项目里用到的知识<br> 2、3次握手、4次挥手、为什么不4次、5次<br> 3、数据结构，10大排序挑2个讲<br> 4、计算机系统，中断是怎么实现的<br> 5、计算机系统的锁底层是怎么样实现的<br> 6、多核cpu，多线程怎么访问同一个内存<br> 安卓：<br> 7、怎么学安卓<br> 8、handle作用，为什么<br> 9、有没有写过安卓的多线程<br> 还有的有点记不清了</p><p> 三面</p><p> 1、项目，项目遇到什么问题，怎么解决<br> 2、有没有接触过安卓，怎么看内存占用情况<br> 3、有没有用过什么框架<br> 4、有没有用过GitHub<br> 5、安卓生命周期<br> c++:<br> 6、list与vector区别<br> 7、多态<br> 8、能不能来实习<br> 9、做题<br> 排序，给一个链表，按照链表某个值排序</p><p>作者：Time_lord<br>链接：<a href="https://www.nowcoder.com/discuss/442244" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/442244</a><br>来源：牛客网</p><h2 id="21届秋招-字节——安卓开发实习生-面经"><a href="#21届秋招-字节——安卓开发实习生-面经" class="headerlink" title="[21届秋招] 字节——安卓开发实习生 面经"></a>[21届秋招] 字节——安卓开发实习生 面经</h2><p><a href=""><img src="https://images.nowcoder.com/images/20180302/2622585_1519998247861_6DB47CD787164AF62BE59CFD6C81D81B?x-oss-process=image/resize,m_mfit,h_100,w_100" alt="头像"></a></p><h3 id="Time-lord-字节跳动提前批"><a href="#Time-lord-字节跳动提前批" class="headerlink" title="Time_lord  #字节跳动提前批# "></a><a href="">Time_lord</a> <a href=""> #字节跳动提前批# </a></h3><p>编辑于  2020-06-21 12:23:01 APP内打开</p><h4 id="一面"><a href="#一面" class="headerlink" title="一面:"></a>一面:</h4><p>先自我介绍<br>进程线程了解吗<br>再浏览器中输入url回车后发生了什么<br>TCP和UDP的区别<br>然后开始写题<br>1.求树的直径<br>2.给一个链表，判断链表元素是否回文，要求空间复杂度O(1)<br>写完接着二面</p><h4 id="二面"><a href="#二面" class="headerlink" title="二面:"></a>二面:</h4><p>DNS解析的过程<br>然后接着写题:<br>1.如何判断一个二叉树是否是完全二叉树<br>2.手写一个堆排序<br>然后随便聊了会儿天</p><p>感觉自己代码写得好烂，全是bug，调了好长时间，语言的基础竟然没问。<br>通知周日三面，许愿三面能过</p><h4 id="2020-6-21更新"><a href="#2020-6-21更新" class="headerlink" title="2020.6.21更新"></a>2020.6.21更新</h4><h4 id="三面"><a href="#三面" class="headerlink" title="三面"></a>三面</h4><p>自我介绍<br>问了高考的情况<br>问了学校的竞赛经历<br>然后写题，一个dp一个单调栈<br>很短，我都以为我要挂了，不一会hr打电话来hr面了</p><h4 id="hr面"><a href="#hr面" class="headerlink" title="hr面"></a>hr面</h4><p>自我介绍<br>介绍了下最近在看的csapp这本书<br>问竞赛中印象深刻的事情<br>然后随便聊聊</p><p>总共加起来一共2h40m的面试。有一说一字节的面试体验真的好，大家都很和蔼</p><p>最后许愿offer</p><h2 id="字节安卓一面二面面经"><a href="#字节安卓一面二面面经" class="headerlink" title="字节安卓一面二面面经"></a>字节安卓一面二面面经</h2><p><a href=""><img src="https://images.nowcoder.com/head/138m.png?x-oss-process=image/resize,m_mfit,h_100,w_100" alt="头像"></a></p><h3 id="hahhahaah"><a href="#hahhahaah" class="headerlink" title="hahhahaah"></a><a href="">hahhahaah</a></h3><p>编辑于  2020-06-08 12:12:51 APP内打开</p><h3 id="字节抖音安卓客户端一面二面面经，许愿三面。"><a href="#字节抖音安卓客户端一面二面面经，许愿三面。" class="headerlink" title="字节抖音安卓客户端一面二面面经，许愿三面。"></a>字节抖音安卓客户端一面二面面经，许愿三面。</h3><p>没有录音，纯凭回忆，有些问题可能有遗漏。</p><h4 id="更新，已收到三面通知。"><a href="#更新，已收到三面通知。" class="headerlink" title="更新，已收到三面通知。"></a>更新，已收到三面通知。</h4><h4 id="一面-6-4-（30分钟）"><a href="#一面-6-4-（30分钟）" class="headerlink" title="一面 6.4 （30分钟）"></a>一面 6.4 （30分钟）</h4><p>1.项目情况<br>2.handler原理<br>3.怎么解决handler内存泄露<br>4.四大引用<br>5.接口和抽象类区别<br>6.对MVP的理解<br>7.retrofit源码<br>8.java面向对象三大特性<br>9.java异常机制<br>10.算法：反转链表</p><h4 id="二面-6-4（40分钟）"><a href="#二面-6-4（40分钟）" class="headerlink" title="二面 6.4（40分钟）"></a>二面 6.4（40分钟）</h4><p>1.项目情况<br>2.最近解决过的项目中的困难<br>3.handler原理<br>4.ANR原因<br>5.ANR排查<br>6.怎么解决加载大图OOM的问题<br>7.https过程，对称加密，非对称加密<br>8.TCP和UDP区别<br>9.手撕代码：单例模式DCL，面试官问我有没有更优的，我说了枚举的方式，但没写出来。。<br>二叉搜索树转双向链表，一开始是用ArrayList写的，面试官说只能原地操作，然后就卡了。<br>后面面试官又出了一道，大数加法，写到最后有情况没考虑到，面试官提示了一句，后面写出来了。<br>面试体验：两个面试官都还不错，只能怪自己菜。二面感觉答得不是很好，最后问面试官评价的时候，他说不能告诉我，让我等hr联系（一面的面试官很倒是说我还不错）。感觉有点凉，等了一天hr的电话，等到现在也没有。还是许愿一下希望能收到三面的通知吧。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/Android/事件分发机制</title>
      <link href="blog/150980626.html"/>
      <url>blog/150980626.html</url>
      
        <content type="html"><![CDATA[<p><img src=".%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6_images/0feff0b4.png" alt=""><br><img src=".%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6_images/f09c9732.png" alt=""><br><img src=".%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6_images/93f8ddd7.png" alt="">  </p><p><img src=".%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6_images/0eefdc9b.png" alt="">  </p><ol><li><p>onClick 和 onTouch都会打印吗<br>事件分发开始会走到这里View.dispatchTouchEvent()-&gt;<br>li.mOnTouchListener.onTouch(this, event)-&gt;<br>false的话-&gt;onTouchEvent(event)-&gt;case MotionEvent.ACTION_UP-&gt;<br>performClick();-&gt; li.mOnClickListener.onClick(this);</p><p>所onTouch返回false时会执行onClick,true则不会<br><img src=".%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6_images/8bb0d5c9.png" alt="">  </p></li></ol><p><img src=".%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6_images/image-20200426160519980.png" alt="image-20200426160519980"></p><p>ViewPager包含Listview  </p><ol><li>onInterceptTouchEvent返回true时 为什么只能左右滑动 不能上下滑</li></ol><p>onInterceptTouchEvent 返回true不会问下面了，直接处理 消费掉，</p><p>return false 才会传给下面.</p><ol start="2"><li>onInterceptTouchEvent返回true时 为什么只能上下滑动 不能左右滑</li></ol><pre class=" language-java"><code class="language-java"><span class="token punctuation">[</span>Activity<span class="token punctuation">.</span>java<span class="token punctuation">]</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">dispatchTouchEvent</span><span class="token punctuation">(</span>MotionEvent ev<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>ev<span class="token punctuation">.</span><span class="token function">getAction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> MotionEvent<span class="token punctuation">.</span>ACTION_DOWN<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">onUserInteraction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">getWindow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">superDispatchTouchEvent</span><span class="token punctuation">(</span>ev<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token function">onTouchEvent</span><span class="token punctuation">(</span>ev<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token punctuation">[</span>Activity<span class="token punctuation">.</span>java<span class="token punctuation">]</span>  <span class="token keyword">public</span> Window <span class="token function">getWindow</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> mWindow<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">private</span> Window mWindow<span class="token punctuation">;</span></code></pre><p>Window只有唯一的实现类PhoneWindow</p><pre class=" language-java"><code class="language-java"><span class="token punctuation">[</span>Window<span class="token punctuation">.</span>java<span class="token punctuation">]</span>The only existing implementation of <span class="token keyword">this</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">is</span> <span class="token operator">*</span> android<span class="token punctuation">.</span>view<span class="token punctuation">.</span>PhoneWindow<span class="token punctuation">,</span> which you should instantiate when needing a <span class="token operator">*</span> Window<span class="token punctuation">.</span> <span class="token operator">*</span><span class="token operator">/</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Window</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token punctuation">[</span>PhoneWindow<span class="token punctuation">.</span>java<span class="token punctuation">]</span><span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">superDispatchTouchEvent</span><span class="token punctuation">(</span>MotionEvent event<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> mDecor<span class="token punctuation">.</span><span class="token function">superDispatchTouchEvent</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// This is the top-level view of the window, containing the window decor.</span>    <span class="token keyword">private</span> DecorView mDecor<span class="token punctuation">;</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token punctuation">[</span>DecorView<span class="token punctuation">.</span>java<span class="token punctuation">]</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DecorView</span> <span class="token keyword">extends</span> <span class="token class-name">FrameLayout</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">superDispatchTrackballEvent</span><span class="token punctuation">(</span>MotionEvent event<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">dispatchTouchEvent</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p><code>FrameLayout</code>没有重写<code>dispatchTouchEvent</code>，接下来，直接到了</p><ol><li><code>disallowIntercept</code>：是否禁用掉拦截，可以通过<code>requestDisallowInterceptTouchEvent(boolean disallowIntercept)</code>请求不拦截</li><li>先走ViewGroup的<code>onInterceptTouchEvent</code>，默认返回false  </li><li>ViewGroup不拦截的话，分发事件，怎么分发的？<ol><li><code>buildTouchDispatchChildList()：</code>根据Z值对它的子view 进行排序,返回一个ArrayList</li><li>遍历判断<ol><li><code>canViewReceivePointerEvents</code>：是否能够接收点击事件</li><li><code>isTransformedTouchPointInView</code>:点击事件是否在点击的view区域中</li><li><code>dispatchTransformedTouchEvent</code>分发调用child.dispatchTouchEvent, 这里child如果是ViewGroup，相当于这里递归调用了VIewGroup的dispatchTouchEvent；向下传递的过程中，如果拦截/响应了事件则终止向下传递，并返回给父，父也不用处理了</li><li>拦截/响应事件后设置参数<ol><li><code>newTouchTarget = addTouchTarget(child,) = mFirstTouchTarget;</code></li><li><code>alreadyDispatchedToNewTouchTarget = true</code></li></ol></li></ol></li></ol></li></ol><pre class=" language-java"><code class="language-java"><span class="token punctuation">[</span>ViewGroup<span class="token punctuation">.</span>java<span class="token punctuation">]</span> <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">dispatchTouchEvent</span><span class="token punctuation">(</span>MotionEvent ev<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token comment" spellcheck="true">// Check for interception.</span>            <span class="token keyword">final</span> <span class="token keyword">boolean</span> intercepted<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>actionMasked <span class="token operator">==</span> MotionEvent<span class="token punctuation">.</span>ACTION_DOWN                    <span class="token operator">||</span> mFirstTouchTarget <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">final</span> <span class="token keyword">boolean</span> disallowIntercept <span class="token operator">=</span> <span class="token punctuation">(</span>mGroupFlags <span class="token operator">&amp;</span> FLAG_DISALLOW_INTERCEPT<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>disallowIntercept<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    intercepted <span class="token operator">=</span> <span class="token function">onInterceptTouchEvent</span><span class="token punctuation">(</span>ev<span class="token punctuation">)</span><span class="token punctuation">;</span>                    ev<span class="token punctuation">.</span><span class="token function">setAction</span><span class="token punctuation">(</span>action<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// restore action in case it was changed</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    intercepted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// There are no touch targets and this action is not an initial down</span>                <span class="token comment" spellcheck="true">// so this view group continues to intercept touches.</span>                intercepted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>      <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token comment" spellcheck="true">//2.事件分发  </span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>canceled <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>intercepted<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// If the event is targeting accessiiblity focus we give it to the</span>                <span class="token comment" spellcheck="true">// view that has accessibility focus and if it does not handle it</span>                <span class="token comment" spellcheck="true">// we clear the flag and dispatch the event to all children as usual.</span>                <span class="token comment" spellcheck="true">// We are looking up the accessibility focused host to avoid keeping</span>                <span class="token comment" spellcheck="true">// state since these events are very rare.</span>                View childWithAccessibilityFocus <span class="token operator">=</span> ev<span class="token punctuation">.</span><span class="token function">isTargetAccessibilityFocus</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                        <span class="token operator">?</span> <span class="token function">findChildWithAccessibilityFocus</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> null<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>actionMasked <span class="token operator">==</span> MotionEvent<span class="token punctuation">.</span>ACTION_DOWN                        <span class="token operator">||</span> <span class="token punctuation">(</span>split <span class="token operator">&amp;&amp;</span> actionMasked <span class="token operator">==</span> MotionEvent<span class="token punctuation">.</span>ACTION_POINTER_DOWN<span class="token punctuation">)</span>                        <span class="token operator">||</span> actionMasked <span class="token operator">==</span> MotionEvent<span class="token punctuation">.</span>ACTION_HOVER_MOVE<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">final</span> <span class="token keyword">int</span> actionIndex <span class="token operator">=</span> ev<span class="token punctuation">.</span><span class="token function">getActionIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// always 0 for down</span>                    <span class="token keyword">final</span> <span class="token keyword">int</span> idBitsToAssign <span class="token operator">=</span> split <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> ev<span class="token punctuation">.</span><span class="token function">getPointerId</span><span class="token punctuation">(</span>actionIndex<span class="token punctuation">)</span>                            <span class="token operator">:</span> TouchTarget<span class="token punctuation">.</span>ALL_POINTER_IDS<span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// Clean up earlier touch targets for this pointer id in case they</span>                    <span class="token comment" spellcheck="true">// have become out of sync.</span>                    <span class="token function">removePointersFromTouchTargets</span><span class="token punctuation">(</span>idBitsToAssign<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">final</span> <span class="token keyword">int</span> childrenCount <span class="token operator">=</span> mChildrenCount<span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>newTouchTarget <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span> childrenCount <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">final</span> <span class="token keyword">float</span> x <span class="token operator">=</span> ev<span class="token punctuation">.</span><span class="token function">getX</span><span class="token punctuation">(</span>actionIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">final</span> <span class="token keyword">float</span> y <span class="token operator">=</span> ev<span class="token punctuation">.</span><span class="token function">getY</span><span class="token punctuation">(</span>actionIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// Find a child that can receive the event.</span>                        <span class="token comment" spellcheck="true">// Scan children from front to back.</span>                        <span class="token keyword">final</span> ArrayList<span class="token operator">&lt;</span>View<span class="token operator">></span> preorderedList <span class="token operator">=</span> <span class="token function">buildTouchDispatchChildList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">final</span> <span class="token keyword">boolean</span> customOrder <span class="token operator">=</span> preorderedList <span class="token operator">==</span> null                                <span class="token operator">&amp;&amp;</span> <span class="token function">isChildrenDrawingOrderEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">final</span> View<span class="token punctuation">[</span><span class="token punctuation">]</span> children <span class="token operator">=</span> mChildren<span class="token punctuation">;</span>                        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> childrenCount <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                            <span class="token keyword">final</span> <span class="token keyword">int</span> childIndex <span class="token operator">=</span> <span class="token function">getAndVerifyPreorderedIndex</span><span class="token punctuation">(</span>                                    childrenCount<span class="token punctuation">,</span> i<span class="token punctuation">,</span> customOrder<span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token keyword">final</span> View child <span class="token operator">=</span> <span class="token function">getAndVerifyPreorderedView</span><span class="token punctuation">(</span>                                    preorderedList<span class="token punctuation">,</span> children<span class="token punctuation">,</span> childIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token comment" spellcheck="true">// If there is a view that has accessibility focus we want it</span>                            <span class="token comment" spellcheck="true">// to get the event first and if not handled we will perform a</span>                            <span class="token comment" spellcheck="true">// normal dispatch. We may do a double iteration but this is</span>                            <span class="token comment" spellcheck="true">// safer given the timeframe.</span>                           <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span>newTouchTarget <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                                <span class="token comment" spellcheck="true">// Child is already receiving touch within its bounds.</span>                                <span class="token comment" spellcheck="true">// Give it the new pointer in addition to the ones it is handling.</span>                                newTouchTarget<span class="token punctuation">.</span>pointerIdBits <span class="token operator">|=</span> idBitsToAssign<span class="token punctuation">;</span>                                <span class="token keyword">break</span><span class="token punctuation">;</span>                            <span class="token punctuation">}</span>                            <span class="token function">resetCancelNextUpFlag</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">dispatchTransformedTouchEvent</span><span class="token punctuation">(</span>ev<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> child<span class="token punctuation">,</span> idBitsToAssign<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                                <span class="token comment" spellcheck="true">// Child wants to receive touch within its bounds.</span>                                mLastTouchDownTime <span class="token operator">=</span> ev<span class="token punctuation">.</span><span class="token function">getDownTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                <span class="token keyword">if</span> <span class="token punctuation">(</span>preorderedList <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                                    <span class="token comment" spellcheck="true">// childIndex points into presorted list, find original index</span>                                    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> childrenCount<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                                        <span class="token keyword">if</span> <span class="token punctuation">(</span>children<span class="token punctuation">[</span>childIndex<span class="token punctuation">]</span> <span class="token operator">==</span> mChildren<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                                            mLastTouchDownIndex <span class="token operator">=</span> j<span class="token punctuation">;</span>                                            <span class="token keyword">break</span><span class="token punctuation">;</span>                                        <span class="token punctuation">}</span>                                    <span class="token punctuation">}</span>                                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                                    mLastTouchDownIndex <span class="token operator">=</span> childIndex<span class="token punctuation">;</span>                                <span class="token punctuation">}</span>                                mLastTouchDownX <span class="token operator">=</span> ev<span class="token punctuation">.</span><span class="token function">getX</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                mLastTouchDownY <span class="token operator">=</span> ev<span class="token punctuation">.</span><span class="token function">getY</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                newTouchTarget <span class="token operator">=</span> <span class="token function">addTouchTarget</span><span class="token punctuation">(</span>child<span class="token punctuation">,</span> idBitsToAssign<span class="token punctuation">)</span><span class="token punctuation">;</span>                                alreadyDispatchedToNewTouchTarget <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                                <span class="token keyword">break</span><span class="token punctuation">;</span>                            <span class="token punctuation">}</span>                            <span class="token comment" spellcheck="true">// The accessibility focus didn't handle the event, so clear</span>                            <span class="token comment" spellcheck="true">// the flag and do a normal dispatch to all children.</span>                            ev<span class="token punctuation">.</span><span class="token function">setTargetAccessibilityFocus</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>preorderedList <span class="token operator">!=</span> null<span class="token punctuation">)</span> preorderedList<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>newTouchTarget <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span> mFirstTouchTarget <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token comment" spellcheck="true">// Did not find a child to receive the event.</span>                        <span class="token comment" spellcheck="true">// Assign the pointer to the least recently added target.</span>                        newTouchTarget <span class="token operator">=</span> mFirstTouchTarget<span class="token punctuation">;</span>                        <span class="token keyword">while</span> <span class="token punctuation">(</span>newTouchTarget<span class="token punctuation">.</span>next <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                            newTouchTarget <span class="token operator">=</span> newTouchTarget<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                        newTouchTarget<span class="token punctuation">.</span>pointerIdBits <span class="token operator">|=</span> idBitsToAssign<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>      ·················         <span class="token comment" spellcheck="true">// Dispatch to touch targets.</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>mFirstTouchTarget <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// No touch targets so treat this as an ordinary view.</span>                handled <span class="token operator">=</span> <span class="token function">dispatchTransformedTouchEvent</span><span class="token punctuation">(</span>ev<span class="token punctuation">,</span> canceled<span class="token punctuation">,</span> null<span class="token punctuation">,</span>                        TouchTarget<span class="token punctuation">.</span>ALL_POINTER_IDS<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>                                                            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>              <span class="token punctuation">}</span></code></pre><p><code>dispatchTransformedTouchEvent</code>是对事件的分发或者处理:</p><ul><li><p>返回值变量handled: false表示无人处理，true表示activity处理了</p></li><li><p>(拦截的话走到这里)child == null时，调用<code>view</code>的<code>dispatchTouchEvent</code>(),就是转到View的事件处理,处理就返回true,赋值给handled变量作为<code>dispatchTransformedTouchEvent</code>的返回值，true表示;</p></li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">dispatchTransformedTouchEvent</span><span class="token punctuation">(</span>MotionEvent event<span class="token punctuation">,</span> <span class="token keyword">boolean</span> cancel<span class="token punctuation">,</span>            View child<span class="token punctuation">,</span> <span class="token keyword">int</span> desiredPointerIdBits<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> <span class="token keyword">boolean</span> handled<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// Canceling motions is a special case.  We don't need to perform any transformations</span>        <span class="token comment" spellcheck="true">// or filtering.  The important part is the action, not the contents.</span>        <span class="token keyword">final</span> <span class="token keyword">int</span> oldAction <span class="token operator">=</span> event<span class="token punctuation">.</span><span class="token function">getAction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cancel <span class="token operator">||</span> oldAction <span class="token operator">==</span> MotionEvent<span class="token punctuation">.</span>ACTION_CANCEL<span class="token punctuation">)</span> <span class="token punctuation">{</span>            event<span class="token punctuation">.</span><span class="token function">setAction</span><span class="token punctuation">(</span>MotionEvent<span class="token punctuation">.</span>ACTION_CANCEL<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>child <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                handled <span class="token operator">=</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">dispatchTouchEvent</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                handled <span class="token operator">=</span> child<span class="token punctuation">.</span><span class="token function">dispatchTouchEvent</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            event<span class="token punctuation">.</span><span class="token function">setAction</span><span class="token punctuation">(</span>oldAction<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> handled<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// Calculate the number of pointers to deliver.</span>        <span class="token keyword">final</span> <span class="token keyword">int</span> oldPointerIdBits <span class="token operator">=</span> event<span class="token punctuation">.</span><span class="token function">getPointerIdBits</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">final</span> <span class="token keyword">int</span> newPointerIdBits <span class="token operator">=</span> oldPointerIdBits <span class="token operator">&amp;</span> desiredPointerIdBits<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// If for some reason we ended up in an inconsistent state where it looks like we</span>        <span class="token comment" spellcheck="true">// might produce a motion event with no pointers in it, then drop the event.</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>newPointerIdBits <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// If the number of pointers is the same and we don't need to perform any fancy</span>        <span class="token comment" spellcheck="true">// irreversible transformations, then we can reuse the motion event for this</span>        <span class="token comment" spellcheck="true">// dispatch as long as we are careful to revert any changes we make.</span>        <span class="token comment" spellcheck="true">// Otherwise we need to make a copy.</span>        <span class="token keyword">final</span> MotionEvent transformedEvent<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>newPointerIdBits <span class="token operator">==</span> oldPointerIdBits<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>child <span class="token operator">==</span> null <span class="token operator">||</span> child<span class="token punctuation">.</span><span class="token function">hasIdentityMatrix</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>child <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    handled <span class="token operator">=</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">dispatchTouchEvent</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    <span class="token keyword">final</span> <span class="token keyword">float</span> offsetX <span class="token operator">=</span> mScrollX <span class="token operator">-</span> child<span class="token punctuation">.</span>mLeft<span class="token punctuation">;</span>                    <span class="token keyword">final</span> <span class="token keyword">float</span> offsetY <span class="token operator">=</span> mScrollY <span class="token operator">-</span> child<span class="token punctuation">.</span>mTop<span class="token punctuation">;</span>                    event<span class="token punctuation">.</span><span class="token function">offsetLocation</span><span class="token punctuation">(</span>offsetX<span class="token punctuation">,</span> offsetY<span class="token punctuation">)</span><span class="token punctuation">;</span>                    handled <span class="token operator">=</span> child<span class="token punctuation">.</span><span class="token function">dispatchTouchEvent</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>                    event<span class="token punctuation">.</span><span class="token function">offsetLocation</span><span class="token punctuation">(</span><span class="token operator">-</span>offsetX<span class="token punctuation">,</span> <span class="token operator">-</span>offsetY<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">return</span> handled<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            transformedEvent <span class="token operator">=</span> MotionEvent<span class="token punctuation">.</span><span class="token function">obtain</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            transformedEvent <span class="token operator">=</span> event<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span>newPointerIdBits<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// Perform any necessary transformations and dispatch.</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>child <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            handled <span class="token operator">=</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">dispatchTouchEvent</span><span class="token punctuation">(</span>transformedEvent<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">final</span> <span class="token keyword">float</span> offsetX <span class="token operator">=</span> mScrollX <span class="token operator">-</span> child<span class="token punctuation">.</span>mLeft<span class="token punctuation">;</span>            <span class="token keyword">final</span> <span class="token keyword">float</span> offsetY <span class="token operator">=</span> mScrollY <span class="token operator">-</span> child<span class="token punctuation">.</span>mTop<span class="token punctuation">;</span>            transformedEvent<span class="token punctuation">.</span><span class="token function">offsetLocation</span><span class="token punctuation">(</span>offsetX<span class="token punctuation">,</span> offsetY<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span> child<span class="token punctuation">.</span><span class="token function">hasIdentityMatrix</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                transformedEvent<span class="token punctuation">.</span><span class="token function">transform</span><span class="token punctuation">(</span>child<span class="token punctuation">.</span><span class="token function">getInverseMatrix</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            handled <span class="token operator">=</span> child<span class="token punctuation">.</span><span class="token function">dispatchTouchEvent</span><span class="token punctuation">(</span>transformedEvent<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// Done.</span>        transformedEvent<span class="token punctuation">.</span><span class="token function">recycle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> handled<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>第一个是Down事件</p><p>再来是Move事件，会沿着(前面形成的事件分发链)销售链走  </p><p>怎么沿着销售链走的？  </p><ol><li>Move事件照样会走到Activity …ViewGroup的<code>dispatchTouchEvent</code>，还是有拦截事件的权利</li><li>此时 mFirstTouchTarget != null </li><li>如果第2步不拦截, 会走到<code>dispatchTransformedTouchEvent(ev,cancelChild,targe.child,..)</code>,target是自己，然后(递归)去分发</li></ol><p>当销售链形成后，11号有什么权利？底层才对上层有反向制约的权利，通过对<code>disallowIntercept</code>(是否不允许拦截)布尔变量设置</p><p>1.<code>onInterceptTouchEvent</code>返回true就是对事件的拦截(ViewGroup是经销商?)，如果<code>disallowIntercept=true</code>,则ViewPager中<code>onInterceptTouchEvent</code>返回true也没用。</p><pre class=" language-java"><code class="language-java"><span class="token punctuation">[</span>ViewGroup<span class="token punctuation">.</span>java<span class="token punctuation">]</span> <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">onInterceptTouchEvent</span><span class="token punctuation">(</span>MotionEvent ev<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>ev<span class="token punctuation">.</span><span class="token function">isFromSource</span><span class="token punctuation">(</span>InputDevice<span class="token punctuation">.</span>SOURCE_MOUSE<span class="token punctuation">)</span>                <span class="token operator">&amp;&amp;</span> ev<span class="token punctuation">.</span><span class="token function">getAction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> MotionEvent<span class="token punctuation">.</span>ACTION_DOWN                <span class="token operator">&amp;&amp;</span> ev<span class="token punctuation">.</span><span class="token function">isButtonPressed</span><span class="token punctuation">(</span>MotionEvent<span class="token punctuation">.</span>BUTTON_PRIMARY<span class="token punctuation">)</span>                <span class="token operator">&amp;&amp;</span> <span class="token function">isOnScrollbarThumb</span><span class="token punctuation">(</span>ev<span class="token punctuation">.</span><span class="token function">getX</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ev<span class="token punctuation">.</span><span class="token function">getY</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>2.<code>requestDisallowInterceptTouchEvent(boolean disallowIntercept)</code>请求不拦截</p><ul><li><p>ViewPager包裹ListView时，让ViewPager不拦截</p><p>在ListView中重写如下方法，</p><ul><li>ACTION_MOVE时即左右滑动时，viewPager拦截</li><li>ACTION_DOWN时，上下滑动时，viewPager不拦截</li></ul><p>![image-20200426115035531](.事件分发机制_images/image-20200426115035531.png</p><p><img src=".%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6_images/image-20200426115150064.png" alt="image-20200426115150064"></p></li></ul><ol start="3"><li>销售链的形成需要经历完ACTION_DOWN，如果父view在形成之前拦截了则销售链就只到父view  </li></ol><p>实际上任何2个view叠加在一起都会产生冲突。</p><p><img src=".%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6_images/image-20200426120917813.png" alt="image-20200426120917813"></p><p>View的事件处理，<code>dispatchTouchEvent</code>-&gt;<code>onTouch</code>-&gt;<code>onTouchEvent</code></p><ol><li>onTouch和onTouchEvent有什么区别，又该如何使用？</li></ol><p>从源码中可以看出，这两个方法都是在View的dispatchTouchEvent中调用的，onTouch优先于onTouchEvent执行。如果在onTouch方法中通过返回true将事件消费掉，onTouchEvent将不会再执行。</p><p>另外需要注意的是，onTouch能够得到执行需要两个前提条件，第一mOnTouchListener的值不能为空，第二当前点击的控件必须是enable的。因此如果你有一个控件是非enable的，那么给它注册onTouch事件将永远得不到执行。对于这一类控件，如果我们想要监听它的touch事件，就必须通过在该控件中重写onTouchEvent方法来实现。</p><ol start="2"><li>为什么给ListView引入了一个滑动菜单的功能，ListView就不能滚动了？</li></ol><p>如果你阅读了Android滑动框架完全解析，教你如何一分钟实现滑动菜单特效这篇文章，你应该会知道滑动菜单的功能是通过给ListView注册了一个touch事件来实现的。如果你在onTouch方法里处理完了滑动逻辑后返回true，那么ListView本身的滚动事件就被屏蔽了，自然也就无法滑动(原理同前面例子中按钮不能点击)，因此解决办法就是在onTouch方法里返回false。</p><p><strong>Android中touch事件的传递，绝对是先传递到ViewGroup，再传递到View的。</strong></p><p>总结：</p><ol><li><p>Android事件分发机制分为View和ViewGroup的事件分发和处理，是从ViewGroup传给view的</p></li><li><p>其中View的会调用onTouch()方法，如果返回true，表示这个事件被他消费掉。则onClick不会执行，点击事件失效</p></li><li><p>ViewGroup的</p><p>​    1. 首先看他自己是否要拦截，可重写onInterceptTouchEvent中，返回true表示拦截，不会向下传递，默认是返回false，也可通过<code>requestDisallowInterceptTouchEvent(true)</code>请求禁用掉拦截.该开关优先于onInterceptTouchEvent</p><p>​    2. 如果不拦截，则遍历它的子view，递归分发事件，一旦某一层消费掉，就往上回传结果，但父view也就不再能处理。</p></li></ol><p>再举几个例子：</p><p>layout中2个button,layout的onInterceptTouchEvent返回true,则button的click事件失效。</p><h3 id="Android开发艺术探索-事件分发"><a href="#Android开发艺术探索-事件分发" class="headerlink" title="Android开发艺术探索-事件分发"></a>Android开发艺术探索-事件分发</h3><h4 id="1-位置参数"><a href="#1-位置参数" class="headerlink" title="1.位置参数"></a>1.位置参数</h4><p>View的位置主要由它的4个顶点来决定，对应View的四个属性:top,left,right,bottom</p><p>从3.0开始，</p><pre><code>新增x,y是View左上角的坐标，translationX和translationY是View左上角相对于父容器的偏移量x = left + translationX;y = top + translationY;注：View在平移过程中，top和left表示的是原始左上角的位置信息不会改变，此时改变的是新增的4个参数</code></pre><h4 id="2-MotionEvent和TouchSlop"><a href="#2-MotionEvent和TouchSlop" class="headerlink" title="2.MotionEvent和TouchSlop"></a>2.MotionEvent和TouchSlop</h4><h4 id="3-VelocityTracker、GestureDetector和Scroller"><a href="#3-VelocityTracker、GestureDetector和Scroller" class="headerlink" title="3.VelocityTracker、GestureDetector和Scroller"></a>3.VelocityTracker、GestureDetector和Scroller</h4><h5 id="Scroller"><a href="#Scroller" class="headerlink" title="Scroller"></a>Scroller</h5><p>用于实现View的弹性滑动.</p><p>View的滑动</p><p>4.View的事件分发机制</p><p>4.1 点击事件的传递规则</p><p>所谓点击事件的事件分发，就是对MotionEvent事件的分发过程,由三个很重要的方法来共同完成.</p><p><code>public boolean dispatchTouchEvent(MotionEvent ev).</code></p><p>用来进行事件的分发,返回是否消耗当前事件.</p><p><code>public boolean onIntecerptTouchEvent(MotionEvent event)</code></p><p>上面方法中的方法,用来判断是否拦截某个事件(ViewGroup 中源码默认返回false表示不拦截)</p><p><code>public boolean onTouchEvent(MotionEvent event)</code></p><p>在<code>dispatchTouchEvent</code>方法中调用，用来处理点击事件,返回是否消耗当前事件，如果不消耗，则在同一个事件序列中，当前View无法再次接收到事件.</p><p>ViewGroup</p><p>关于拦截</p><p>1.requestDisallowInterceptTouchEvent() 请求禁用拦截</p><p>一般用于子View中调用父view的这个方法，让父view不再拦截除了ACTION_DOWN以外的点击事件。</p><p>当面对<code>ACTION_DOWN</code>事件时，ViewGroup总是会调用自己的onIntecerptTouchEvent询问自己是否拦截事件.</p><p>2.当ViewGroup决定拦截事件后，后续的点击事件(不包括<code>ACTION_DOWN</code>)将会默认交给它处理并且不再问自己是否拦截. </p><p>3.onIntecerptTouchEvent()不是每次都会调用，如果想提前处理所有的点击事件，要选择dispatchTouchEvent,前提当然是事件能传到当前的ViewGroup.</p><p>分发（不拦截时）</p><p>事件分发交给它的子View进行处理，怎么分发？</p><p>1.循环遍历ViewGroup的所有孩子，交给能接收点击事件(点击事件的坐标是否落在子元素内)的孩子进行处理(dispatchTouchEvent分发)。</p><p>2.如果孩子消耗掉这个事件(dispatchTouchEvent返回true)，mFirstTouchTarget被赋值并终止循环;</p><p>   反之，则交给它的下一个孩子进行处理</p><p>3,如果遍历所有的子元素后事件都没有被合适地处理(消耗)，两种情况</p><ul><li>没有孩子</li><li>所有孩子处理了但是dispatchTouchEvent中返回了false(没消耗)</li></ul><p>mFirstTouchTarget就为null,因为没有赋值。ViewGroup会自己处理点击事件（super.dispatchTouchEvent(event)这里是View的方法，没有拦截，没有分发），进入View的点击事件处理</p><p>为什么mFirstTouchTarget为null ，ViewGroup就默认拦截接下来同一序列中的所有点击事件.??</p><p>因为</p><pre><code>if(事件是ACTION_DOWN || mFirstTouchTarget != null){        先看是否禁用掉了拦截，判断是否拦截}else{   intercepted = true;}</code></pre><p>View对点击事件的处理</p><p>onTouch（设置了触摸监听器时）  优先于onTouchEvent;</p><p>ACTION_UP发生时，会触发performclick方法，内部会调用它的onClick方法;</p><p>View的dispatchTouchEvent方法中的switch 对ACTION的分别处理最后都是返回true,表示消耗事件</p><h3 id="View的滑动冲突？"><a href="#View的滑动冲突？" class="headerlink" title="View的滑动冲突？"></a>View的滑动冲突？</h3><h4 id="1-什么是滑动冲突？"><a href="#1-什么是滑动冲突？" class="headerlink" title="1.什么是滑动冲突？"></a>1.什么是滑动冲突？</h4><p>​    在界面中只要内外两层同时可以滑动，这个时候就会产生滑动冲突。</p><h4 id="2-三种场景"><a href="#2-三种场景" class="headerlink" title="2.三种场景"></a>2.三种场景</h4><ul><li>父View和子View滑动方向不一致</li><li>父View和子View滑动方向一致(系统无法知道让哪一层滑动,卡顿或者只有1层能滑动)</li><li>上面两种的嵌套</li></ul><h4 id="3-处理规则"><a href="#3-处理规则" class="headerlink" title="3.处理规则"></a>3.处理规则</h4><ul><li>场景1：用户左右滑动时，让父View拦截touch事件,上下滑动时，子View拦截/消耗touch事件;根据他们的特征解决滑动冲突。如何判断是竖直还是水平滑动？</li><li>场景2：无法根据滑动的角度，距离差（滑动规则），以及速度差来判断，这个时候一般能在业务上找到突破点</li><li>场景3：同样是从业务上找突破点</li></ul><blockquote><p>不管多复杂的滑动冲突，他们之间的区别仅仅是滑动规则不同而已。</p></blockquote><pre class=" language-csharp"><code class="language-csharp"><span class="token comment" spellcheck="true">/**  * 分析1：onUserInteraction()  * 作用：实现屏保功能  * 注：  *    a. 该方法为空方法  *    b. 当此activity在栈顶时，触屏点击按home，back，menu键等都会触发此方法  */</span>      <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onUserInteraction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token punctuation">}</span></code></pre><pre class=" language-csharp"><code class="language-csharp">b<span class="token punctuation">.</span> DecorView继承自FrameLayout，是所有界面的父类  <span class="token operator">*</span>     c<span class="token punctuation">.</span> FrameLayout是ViewGroup的子类，故DecorView的间接父类 <span class="token operator">=</span> ViewGroup</code></pre><h4 id="如果viewgroup不拦截事件-那么哪些子view可以接收到事件"><a href="#如果viewgroup不拦截事件-那么哪些子view可以接收到事件" class="headerlink" title="如果viewgroup不拦截事件, 那么哪些子view可以接收到事件"></a>如果viewgroup不拦截事件, 那么哪些子view可以接收到事件</h4><p>if (!canViewReceivePointerEvents(child)<br>|| !isTransformedTouchPointInView(x, y, child, null)) {<br>ev.setTargetAccessibilityFocus(false);<br>continue;<br>}<br>ViewGroup通过判断所有的子View是否可见是否在播放动画和是否在点击范围内来决定它是否能够有资格接受事件。只有满足条件的child才能够调用dispatch。</p><h3 id="Activity对点击事件的分发机制"><a href="#Activity对点击事件的分发机制" class="headerlink" title="Activity对点击事件的分发机制"></a><code>Activity</code>对点击事件的分发机制</h3><h3 id="ViewGroup对点击事件的分发机制"><a href="#ViewGroup对点击事件的分发机制" class="headerlink" title="ViewGroup对点击事件的分发机制"></a><code>ViewGroup</code>对点击事件的分发机制</h3><h3 id="View对点击事件的分发机制"><a href="#View对点击事件的分发机制" class="headerlink" title="View对点击事件的分发机制"></a><code>View</code>对点击事件的分发机制</h3><h5 id="场景一-点击如图的空白区域"><a href="#场景一-点击如图的空白区域" class="headerlink" title="场景一 点击如图的空白区域"></a>场景一 点击如图的空白区域</h5><p><img src=".%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6_images/image-20200717235536395.png" alt="image-20200717235536395"></p><pre><code>W/DemoSocketActivity: dispatchTouchEvent: ACTION_DOWNW/MyLinearLayout: dispatchTouchEvent: ACTION_DOWNW/MyLinearLayout: onInterceptTouchEvent: ACTION_DOWNE/MyLinearLayout: onInterceptTouchEvent: ACTION_DOWN  falseW/MyLinearLayout: onTouchEvent: ACTION_DOWNE/MyLinearLayout: onTouchEvent: ACTION_DOWN  falseE/MyLinearLayout: dispatchTouchEvent: ACTION_DOWN  falseW/DemoSocketActivity: dispatchTouchEvent: ACTION_DOWNfalseW/DemoSocketActivity: dispatchTouchEvent: ACTION_UPW/DemoSocketActivity: dispatchTouchEvent: ACTION_UPfalse</code></pre><p>没有ACTION_UP事件是因为MyLinearLayout没处理，MyLinearLayout默认是不可点击的。</p><h5 id="点击测试按钮"><a href="#点击测试按钮" class="headerlink" title="点击测试按钮"></a>点击测试按钮</h5><pre><code>W/DemoSocketActivity: dispatchTouchEvent: ACTION_DOWNW/MyLinearLayout: dispatchTouchEvent: ACTION_DOWNW/MyLinearLayout: onInterceptTouchEvent: ACTION_DOWNE/MyLinearLayout: onInterceptTouchEvent: ACTION_DOWN  falseW/MyButton: dispatchTouchEvent: ACTION_DOWNW/MyButton: onTouchEvent: ACTION_DOWNE/MyButton: onTouchEvent: ACTION_DOWN  trueE/MyButton: dispatchTouchEvent: ACTION_DOWN  trueE/MyLinearLayout: dispatchTouchEvent: ACTION_DOWN  trueW/DemoSocketActivity: dispatchTouchEvent: ACTION_DOWNtrueW/DemoSocketActivity: dispatchTouchEvent: ACTION_UPW/MyLinearLayout: dispatchTouchEvent: ACTION_UPW/MyLinearLayout: onInterceptTouchEvent: ACTION_UPE/MyLinearLayout: onInterceptTouchEvent: ACTION_UP  falseW/MyButton: dispatchTouchEvent: ACTION_UPW/MyButton: onTouchEvent: ACTION_UPE/MyButton: onTouchEvent: ACTION_UP  trueE/MyButton: dispatchTouchEvent: ACTION_UP  trueE/MyLinearLayout: dispatchTouchEvent: ACTION_UP  trueW/DemoSocketActivity: dispatchTouchEvent: ACTION_UPtrue</code></pre><p>onTouchEvent返回true是因为Button是可点击的</p><h2 id="背诵版总结"><a href="#背诵版总结" class="headerlink" title="背诵版总结"></a>背诵版总结</h2><p>从手指接触屏幕 至 手指离开屏幕，这个过程产生的一系列事件。一般情况下，事件列都是以<code>DOWN</code>事件开始、<code>UP</code>事件结束，中间有无数的MOVE事件。事件分发指的是 将点击事件（MotionEvent）传递到某个具体的<code>View</code> &amp; 处理的整个过程。</p><p>事件在哪些对象之间进行传递？</p><p><strong>答：Activity、ViewGroup、View</strong></p><h3 id="事件分发过程主要由3个方法协作完成。"><a href="#事件分发过程主要由3个方法协作完成。" class="headerlink" title="事件分发过程主要由3个方法协作完成。"></a>事件分发过程主要由3个方法协作完成。</h3><p>*<em>dispatchTouchEvent() *</em>：事件分发</p><p><strong>onInterceptTouchEvent()</strong>：拦截事件</p><p><strong>和onTouchEvent()</strong>:处理事件</p><h3 id="分发从3个方面讲"><a href="#分发从3个方面讲" class="headerlink" title="分发从3个方面讲"></a>分发从3个方面讲</h3><h4 id="1-Activity-对点击事件的分发机制"><a href="#1-Activity-对点击事件的分发机制" class="headerlink" title="1.Activity`对点击事件的分发机制"></a>1.Activity`对点击事件的分发机制</h4><p>当一个点击事件发生时，事件最先传到<code>Activity</code>的<code>dispatchTouchEvent()</code>进行事件分发</p><h4 id="2-ViewGroup-对点击事件的分发机制"><a href="#2-ViewGroup-对点击事件的分发机制" class="headerlink" title="2.ViewGroup`对点击事件的分发机制"></a>2.ViewGroup`对点击事件的分发机制</h4><p>先看自己是否拦截，默认可以认为不拦截。一旦拦截，那么这个事件序列（如果事件序列能够传递的话）都只能由它来处理，并且它的onInterceptTouchEvent不再调用,</p><p>遍历ViewGroup的所有子元素，判断子元素是否能够接收到点击事件。主要由：子元素是否在播放动画和点击事件的坐标是否落在子元素的区域内。</p><h4 id="3-View-对点击事件的分发机制"><a href="#3-View-对点击事件的分发机制" class="headerlink" title="3.View`对点击事件的分发机制"></a>3.View`对点击事件的分发机制</h4><p>某个View一旦开始处理事件，如果它不消耗ACTION_DOWN事件(onTouchEvent 返回了false),那么同一事件序列中的其他事件都不会再交给它来处理，并且事件将重新交由它的父容器去处理。</p><p>View的onTouchEvent默认都会消耗事件，除非它是不可点击的。</p><p>如何设置了有onTouchListener，且onTouch返回true表示消耗了事件，则不会调用onTouchEvent方法。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/设计模式/Android架构</title>
      <link href="blog/320856030.html"/>
      <url>blog/320856030.html</url>
      
        <content type="html"><![CDATA[<ol><li>什么是MVC，MVC的目标</li><li>Android中的MVC使得acitivity既做了控制层，也做了View层，违背了单一职责原则</li><li>什么是MVP, MVP各层负责做什么，MVP的好处</li></ol><h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><p>MVC全称是Model-View-Controller也就是模型-视图-控制器  </p><p><strong>MVC的目的</strong>是为了将<strong>数据模型和视图分离开来</strong>，并以控制器作为连接两者的桥梁实现解耦,<strong>以使代码可扩展性、可复用性、可维护性、灵活性加强。</strong>。</p><p>MVC是一种框架模式而非应用模式。</p><p>框架面向于一系列相同行为代码的重用，设计面向的是一系列相同结构代码的重用。</p><p>平常说的架构介于框架和设计之间。</p><h3 id="软件开发领域三种级别的重用"><a href="#软件开发领域三种级别的重用" class="headerlink" title="软件开发领域三种级别的重用"></a>软件开发领域三种级别的重用</h3><ul><li>内部重用：同一应用中能公共使用的抽象块</li><li>代码重用：通用模块组合成库，以便在多个应用和领域中使用</li><li>应用框架的重用：为专用领域提供通用的基础结构，获得最高级别的重用性</li></ul><h3 id="框架模式"><a href="#框架模式" class="headerlink" title="框架模式"></a>框架模式</h3><p>框架是大智慧，用来对软件设计进行分工；设计模式是小技巧，对具体问题提出解决方案，提供代码重用率，降低耦合。</p><p>有MVC,MVVC.MVP</p><h3 id="MVC的优点"><a href="#MVC的优点" class="headerlink" title="MVC的优点"></a>MVC的优点</h3><ul><li>理解比较容易，开发和维护起来成本较低</li><li>耦合性不高，表现层(前端)和业务层(后端)分离</li></ul><h3 id="MVC在Android中的实现"><a href="#MVC在Android中的实现" class="headerlink" title="MVC在Android中的实现"></a>MVC在Android中的实现</h3><p>Acvitiy作为控制器，在Activity中获取数据和界面元素(xml布局)，将两者绑定,这里 View和Model是分离的</p><h2 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h2><p>MVP全称Model View Presenter：</p><ul><li>MVP分离表现层和逻辑层，它们之间通过接口进行通信，降低耦合。</li><li>同时又带来良好的可扩展性，可测试性。</li><li>理想化的MVP可以实现同一份逻辑代码搭配不同的显示界面，因为他们之间并不依赖于具体，而是依赖于抽象.</li></ul><p>对于应用，我们需要定义分离各个层，主要是UI层，业务逻辑层和数据层.</p><h3 id="MVP种的三个角色"><a href="#MVP种的三个角色" class="headerlink" title="MVP种的三个角色"></a>MVP种的三个角色</h3><ol><li><p>Presenter–交互中间人</p><ul><li>Presenter主要作为沟通View和Model的桥梁，它从Model层检索数据后，返回给View层，使得View和Model之间没有耦合，也将业务逻辑从View角色上抽离出来。</li><li>完成业务逻辑：业务功能逻辑，从网络获取数据逻辑</li></ul></li><li><p>View–用户界面</p><p>View通常指Activity,Fragment或者某个View控件，它含有一个Presenter成员变量。通常View需要实现一个(展示UI的)逻辑接口，将View上的(更新OR展示UI)操作转交给Presenter进行调用，最后Presenter调用View逻辑接口将结果返回给View元素</p></li><li><p>Model–数据的存取</p><p>对于一个结构化的App来说，Model角色主要是提供数据的存取功能。Presenter需要通过Model层存储、获取数据，Model就像一个数据仓库。更直白的说，Model是封装了数据库DAO或者网络获取数据的角色，或者两种数据获取方式的集和</p></li></ol><p>从网络或者数据数据库或者其他地方获取数据的逻辑过程就是业务逻辑，由Presenter持有的Model层对象引用去完成。</p><blockquote><p>注：表现层(User Interface Layer)就是UI层，指的View层</p></blockquote><p>2、MVP与MVC的区别（阅读时请不断对比上面的两张图）</p><ul><li><p>Activity职责不同，Activity在MVP中是View层，在MVC中是Controller层，这是MVC和MVP很主要的一个区别，可以说Android从MVC转向MVP开发也主要是优化Activity的代码，避免Activity的代码臃肿庞大。</p></li><li><p>View层不同，MVC的View层指的是XML布局文件或者是用Java自定义的View，MVP的View层是Activity或者Fragment。使用传统的MVC，其中的View，对应的是各种Layout布局文件，但是这些布局文件中并不像Web端那样强大，能做的事情非常有限。MVP的View层Activity在实际项目中，随着逻辑的复杂度越来越大，Activity臃肿的缺点仍然体现出来了，因为Activity中还是充满了大量与View层无关的代码，比如各种事件的处理派发，就如MVC中的那样View层和Controller代码耦合在一起无法自拔。</p></li><li><p>控制层不同，MVC的控制层是Activity，或者是Fragment，，而Activity中却又具有操作UI的功能，也做了很多View中应该做的事情，当然Activity中也包含Controller应该做的事情，比如各种事件的派发回调，而且在一层中我们会根据事件再去调用Model层操作数据，所以这种MVC的方式在实际项目中，Activity所在的Controller是非常重的，各层次之间的耦合情况也比较严重，不方便单元测试。</p><p>MVP的控制层是Presenter，里面没有很多的实际东西，主要是做Model和View层的交互。</p></li><li><p>关系链不同，MVP中Model层与View是没有关系的，彼此不会通讯和操作，Model与View的通讯都是Presenter层来传达的。但是在MVC中，Model层和View是曾在交互的。比如我们自定义的View控件里面肯定是要使用Model的数据的，View也要根据不同的Model数据做出不同的展现！这点尤其是体现在自定义的View中，自定义View需要设置数据，用户操作了自定义控件需要改变数据，View要操作Model怎么办？有人说把Controller传到自定义的View啊，现实是不可能没一个自定义View都去持有Controller的引用，其实在MVP中就不会这么尴尬，接口就可以完成。</p></li><li><p>适用范围不同，在Android中，MVP和MVC都用自己的适用情况，使用MVP可以更好的解耦三大模块，模块之间比较清晰，也很方便使用MVP来组件化架构整体项目。但是MVC也是有用武之地的，在组件化的Module或者中间件我们可以使用MVC来做，Module或者中间件不会存在很复杂的View层，使用MVC可以更加方便我们实现功能。</p></li><li><p>交互方式不同，MVP中通讯交互基本都是通过接口的，MVC中的通讯交互很多时候都是实打实的调用对象的方法，简单粗暴！</p></li><li><p>实现方法不同 ，MVC和MVP的Model几乎一样的，都是处理数据，只要不在Activity或者Fragment中请求数据，其他的所有控制都放在Activity或者Fragment中，这样写就基本是MVC的模式，这样写不麻烦，但是很容易把Activity写出上万行代码。用MVP的时候我们需要写很多View和Presenter接口来实现模块之间的通讯，会增加很多类。<br>————————————————<br>版权声明：本文为CSDN博主「Dawish_大D」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/u010072711/article/details/77132403" target="_blank" rel="noopener">https://blog.csdn.net/u010072711/article/details/77132403</a></p></li></ul><p>背诵版</p><h4 id="1-MVC"><a href="#1-MVC" class="headerlink" title="1.MVC"></a>1.MVC</h4><p><strong>MVC的目的</strong>是为了将<strong>数据模型和视图分离开来</strong>，并以控制器作为连接两者的桥梁实现解耦。</p><p>MVC的M是数据，V是xml布局，控制器是activity,  View 将操作反馈给 Activity，Activitiy 去获取数据，数据通过观察 者模式刷新给 View。</p><p>优点：把业务逻辑全部分离到Controller中，模块化程度高。当业务逻辑变更的时候，不需要变更View和Model，只需要Controller换成另外一个Controller就行了（Swappable Controller）。</p><p>缺点：controller测试困难。</p><p>这里activity既做了控制层，又能操作UI，随着逻辑的复杂度越来越大，activity将变得很臃肿，很难做单元测试。</p><h4 id="2-MVP"><a href="#2-MVP" class="headerlink" title="2.MVP"></a>2.MVP</h4><ol><li>MVP全称Model View Presenter，MVP是把MVC中的Controller换成了Presenter（呈现），目的就是为了完全切断View跟Model之间的联系。presenter是什么 做什么用，view是什么，做什么用</li></ol><p>优点：MVP分离表现层和逻辑层，它们之间通过接口进行通信，降低耦合 ，方便进行单元测试</p><p>缺点：MVP的缺点是接口爆炸，会需要写很多的接口，presenter很重</p><h4 id="3-MVVM"><a href="#3-MVVM" class="headerlink" title="3.MVVM"></a>3.MVVM</h4><p>他将Presenter替换成ViewModel，并通过双向数据绑定来实现视图和数据的交互。视图的数据的变化会同时修改数据源，而数据源数据的变化也会立即反应到View上。</p><p>优点：</p><p>MVVM模式它不仅解决MV耦合问题，还同时解决了维护两者映射关系的大量繁杂代码，提高开发效率。</p><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>一个公司只有1个CEO</p><h4 id="实现单例模式的要点"><a href="#实现单例模式的要点" class="headerlink" title="实现单例模式的要点"></a>实现单例模式的要点</h4><ol><li><p>构造函数私有化</p></li><li><p>提供静态公有的getInstance()方法返回单例对象</p></li><li><p>成员变量私有化</p></li><li><p>确保单例类对象在反序列化时不会重新构建对象</p></li></ol><h4 id="几种实现方式"><a href="#几种实现方式" class="headerlink" title="几种实现方式"></a>几种实现方式</h4><ol><li><p>饿汉式</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CEO</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> CEM mCEO <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CEO</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">CEO</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> CEO <span class="token function">getCEO</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> mCEO<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ol><ol start="2"><li><p>懒汉式</p></li><li><p>Double Check Lock 懒汉式 + volatile(防止指令重排)  </p></li></ol><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><ul><li>Mvc,mvp的差异</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/Android/Gradle/1</title>
      <link href="blog/2272389154.html"/>
      <url>blog/2272389154.html</url>
      
        <content type="html"><![CDATA[<p>dependencies中的</p><ol><li>compile</li><li>implemaintation</li><li>api</li></ol><h3 id="引用aar的第二种模式"><a href="#引用aar的第二种模式" class="headerlink" title="引用aar的第二种模式"></a>引用aar的第二种模式</h3><p>new module  -&gt; import .jar/.aar package -&gt; 选择.aar文件  然后会创建一个module拷贝了这个文件，并且生成有gradle文件</p><pre><code>configurations.maybeCreate(&quot;default&quot;)artifacts.add(&quot;default&quot;, file(&#39;imageembellish-release.aar&#39;))</code></pre><p>然后这样引用</p><pre><code>compile project(&#39;:module_name&#39;)</code></pre><p>./gradlew carpublishandroid:dependencies –configuration compile</p><h4 id="依赖官方文档"><a href="#依赖官方文档" class="headerlink" title="依赖官方文档"></a>依赖官方文档</h4><p><a href="https://developer.android.google.cn/studio/build/dependencies" target="_blank" rel="noopener">https://developer.android.google.cn/studio/build/dependencies</a></p><p><strong>本地二进制文件依赖项</strong></p><pre class=" language-groovy"><code class="language-groovy">implementation <span class="token function">fileTree</span><span class="token punctuation">(</span>dir<span class="token punctuation">:</span> <span class="token string">'libs'</span><span class="token punctuation">,</span> include<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'*.jar'</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p>Gradle 声明了对项目的 module_name/libs/ 目录中 JAR 文件的依赖关系（因为 Gradle 会读取 build.gradle 文件的相对路径）。或者，您也可以按如下方式指定各个文件：</p><pre class=" language-groovy"><code class="language-groovy">implementation <span class="token function">files</span><span class="token punctuation">(</span><span class="token string">'libs/foo.jar'</span><span class="token punctuation">,</span> <span class="token string">'libs/bar.jar'</span><span class="token punctuation">)</span></code></pre><p><strong>远程二进制文件依赖项</strong></p><pre><code>implementation &#39;com.example.android:app-magic:12.3&#39;实际是下面的简写implementation group: &#39;com.example.android&#39;, name: &#39;app-magic&#39;, version: &#39;12.3&#39;</code></pre><h4 id="gradle-依赖的包存储的本地路径"><a href="#gradle-依赖的包存储的本地路径" class="headerlink" title="gradle 依赖的包存储的本地路径"></a>gradle 依赖的包存储的本地路径</h4><p>~/.gradle/caches/modules-2/files-2.1/</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/Android/Handler</title>
      <link href="blog/2460039874.html"/>
      <url>blog/2460039874.html</url>
      
        <content type="html"><![CDATA[<p><img src=".Handler_images/4e6497a7.png" alt="">   </p><ol><li><p>一个线程有几个Handler</p><ol><li><code>new</code> 几个 有几个，每个<code>activity</code>都可以<code>new</code>，<code>activity</code> 跑在主线程</li></ol></li><li><p>一个线程有几个Looper，如何保证  </p><ol><li>1个,再创建会抛运行时异常。</li><li><code>Looper</code>类中有成员<code>ThreadLocal</code>,<code>ThreadLocalMap</code>存的 key是<code>ThreadLocal</code>,<code>value</code>是<code>Looper</code>对象</li></ol></li><li><p><code>Handler</code>内存泄露原因？为什么其他的内部类没有说过有这个问题？</p><ul><li>（静态？）内部类持有了外部类对象的引用，<code>handler</code>匿名内部类持有<code>activity</code>的引用，可以调用activity的方法。<code>activity</code>走了<code>onDestroy</code>后，<code>jvm</code>的可达性分析认为<code>activity</code>的引用任然被其他地方持有，就不能回收释放。有所有的内存泄露都是生命周期不一致</li><li><code>RecyclerView</code>里面的内部类ViewHolder为什么没有这个问题，要从<code>handler</code>的发消息原理分析，handler有延迟发送message的方法（比如延迟1分钟），<code>message</code>没处理完，将一直在内存中，而message持有<code>handler</code>的引用，<code>handler</code>持有<code>messagequeue</code>和<code>activity</code>的引用. 所有内部类都持有外部类的引用，但其他类一般没有耗时的东西，没有另外一个东西持有这个内部类，所以其他的没有这个问题。怎么解决：软引用，弱引用。</li></ul></li><li><p>为何主线程可以<code>new Handler</code>?如果想要在子线程中new Handler要做哪些准备？</p><ul><li>ActivityThread的main中调用了Looper.prepareMainLooper() 和 Looper.loop(),主线程(所有activity,service生命周期的函数)的所有代码运行于loop函数中，且都以消息的方式存在</li><li>子线程中要new Handler怎么做？创建Looper，1.prepare() 2.loop()</li></ul></li><li><p>子线程中维护的Looper，消息队列无消息的时候处理方案是什么？有什么用？</p><p>调用Looper的quitsafely()，实际调用MessageQueue的quit,会调用nativeWake,会remove所有消息，释放内存的作用；但是loop死循环仍在跑，任然在阻塞,实际不会，nativeWake会叫醒，loop中的去消息会返回null,死循环退出。主线程不允许调消息队列的quit,会抛非常状态异常。</p></li><li><p>多个线程共享handler，都在里面发消息给主线程，如何保证线程安全  ?  </p><p><img src=".Handler_images/fd1875e6.png" alt=""></p><p>handler的消息入队和Looper的loop中取消息方法加锁了，锁的是handler对象  ;</p><p>handler的消息delay 时间准确吗，不完全准确。因为多线程访问时，加了锁，可能会延时。</p></li><li><p>使用Message时如何创建它？</p><p>new 就玩了，应该用obtain():</p><p>sPool,享元设计模式</p><p>先讲内存共享(内存复用，内存抖动)</p></li><li><p>sd</p><ul><li>MessageQueue中没有消息，则不会执行，计算等待多长时间，wait,</li></ul></li><li><p>Looper死循环为什么不会导致应用卡死，不会anr？</p><p>这个问题是最难的。loop中取消息阻塞block状态（主线程睡眠，睡眠不是卡死）10S是不会ANR（ANR是卡死）的。</p><p>9.1 什么时候会ANR？</p><ul><li>在5s没有响应输入事件（按键按下，屏幕触摸）,eg:某个事件或者oncreate中有个非常耗时的操作，那么点击其他按钮就没有响应，loop无法处理其他消息就ANR</li><li>BroadcastReceiver在10s内没有执行完毕</li></ul><p>9.2 主线程唤醒的方式</p><ul><li>输入的事件（每一个事件都是Looper里面的一个message,所有的事件都是在activity的生命周期执行的，界面的所有操作执行在loop方法中，没有任何操作时就阻塞在取消息那里）</li><li>往Looper添加消息</li></ul></li></ol><p>post + send 共14个方法<br><img src=".Handler_images/e2c55f8b.png" alt=""><br>Handler工作流程<br><img src=".Handler_images/217e2ed9.png" alt=""><br><img src=".Handler_images/9060018f.png" alt=""><br><img src=".Handler_images/ce8d9ae2.png" alt=""><br><img src=".Handler_images/0f71781a.png" alt="">  </p><p><code>Handler</code>中有<code>MessageQueue</code>类的成员变量</p><p>Message中有Handler类成员变量，持有Handler的引用</p><p>MessageQueue ：(传送带)单链表+ 执行时刻when小到大实现的优先级队列<br>mMessages:表示执行时刻小的消息，表示队头?还是对尾<br>next():如果当前时间毫秒值now 比队头消息的when还小，等待；<br>否则， </p><h3 id="Looper"><a href="#Looper" class="headerlink" title="Looper"></a>Looper</h3><p>Looper.loop():传送带的动力，开关的作用，死循环不断调用MessageQueue的next()<br>loop()中取消息基本不会为null，如果消息队列为null,nativePollOnce(ptr, nextPollTimeoutMillis);会使线程一直处于block状态，next()不会返回Null<br>handler消息传送是子线程发送消息到主线程的过程<br><img src=".Handler_images/c7655c6a.png" alt=""><br><img src=".Handler_images/64d8fd54.png" alt=""><br>新浪面试题<br><img src=".Handler_images/224bfe10.png" alt=""><br><img src=".Handler_images/1ace9dee.png" alt=""><br><img src=".Handler_images/1160f9c7.png" alt=""><br><img src=".Handler_images/6c9f874e.png" alt=""><br><img src=".Handler_images/4d871b39.png" alt="">  </p><p>所谓的入队其实就是将所有的消息按时间来进行排序</p><p><img src=".Handler_images/image-20200604165223395.png" alt="image-20200604165223395"></p><p>所谓的入队其实就是将所有的消息按时间来进行排序</p><h4 id="1-概念-作用"><a href="#1-概念-作用" class="headerlink" title="1.概念(作用)"></a>1.概念(作用)</h4><p>Handler的主要作用是发送和处理消息；</p><p>MessageQueue称作消息队列，采用单链表的数据结构存储Message；</p><p>Looper是一个循环，会在一个无限循环中不断从MessageQueue中获取Message，如果有Message，就交给对应的Handler去处理；每个<code>Handler</code>都关联着一个<code>Looper</code></p><p>Message是传递的消息，它的target参数是发送它的Handler对象。(Message中有Handler类成员变量，持有Handler的引用)</p><h4 id="2-dispatchMessage-Message-msg-是如何处理的。"><a href="#2-dispatchMessage-Message-msg-是如何处理的。" class="headerlink" title="2.dispatchMessage(Message msg)是如何处理的。"></a>2.dispatchMessage(Message msg)是如何处理的。</h4><p>msg.callback(Runnable类型)-&gt;Handler中的mCallback(interface  Callback，只有1个handlerMessage方法)-&gt;handleMessage方法</p><h4 id="3-Handler如何切换线程"><a href="#3-Handler如何切换线程" class="headerlink" title="3.Handler如何切换线程"></a>3.Handler如何切换线程</h4><p><img src=".Handler_images/image-20200720010841217.png" alt="image-20200720010841217"></p><p>我们都是在线程内创建<code>Handler</code>之后，就调用<code>Looper.loop()</code>的。当消息循环执行到我们发送的那个消息时，它自然就在调用<code>Looper.loop()</code>方法的线程内执行了，<strong>这就是跨线程的原因</strong>，就这么简单，有没有<code>ThreadLocal</code>它都能跨。</p><h4 id="4-更新UI的方式"><a href="#4-更新UI的方式" class="headerlink" title="4.更新UI的方式"></a>4.更新UI的方式</h4><p>1.使用Handler的post(Runnable r)方法</p><p>调用了sendMessageDelayed-&gt;sendMessageAtTime-≥enqueueMessage</p><p>和send有什么区别？post的Message的callback不空</p><p>2.Handler的sendMessage()</p><p>3.在Activity中使用runOnUiThread 方法，实际也是调用了Handler的post方法(不是UI线程时)</p><p>4.view.post(Runnable action)方法 也是调用了Handler的post</p><p>5.AsyncTask</p><h3 id="5-ThreadLocal使得每个线程只有一个Looper"><a href="#5-ThreadLocal使得每个线程只有一个Looper" class="headerlink" title="5.ThreadLocal使得每个线程只有一个Looper"></a>5.ThreadLocal使得每个线程只有一个Looper</h3><h3 id="6-消息怎么入队-怎么出队"><a href="#6-消息怎么入队-怎么出队" class="headerlink" title="6.消息怎么入队 怎么出队"></a>6.消息怎么入队 怎么出队</h3><p>主线程创建的成员变量handler， 因为子线程匿名内部类持有外部activity的引用.</p><p>所以能够访问它的成员变量，调用handler的方法，而handler的sendMessage方法，是往消息队列中插入消息，该消息入队的方法是同步的，锁的对象是MessageQueue对象，这个对象1个线程只有1个，是在主线程中创建looper时创建的，looper取消息锁的对象也是MessageQueue对象。</p><p>也就是Handler对象在堆中是这2个线程共享的，子线程调用入队方法，MessageQueue对象也是共享的。</p><p>总结:</p><p>1.子线程中调用堆中共享对象MessageQueue的入队方法，链表插入节点</p><p>2.发送完消息，操作系统线程调度（比如时间片，先进先出）时间片到主线程了。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/Java虚拟机/Java内存模型背诵版</title>
      <link href="blog/735422251.html"/>
      <url>blog/735422251.html</url>
      
        <content type="html"><![CDATA[<p>Java虚拟机规范中试图定义一种Java内存模型（JMM）来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。</p><h2 id="主内存与工作内存"><a href="#主内存与工作内存" class="headerlink" title="主内存与工作内存"></a>主内存与工作内存</h2><p>Java内存模型的<strong>主要目标</strong>是定义程序中各个变量的访问规则</p><h2 id="原子性synchrnized"><a href="#原子性synchrnized" class="headerlink" title="原子性synchrnized"></a>原子性synchrnized</h2><p>synchronized 既保证了原子性又保证了可见性</p><h2 id="可见性volatile"><a href="#可见性volatile" class="headerlink" title="可见性volatile"></a>可见性volatile</h2><p>volatile修饰保证变量不同线程的可见性，强制读主存</p><h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><p>volatile可禁用指令重排，DCL在多线程访问时会有问题.</p><h2 id="CAS与原子类"><a href="#CAS与原子类" class="headerlink" title="CAS与原子类"></a>CAS与原子类</h2><p>CAS(synchronized效率低，要加锁解锁，线程切换，上下文切换)</p><p>乐观锁与悲观锁是一种思想：synchronized体现了悲观锁的思想，CAS + volatile体现了乐观锁的思想，并且可细线无锁并发</p><p>Java并发包下提供了一些原子类，底层实现用的CAS+volatile</p><h2 id="synchronized优化"><a href="#synchronized优化" class="headerlink" title="synchronized优化"></a>synchronized优化</h2><p>对象头重的Mark Word</p><p>偏向锁：thread-id(名字)</p><p>轻量级锁 :栈帧中的锁记录结构</p><p>重量级锁：Monitor</p><p>重量级锁自旋优化</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/java/并发编程/并发编程-原理篇</title>
      <link href="blog/2689811167.html"/>
      <url>blog/2689811167.html</url>
      
        <content type="html"><![CDATA[<h2 id="synchronized-原理进阶"><a href="#synchronized-原理进阶" class="headerlink" title="synchronized 原理进阶"></a>synchronized 原理进阶</h2><h3 id="1-轻量级锁"><a href="#1-轻量级锁" class="headerlink" title="1. 轻量级锁"></a>1. 轻量级锁</h3><p>轻量级锁的使用场景：如果一个对象虽然有多线程要加锁，但加锁的时间是错开的（也就是没有竞争），那么可以 使用轻量级锁来优化。 轻量级锁对使用者是透明的，即语法仍然是 synchronized 假设有两个方法同步块，利用同一个对象加锁</p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> Object obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>             <span class="token comment" spellcheck="true">// 同步块 A</span>            <span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>             <span class="token comment" spellcheck="true">// 同步块 B </span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><ul><li><p>创建锁记录（Lock Record）对象，每个线程都的栈帧都会包含一个锁记录的结构，内部可以存储锁定对象的 Mark Word<br><img src=".%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%8E%9F%E7%90%86%E7%AF%87_images/85a92afc.png" alt=""></p></li><li><p>让锁记录中 Object reference 指向锁对象，并尝试用 cas 替换 Object 的 Mark Word，将 Mark Word 的值存 入锁记录<br><img src=".%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%8E%9F%E7%90%86%E7%AF%87_images/5f6f7e35.png" alt="">  </p></li><li><p>如果 cas 替换成功，对象头中存储了 锁记录地址和状态 00 ，表示由该线程给对象加锁，这时图示如下<br><img src=".%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%8E%9F%E7%90%86%E7%AF%87_images/f14c2f5e.png" alt="">  </p></li><li><p>如果 cas 失败，有两种情况</p><ul><li>如果是其它线程已经持有了该 Object 的轻量级锁，这时表明有竞争，进入锁膨胀过程 </li><li>如果是自己执行了 <code>synchronized 锁重入</code>，那么再添加一条 <code>Lock Record</code> 作为重入的计数<br><img src=".%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%8E%9F%E7%90%86%E7%AF%87_images/7cd84300.png" alt="">  </li></ul></li><li><p>当退出 <code>synchronized</code> 代码块（解锁时）如果有取值为 <code>null</code> 的锁记录，表示有重入，这时重置锁记录，表示重 入计数减一 </p></li><li><p>当退出 <code>synchronized</code> 代码块（解锁时）锁记录的值不为 <code>null</code>，这时使用 <code>cas</code> 将 <code>Mark Word</code> 的值恢复给对象 头</p><ul><li>成功，则解锁成功 </li><li>失败，说明轻量级锁进行了锁膨胀或已经升级为重量级锁，<strong>进入重量级锁解锁流程</strong>  </li></ul></li></ul><h3 id="2-锁膨胀"><a href="#2-锁膨胀" class="headerlink" title="2. 锁膨胀"></a>2. 锁膨胀</h3><p>如果在尝试加轻量级锁的过程中，<code>CAS</code> 操作无法成功，这时一种情况就是有其它线程为此对象加上了轻量级锁（有 竞争），这时需要进行锁膨胀，将轻量级锁变为重量级锁。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> Object obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">synchronized</span><span class="token punctuation">(</span> obj <span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 同步块</span>    <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre><p>当 Thread-1 进行轻量级加锁时，Thread-0 已经对该对象加了轻量级锁<br><img src=".%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%8E%9F%E7%90%86%E7%AF%87_images/e63d8eab.png" alt="">  </p><ul><li>这时 Thread-1 加轻量级锁失败，进入锁膨胀流程<ul><li><strong>即为 Object 对象申请 Monitor 锁，让 Object 指向重量级锁地址</strong> </li><li><strong>然后自己进入 Monitor 的 EntryList BLOCKED</strong>  </li></ul></li></ul><p><img src=".%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%8E%9F%E7%90%86%E7%AF%87_images/d2be12af.png" alt=""></p><ul><li>当 Thread-0 退出同步块解锁时，使用 <code>cas</code> 将 Mark Word 的值恢复给对象头，失败。这时会进入重量级解锁 流程，即按照 Monitor 地址找到 Monitor 对象，设置 Owner 为 null，唤醒 EntryList 中 BLOCKED 线程</li></ul><h3 id="3-自旋优化"><a href="#3-自旋优化" class="headerlink" title="3. 自旋优化"></a>3. 自旋优化</h3><p>重量级锁竞争的时候，还可以使用自旋来进行优化，如果当前线程自旋成功（即这时候持锁线程已经退出了同步 块，释放了锁），这时当前线程就<code>可以避免阻塞</code>。 </p><p>自旋重试成功的情况</p><table><thead><tr><th>线程 1 （core 1 上）</th><th>对象 Mark</th><th>线程 2 （core 2 上）</th></tr></thead><tbody><tr><td>-</td><td>10（重量锁）</td><td>-</td></tr><tr><td>访问同步块，获取 monitor</td><td>10（重量锁）重量锁指针</td><td>-</td></tr><tr><td>成功（加锁）</td><td>10（重量锁）重量锁指针</td><td>-</td></tr><tr><td>执行同步块</td><td>10（重量锁）重量锁指针</td><td>-</td></tr><tr><td>执行同步块</td><td>10（重量锁）重量锁指针</td><td>访问同步块，获取 monitor</td></tr><tr><td>执行同步块</td><td>10（重量锁）重量锁指针</td><td>自旋重试</td></tr><tr><td>执行完毕</td><td>10（重量锁）重量锁指针</td><td>自旋重试</td></tr><tr><td>成功（解锁）</td><td>01（无锁）</td><td>自旋重试</td></tr><tr><td>-</td><td>10（重量锁）重量锁指针</td><td>成功（加锁）</td></tr><tr><td>-</td><td>10（重量锁）重量锁指针</td><td>执行同步块</td></tr><tr><td>-</td><td>…</td><td>…</td></tr></tbody></table><p>自旋重试失败的情况</p><table><thead><tr><th>线程 1 （core 1 上）</th><th>对象 Mark</th><th>线程 2 （core 2 上）</th></tr></thead><tbody><tr><td>-</td><td>10（重量锁）</td><td>-</td></tr><tr><td>访问同步块，获取 monitor</td><td>10（重量锁）重量锁指针</td><td>-</td></tr><tr><td>成功（加锁）</td><td>10（重量锁）重量锁指针</td><td>-</td></tr><tr><td>执行同步块</td><td>10（重量锁）重量锁指针</td><td>-</td></tr><tr><td>执行同步块</td><td>10（重量锁）重量锁指针</td><td>访问同步块，获取 monitor</td></tr><tr><td>执行同步块</td><td>10（重量锁）重量锁指针</td><td>自旋重试</td></tr><tr><td>执行同步块</td><td>10（重量锁）重量锁指针</td><td>自旋重试</td></tr><tr><td>执行同步块</td><td>10（重量锁）重量锁指针</td><td>自旋重试</td></tr><tr><td>执行同步块</td><td>10（重量锁）重量锁指针</td><td>阻塞</td></tr><tr><td>-</td><td>…</td><td>…</td></tr></tbody></table><ul><li>自旋会占用 CPU 时间，单核 CPU 自旋就是浪费，多核 CPU 自旋才能发挥优势。</li><li>在 Java 6 之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会 高，就多自旋几次；反之，就少自旋甚至不自旋，总之，比较智能。</li><li>Java 7 之后不能控制是否开启自旋功能</li></ul><h3 id="4-偏向锁"><a href="#4-偏向锁" class="headerlink" title="4. 偏向锁"></a>4. 偏向锁</h3><p>轻量级锁在没有竞争时（就自己这个线程），每次重入仍然需要执行 CAS 操作。 </p><p>Java 6 中引入了偏向锁来做进一步优化：只有第一次使用 CAS 将线程 ID 设置到对象的 Mark Word 头，之后发现 这个线程 ID 是自己的就表示没有竞争，不用重新 CAS。以后只要不发生竞争，这个对象就归该线程所有 </p><p>例如：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> Object obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">m1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 同步块 A </span>            <span class="token function">m2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">m2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 同步块 B </span>            <span class="token function">m3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">m3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 同步块 C</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p><img src=".%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%8E%9F%E7%90%86%E7%AF%87_images/203cc914.png" alt="">  </p><h4 id="偏向状态"><a href="#偏向状态" class="headerlink" title="偏向状态"></a>偏向状态</h4><p>对象头格式</p><pre class=" language-java"><code class="language-java"><span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">|</span> <span class="token operator">|</span>                                                             Mark <span class="token function">Word</span> <span class="token punctuation">(</span><span class="token number">64</span> bits<span class="token punctuation">)</span>              <span class="token operator">|</span>                 State       <span class="token operator">|</span> <span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">|</span> <span class="token operator">|</span> unused<span class="token operator">:</span><span class="token number">25</span><span class="token operator">|</span>hashcode<span class="token operator">:</span><span class="token number">31</span><span class="token operator">|</span>unused<span class="token operator">:</span><span class="token number">1</span><span class="token operator">|</span>age<span class="token operator">:</span><span class="token number">4</span><span class="token operator">|</span> biased_lock<span class="token operator">:</span><span class="token number">0</span>   <span class="token operator">|</span><span class="token number">01</span><span class="token operator">|</span>                 Normal      <span class="token operator">|</span> <span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">|</span> <span class="token operator">|</span> thread<span class="token operator">:</span><span class="token number">54</span><span class="token operator">|</span>epoch<span class="token operator">:</span><span class="token number">2</span><span class="token operator">|</span>unused<span class="token operator">:</span><span class="token number">1</span><span class="token operator">|</span> age<span class="token operator">:</span><span class="token number">4</span> <span class="token operator">|</span> biased_lock<span class="token operator">:</span><span class="token number">1</span>         <span class="token operator">|</span><span class="token number">01</span><span class="token operator">|</span>                 Biased             <span class="token operator">|</span> <span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">|</span> <span class="token operator">|</span> ptr_to_lock_record<span class="token operator">:</span><span class="token number">62</span>                                                               <span class="token operator">|</span><span class="token number">00</span><span class="token operator">|</span> Lightweight Locked <span class="token operator">|</span> <span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">|</span> <span class="token operator">|</span> ptr_to_heavyweight_monitor<span class="token operator">:</span><span class="token number">62</span>                                                  <span class="token operator">|</span><span class="token number">10</span><span class="token operator">|</span> Heavyweight Locked <span class="token operator">|</span> <span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">|</span> <span class="token operator">|</span>                                                                                                             <span class="token operator">|</span><span class="token number">11</span><span class="token operator">|</span>         Marked <span class="token keyword">for</span> GC      <span class="token operator">|</span> <span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">|</span></code></pre><p>一个对象创建时：</p><ul><li>如果开启了偏向锁（默认开启），那么对象创建后，markword 值为 0x05 即最后 3 位为 101，这时它的 thread、epoch、age 都为 0 </li><li>偏向锁是默认是延迟的，不会在程序启动时立即生效，如果想避免延迟，可以加 VM 参数 XX:BiasedLockingStartupDelay=0 来禁用延迟 </li><li>如果没有开启偏向锁，那么对象创建后，markword 值为 0x01 即最后 3 位为 001，这时它的 hashcode、 age 都为 0，第一次用到 hashcode(调用对象hashcode()) 时才会赋值</li></ul><p>1） 测试延迟特性 </p><p>2） 测试偏向锁</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Dog</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><p>利用 jol 第三方工具来查看对象头信息（注意这里扩展了 jol 让它输出更为简洁）</p><pre class=" language-java"><code class="language-java"> <span class="token comment" spellcheck="true">// 添加虚拟机参数 -XX:BiasedLockingStartupDelay=0 </span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        Dog d <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ClassLayout classLayout <span class="token operator">=</span> ClassLayout<span class="token punctuation">.</span><span class="token function">parseInstance</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"synchronized 前"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>classLayout<span class="token punctuation">.</span><span class="token function">toPrintableSimple</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>d<span class="token punctuation">)</span> <span class="token punctuation">{</span>                log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"synchronized 中"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>classLayout<span class="token punctuation">.</span><span class="token function">toPrintableSimple</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"synchronized 后"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>classLayout<span class="token punctuation">.</span><span class="token function">toPrintableSimple</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"t1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>输出</p><pre><code>11:08:58.117 c.TestBiased [t1] - synchronized 前 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000101 11:08:58.121 c.TestBiased [t1] - synchronized 中 00000000 00000000 00000000 00000000 00011111 11101011 11010000 00000101 11:08:58.121 c.TestBiased [t1] - synchronized 后 00000000 00000000 00000000 00000000 00011111 11101011 11010000 00000101</code></pre><blockquote><p>注意:处于偏向锁的对象解锁后，线程 id 仍存储于对象头中</p></blockquote><p>3）测试禁用</p><p>在上面测试代码运行时在添加 VM 参数 -XX:-UseBiasedLocking 禁用偏向锁</p><p>输出</p><pre><code>11:13:10.018 c.TestBiased [t1] - synchronized 前 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 11:13:10.021 c.TestBiased [t1] - synchronized 中 00000000 00000000 00000000 00000000 00100000 00010100 11110011 10001000 11:13:10.021 c.TestBiased [t1] - synchronized 后 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001</code></pre><p>4) 测试 hashCode</p><ul><li>正常状态对象一开始是没有 hashCode 的，第一次调用才生成</li></ul><h4 id="撤销-调用对象-hashCode-从偏向变为不可偏向"><a href="#撤销-调用对象-hashCode-从偏向变为不可偏向" class="headerlink" title="撤销 - 调用对象 hashCode(从偏向变为不可偏向)"></a>撤销 - 调用对象 hashCode(从偏向变为不可偏向)</h4><p>调用了对象的 hashCode，但偏向锁的对象 MarkWord 中存储的是线程 id，如果调用 hashCode 会导致偏向锁被 撤销,并重新设置markword中的hashcode</p><ul><li><p>轻量级锁会在锁记录中记录 hashCode</p></li><li><p>重量级锁会在 Monitor 中记录 hashCode 在调用 hashCode 后使用偏向锁，记得去掉 -XX:-UseBiasedLocking </p></li></ul><p>输出</p><pre><code>11:22:10.386 c.TestBiased [main] - 调用 hashCode:1778535015 11:22:10.391 c.TestBiased [t1] - synchronized 前 00000000 00000000 00000000 01101010 00000010 01001010 01100111 00000001 11:22:10.393 c.TestBiased [t1] - synchronized 中 00000000 00000000 00000000 00000000 00100000 11000011 11110011 01101000 11:22:10.393 c.TestBiased [t1] - synchronized 后 00000000 00000000 00000000 01101010 00000010 01001010 01100111 00000001</code></pre><h4 id="撤销-由可偏向101变为不可偏向001-其它线程使用对象"><a href="#撤销-由可偏向101变为不可偏向001-其它线程使用对象" class="headerlink" title="撤销(由可偏向101变为不可偏向001) - 其它线程使用对象"></a>撤销(由可偏向101变为不可偏向001) - 其它线程使用对象</h4><p>当有其它线程使用偏向锁对象时，会将偏向锁升级为轻量级锁  </p><p>（偏向锁和轻量级锁有一个前提，那就是两个线程错开的访问这个对象）  </p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        Dog d <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>d<span class="token punctuation">)</span> <span class="token punctuation">{</span>                log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span>ClassLayout<span class="token punctuation">.</span><span class="token function">parseInstance</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toPrintableSimple</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>          <span class="token comment" spellcheck="true">//以下代码使得t1执行完上面的代码块，才执行t2，第二个同步代步代码块</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>TestBiased<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                TestBiased<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 如果不用 wait/notify 使用 join 必须打开下面的注释 </span>            <span class="token comment" spellcheck="true">// 因为：t1 线程不能结束，否则底层线程可能被 jvm 重用作为 t2 线程，底层线程 id 是一样的 </span>             <span class="token comment" spellcheck="true">/*try {                  System.in.read();              } catch (IOException e) {                  e.printStackTrace();              }*/</span>              <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"t1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread t2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>TestBiased<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">try</span> <span class="token punctuation">{</span>                        TestBiased<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>                log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span>ClassLayout<span class="token punctuation">.</span><span class="token function">parseInstance</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toPrintableSimple</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>d<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span>ClassLayout<span class="token punctuation">.</span><span class="token function">parseInstance</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toPrintableSimple</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span>ClassLayout<span class="token punctuation">.</span><span class="token function">parseInstance</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toPrintableSimple</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"t2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            t2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>   </code></pre><p>输出  </p><pre><code>[t1] - 00000000 00000000 00000000 00000000 00011111 01000001 00010000 00000101 [t2] - 00000000 00000000 00000000 00000000 00011111 01000001 00010000 00000101 [t2] - 00000000 00000000 00000000 00000000 00011111 10110101 11110000 01000000 [t2] - 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001</code></pre><h4 id="撤销-调用-wait-notify（这个只有重量级锁才有）"><a href="#撤销-调用-wait-notify（这个只有重量级锁才有）" class="headerlink" title="撤销 - 调用 wait/notify（这个只有重量级锁才有）"></a>撤销 - 调用 wait/notify（这个只有重量级锁才有）</h4><blockquote><p>所谓偏向，是让对象的thread-id变化</p></blockquote><h4 id="批量重偏向"><a href="#批量重偏向" class="headerlink" title="批量重偏向"></a>批量重偏向</h4><p>如果对象虽然被多个线程访问，但没有竞争，这时偏向了线程 T1 的对象仍有机会重新偏向 T2，重偏向会重置对象 的 Thread ID</p><p>当撤销偏向锁阈值超过 20 次后，jvm 会这样觉得，我是不是偏向错了呢，于是会在给这些对象加锁时重新偏向至 加锁线程</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        Vector<span class="token operator">&lt;</span>Dog<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vector</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">30</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                Dog d <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>d<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token string">"\t"</span> <span class="token operator">+</span> ClassLayout<span class="token punctuation">.</span><span class="token function">parseInstance</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toPrintableSimple</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>list<span class="token punctuation">)</span> <span class="token punctuation">{</span>                list<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"t1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread t2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>list<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    list<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"===============> "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">30</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                Dog d <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>                log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token string">"\t"</span> <span class="token operator">+</span> ClassLayout<span class="token punctuation">.</span><span class="token function">parseInstance</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toPrintableSimple</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>d<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token string">"\t"</span> <span class="token operator">+</span> ClassLayout<span class="token punctuation">.</span><span class="token function">parseInstance</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toPrintableSimple</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token string">"\t"</span> <span class="token operator">+</span> ClassLayout<span class="token punctuation">.</span><span class="token function">parseInstance</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toPrintableSimple</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"t2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>输出过长，这里不与展示</p><h4 id="批量撤销"><a href="#批量撤销" class="headerlink" title="批量撤销"></a>批量撤销</h4><p>当撤销偏向锁阈值超过 40 次后，jvm 会这样觉得，自己确实偏向错了，根本就不该偏向。于是整个类的所有对象 都会变为不可偏向（001）的，新建的对象也是不可偏向的</p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> Thread t1<span class="token punctuation">,</span> t2<span class="token punctuation">,</span> t3<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test4</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        Vector<span class="token operator">&lt;</span>Dog<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vector</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> loopNumber <span class="token operator">=</span> <span class="token number">39</span><span class="token punctuation">;</span>        t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> loopNumber<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                Dog d <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>d<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token string">"\t"</span> <span class="token operator">+</span> ClassLayout<span class="token punctuation">.</span><span class="token function">parseInstance</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toPrintableSimple</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            LockSupport<span class="token punctuation">.</span><span class="token function">unpark</span><span class="token punctuation">(</span>t2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"t1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            LockSupport<span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"===============> "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> loopNumber<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                Dog d <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>                log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token string">"\t"</span> <span class="token operator">+</span> ClassLayout<span class="token punctuation">.</span><span class="token function">parseInstance</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toPrintableSimple</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>d<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token string">"\t"</span> <span class="token operator">+</span> ClassLayout<span class="token punctuation">.</span><span class="token function">parseInstance</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toPrintableSimple</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token string">"\t"</span> <span class="token operator">+</span> ClassLayout<span class="token punctuation">.</span><span class="token function">parseInstance</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toPrintableSimple</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            LockSupport<span class="token punctuation">.</span><span class="token function">unpark</span><span class="token punctuation">(</span>t3<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"t2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            LockSupport<span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"===============> "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> loopNumber<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                Dog d <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>                log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token string">"\t"</span> <span class="token operator">+</span> ClassLayout<span class="token punctuation">.</span><span class="token function">parseInstance</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toPrintableSimple</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>d<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token string">"\t"</span> <span class="token operator">+</span> ClassLayout<span class="token punctuation">.</span><span class="token function">parseInstance</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toPrintableSimple</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token string">"\t"</span> <span class="token operator">+</span> ClassLayout<span class="token punctuation">.</span><span class="token function">parseInstance</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toPrintableSimple</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"t3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t3<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t3<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span>ClassLayout<span class="token punctuation">.</span><span class="token function">parseInstance</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toPrintableSimple</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><blockquote><p>参考资料</p><p><a href="https://github.com/farmerjohngit/myblog/issues/12" target="_blank" rel="noopener">https://github.com/farmerjohngit/myblog/issues/12</a> </p><p><a href="https://www.cnblogs.com/LemonFive/p/11246086.html" target="_blank" rel="noopener">https://www.cnblogs.com/LemonFive/p/11246086.html</a></p><p><a href="https://www.cnblogs.com/LemonFive/p/11248248.html" target="_blank" rel="noopener">https://www.cnblogs.com/LemonFive/p/11248248.html</a> </p><p>偏向锁论文</p></blockquote><h3 id="5-锁消除"><a href="#5-锁消除" class="headerlink" title="5. 锁消除"></a>5. 锁消除</h3><p>锁消除</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Fork</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token annotation punctuation">@BenchmarkMode</span><span class="token punctuation">(</span>Mode<span class="token punctuation">.</span>AverageTime<span class="token punctuation">)</span><span class="token annotation punctuation">@Warmup</span><span class="token punctuation">(</span>iterations<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Measurement</span><span class="token punctuation">(</span>iterations<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token annotation punctuation">@OutputTimeUnit</span><span class="token punctuation">(</span>TimeUnit<span class="token punctuation">.</span>NANOSECONDS<span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyBenchmark</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Benchmark</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        x<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Benchmark</span>    <span class="token comment" spellcheck="true">// JIT  即时编译器热点代码进一步优化，JIT认为o是局部变量不会逃离方法的作用范围，会把锁消除掉</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        Object o <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>o<span class="token punctuation">)</span> <span class="token punctuation">{</span>            x<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><code>java -jar benchmarks.jar</code>（要打成jar包用）</p><pre><code>Benchmark                          Mode  Samples    Score  Score error Units c.i.MyBenchmark.a         avgt            5        1.542            0.056             ns/opc.i.MyBenchmark.b            avgt            5        1.518            0.091             ns/op</code></pre><p><code>java -XX:-EliminateLocks -jar benchmarks.jar</code>（锁消除的开关）</p><pre><code>Benchmark                          Mode  Samples    Score  Score error Units c.i.MyBenchmark.a         avgt            5        1.507            0.108             ns/opc.i.MyBenchmark.b            avgt            5     16.976            1.572             ns/op</code></pre><h2 id="wait-notify-原理"><a href="#wait-notify-原理" class="headerlink" title="wait/notify 原理"></a>wait/notify 原理</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/java/并发编程/共享模型之管程</title>
      <link href="blog/1047611555.html"/>
      <url>blog/1047611555.html</url>
      
        <content type="html"><![CDATA[<h1 id="共享模型之管程"><a href="#共享模型之管程" class="headerlink" title="共享模型之管程"></a>共享模型之管程</h1><h2 id="1-共享带来的问题"><a href="#1-共享带来的问题" class="headerlink" title="1. 共享带来的问题"></a>1. 共享带来的问题</h2><p>两个线程对初始值为 0 的静态变量一个做自增，一个做自减，各做 5000 次，结果是 0 吗？</p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">int</span> counter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        Thread t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                counter<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"t1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread t2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                counter<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"t2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> counter<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>以上的结果可能是正数、负数、零。为什么呢？因为 Java 中对静态变量的自增，自减并不是原子操作，要彻底理 解，必须从字节码来进行分析    </p><pre class=" language-java"><code class="language-java">getstatic   i   <span class="token comment" spellcheck="true">// 获取静态变量i的值   </span>iconst_1                <span class="token comment" spellcheck="true">// 准备常量1</span>iadd                      <span class="token comment" spellcheck="true">// 自增</span>putstatic   i   <span class="token comment" spellcheck="true">// 将修改后的值存入静态变量i</span></code></pre><p>例如对于 <code>i++</code> 而言（i 为静态变量），实际会产生如下的 JVM 字节码指令：</p><blockquote><p>getstatic 从类中获取静态字段</p><p>putstatic 设置类中静态字段的值</p><p>iconst_m1  将1个常量加载到操作数栈</p><p>iadd           加法指令</p></blockquote><p>而对应 <code>i--</code> 也是类似：</p><pre class=" language-java"><code class="language-java">getstatic   i   <span class="token comment" spellcheck="true">// 获取静态变量i的值   </span>iconst_1                <span class="token comment" spellcheck="true">// 准备常量1</span>isub                      <span class="token comment" spellcheck="true">// 自减</span>putstatic   i   <span class="token comment" spellcheck="true">// 将修改后的值存入静态变量i</span></code></pre><p>而Java 的内存模型如下，完成静态变量的自增，自减需要在主存和工作内存中进行数据交换：</p><p><img src=".%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E7%AE%A1%E7%A8%8B_images/5024c097.png" alt="">  </p><p>如果是单线程以上 8 行代码是顺序执行（不会交错）没有问题：</p><p>但多线程下这 8 行代码可能交错运行,进而会出现正数和负数的情况.</p><h3 id="临界区-Critical-Section"><a href="#临界区-Critical-Section" class="headerlink" title="临界区 Critical Section"></a>临界区 Critical Section</h3><ul><li><p>一个程序运行多个线程本身是没有问题的 问题出在多个线程访问共享资源</p><ul><li>多个线程读共享资源其实也没有问题 </li><li>在多个线程对共享资源读写操作时发生指令交错，就会出现问题 </li></ul></li><li><p>一段代码块内如果存在对<strong>共享资源</strong>的多线程读写操作，称这段代码块为<strong>临界区</strong></p><p>例如，下面代码中的临界区  </p></li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">int</span> counter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 临界区 </span><span class="token punctuation">{</span>     counter<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">decrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 临界区 </span><span class="token punctuation">{</span>     counter<span class="token operator">--</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><h3 id="竞态条件-Race-Condition"><a href="#竞态条件-Race-Condition" class="headerlink" title="竞态条件 Race Condition"></a>竞态条件 Race Condition</h3><p>多个线程在临界区内执行，由于代码的执行序列不同而导致结果无法预测，称之为发生了竞态条件</p><h2 id="2-synchronized-解决方案"><a href="#2-synchronized-解决方案" class="headerlink" title="2. synchronized 解决方案"></a>2. synchronized 解决方案</h2><p>为了避免临界区的竞态条件发生，有多种手段可以达到目的。</p><ul><li>阻塞式的解决方案：synchronized，Lock </li><li>非阻塞式的解决方案：原子变量  </li></ul><p>synchronized，俗称【对象锁】，它采用互斥的方式让同一 时刻至多只有一个线程能持有【对象锁】，其它线程再想获取这个【对象锁】时就会阻塞住。这样就能保证拥有锁 的线程可以安全的执行临界区内的代码，不用担心线程上下文切换  </p><blockquote><p>注意<br>虽然 java 中互斥和同步都可以采用 synchronized 关键字来完成，但它们还是有区别的：  </p><ul><li>互斥是保证同一时刻只能有一个线程执行临界区代码  </li><li>同步是由于线程执行的先后、顺序不同、需要一个线程等待其它线程运行到某个点  </li></ul></blockquote><p>语法  </p><pre class=" language-java"><code class="language-java"><span class="token keyword">synchronized</span><span class="token punctuation">(</span>对象<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 线程1， 线程2(blocked) </span><span class="token punctuation">{</span>     临界区 <span class="token punctuation">}</span></code></pre><p>解决  </p><pre class=" language-java"><code class="language-java"> <span class="token keyword">static</span> <span class="token keyword">int</span> counter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> Object room <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        Thread t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>room<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    counter<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"t1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread t2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>room<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    counter<span class="token operator">--</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"t2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> counter<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p><img src=".%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E7%AE%A1%E7%A8%8B_images/c86ef8e6.png" alt=""></p><p>你可以做这样的类比：</p><ul><li><code>synchronized(对象)</code> 中的对象，可以想象为一个房间（room），有唯一入口（门）房间只能一次进入一人 进行计算，线程 t1，t2 想象成两个人 </li><li>当线程 t1 执行到 <code>synchronized(room)</code> 时就好比 t1 进入了这个房间，并锁住了门拿走了钥匙，在门内执行 <code>count++</code> 代码 </li><li>这时候如果 t2 也运行到了 <code>synchronized(room)</code> 时，它发现门被锁住了，只能在门外等待，发生了上下文切 换，阻塞住了 </li><li>这中间即使 t1 的 cpu 时间片不幸用完，被踢出了门外（不要错误理解为锁住了对象就能一直执行下去哦）， 这时门还是锁住的，t1 仍拿着钥匙，t2 线程还在阻塞状态进不来，只有下次轮到 t1 自己再次获得时间片时才 能开门进入</li><li>当 t1 执行完 <code>synchronized{}</code> 块内的代码，这时候才会从 obj 房间出来并解开门上的锁，唤醒 t2 线程把钥 匙给他。t2 线程这时才可以进入 <code>obj</code> 房间，锁住了门拿上钥匙，执行它的 <code>count--</code> 代码</li></ul><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>synchronized 实际是用对象锁保证了临界区内代码的原子性，临界区内的代码对外是不可分割的，不会被线程切 换所打断。 为了加深理解，请思考下面的问题  </p><ul><li>如果把 <code>synchronized(obj)</code> 放在 for 循环的外面，如何理解？– 原子性</li><li>如果 t1  <code>synchronized(obj1)</code> 而 <code>t2 synchronized(obj2)</code> 会怎样运作？– 锁对象</li><li>如果 t1 <code>synchronized(obj)</code> 而 t2 没有加会怎么样？如何理解？– 锁对象</li></ul><h3 id="方法上的-synchronized"><a href="#方法上的-synchronized" class="headerlink" title="方法上的 synchronized"></a>方法上的 synchronized</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span> 等价于<span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>       </code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span> 等价于<span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>Test<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>       </code></pre><h3 id="不加-synchronized-的方法"><a href="#不加-synchronized-的方法" class="headerlink" title="不加 synchronized 的方法"></a>不加 synchronized 的方法</h3><p>不加 synchronzied 的方法就好比不遵守规则的人，不去老实排队（好比翻窗户进去的）</p><h2 id="3-变量的线程安全分析"><a href="#3-变量的线程安全分析" class="headerlink" title="3. 变量的线程安全分析"></a>3. 变量的线程安全分析</h2><h3 id="成员变量和静态变量是否线程安全？"><a href="#成员变量和静态变量是否线程安全？" class="headerlink" title="成员变量和静态变量是否线程安全？"></a>成员变量和静态变量是否线程安全？</h3><ul><li><p>如果它们没有共享，则线程安全 </p></li><li><p>如果它们被共享了，根据它们的状态是否能够改变，又分两种情况</p><ul><li><p>如果只有读操作，则线程安全</p></li><li><p>如果有读写操作，则这段代码是临界区，需要考虑线程安全</p></li></ul></li></ul><h3 id="局部变量是否线程安全？"><a href="#局部变量是否线程安全？" class="headerlink" title="局部变量是否线程安全？"></a>局部变量是否线程安全？</h3><ul><li><p>局部变量是线程安全的 </p></li><li><p>但局部变量引用的对象则未必</p><ul><li>如果该对象没有逃离方法的作用范围，它是线程安全的 </li><li>如果该对象逃离方法的作用范围，需要考虑线程安全(public非final方法可能会子类重写，局部变量可能会被多线程访问，进而引发线程安全问题)</li></ul></li></ul><h3 id="常见线程安全类"><a href="#常见线程安全类" class="headerlink" title="常见线程安全类"></a>常见线程安全类</h3><ul><li>String</li><li>Integer </li><li>StringBuﬀer </li><li>Random </li><li>Vector </li><li>Hashtable </li><li>java.util.concurrent 包下的类</li></ul><p>这里说它们是线程安全的是指，多个线程调用它们同一个实例的某个方法时，是线程安全的。也可以理解为  </p><ul><li>它们的每个方法是原子的 </li><li>但注意它们多个方法的组合不是原子的  </li></ul><h3 id="不可变类线程安全性"><a href="#不可变类线程安全性" class="headerlink" title="不可变类线程安全性"></a>不可变类线程安全性</h3><p>String、Integer 等都是不可变类，因为其内部的状态不可以改变，因此它们的方法都是线程安全的 有人或许有疑问，String 有 replace，substring 等方法【可以】改变值啊，那么这些方法又是如何保证线程安 全的呢？</p><ul><li>通过创建新的对象并返回,原有的不变</li></ul><h2 id="4-Monitor-概念"><a href="#4-Monitor-概念" class="headerlink" title="4. Monitor 概念"></a>4. Monitor 概念</h2><h3 id="Java-对象头"><a href="#Java-对象头" class="headerlink" title="Java 对象头"></a>Java 对象头</h3><p>以 32 位虚拟机为例</p><p>普通对象</p><pre class=" language-java"><code class="language-java"><span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">|</span> <span class="token operator">|</span>                                     Object <span class="token function">Header</span> <span class="token punctuation">(</span><span class="token number">64</span> bits<span class="token punctuation">)</span>                                         <span class="token operator">|</span> <span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">|</span> <span class="token operator">|</span>                     Mark <span class="token function">Word</span> <span class="token punctuation">(</span><span class="token number">32</span> bits<span class="token punctuation">)</span>          <span class="token operator">|</span>         Klass <span class="token function">Word</span> <span class="token punctuation">(</span><span class="token number">32</span> bits<span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">|</span></code></pre><p>数组对象</p><pre class=" language-java"><code class="language-java"><span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">|</span> <span class="token operator">|</span>                                                     Object <span class="token function">Header</span> <span class="token punctuation">(</span><span class="token number">96</span> bits<span class="token punctuation">)</span>                                                             <span class="token operator">|</span> <span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">|</span> <span class="token operator">|</span>                         Mark <span class="token function">Word</span><span class="token punctuation">(</span>32bits<span class="token punctuation">)</span>     <span class="token operator">|</span> Klass <span class="token function">Word</span><span class="token punctuation">(</span>32bits<span class="token punctuation">)</span>      <span class="token operator">|</span> array <span class="token function">length</span><span class="token punctuation">(</span>32bits<span class="token punctuation">)</span>     <span class="token operator">|</span> <span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">|</span></code></pre><p>其中 Mark Word 结构为</p><pre class=" language-java"><code class="language-java"><span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">|</span> <span class="token operator">|</span>                                                 Mark <span class="token function">Word</span> <span class="token punctuation">(</span><span class="token number">32</span> bits<span class="token punctuation">)</span>                         <span class="token operator">|</span>             State                 <span class="token operator">|</span> <span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">|</span> <span class="token operator">|</span>         hashcode<span class="token operator">:</span><span class="token number">25</span>              <span class="token operator">|</span>     age<span class="token operator">:</span><span class="token number">4</span>     <span class="token operator">|</span> biased_lock<span class="token operator">:</span><span class="token number">0</span> <span class="token operator">|</span> <span class="token number">01</span>  <span class="token operator">|</span>             Normal              <span class="token operator">|</span> <span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">|</span> <span class="token operator">|</span>     thread<span class="token operator">:</span><span class="token number">23</span> <span class="token operator">|</span> epoch<span class="token operator">:</span><span class="token number">2</span> <span class="token operator">|</span>  age<span class="token operator">:</span><span class="token number">4</span>  <span class="token operator">|</span> biased_lock<span class="token operator">:</span><span class="token number">1</span> <span class="token operator">|</span> <span class="token number">01</span>  <span class="token operator">|</span>             Biased             <span class="token operator">|</span> <span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">|</span> <span class="token operator">|</span>                                                   ptr_to_lock_record<span class="token operator">:</span><span class="token number">30</span> <span class="token operator">|</span> <span class="token number">00</span>  <span class="token operator">|</span> Lightweight Locked <span class="token operator">|</span> <span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">|</span> <span class="token operator">|</span>                                     ptr_to_heavyweight_monitor<span class="token operator">:</span><span class="token number">30</span> <span class="token operator">|</span> <span class="token number">10</span>  <span class="token operator">|</span> Heavyweight Locked <span class="token operator">|</span> <span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">|</span> <span class="token operator">|</span>                                                                                                 <span class="token operator">|</span> <span class="token number">11</span>  <span class="token operator">|</span>         Marked <span class="token keyword">for</span> GC  <span class="token operator">|</span> <span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">|</span></code></pre><p>64 位虚拟机 Mark Word</p><pre class=" language-java"><code class="language-java"><span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">|</span> <span class="token operator">|</span>                                                             Mark <span class="token function">Word</span> <span class="token punctuation">(</span><span class="token number">64</span> bits<span class="token punctuation">)</span>              <span class="token operator">|</span>                 State       <span class="token operator">|</span> <span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">|</span> <span class="token operator">|</span> unused<span class="token operator">:</span><span class="token number">25</span><span class="token operator">|</span>hashcode<span class="token operator">:</span><span class="token number">31</span><span class="token operator">|</span>unused<span class="token operator">:</span><span class="token number">1</span><span class="token operator">|</span>age<span class="token operator">:</span><span class="token number">4</span><span class="token operator">|</span> biased_lock<span class="token operator">:</span><span class="token number">0</span>   <span class="token operator">|</span><span class="token number">01</span><span class="token operator">|</span>                 Normal      <span class="token operator">|</span> <span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">|</span> <span class="token operator">|</span> thread<span class="token operator">:</span><span class="token number">54</span><span class="token operator">|</span>epoch<span class="token operator">:</span><span class="token number">2</span><span class="token operator">|</span>unused<span class="token operator">:</span><span class="token number">1</span><span class="token operator">|</span> age<span class="token operator">:</span><span class="token number">4</span> <span class="token operator">|</span> biased_lock<span class="token operator">:</span><span class="token number">1</span>         <span class="token operator">|</span><span class="token number">01</span><span class="token operator">|</span>                 Biased             <span class="token operator">|</span> <span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">|</span> <span class="token operator">|</span> ptr_to_lock_record<span class="token operator">:</span><span class="token number">62</span>                                                               <span class="token operator">|</span><span class="token number">00</span><span class="token operator">|</span> Lightweight Locked <span class="token operator">|</span> <span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">|</span> <span class="token operator">|</span> ptr_to_heavyweight_monitor<span class="token operator">:</span><span class="token number">62</span>                                                  <span class="token operator">|</span><span class="token number">10</span><span class="token operator">|</span> Heavyweight Locked <span class="token operator">|</span> <span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">|</span> <span class="token operator">|</span>                                                                                                             <span class="token operator">|</span><span class="token number">11</span><span class="token operator">|</span>         Marked <span class="token keyword">for</span> GC      <span class="token operator">|</span> <span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">|</span></code></pre><p>参考资料</p><p> <a href="https://stackoverﬂow.com/questions/26357186/what-is-in-java-object-header" target="_blank" rel="noopener">https://stackoverﬂow.com/questions/26357186/what-is-in-java-object-header</a></p><ul><li><p>原理之 Monitor(锁)</p></li><li><p>原理之 synchronized</p></li></ul><p>小故事</p><p>故事角色</p><ul><li>老王 - JVM </li><li>小南 - 线程 </li><li>小女 - 线程 </li><li>房间 - 对象 </li><li>房间门上 - 防盗锁 - Monitor </li><li>房间门上 - 小南书包 - 轻量级锁 </li><li>房间门上 - 刻上小南大名 - 偏向锁 </li><li>批量重刻名 - 一个类的偏向锁撤销到达 20 阈值 </li><li>不能刻名字 - 批量撤销该类对象的偏向锁，设置该类不可偏向</li></ul><p>小南要使用房间保证计算不被其它人干扰（原子性），最初，他用的是防盗锁，当上下文切换时，锁住门。这样， 即使他离开了，别人也进不了门，他的工作就是安全的。</p><p>但是，很多情况下没人跟他来竞争房间的使用权。小女是要用房间，但使用的时间上是错开的，小南白天用，小女 晚上用。每次上锁太麻烦了，有没有更简单的办法呢？</p><p>小南和小女商量了一下，约定不锁门了，而是谁用房间，谁把自己的书包挂在门口，但他们的书包样式都一样，因 此每次进门前得翻翻书包，看课本是谁的，如果是自己的，那么就可以进门，这样省的上锁解锁了。万一书包不是 自己的，那么就在门外等，并通知对方下次用锁门的方式。</p><p>后来，小女回老家了，很长一段时间都不会用这个房间。小南每次还是挂书包，翻书包，虽然比锁门省事了，但仍 然觉得麻烦。</p><p>于是，小南干脆在门上刻上了自己的名字：【小南专属房间，其它人勿用】，下次来用房间时，只要名字还在，那 么说明没人打扰，还是可以安全地使用房间。如果这期间有其它人要用这个房间，那么由使用者将小南刻的名字擦 掉，升级为挂书包的方式。</p><p>同学们都放假回老家了，小南就膨胀了，在 20 个房间刻上了自己的名字，想进哪个进哪个。后来他自己放假回老 家了，这时小女回来了（她也要用这些房间），结果就是得一个个地擦掉小南刻的名字，升级为挂书包的方式。老 王觉得这成本有点高，提出了一种批量重刻名的方法，他让小女不用挂书包了，可以直接在门上刻上自己的名字</p><p>后来，刻名的现象越来越频繁，老王受不了了：算了，这些房间都不能刻名了，只能挂书包</p><ul><li>原理之 synchronized 进阶</li></ul><h2 id="5-wait-notify"><a href="#5-wait-notify" class="headerlink" title="5. wait/notify"></a>5. wait/notify</h2><h4 id="小故事-为什么需要-wait"><a href="#小故事-为什么需要-wait" class="headerlink" title="小故事 - 为什么需要 wait"></a>小故事 - 为什么需要 wait</h4><ul><li>由于条件不满足，小南不能继续进行计算 </li><li>但小南如果一直占用着锁，其它人就得一直阻塞，效率太低<br><img src=".%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E7%AE%A1%E7%A8%8B_images/2d5ddef7.png" alt="">  </li><li>于是老王单开了一间休息室（调用 wait 方法），让小南到休息室（WaitSet）等着去了，但这时锁释放开， 其它人可以由老王随机安排进屋 </li><li>直到小M将烟送来，大叫一声 [ 你的烟到了 ] （调用 notify 方法）<br><img src=".%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E7%AE%A1%E7%A8%8B_images/9e47f2b7.png" alt="">  </li><li>小南于是可以离开休息室，重新进入竞争锁的队列<br><img src=".%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E7%AE%A1%E7%A8%8B_images/1580f8d8.png" alt="">  </li></ul><p>*原理之 wait / notify</p><p>API 介绍</p><ul><li>obj.wait() 让进入 object 监视器的线程（获得锁的线程）到 waitSet 等待 </li><li>obj.wait(long 毫秒值)让进入 object 监视器的线程（获得锁的线程）到 waitSet 等待一定时间，时间到了后，自动被notify() ，或者时间到之前被其他线程唤醒</li><li>obj.notify() 在 object 上正在 waitSet 等待的线程中挑一个唤醒 </li><li>obj.notifyAll() 让 object 上正在 waitSet 等待的线程全部唤醒</li></ul><p>它们都是线程之间进行协作的手段，都属于 Object 对象的方法。<strong>必须获得此对象的锁，才能调用这几个方法</strong></p><p><code>wait()</code> 方法会释放对象的锁，进入 <code>WaitSet</code> 等待区，从而让其他线程就机会获取对象的锁。无限制等待，直到 <code>notify</code> 为止</p><h2 id="6-wait-notify-的正确姿势"><a href="#6-wait-notify-的正确姿势" class="headerlink" title="6 wait notify 的正确姿势"></a>6 wait notify 的正确姿势</h2><p>先看看</p><p><code>sleep(long n)</code> 和 <code>wait(long n)</code> 的区别</p><p>1) <code>sleep</code> 是 <code>Thread</code> 方法，而 <code>wait</code> 是 <code>Object</code> 的方法 </p><p>2) <code>sleep</code> 不需要强制和 <code>synchronized</code> 配合使用，但 <code>wait</code> 需要 和 <code>synchronized</code> 一起用 </p><p>3) <code>sleep</code> 在睡眠的同时，不会释放对象锁的，但 <code>wait</code> 在等待的时候会释放对象锁 </p><p>4) 它们 状态都是 <code>TIMED_WAITING</code></p><ul><li>sleep不释放锁，会阻塞其他线程，效率低，解决办法wait-notify</li><li>虚假唤醒：wait只能随机叫醒一个线程，多个线程在等待时，无法叫醒指定线程</li><li>notifyAll叫醒了不该叫醒（或者称任然未满足条件的）的进程，也不好</li><li>obj.wait()区域用while包裹，另一个线程用obj,notifyAll(),如下  </li></ul><p>正确姿势  </p><pre class=" language-java"><code class="language-java"><span class="token keyword">synchronized</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">while</span><span class="token punctuation">(</span>条件不成立<span class="token punctuation">)</span> <span class="token punctuation">{</span>     lock<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token comment" spellcheck="true">// 干活 </span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//另一个线程 </span><span class="token keyword">synchronized</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span> <span class="token punctuation">{</span>   lock<span class="token punctuation">.</span><span class="token function">notifyAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><h2 id="Park和Unpark"><a href="#Park和Unpark" class="headerlink" title="Park和Unpark"></a>Park和Unpark</h2><p>基本使用</p><h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><p>1个线程有1个Parker对象，由_cond，_counter，_mutex构成.</p><p>打个比喻：</p><ul><li>线程就像一个旅人，Parker相当于旅人的背包</li><li>_cond条件变量相当于背包中的帐篷</li><li>_counter相当于背包中的备用干粮(0为耗尽，1为充足)，背包容量有限</li><li>_mutext为互斥锁</li></ul><p>调用unpark,就好比令干粮充足(_counter为1)</p><ul><li>如果线程还在帐篷，唤醒他继续前进</li><li>如果线程在前进中，那下次调用park，仅是消耗掉备用干粮，线程不需休息继续前进<ul><li>因为背包容量，多次调用unpark也只能补充1份干粮(令_counter为1)</li></ul></li></ul><p>调用upark,会检查干粮</p><ul><li>如果备用干粮耗尽，则进入帐篷休息（获得_mutex互斥锁，进入_cond条件变量阻塞）</li><li>如果备用干粮充足，则继续前进，并消耗掉干粮</li></ul><h2 id="多把锁"><a href="#多把锁" class="headerlink" title="多把锁"></a>多把锁</h2><p>1个大房间有多个功能，睡觉和学习。</p><p>1把锁的话并发度低，设置(多个房间)多把锁，比如1个房间睡觉，1个房间自习 ，2把锁。</p><p>好处：增加并发度</p><p>坏处：1个线程要获取多把锁（资源），可能造成死锁</p><h2 id="活跃性问题"><a href="#活跃性问题" class="headerlink" title="活跃性问题"></a>活跃性问题</h2><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>1个线程持有了资源，又去申请资源， 申请资源的顺序不当可能导致死锁。</p><ul><li>定位死锁</li><li>哲学家就餐</li></ul><h3 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h3><p>2个线程互相修改对方的结束条件，导致都无法结束。</p><h3 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h3><p>优先级低的任务总是得不到执行。</p><h2 id="可重入锁ReentrantLock"><a href="#可重入锁ReentrantLock" class="headerlink" title="可重入锁ReentrantLock"></a>可重入锁ReentrantLock</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><pre class=" language-java"><code class="language-java">ReentrantLock lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ol><li><p>可重入：同一个线程多次调用(获取锁)reentrantLock.lock()，第一次调用获得锁后，后面的调用不会被阻塞住。</p></li><li><p>可打断：一个线程t1,在调用lock.lockInterruptibly()被阻塞住（获取锁失败）时，其他线程执行t1.interrupt()<strong>可以打断t1线程的等待</strong>，此时线程t1停止等待,抛出异常。</p><blockquote><p> 注:如果是不可中断模式，那么即使使用了 interrupt 也不会让等待中断 </p></blockquote></li><li><p>锁超时：</p><ul><li><p>tryLock()方法：尝试获取锁，如果获取失败，则立即返回false，不会阻塞</p></li><li><p><code>public boolean tryLock(long timeout, TimeUnit unit)throws InterruptedException</code></p><p>尝试等待timeout时间获取锁，超时后立即返回</p></li></ul><p>应用：可用tryLock()解决哲学家就餐的死锁问题</p></li><li><p>公平锁：ReentrantLock默认是不公平的.</p><ol><li><p>什么是公平与不公平？</p><p>先启动的线程和后启动的线程在争抢锁时都是随机的，随CPU调度，先来的不能先获得锁/资源，这称之为不公平。反之则为公平，可以通过构造函数中传入参数设置为公平或者不公平</p></li><li><p>公平锁一般没有必要，会降低并发度</p></li></ol></li><li><p>条件变量</p><ol><li><p>synchrnized中也有条件变量，就是那个waitSet休息室，条件不满足时进入waitSet等待</p></li><li><p>ReentrantLock的强大在于支持多个条件变量，也就是有多个休息室,可以有专门等烟的，专门等早餐的</p></li><li><p>使用要点：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> ReentrantLock lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">static</span> Condition waitCigaretteQueue <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">static</span> Condition waitbreakfastQueue <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>waitCigaretteQueue<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>waitCigaretteQueue<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ul><li>await前要获得锁,也就是调用lock.lock()</li><li>await执行后会释放锁，进入Conditionz对象中等待</li><li>await的线程被唤醒（被打断或超时）需重新竞争lock锁</li><li>竞争lock锁成功后，从await后开始执行</li></ul></li></ol></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/java/比较</title>
      <link href="blog/3955358020.html"/>
      <url>blog/3955358020.html</url>
      
        <content type="html"><![CDATA[<ol><li>为什么第一个结果是true，第二个是false?</li></ol><pre class=" language-java"><code class="language-java">Integer a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>Integer b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>Integer c <span class="token operator">=</span> <span class="token number">500</span><span class="token punctuation">;</span>Integer d <span class="token operator">=</span> <span class="token number">500</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>a <span class="token operator">==</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>c <span class="token operator">==</span> d<span class="token punctuation">)</span><span class="token punctuation">;</span>上述代码返回结果为：<span class="token boolean">true</span> <span class="token boolean">false</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> Integer <span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> IntegerCache<span class="token punctuation">.</span>low <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;=</span> IntegerCache<span class="token punctuation">.</span>high<span class="token punctuation">)</span>            <span class="token keyword">return</span> IntegerCache<span class="token punctuation">.</span>cache<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token operator">-</span>IntegerCache<span class="token punctuation">.</span>low<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java">IntegerCache<span class="token punctuation">.</span>low <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">128</span>IntegerCache<span class="token punctuation">.</span>low <span class="token operator">=</span> <span class="token number">127</span></code></pre><p>整数赋给Integer型变量，会调用Interger.valueOf方法，-128到127返回的是IntegerCache中的缓存，其他值会new Integer(i)</p><ol start="2"><li>字符串的equals 和 == </li></ol><p>hashcode() : 返回对象的hashcode(),通常实现为对象的内部地址转化为整数。</p><p>equals()返回true,则hashcode()一定相同。equals{}返回false,hashcode()不一定不同。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/java/集合框架/HashMap原理</title>
      <link href="blog/4023234597.html"/>
      <url>blog/4023234597.html</url>
      
        <content type="html"><![CDATA[<ol><li>put方法过程中，计算出索引位置，如果存在值，则比较hashcode?到存在这一步不是已经说明了hashcode一样吗？</li></ol><h2 id="11-hashMap的putVal详解"><a href="#11-hashMap的putVal详解" class="headerlink" title="11 hashMap的putVal详解"></a>11 hashMap的putVal详解</h2><ol><li><p>如何判断2个是相同的：<br>①hash(由key的hashcode ^ (hashcode &gt;&gt;&gt; 16)得到)是否相等</p><p>②key 是否相等（比较两个对象的地址？） 或者 key的equals是否为true</p></li><li><p>e 和 p是什么？</p></li></ol><h2 id="12-putVal中的treeifyBin-方法"><a href="#12-putVal中的treeifyBin-方法" class="headerlink" title="12 putVal中的treeifyBin()方法"></a>12 putVal中的treeifyBin()方法</h2><ul><li>链表长度大于等于8，数组长度 &lt; MIN_TREEIFY_CAPACITY = 64 ,进行扩容resize()</li><li>链表长度大于8，数组长度  &gt;= 64,转为红黑树<ul><li>先将链表的每一个结点转为TreeNode类型(链表结点Node的子类)，并设置prev,next指针</li><li>table[index] 桶/数组结点从存的链表结点变为TreeNode的树根head</li><li>调用head.treeify(tab) 进行 旋转 变为真正的红黑树</li></ul></li></ul><h2 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h2><h3 id="13-14"><a href="#13-14" class="headerlink" title="13 14"></a>13 14</h3><p>JDK1.8扩容时不再需要重新计算hash,但是元素的位置还是重新计算的，只是重新计算时比以前省去了计算hash值的时间，看hash值的高位是否为1，若为1，则新的索引为 原位置+旧容量</p><ul><li>遍历原数组，如果元素Null,不做什么</li><li>如果元素next为null，直接剪切过去</li><li>如果元素Next为treenode类型，split红黑树</li><li>如果元素Next不为null,是个链表, 遍历链表计算元素新位置，copy过去</li></ul><p>什么时候扩容？</p><ul><li>size &gt; capacity * loadfactor</li><li>链表结点数 &gt;=8 且 capacity &lt; 64</li></ul><h2 id="remove删除"><a href="#remove删除" class="headerlink" title="remove删除"></a>remove删除</h2><h3 id="15"><a href="#15" class="headerlink" title="15"></a>15</h3><h2 id="get方法讲解"><a href="#get方法讲解" class="headerlink" title="get方法讲解"></a>get方法讲解</h2><h3 id="16"><a href="#16" class="headerlink" title="16"></a>16</h3><h2 id="map的4种遍历，一种不建议用"><a href="#map的4种遍历，一种不建议用" class="headerlink" title="map的4种遍历，一种不建议用"></a>map的4种遍历，一种不建议用</h2><p>17</p><h2 id="hashmap初始化容量采用阿里的推荐做法"><a href="#hashmap初始化容量采用阿里的推荐做法" class="headerlink" title="hashmap初始化容量采用阿里的推荐做法"></a>hashmap初始化容量采用阿里的推荐做法</h2><p>18</p><ol><li>HashMap的创建(1.7和1.8的区别)</li></ol><ol start="2"><li><p>HashMap的2个成员变量 负载因子 和初始容量</p></li><li><p>HashMap的put方法</p><ol><li><p>hash(key)   如何实现</p></li><li><p>什么时候发生冲突</p></li><li><p>怎样解决冲突？treeifyBin</p></li><li><p>1.7中新增节点采用头插法，1.8中新增节点采用尾插法。这也是为什么1.8不容易出现环型链表的原因。</p></li></ol></li></ol><ol start="4"><li><p>HashMap的扩容</p></li><li><p>HashMap的rehash</p><p>1.8rehash时保证原链表的顺序，而1.7中rehash时有可能改变链表的顺序（头插法导致）。</p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/java/线程&amp;线程池</title>
      <link href="blog/2790569186.html"/>
      <url>blog/2790569186.html</url>
      
        <content type="html"><![CDATA[<p><img src=".%E7%BA%BF%E7%A8%8B&%E7%BA%BF%E7%A8%8B%E6%B1%A0_images/c7cfc454.png" alt=""><br><img src=".%E7%BA%BF%E7%A8%8B&%E7%BA%BF%E7%A8%8B%E6%B1%A0_images/872cdb3c.png" alt="">  </p><ul><li>JVM采用的第二种，创建几百个线程，观察活动监视器线程数量的变化<br><img src=".%E7%BA%BF%E7%A8%8B&%E7%BA%BF%E7%A8%8B%E6%B1%A0_images/92f499ff.png" alt=""><br><img src=".%E7%BA%BF%E7%A8%8B&%E7%BA%BF%E7%A8%8B%E6%B1%A0_images/e4dbf3a5.png" alt=""></li><li>JVM 提升权限陷入内核态，利用系统提供的api创建线程    </li><li>内核线程和java线程（很多栈帧？栈帧有栈帧指令，就是字节码指令?）是一对一的，内核线程执行的就是java栈帧中的指令？</li></ul><h2 id="线程池的意义"><a href="#线程池的意义" class="headerlink" title="线程池的意义"></a>线程池的意义</h2><p><img src=".%E7%BA%BF%E7%A8%8B&%E7%BA%BF%E7%A8%8B%E6%B1%A0_images/7e253d4b.png" alt="">  </p><ul><li>new ThreadPoolExecutor()构造函数7个参数的意思以及运行流程;</li><li>task是否会顺序执行？<br><img src=".%E7%BA%BF%E7%A8%8B&%E7%BA%BF%E7%A8%8B%E6%B1%A0_images/cf38a7fb.png" alt=""><br><img src=".%E7%BA%BF%E7%A8%8B&%E7%BA%BF%E7%A8%8B%E6%B1%A0_images/840a6912.png" alt=""></li><li>shutdown()和shutdownNow的区别</li><li>worker工作原理与线程池关闭过程</li></ul><p>Lock类？</p><h3 id="线程创建的3种方式"><a href="#线程创建的3种方式" class="headerlink" title="线程创建的3种方式"></a>线程创建的3种方式</h3><ol><li>继承Thread类，重写run方法</li><li>创建一个类，实现Runnable接口，将这个类的对象作为Thread类构造函数的参数<ol><li>建议用这种方式，扩展性更好。Java是单继承，多实现的，第一种方式就不能再继承其他的了</li></ol></li><li>创建带返回值的，run方法无返回值，实现Callable接口，用FutureTask包装，将FutureTask类的对象Thread类构造函数的参数，返回值通过FutureTask的get方法获取</li></ol><h3 id="用户线程和守护线程setDaemon"><a href="#用户线程和守护线程setDaemon" class="headerlink" title="用户线程和守护线程setDaemon()"></a>用户线程和守护线程setDaemon()</h3><pre class=" language-java"><code class="language-java">在Java中有两类线程：User <span class="token function">Thread</span><span class="token punctuation">(</span>用户线程<span class="token punctuation">)</span>、Daemon <span class="token function">Thread</span><span class="token punctuation">(</span>守护线程<span class="token punctuation">)</span> 只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。Daemon的作用是为其他线程的运行提供便利服务，守护线程最典型的应用就是 <span class="token function">GC</span> <span class="token punctuation">(</span>垃圾回收器<span class="token punctuation">)</span>，它就是一个很称职的守护者。Thread类<span class="token function">setDaemon</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>方法可以设置一个线程为守护线程</code></pre><blockquote><p>注：</p><ul><li>thread.setDaemon(true)必须在thread.start()之前调用</li><li>在Daemon线程中产生的新线程也是Daemon的</li><li>当用户线程全部结束时，守护线程即使他还有任务，也会结束。</li></ul></blockquote><h3 id="线程优先级setPriority"><a href="#线程优先级setPriority" class="headerlink" title="线程优先级setPriority()"></a>线程优先级setPriority()</h3><pre class=" language-java"><code class="language-java">    线程的切换是由线程调度控制的，我们无法通过代码来干涉，但是我们可以通过提高线程的优先级来最大程度的改善线程优先获取时间片的几率    Java中线程的优先级被划分为<span class="token number">10</span>级，值分别为<span class="token number">1</span><span class="token operator">-</span><span class="token number">10</span>，<span class="token number">1</span>最低，<span class="token number">10</span>最高。Thread类提供了<span class="token number">3</span>个常量来表示最低最高和默认优先级<span class="token punctuation">.</span>    Thread<span class="token punctuation">.</span>MIN_PRIORITY <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        Thread<span class="token punctuation">.</span>NORM_PRIORITY <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>        Thread<span class="token punctuation">.</span>MAX_PRIORITY <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>        <span class="token keyword">void</span> <span class="token function">setPriority</span><span class="token punctuation">(</span><span class="token keyword">int</span> priority<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//设制线程的优先级</span></code></pre><h3 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h3><p>常用方法</p><p>join()方法</p><p>等待某个线程运行结束,</p><pre><code>比如main线程中 调用t1线程的start(),join()后，则main线程需要等待t1线程运行完之后继续执行，main线程进入 WAITING态</code></pre><p>join(long ms):等待某个线程运行结束，最多等待ms毫秒.TIMED_WAITING</p><p>sleep</p><ol><li><p>调用 sleep 会让当前线程从 Running 进入 Timed Waiting 状态（阻塞）</p></li><li><p>其它线程可以使用 interrupt 方法打断正在睡眠的线程，这时 sleep 方法会抛出 InterruptedException</p></li><li><p>睡眠结束后的线程未必会立刻得到执行</p></li><li><p>建议用 TimeUnit 的 sleep 代替 Thread 的 sleep 来获得更好的可读性</p></li></ol><p>yield</p><ol><li><p>调用 yield 会让当前线程从 Running 进入 Runnable 就绪状态，然后调度执行其它线程</p></li><li><p>具体的实现依赖于操作系统的任务调度器</p></li></ol><p>sychronized会使线程进入blocked状态</p><p>new Thread 会使线程进入NEW状态。</p><p>线程运行完进入terminated状态。</p><h1 id="全面深入学习java并发编程"><a href="#全面深入学习java并发编程" class="headerlink" title="全面深入学习java并发编程"></a>全面深入学习java并发编程</h1><p>synchronized（对象）中的对象，可以想象为一个房间，有唯一入口门。</p><p>synchronized形象理解.</p><p>synchronized加在成员方法上的理解，原来只是锁住了当前对象，sychronized只能锁对象；</p><p>synchronized加在类方法的等同形式是什么？锁类对象。</p><p>不加synchronized的方法好比是翻窗户进去的，没法保持原子性</p><p>局部变量线程安全</p><p>public 方法 + final 不让子类去改变我的行为,</p><p>private 方法 不让子类去重写进而改变我的行为，起到一定线程安全的保护</p><p>常见线程安全的类以及他们的方法组合的线程不安全分析</p><p>设计方法内的变量时，是否线程安全 要看它是否会被暴露给其他线程</p><p>String类为什么做成final的，防止继承破坏它不可变的设计，体现了闭合原则</p><p>要分析线程安全问题，要找出临界区，临界区：多个线程对共享变量有读写操作</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/java/JDK各版本新特性</title>
      <link href="blog/2778598722.html"/>
      <url>blog/2778598722.html</url>
      
        <content type="html"><![CDATA[<h1 id="jdk5-jdk9各个版本的新特性"><a href="#jdk5-jdk9各个版本的新特性" class="headerlink" title="jdk5-jdk9各个版本的新特性"></a>jdk5-jdk9各个版本的新特性</h1><h2 id="JDK1-5新特性："><a href="#JDK1-5新特性：" class="headerlink" title="JDK1.5新特性："></a>JDK1.5新特性：</h2><p>1.自动装箱与拆箱：</p><p>2.枚举</p><p>3.静态导入，如：import staticjava.lang.System.out</p><p>4.可变参数（Varargs）</p><p>5.内省（Introspector），主要用于操作JavaBean中的属性，通过getXxx/setXxx。一般的做法是通过类Introspector来获取某个对象的BeanInfo信息，然后通过BeanInfo来获取属性的描述器（PropertyDescriptor），通过这个属性描述器就可以获取某个属性对应的getter/setter方法，然后我们就可以通过反射机制来调用这些方法。</p><p>6.泛型(Generic)（包括通配类型/边界类型等）</p><p>7.For-Each循环</p><p>8.注解</p><p>9.协变返回类型：实际返回类型可以是要求的返回类型的一个子类型</p><h2 id="JDK1-6新特性："><a href="#JDK1-6新特性：" class="headerlink" title="JDK1.6新特性："></a>JDK1.6新特性：</h2><p>\1. AWT新增加了两个类:Desktop和SystemTray，其中前者用来通过系统默认程序来执行一个操作，如使用默认浏览器浏览指定的URL,用默认邮件客户端给指定的邮箱发邮件,用默认应用程序打开或编辑文件(比如,用记事本打开以txt为后缀名的文件),用系统默认的打印机打印文档等。后者可以用来在系统托盘区创建一个托盘程序</p><p>2.使用JAXB2来实现对象与XML之间的映射，可以将一个Java对象转变成为XML格式，反之亦然</p><p>\3. StAX，一种利用拉模式解析(pull-parsing)XML文档的API。类似于SAX，也基于事件驱动模型。之所以将StAX加入到JAXP家族，是因为JDK6中的JAXB2和JAX-WS 2.0中都会用StAX。</p><p>4.使用Compiler API，动态编译Java源文件，如JSP编译引擎就是动态的，所以修改后无需重启服务器。</p><p>5.轻量级Http Server API，据此可以构建自己的嵌入式HttpServer,它支持Http和Https协议。</p><p>6.插入式注解处理API(PluggableAnnotation Processing API)</p><p>7.提供了Console类用以开发控制台程序，位于java.io包中。据此可方便与Windows下的cmd或Linux下的Terminal等交互。</p><p>8.对脚本语言的支持如: ruby,groovy, javascript</p><p>9.Common Annotations，原是J2EE 5.0规范的一部分，现在把它的一部分放到了J2SE 6.0中</p><p>10.嵌入式数据库 Derby</p><h2 id="JDK1-7-新特性"><a href="#JDK1-7-新特性" class="headerlink" title="JDK1.7 新特性"></a>JDK1.7 新特性</h2><p>1.对Java集合（Collections）的增强支持，可直接采用[]、{}的形式存入对象，采用[]的形式按照索引、键值来获取集合中的对象。如：</p><p>List<String>list=[“item1”,”item2”];//存</p><p>Stringitem=list[0];//直接取</p><p>​     Set<String>set={“item1”,”item2”,”item3”};//存</p><p>​     Map&lt;String,Integer&gt; map={“key1”:1,”key2”:2};//存</p><p>​     Intvalue=map[“key1”];//取</p><p>2.在Switch中可用String</p><p>3.数值可加下划线用作分隔符（编译时自动被忽略）</p><p>4.支持二进制数字，如：int binary= 0b1001_1001;</p><p>5.简化了可变参数方法的调用</p><p>6.调用泛型类的构造方法时，可以省去泛型参数，编译器会自动判断。</p><p>7.Boolean类型反转，空指针安全,参与位运算</p><p>8.char类型的equals方法: booleanCharacter.equalsIgnoreCase(char ch1, char ch2)</p><p>9.安全的加减乘除: Math.safeToInt(longv); Math.safeNegate(int v); Math.safeSubtract(long v1, int v2);Math.safeMultiply(int v1, int v2)……</p><p>10 .Map集合支持并发请求，注HashTable是线程安全的，Map是非线程安全的。但此处更新使得其也支持并发。另外，Map对象可这样定义：Map map = {name:”xxx”,age:18};</p><h2 id="JDK1-8新特性"><a href="#JDK1-8新特性" class="headerlink" title="JDK1.8新特性"></a>JDK1.8新特性</h2><p>1.接口的默认方法：即接口中可以声明一个非抽象的方法做为默认的实现，但只能声明一个，且在方法的返回类型前要加上“default”关键字。</p><p>\2. Lambda 表达式：是对匿名比较器的简化，如：</p><p>​     Collections.sort(names,(String a, String b) -&gt; {</p><p>​    returnb.compareTo(a);</p><p>});</p><p>对于函数体只有一行代码的，你可以去掉大括号{}以及return关键字。如：</p><p>​     Collections.sort(names,(String a, String b) -&gt; b.compareTo(a));</p><p>或：Collections.sort(names, (a, b) -&gt; b.compareTo(a));</p><p>\3. 函数式接口：是指仅仅只包含一个抽象方法的接口，要加@FunctionalInterface注解</p><p>\4. 使用 :: 关键字来传递方法或者构造函数引用</p><p>5.多重注解</p><p>6.还增加了很多与函数式接口类似的接口以及与Map相关的API等……</p><h2 id="jdk1-9新特性"><a href="#jdk1-9新特性" class="headerlink" title="jdk1.9新特性"></a>jdk1.9新特性</h2><h3 id="1、Java-平台级模块系统"><a href="#1、Java-平台级模块系统" class="headerlink" title="1、Java 平台级模块系统"></a>1、Java 平台级模块系统</h3><p>当启动一个模块化应用时， JVM 会验证是否所有的模块都能使用，这基于 <code>requires</code> 语句——比脆弱的类路径迈进了一大步。模块允许你更好地强制结构化封装你的应用并明确依赖。</p><h3 id="2-Linking"><a href="#2-Linking" class="headerlink" title="2. Linking"></a>2. Linking</h3><p>当你使用具有显式依赖关系的模块和模块化的 JDK 时，新的可能性出现了。你的应用程序模块现在将声明其对其他应用程序模块的依赖以及对其所使用的 JDK 模块的依赖。为什么不使用这些信息创建一个最小的运行时环境，其中只包含运行应用程序所需的那些模块呢？ 这可以通过 Java 9 中的新的 jlink 工具实现。你可以创建针对应用程序进行优化的最小运行时映像而不需要使用完全加载 JDK 安装版本。</p><h3 id="3-JShell-交互式-Java-REPL"><a href="#3-JShell-交互式-Java-REPL" class="headerlink" title="3. JShell : 交互式 Java REPL"></a>3. JShell : 交互式 Java REPL</h3><p>许多语言已经具有交互式编程环境，Java 现在加入了这个俱乐部。您可以从控制台启动 jshell ，并直接启动输入和执行 Java 代码。 jshell 的即时反馈使它成为探索 API 和尝试语言特性的好工具。</p><h3 id="4-改进的-Javadoc"><a href="#4-改进的-Javadoc" class="headerlink" title="4. 改进的 Javadoc"></a>4. 改进的 Javadoc</h3><p>Javadoc 现在支持在 API 文档中的进行搜索。另外，Javadoc 的输出现在符合兼容 HTML5 标准。此外，你会注意到，每个 Javadoc 页面都包含有关 JDK 模块类或接口来源的信息。</p><p><a href="http://www.importnew.com/?attachment_id=24532" target="_blank" rel="noopener"><img src="http://incdn1.b0.upaiyun.com/2017/05/3dbe50499ff59393262f30dfe88d9a97.png" alt="110905_3Rha_2896879"></a></p><h3 id="5-集合工厂方法"><a href="#5-集合工厂方法" class="headerlink" title="5. 集合工厂方法"></a>5. 集合工厂方法</h3><p>通常，您希望在代码中创建一个集合（例如，List 或 Set ），并直接用一些元素填充它。 实例化集合，几个 “add” 调用，使得代码重复。 Java 9，添加了几种集合工厂方法：</p><pre><code>Set ints = Set.of(``1``,``2``,``3``);` `List strings = List.of(``&quot;first&quot;``,``&quot;second&quot;``);</code></pre><p>除了更短和更好阅读之外，这些方法也可以避免您选择特定的集合实现。 事实上，从工厂方法返回已放入数个元素的集合实现是高度优化的。这是可能的，因为它们是不可变的：在创建后，继续添加元素到这些集合会导致 “UnsupportedOperationException” 。</p><h3 id="6-改进的-Stream-API"><a href="#6-改进的-Stream-API" class="headerlink" title="6. 改进的 Stream API"></a>6. 改进的 Stream API</h3><p>长期以来，Stream API 都是 Java 标准库最好的改进之一。通过这套 API 可以在集合上建立用于转换的申明管道。在 Java 9 中它会变得更好。Stream 接口中添加了 4 个新的方法：dropWhile, takeWhile, ofNullable。还有个 iterate 方法的新重载方法，可以让你提供一个 Predicate (判断条件)来指定什么时候结束迭代：</p><pre><code>IntStream.iterate(``1``, i -&gt; i &lt; ``100``, i -&gt; i + ``1``).forEach(System.out::println);</code></pre><p>第二个参数是一个 Lambda，它会在当前 IntStream 中的元素到达 100 的时候返回 true。因此这个简单的示例是向控制台打印 1 到 99。</p><p>除了对 Stream 本身的扩展，Optional 和 Stream 之间的结合也得到了改进。现在可以通过 Optional 的新方法 <code>stram</code> 将一个 Optional 对象转换为一个(可能是空的) Stream 对象：</p><pre><code>Stream s = Optional.of(``1``).stream();</code></pre><p>在组合复杂的 Stream 管道时，将 Optional 转换为 Stream 非常有用。</p><h3 id="7-私有接口方法"><a href="#7-私有接口方法" class="headerlink" title="7. 私有接口方法"></a>7. 私有接口方法</h3><p>使用 Java 9，您可以向接口添加私有辅助方法来解决此问题：</p><pre><code>public``interface` `MyInterface {`  `  ``void``normalInterfaceMethod();`  `  ``default``void` `interfaceMethodWithDefault() { init(); }`  `  ``default``void` `anotherDefaultMethod() { init(); }`  `  ``// This method is not part of the public API exposed by MyInterface` `  ``private``void` `init() { System.out.println(``&quot;Initializing&quot;``); }` `}</code></pre><p>如果您使用默认方法开发 API ，那么私有接口方法可能有助于构建其实现。</p><h3 id="8-HTTP-2"><a href="#8-HTTP-2" class="headerlink" title="8. HTTP/2"></a>8. HTTP/2</h3><p>Java 9 中有新的方式来处理 HTTP 调用。这个迟到的特性用于代替老旧的 <code>HttpURLConnection</code> API，并提供对 WebSocket 和 HTTP/2 的支持。注意：新的 HttpClient API 在 Java 9 中以所谓的孵化器模块交付。也就是说，这套 API 不能保证 100% 完成。不过你可以在 Java 9 中开始使用这套 API：</p><pre><code>HttpClient client = HttpClient.newHttpClient();`  `HttpRequest req =` `  ``HttpRequest.newBuilder(URI.create(``&quot;http://www.google.com&quot;``))` `       ``.header(``&quot;User-Agent&quot;``,``&quot;Java&quot;``)` `       ``.GET()` `       ``.build();`   `HttpResponse resp = client.send(req, HttpResponse.BodyHandler.asString());</code></pre><p>HttpResponse<String> resp = client.send(req, HttpResponse.BodyHandler.asString());<br>除了这个简单的请求/响应模型之外，HttpClient 还提供了新的 API 来处理 HTTP/2 的特性，比如流和服务端推送。</p><h3 id="9-多版本兼容-JAR"><a href="#9-多版本兼容-JAR" class="headerlink" title="9. 多版本兼容 JAR"></a>9. 多版本兼容 JAR</h3><p>我们最后要来着重介绍的这个特性对于库的维护者而言是个特别好的消息。当一个新版本的 Java 出现的时候，你的库用户要花费数年时间才会切换到这个新的版本。这就意味着库得去向后兼容你想要支持的最老的 Java 版本 (许多情况下就是 Java 6 或者 7)。这实际上意味着未来的很长一段时间，你都不能在库中运用 Java 9 所提供的新特性。幸运的是，多版本兼容 JAR 功能能让你创建仅在特定版本的 Java 环境中运行库程序时选择使用的 class 版本：</p><pre><code>multirelease.jar` `├── META-INF` `│  └── versions` `│    └── ``9` `│      └── multirelease` `│        └── Helper.``class` `├── multirelease` `  ``├── Helper.``class` `  ``└── Main.``class</code></pre><p>在上述场景中， multirelease.jar 可以在 Java 9 中使用, 不过 Helper 这个类使用的不是顶层的 multirelease.Helper 这个 class, 而是处在“META-INF/versions/9”下面的这个。这是特别为 Java 9 准备的 class 版本，可以运用 Java 9 所提供的特性和库。同时，在早期的 Java 诸版本中使用这个 JAR 也是能运行的，因为较老版本的 Java 只会看到顶层的这个 Helper 类。</p><p><a href="https://blog.csdn.net/pursue_vip/article/details/78692584" target="_blank" rel="noopener">https://blog.csdn.net/pursue_vip/article/details/78692584</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/Java虚拟机/编译期处理-语法糖</title>
      <link href="blog/3262433004.html"/>
      <url>blog/3262433004.html</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="编译期处理"><a href="#编译期处理" class="headerlink" title="编译期处理"></a>编译期处理</h1><p>所谓的 语法糖 ，其实就是指 <code>java</code> 编译器把 <code>*.java</code> 源码编译为 <code>*.class</code> 字节码的过程中，自动生成 和转换的一些代码，主要是为了减轻程序员的负担，算是 java 编译器给我们的一个额外福利（给糖吃嘛）</p><p>注意，以下代码的分析，借助了 <code>javap</code> 工具，<code>idea</code> 的反编译功能，idea 插件 <code>jclasslib</code> 等工具。另外， 编译器转换的结果直接就是 class 字节码，只是为了便于阅读，给出了 几乎等价 的 java 源码方式，<strong>并不是编译器还会转换出中间的 java 源码，切记</strong>。</p><h2 id="3-1-默认构造器"><a href="#3-1-默认构造器" class="headerlink" title="3.1 默认构造器"></a>3.1 默认构造器</h2><pre><code>public class Candy1 { }</code></pre><p>编译成class后的代码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Candy1</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">// 这个无参构造是编译器帮助我们加上的 </span>        <span class="token keyword">public</span> <span class="token function">Candy1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                 <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 即调用父类 Object 的无参构造方法，即调用 java/lang/Object." &lt;init>":()V </span>        <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre><h2 id="3-2-自动拆装箱"><a href="#3-2-自动拆装箱" class="headerlink" title="3.2 自动拆装箱"></a>3.2 自动拆装箱</h2><p>这个特性是 JDK 5 开始加入的， 代码片段1 ：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Candy2</span> <span class="token punctuation">{</span>     <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>         Integer x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>         <span class="token keyword">int</span> y <span class="token operator">=</span> x<span class="token punctuation">;</span>     <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre><p>这段代码在 JDK 5 之前是无法编译通过的，必须改写为 代码片段 2 :</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Candy2</span> <span class="token punctuation">{</span>     <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>         Integer x <span class="token operator">=</span> Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">int</span> y <span class="token operator">=</span> x<span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre><pre><code> 显然之前版本的代码太麻烦了，需要在基本类型和包装类型之间来回转换（尤其是集合类中操作的都是 包装类型），因此这些转换的事情在 JDK 5 以后都由编译器在编译阶段完成。即 `代码片段1` 都会在编 译阶段被转换为 `代码片段2`  </code></pre><h2 id="3-3-泛型集合取值"><a href="#3-3-泛型集合取值" class="headerlink" title="3.3 泛型集合取值"></a>3.3 泛型集合取值</h2><p>泛型也是在 JDK 5 开始加入的特性，但 java 在编译泛型代码后会执行 泛型擦除 的动作，即泛型信息 在编译为字节码之后就丢失了，实际的类型都当做了 Object 类型来处理：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Candy3</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>       List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 实际调用的是 List.add(Object e) </span>       Integer x <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 实际调用的是 Object obj = List.get(int index); </span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>所以在取值时，编译器真正生成的字节码中，还要额外做一个类型转换的操作：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 需要将 Object 转为 Integer </span>Integer x <span class="token operator">=</span> <span class="token punctuation">(</span>Integer<span class="token punctuation">)</span>list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>如果前面的</p><p>x 变量类型修改为 int 基本类型那么最终生成的字节码是：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 需要将 Object 转为 Integer, 并执行拆箱操作 </span><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>Integer<span class="token punctuation">)</span>list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>还好这些麻烦事都不用自己做。</p><p>擦除的是字节码上的泛型信息，可以看到 LocalVariableTypeTable 仍然保留了方法参数泛型的信息</p><pre class=" language-java"><code class="language-java"> <span class="token keyword">public</span> cn<span class="token punctuation">.</span>itcast<span class="token punctuation">.</span>jvm<span class="token punctuation">.</span>t3<span class="token punctuation">.</span>candy<span class="token punctuation">.</span><span class="token function">Candy3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    descriptor<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>V    flags<span class="token operator">:</span> ACC_PUBLIC    Code<span class="token operator">:</span>      stack<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> locals<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> args_size<span class="token operator">=</span><span class="token number">1</span>         <span class="token number">0</span><span class="token operator">:</span> aload_0         <span class="token number">1</span><span class="token operator">:</span> invokespecial #<span class="token number">1</span>                  <span class="token comment" spellcheck="true">// Method java/lang/Object."&lt;init>":()V</span>         <span class="token number">4</span><span class="token operator">:</span> <span class="token keyword">return</span>      LineNumberTable<span class="token operator">:</span>        line <span class="token number">11</span><span class="token operator">:</span> <span class="token number">0</span>      LocalVariableTable<span class="token operator">:</span>        Start  Length  Slot  Name   Signature            <span class="token number">0</span>       <span class="token number">5</span>     <span class="token number">0</span>  <span class="token keyword">this</span>   Lcn<span class="token operator">/</span>itcast<span class="token operator">/</span>jvm<span class="token operator">/</span>t3<span class="token operator">/</span>candy<span class="token operator">/</span>Candy3<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     descriptor<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">[</span>Ljava<span class="token operator">/</span>lang<span class="token operator">/</span>String<span class="token punctuation">;</span><span class="token punctuation">)</span>V   flags<span class="token operator">:</span> ACC_PUBLIC<span class="token punctuation">,</span> ACC_STATIC   Code<span class="token operator">:</span>        stack<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> locals<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> args_size<span class="token operator">=</span><span class="token number">1</span>        <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span>对象<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>                <span class="token number">0</span><span class="token operator">:</span> <span class="token keyword">new</span> #<span class="token number">2</span>   <span class="token comment" spellcheck="true">// class java/util/ArrayList </span>       <span class="token number">3</span><span class="token operator">:</span> dup        <span class="token number">4</span><span class="token operator">:</span> invokespecial #<span class="token number">3</span> <span class="token comment" spellcheck="true">// Method java/util/ArrayList."&lt;init>":()V </span>       <span class="token number">7</span><span class="token operator">:</span> astore_1        <span class="token number">8</span><span class="token operator">:</span> aload_1        <span class="token number">9</span><span class="token operator">:</span> bipush <span class="token number">10</span>        <span class="token number">11</span><span class="token operator">:</span> invokestatic #<span class="token number">4</span> <span class="token comment" spellcheck="true">// Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer; </span>       <span class="token comment" spellcheck="true">//add方法的参数类型实际是Object类型</span>       <span class="token number">14</span><span class="token operator">:</span> invokeinterface #<span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token comment" spellcheck="true">// InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z </span>       <span class="token number">19</span><span class="token operator">:</span> pop        <span class="token number">20</span><span class="token operator">:</span> aload_1        <span class="token number">21</span><span class="token operator">:</span> iconst_0        <span class="token comment" spellcheck="true">//get方法的参数类型实际是Object类型</span>       <span class="token number">22</span><span class="token operator">:</span> invokeinterface #<span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token comment" spellcheck="true">// InterfaceMethod java/util/List.get:(I)Ljava/lang/Object; </span>       <span class="token comment" spellcheck="true">//    强制类型转换         </span>       <span class="token number">27</span><span class="token operator">:</span> checkcast #<span class="token number">7</span> <span class="token comment" spellcheck="true">// class java/lang/Integer </span>       <span class="token number">30</span><span class="token operator">:</span> astore_2        <span class="token number">31</span><span class="token operator">:</span> <span class="token keyword">return</span>        LineNumberTable<span class="token operator">:</span>                    line <span class="token number">8</span><span class="token operator">:</span> <span class="token number">0</span>           line <span class="token number">9</span><span class="token operator">:</span> <span class="token number">8</span>           line <span class="token number">10</span><span class="token operator">:</span> <span class="token number">20</span>           line <span class="token number">11</span><span class="token operator">:</span> <span class="token number">31</span>        LocalVariableTable<span class="token operator">:</span>                  Start Length Slot Name    Signature              <span class="token number">0</span>   <span class="token number">32</span>    <span class="token number">0</span>   args      <span class="token punctuation">[</span>Ljava<span class="token operator">/</span>lang<span class="token operator">/</span>String<span class="token punctuation">;</span>               <span class="token number">8</span>   <span class="token number">24</span>    <span class="token number">1</span>   list      Ljava<span class="token operator">/</span>util<span class="token operator">/</span>List<span class="token punctuation">;</span>       LocalVariableTypeTable<span class="token operator">:</span>                    Start Length  Slot   Signature                        <span class="token number">8</span>   <span class="token number">24</span>     <span class="token number">1</span>      Ljava<span class="token operator">/</span>util<span class="token operator">/</span>List<span class="token operator">&lt;</span>Ljava<span class="token operator">/</span>lang<span class="token operator">/</span>Integer<span class="token punctuation">;</span><span class="token operator">></span><span class="token punctuation">;</span></code></pre><ul><li><p>list.add 和 get 方法在bycecode层面上的参数类型都是Object类型，最后会执行checkcast指令进行类型转换为真实类型</p></li><li><p>方法体内部的泛型在虚拟机执行时会进行泛型擦除</p></li><li><p>使用反射，能够获得方法参数和返回值中的泛型信息：</p></li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> Set<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">test</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>String<span class="token operator">></span> list<span class="token punctuation">,</span> Map<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> Object<span class="token operator">></span> map<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>Method test <span class="token operator">=</span> Candy3<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">,</span> List<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> Map<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Type<span class="token punctuation">[</span><span class="token punctuation">]</span> types <span class="token operator">=</span> test<span class="token punctuation">.</span><span class="token function">getGenericParameterTypes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Type type <span class="token operator">:</span> types<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token keyword">instanceof</span> <span class="token class-name">ParameterizedType</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                ParameterizedType parameterizedType <span class="token operator">=</span> <span class="token punctuation">(</span>ParameterizedType<span class="token punctuation">)</span> type<span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"原始类型 - "</span> <span class="token operator">+</span> parameterizedType<span class="token punctuation">.</span><span class="token function">getRawType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                Type<span class="token punctuation">[</span><span class="token punctuation">]</span> arguments <span class="token operator">=</span> parameterizedType<span class="token punctuation">.</span><span class="token function">getActualTypeArguments</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arguments<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"泛型参数[%d] - %s\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> arguments<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>                <span class="token punctuation">}</span></code></pre><p>输出 </p><pre><code>原始类型 - interface java.util.List 泛型参数[0] - class java.lang.String 原始类型 - interface java.util.Map 泛型参数[0] - class java.lang.Integer 泛型参数[1] - class java.lang.Object</code></pre><h2 id="3-4-可变参数"><a href="#3-4-可变参数" class="headerlink" title="3.4 可变参数"></a>3.4 可变参数</h2><p>可变参数也是 JDK 5 开始加入的新特性： 例如：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Candy4</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        String<span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> args<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 直接赋值 </span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">foo</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">,</span> <span class="token string">"world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>可变参数 <code>String... args</code> 其实是一个 <code>String[] args</code> ，从代码中的赋值语句中就可以看出来。 同 样 <code>java</code> 编译器会在编译期间将上述代码变换为：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Candy4</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        String<span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> args<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 直接赋值 </span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token string">"hello"</span><span class="token punctuation">,</span> <span class="token string">"world"</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>注意 如果调用了 <code>foo()</code> 则等价代码为 <code>foo(new String[]{})</code> ，创建了一个空的数组，而不会 传递 <code>null</code> 进去</p><h2 id="3-5-foreach-循环"><a href="#3-5-foreach-循环" class="headerlink" title="3.5 foreach 循环"></a>3.5 foreach 循环</h2><p>仍是 JDK 5 开始引入的语法糖，数组的循环：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Candy5_1</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 数组赋初值的简化写法也是语法糖哦 </span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> e <span class="token operator">:</span> array<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span> </code></pre><p>会被编译器转换为：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Candy5_1</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">Candy5_1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> e <span class="token operator">=</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>而集合的循环：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Candy5_2</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Integer i <span class="token operator">:</span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>实际被编译器转换为对迭代器的调用：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Candy5_2</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">Candy5_2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Iterator iter <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>iter<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            Integer e <span class="token operator">=</span> <span class="token punctuation">(</span>Integer<span class="token punctuation">)</span> iter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>注意 <code>foreach</code> 循环写法，能够配合数组，以及所有实现了 <code>Iterable</code> 接口的集合类一起使用，其 中 <code>Iterable</code> 用来获取集合的迭代器（ <code>Iterator</code> ）</p><h2 id="3-6-switch-字符串"><a href="#3-6-switch-字符串" class="headerlink" title="3.6 switch 字符串"></a>3.6 switch 字符串</h2><p>从 JDK 7 开始，switch 可以作用于字符串和枚举类，这个功能其实也是语法糖，例如：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Candy6_1</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">choose</span><span class="token punctuation">(</span>String str<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">switch</span> <span class="token punctuation">(</span>str<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">case</span> <span class="token string">"hello"</span><span class="token operator">:</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"h"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">case</span> <span class="token string">"world"</span><span class="token operator">:</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"w"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>注意</p><p><code>switch</code> 配合 <code>String</code> 和枚举使用时，变量不能为<code>null</code>，原因分析完语法糖转换后的代码应当自 然清楚</p><p>会被编译器转换为：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Candy6_1</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">Candy6_1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">choose</span><span class="token punctuation">(</span>String str<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">byte</span> x <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">switch</span> <span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">case</span> <span class="token number">99162322</span><span class="token operator">:</span> <span class="token comment" spellcheck="true">// hello 的 hashCode </span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> <span class="token number">113318802</span><span class="token operator">:</span> <span class="token comment" spellcheck="true">// world 的 hashCode </span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"world"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">switch</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">case</span> <span class="token number">0</span><span class="token operator">:</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"h"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span>                              System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"w"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>可以看到，执行了两遍 <code>switch</code>，第一遍是根据字符串的 <code>hashCode</code> 和 <code>equals</code> 将字符串的转换为相应 <code>byte</code> 类型，第二遍才是利用 <code>byte</code> 执行进行比较。</p><p>为什么第一遍时必须既比较 <code>hashCode</code>，又利用 <code>equals</code> 比较呢？<code>hashCode</code> 是为了提高效率，减少可 能的比较；而 <code>equals</code> 是为了防止 <code>hashCode</code> 冲突，例如 <code>BM</code> 和 <code>C</code>. 这两个字符串的<code>hashCode</code>值都是 2123 ，如果有如下代码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Candy6_2</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">choose</span><span class="token punctuation">(</span>String str<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">switch</span> <span class="token punctuation">(</span>str<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">case</span> <span class="token string">"BM"</span><span class="token operator">:</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"h"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">case</span> <span class="token string">"C."</span><span class="token operator">:</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"w"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>会被编译器转换为：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Candy6_2</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">Candy6_2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">choose</span><span class="token punctuation">(</span>String str<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">byte</span> x <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">switch</span> <span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">case</span> <span class="token number">2123</span><span class="token operator">:</span> <span class="token comment" spellcheck="true">// hashCode 值可能相同，需要进一步用 equals 比较 </span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"C."</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"BM"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token keyword">default</span><span class="token operator">:</span>                <span class="token keyword">switch</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">case</span> <span class="token number">0</span><span class="token operator">:</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"h"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">break</span><span class="token punctuation">;</span>                    <span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"w"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="3-7-switch-枚举"><a href="#3-7-switch-枚举" class="headerlink" title="3.7 switch 枚举"></a>3.7 switch 枚举</h2><p>switch 枚举的例子，原始代码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">enum</span> Sex <span class="token punctuation">{</span>   MALE<span class="token punctuation">,</span> FEMALE <span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Candy7</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span>Sex sex<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">switch</span> <span class="token punctuation">(</span>sex<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">case</span> MALE<span class="token operator">:</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"男"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> FEMALE<span class="token operator">:</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"女"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>转换后代码： </p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Candy7</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 定义一个合成类,$MAP这个名字自己取的，jvm中不是这样（仅 jvm 使用，对我们不可见）      * 用来映射枚举的 ordinal 与数组元素的关系      * 枚举的 ordinal 表示枚举对象的序号，从 0 开始      * 即 MALE 的 ordinal()=0，FEMALE 的 ordinal()=1     */</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> $MAP <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 数组大小即为枚举元素个数，里面存储case用来对比的数字</span>        <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">static</span> <span class="token punctuation">{</span>            map<span class="token punctuation">[</span>Sex<span class="token punctuation">.</span>MALE<span class="token punctuation">.</span><span class="token function">ordinal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            map<span class="token punctuation">[</span>Sex<span class="token punctuation">.</span>FEMALE<span class="token punctuation">.</span><span class="token function">ordinal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span>Sex sex<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> x <span class="token operator">=</span> $MAP<span class="token punctuation">.</span>map<span class="token punctuation">[</span>sex<span class="token punctuation">.</span><span class="token function">ordinal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">switch</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"男"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> <span class="token number">2</span><span class="token operator">:</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"女"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="3-8-枚举类"><a href="#3-8-枚举类" class="headerlink" title="3.8 枚举类"></a>3.8 枚举类</h2><p>JDK 5 新增了枚举类，以前面的性别枚举为例：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">enum</span> Sex <span class="token punctuation">{</span>   MALE<span class="token punctuation">,</span> FEMALE <span class="token punctuation">}</span></code></pre><p>转换后代码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Sex</span> <span class="token keyword">extends</span> <span class="token class-name">Enum</span><span class="token operator">&lt;</span>Sex<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Sex MALE<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Sex FEMALE<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Sex<span class="token punctuation">[</span><span class="token punctuation">]</span> $VALUES<span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        MALE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Sex</span><span class="token punctuation">(</span><span class="token string">"MALE"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        FEMALE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Sex</span><span class="token punctuation">(</span><span class="token string">"FEMALE"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        $VALUES <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Sex</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>MALE<span class="token punctuation">,</span> FEMALE<span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * Sole constructor. Programmers cannot invoke this constructor.     * It is for use by code emitted by the compiler in response to     * enum type declarations.     *      * @param name - The name of this enum constant, which is the identifier  used to declare it.     *     * @param ordinal - The ordinal of this enumeration constant (its position in the enum declaration, where the initial constant is assigned     */</span>    <span class="token keyword">private</span> <span class="token function">Sex</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> <span class="token keyword">int</span> ordinal<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> ordinal<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Sex<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> $VALUES<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Sex <span class="token function">valueOf</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> Enum<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>Sex<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="3-9-匿名内部类"><a href="#3-9-匿名内部类" class="headerlink" title="3.9 匿名内部类"></a>3.9 匿名内部类</h2><p>源代码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Candy11</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Runnable runnable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ok"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>转换后代码：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 额外生成的类 </span><span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Candy11</span>$<span class="token number">1</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>    Candy11$<span class="token function">1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ok"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Candy11</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Runnable runnable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Candy11</span>$<span class="token function">1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>引用局部变量的匿名内部类，源代码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Candy11</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Runnable runnable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ok:"</span> <span class="token operator">+</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>转换后代码：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 额外生成的类</span><span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Candy11</span>$<span class="token number">1</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> val$x<span class="token punctuation">;</span>    Candy11$<span class="token function">1</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>val$x <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ok:"</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>val$x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Candy11</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Runnable runnable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Candy11</span>$<span class="token function">1</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>注意 这同时解释了为什么匿名内部类引用局部变量时，局部变量必须是 <code>ﬁnal</code> 的：因为在创建 <code>Candy11$1</code> 对象时，将 <code>x</code> 的值赋值给了 <code>Candy11$1</code> 对象的 <code>val$x</code> 属 性 ，所以<code>x</code> 不应该再发生变化了,如果 变化 ， 那 么 val$x 属性没有机会再跟着一起变化 .</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/Java虚拟机/synchronized</title>
      <link href="blog/792110065.html"/>
      <url>blog/792110065.html</url>
      
        <content type="html"><![CDATA[<h1 id="sychronized代码块如何保证加锁解锁的成对出现"><a href="#sychronized代码块如何保证加锁解锁的成对出现" class="headerlink" title="sychronized代码块如何保证加锁解锁的成对出现?"></a>sychronized代码块如何保证加锁解锁的成对出现?</h1><p>对如下这样一个简单的代码用javap查看的bytecode信息</p><pre><code>public class Demo {        public static void main(String[] args) {        Object lock = new Object();        synchronized (lock) {            System.out.println(&quot;ok&quot;);        }    }}</code></pre><p><code>javac -g Demo.java</code></p><p><code>javap -v Demo</code>    </p><pre class=" language-java"><code class="language-java"> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    descriptor<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">[</span>Ljava<span class="token operator">/</span>lang<span class="token operator">/</span>String<span class="token punctuation">;</span><span class="token punctuation">)</span>V    flags<span class="token operator">:</span> ACC_PUBLIC<span class="token punctuation">,</span> ACC_STATIC    Code<span class="token operator">:</span>      stack<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> locals<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">,</span> args_size<span class="token operator">=</span><span class="token number">1</span>         <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span> <span class="token number">0</span> <span class="token operator">~</span> <span class="token number">7</span> 为 Object lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span>对 应的bytecode <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>           <span class="token comment" spellcheck="true">//new在堆中产生新的对象的同时，将对象的一个引用放入操作数栈</span>         <span class="token number">0</span><span class="token operator">:</span> <span class="token keyword">new</span>           #<span class="token number">2</span>                  <span class="token comment" spellcheck="true">// new Object</span>         <span class="token comment" spellcheck="true">//dup复制一份对象的引用，是为了用2次</span>         <span class="token number">3</span><span class="token operator">:</span> dup         <span class="token comment" spellcheck="true">//执行invokespecial指令，消耗栈顶的一个对象的引用，调用构造方法</span>         <span class="token number">4</span><span class="token operator">:</span> invokespecial #<span class="token number">1</span>                           <span class="token number">7</span><span class="token operator">:</span> astore_1   <span class="token comment" spellcheck="true">//第二个lock引用赋给局部变量表中1号slot的name为lock的局部变量</span>         <span class="token number">8</span><span class="token operator">:</span> aload_1    <span class="token comment" spellcheck="true">//将对象引用加载到操作数栈</span>         <span class="token number">9</span><span class="token operator">:</span> dup                 <span class="token comment" spellcheck="true">//再复制一份，分别给monitorenter,monitorexit使用，分别为加锁和解锁</span>        <span class="token number">10</span><span class="token operator">:</span> astore_2   <span class="token comment" spellcheck="true">//将刚才新产生的对象引用 存储到2号slot（没有名字的slot）</span>        <span class="token number">11</span><span class="token operator">:</span> monitorenter   <span class="token comment" spellcheck="true">//还剩的一个对象引用被monitorenter消耗掉,这就是加锁操作</span>        <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span> <span class="token number">12</span> <span class="token operator">~</span> <span class="token number">21</span> 为sychronized代码块内部<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>                  <span class="token number">12</span><span class="token operator">:</span> getstatic     #<span class="token number">3</span>                  <span class="token comment" spellcheck="true">// &lt; - System.out </span>        <span class="token number">15</span><span class="token operator">:</span> ldc           #<span class="token number">4</span>                  <span class="token comment" spellcheck="true">// &lt; = "ok"</span>        <span class="token number">17</span><span class="token operator">:</span> invokevirtual #<span class="token number">5</span>                  <span class="token comment" spellcheck="true">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span>        <span class="token number">20</span><span class="token operator">:</span> aload_2    <span class="token comment" spellcheck="true">//将刚才存到slot_2的对象引用加载到操作数栈给解锁指令用</span>        <span class="token number">21</span><span class="token operator">:</span> monitorexit          <span class="token number">22</span><span class="token operator">:</span> <span class="token keyword">goto</span>          <span class="token number">30</span>        <span class="token comment" spellcheck="true">//怎样保证一定会解锁？利用异常表</span>        <span class="token number">25</span><span class="token operator">:</span> astore_3   <span class="token comment" spellcheck="true">// 将异常对象的引用存到slot_3</span>        <span class="token number">26</span><span class="token operator">:</span> aload_2    <span class="token comment" spellcheck="true">// &lt; - slot_2(lock引用)</span>        <span class="token number">27</span><span class="token operator">:</span> monitorexit  <span class="token comment" spellcheck="true">// monitorexit(lock引用),确保对同一个对象解锁</span>        <span class="token number">28</span><span class="token operator">:</span> aload_3    <span class="token comment" spellcheck="true">//刚才的异常对象引用加载进来，进行抛出</span>        <span class="token number">29</span><span class="token operator">:</span> athrow        <span class="token number">30</span><span class="token operator">:</span> <span class="token keyword">return</span>      Exception table<span class="token operator">:</span>         from    to  target type            <span class="token number">12</span>    <span class="token number">22</span>    <span class="token number">25</span>   any            <span class="token number">25</span>    <span class="token number">28</span>    <span class="token number">25</span>   any      LocalVariableTable<span class="token operator">:</span>      Start  Length  Slot  Name   Signature          <span class="token number">0</span>      <span class="token number">31</span>     <span class="token number">0</span>  args   <span class="token punctuation">[</span>Ljava<span class="token operator">/</span>lang<span class="token operator">/</span>String<span class="token punctuation">;</span>          <span class="token number">8</span>      <span class="token number">23</span>     <span class="token number">1</span>  lock   Ljava<span class="token operator">/</span>lang<span class="token operator">/</span>Object<span class="token punctuation">;</span></code></pre><p>总结：</p><p>1.<code>sychronized</code>用于对象上时，会产生2份对象的引用，分别给加锁和解锁指令用</p><p>2.<code>sychronized</code>用于对象上时，利用异常表，不管<code>sychronized</code>中的代码是否正常执行，都将会对同一个对象解锁</p><p>重量级锁</p><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>提升同步性能的依据是：对于绝大部分的锁，在整个同步周期内都是不存在竞争的。</p><p>轻量级锁使用CAS操作避免了使用重量级锁(互斥量)的开销。</p><h4 id="加锁过程"><a href="#加锁过程" class="headerlink" title="加锁过程"></a>加锁过程</h4><ol><li><p>建立锁记录,存储Mark Word</p><p>如果此同步对象<strong>没有被锁定(锁标志位为01)</strong>，虚拟机首先在当前线程栈帧中建立一个锁记录的空间,用于存储锁对象当前的Mark Word的拷贝</p></li><li><p>使用CAS将Mark Word指向锁记录</p><ol><li>操作成功，进入<strong>轻量级锁定状态</strong>，锁标志改为00</li><li>CAS操作失败，检查对象的Mark Word是否指向当前线程的栈帧<ol><li>是，进入同步块继续执行（锁重入）</li><li>否，说明这个锁对象被其他线程抢占了，锁膨胀为重量级锁(锁标志位为10)，自己进入阻塞状态。</li></ol></li></ol></li></ol><p>锁对象：门。</p><p>重量级锁：防盗锁。</p><p>轻量级锁：书包(不同人书包是一样的，里面的书本不一样)</p><p>偏向锁：写名字</p><p>偏向锁</p><p>1.是JDK1.6种引入的一项锁优化</p><p>2.它的目的是消除数据在有同步无竞争情况下的同步原语，进一步提高程序的运行性能。</p><p>3.如果说轻量级所是在无竞争的情况下使用CAS操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都消除掉，连CAS操作都不做了。</p><p>开始是偏向锁，有其他线程来时，竞争发生，升级为轻量级锁。</p><p>竞争存在，但竞争的程度轻，自旋即等待 一会儿，另1个线程就胡释放锁。</p><p>自旋超过一定次数，轻量级锁升级为重量级所。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/Java虚拟机/四、内存模型</title>
      <link href="blog/1806175911.html"/>
      <url>blog/1806175911.html</url>
      
        <content type="html"><![CDATA[<h1 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h1><p>[TOC]</p><h2 id="1-java-内存模型"><a href="#1-java-内存模型" class="headerlink" title="1. java 内存模型"></a>1. java 内存模型</h2><p>很多人将【java 内存结构】与【java 内存模型】傻傻分不清，【java 内存模型】是 Java Memory Model（JMM）的意思。</p><p>关于它的权威解释，请参考 <a href="https://download.oracle.com/otn-pub/jcp/memory_model-1.0-pfdspec-oth-JSpec/memory_model-1_0-pfd-spec.pdf" target="_blank" rel="noopener">https://download.oracle.com/otn-pub/jcp/memory_model-1.0-pfdspec-oth-JSpec/memory_model-1_0-pfd-spec.pdf</a>? AuthParam=1562811549_4d4994cbd5b59d964cd2907ea22ca08b</p><p>简单的说，JMM 定义了一套在多线程读写共享数据时（成员变量、数组）时，对数据的可见性、有序 性、和原子性的规则和保障</p><h3 id="1-1-原子性"><a href="#1-1-原子性" class="headerlink" title="1.1 原子性"></a>1.1 原子性</h3><p>原子性在学习线程时讲过，下面来个例子简单回顾一下： 问题提出，两个线程对初始值为 0 的静态变量一个做自增，一个做自减，各做 5000 次，结果是 0 吗？</p><h3 id="1-2-问题分析"><a href="#1-2-问题分析" class="headerlink" title="1.2 问题分析"></a>1.2 问题分析</h3><p>以上的结果可能是正数、负数、零。为什么呢？因为 Java 中对静态变量的自增，自减并不是原子操 作。 例如对于 i++ 而言（i 为静态变量），实际会产生如下的 JVM 字节码指令：</p><pre><code>getstatic i  // 获取静态变量i的值iconst_1     // 准备常量1iadd         // 加法putstatic i  // 将修改后的值存入静态变量i</code></pre><p>而对应 i– 也是类似：</p><pre><code>getstatic i // 获取静态变量i的值iconst_1    // 准备常量1 isub        // 减法putstatic i // 将修改后的值存入静态变量i</code></pre><p> 而 Java 的内存模型如下，完成静态变量的自增，自减需要在主存和线程内存中进行数据交换：</p><p>如果是单线程以上 8 行代码是顺序执行（不会交错）没有问题：</p><pre><code>// 假设i的初始值为0 getstatic i  // 线程1-获取静态变量i的值 线程内i=0 iconst_1     // 线程1-准备常量1iadd         // 线程1-自增 线程内i=1putstatic i  // 线程1-将修改后的值存入静态变量i 静态变量i=1getstatic i  // 线程1-获取静态变量i的值 线程内i=1iconst_1     // 线程1-准备常量1isub         // 线程1-自减 线程内i=0putstatic i  // 线程1-将修改后的值存入静态变量i 静态变量i=0</code></pre><p>但多线程下这 8 行代码可能交错运行（为什么会交错？思考一下）： 出现负数的情况：</p><pre><code>// 假设i的初始值为0 getstatic i  // 线程1-获取静态变量i的值 线程内i=0getstatic i  // 线程2-获取静态变量i的值 线程内i=0iconst_1     // 线程1-准备常量1iadd         // 线程1-自增 线程内i=1putstatic i  // 线程1-将修改后的值存入静态变量i 静态变量i=1iconst_1     // 线程2-准备常量1isub         // 线程2-自减 线程内i=-1putstatic i  // 线程2-将修改后的值存入静态变量i 静态变量i=-1      </code></pre><p>出现正数的情况：</p><pre><code>// 假设i的初始值为0 getstatic i  // 线程1-获取静态变量i的值 线程内i=0getstatic i  // 线程2-获取静态变量i的值 线程内i=0iconst_1     // 线程1-准备常量1 iadd         // 线程1-自增 线程内i=1iconst_1     // 线程2-准备常量1isub         // 线程2-自减 线程内i=-1putstatic i  // 线程2-将修改后的值存入静态变量i 静态变量i=-1 putstatic i  // 线程1-将修改后的值存入静态变量i 静态变量i=1</code></pre><h3 id="1-3-解决方法"><a href="#1-3-解决方法" class="headerlink" title="1.3 解决方法"></a>1.3 解决方法</h3><p><code>synchronized</code> （同步关键字）</p><p>语法</p><pre class=" language-java"><code class="language-java"><span class="token keyword">synchronized</span><span class="token punctuation">(</span> 对象 <span class="token punctuation">)</span> <span class="token punctuation">{</span>   要作为原子操作代码 <span class="token punctuation">}</span></code></pre><p>用 <code>synchronized</code> 解决并发问题：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token keyword">static</span> Object obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>     Thread t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>       <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">5000</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>           i<span class="token operator">++</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Thread t2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">5000</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>           i<span class="token operator">--</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>       <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     t2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>如何理解呢：你可以把 obj 想象成一个房间，线程 t1，t2 想象成两个人。 </p><p>当线程 t1 执行到 synchronized(obj) 时就好比 t1 进入了这个房间，并反手锁住了门，在门内执行 count++ 代码。 这时候如果 t2 也运行到了 synchronized(obj) 时，它发现门被锁住了，只能在门外等待。 </p><p>当 t1 执行完 synchronized{} 块内的代码，这时候才会解开门上的锁，从 obj 房间出来。t2 线程这时才 可以进入 obj 房间，反锁住门，执行它的 count– 代码。</p><blockquote><p> 注意：上例中 t1 和 t2 线程必须用 synchronized 锁住同一个 obj 对象，如果 t1 锁住的是 m1 对 象，t2 锁住的是 m2 对象，就好比两个人分别进入了两个不同的房间，没法起到同步的效果。    </p></blockquote><h2 id="2-可见性"><a href="#2-可见性" class="headerlink" title="2.可见性"></a>2.可见性</h2><h3 id="2-1-退不出的循环"><a href="#2-1-退不出的循环" class="headerlink" title="2.1 退不出的循环"></a>2.1 退不出的循环</h3><p>先来看一个现象，main 线程对 run 变量的修改对于 t 线程不可见，导致了 t 线程无法停止：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">boolean</span> run <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>   Thread t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span>         <span class="token keyword">while</span><span class="token punctuation">(</span>run<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// ....</span>        <span class="token punctuation">}</span>   <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> run <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 线程t不会如预想的停下来</span><span class="token punctuation">}</span></code></pre><p>为什么呢？分析一下： </p><ol><li><p>初始状态， t 线程刚开始从主内存读取了 run 的值到工作内存。</p></li><li><p>因为 t 线程要频繁从主内存中读取 run 的值，JIT 编译器会将 run 的值缓存至自己工作内存中的高</p></li></ol><p>速缓存中，减少对主存中 run 的访问，提高效率 </p><ol start="3"><li>1 秒之后，main 线程修改了 run 的值，并同步至主存，而 t 是从自己工作内存中的高速缓存中读</li></ol><p>取这个变量的值，结果永远是旧值</p><h3 id="2-2-解决方法"><a href="#2-2-解决方法" class="headerlink" title="2.2 解决方法"></a>2.2 解决方法</h3><p><code>volatile</code>（易变关键字）</p><p>它可以用来修饰成员变量和静态成员变量，他可以避免线程从自己的工作缓存中查找变量的值，必须到 主存中获取它的值，线程操作 volatile 变量都是直接操作主存</p><h3 id="2-3-可见性"><a href="#2-3-可见性" class="headerlink" title="2.3 可见性"></a>2.3 可见性</h3><p>前面例子体现的实际就是可见性，它保证的是在多个线程之间，一个线程对 volatile 变量的修改对另一 个线程可见， 不能保证原子性，仅用在一个写线程，多个读线程的情况： 上例从字节码理解是这样 的：</p><pre><code>getstatic  run   // 线程 t 获取 run true getstatic  run   // 线程 t 获取 run true getstatic  run   // 线程 t 获取 run true getstatic  run   // 线程 t 获取 run true putstatic  run   // 线程 main 修改 run 为 false， 仅此一次getstatic  run   // 线程 t 获取 run false</code></pre><p>比较一下之前我们将线程安全时举的例子：两个线程一个 i++ 一个 i– ，只能保证看到最新值，不能解 决指令交错 </p><pre><code>// 假设i的初始值为0 getstatic i   // 线程1-获取静态变量i的值 线程内i=0getstatic i   // 线程2-获取静态变量i的值 线程内i=0iconst_1 i    // 线程1-准备常量1add           // 线程1-自增 线程内i=1putstatic i   // 线程1-将修改后的值存入静态变量i 静态变量i=1iconst_1      // 线程2-准备常量1isub          // 线程2-自减 线程内i=-1putstatic i   // 线程2-将修改后的值存入静态变量i 静态变量i=-1            </code></pre><p>注意 synchronized 语句块既可以保证代码块的原子性，也同时保证代码块内变量的可见性。但 缺点是synchronized是属于重量级操作，性能相对更低 </p><p>如果在前面示例的死循环中加入 System.out.println() 会发现即使不加 volatile 修饰符，线程 t 也 能正确看到对 run 变量的修改了，想一想为什么？</p><h2 id="3-有序性"><a href="#3-有序性" class="headerlink" title="3.有序性"></a>3.有序性</h2><h3 id="3-1-诡异的结果"><a href="#3-1-诡异的结果" class="headerlink" title="3.1 诡异的结果"></a>3.1 诡异的结果</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token keyword">boolean</span> ready <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 线程1 执行此方法 </span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">actor1</span><span class="token punctuation">(</span>I_Result r<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>ready<span class="token punctuation">)</span> <span class="token punctuation">{</span>       r<span class="token punctuation">.</span>r1 <span class="token operator">=</span> num <span class="token operator">+</span> num<span class="token punctuation">;</span>     <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      r<span class="token punctuation">.</span>r1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 线程2 执行此方法 </span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">actor2</span><span class="token punctuation">(</span>I_Result r<span class="token punctuation">)</span> <span class="token punctuation">{</span>    num <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    ready <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><p>I_Result 是一个对象，有一个属性 r1 用来保存结果，问，可能的结果有几种？</p><p>情况1：线程1 先执行，这时 ready = false，所以进入 else 分支结果为 1 </p><p>情况2：线程2 先执行 num = 2，但没来得及执行 ready = true，线程1 执行，还是进入 else 分支，结 果为1 </p><p>情况3：线程2 执行到 ready = true，线程1 执行，这回进入 if 分支，结果为 4（因为 num 已经执行过 了）</p><p>但结果还有可能是 0    ，不信吧！ 这种情况下是：线程2 执行 ready = true，切换到线程1，进入 if 分支，相加为 0，再切回线程2 执行 num = 2 相信很多人已经晕了    </p><p>这种现象叫做<strong>指令重排</strong>，是 JIT 编译器在运行时的一些优化，这个现象需要通过大量测试才能复现： 借助 java 并发压测工具 jcstress <a href="https://wiki.openjdk.java.net/display/CodeTools/jcstress" target="_blank" rel="noopener">https://wiki.openjdk.java.net/display/CodeTools/jcstress</a></p><pre><code>mvn archetype:generate -DinteractiveMode=false DarchetypeGroupId=org.openjdk.jcstress -DarchetypeArtifactId=jcstress-java-testarchetype -DgroupId=org.sample -DartifactId=test -Dversion=1.0</code></pre><p>创建 maven 项目，提供如下测试类</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@JCStressTest</span> <span class="token annotation punctuation">@Outcome</span><span class="token punctuation">(</span>id <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token string">"4"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> expect <span class="token operator">=</span> Expect<span class="token punctuation">.</span>ACCEPTABLE<span class="token punctuation">,</span> desc <span class="token operator">=</span> <span class="token string">"ok"</span><span class="token punctuation">)</span> <span class="token annotation punctuation">@Outcome</span><span class="token punctuation">(</span>id <span class="token operator">=</span> <span class="token string">"0"</span><span class="token punctuation">,</span> expect <span class="token operator">=</span> Expect<span class="token punctuation">.</span>ACCEPTABLE_INTERESTING<span class="token punctuation">,</span> desc <span class="token operator">=</span> <span class="token string">"!!!!"</span><span class="token punctuation">)</span> <span class="token annotation punctuation">@State</span> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcurrencyTest</span> <span class="token punctuation">{</span>  <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>   <span class="token keyword">boolean</span> ready <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>   <span class="token annotation punctuation">@Actor</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">actor1</span><span class="token punctuation">(</span>I_Result r<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">if</span><span class="token punctuation">(</span>ready<span class="token punctuation">)</span> <span class="token punctuation">{</span>           r<span class="token punctuation">.</span>r1 <span class="token operator">=</span> num <span class="token operator">+</span> num<span class="token punctuation">;</span>       <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>          r<span class="token punctuation">.</span>r1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Actor</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">actor2</span><span class="token punctuation">(</span>I_Result r<span class="token punctuation">)</span> <span class="token punctuation">{</span>      num <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>      ready <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>执行</p><pre><code>mvn clean install java -jar target/jcstress.jar</code></pre><p>会输出我们感兴趣的结果，摘录其中一次结果：</p><pre><code>*** INTERESTING tests     Some interesting behaviors observed. This is for the plain curiosity.    2 matching test results.            [OK] test.ConcurrencyTest             (JVM args: [-XX:-TieredCompilation])             Observed state Occurrences         Expectation              Interpretation                   0    1,729         ACCEPTABLE_INTERESTING       !!!!                  1    42,617,915    ACCEPTABLE                                  ok                  4    5,146,627     ACCEPTABLE                                 ok            [OK] test.ConcurrencyTest       (JVM args: [])  Observed state Occurrences     Expectation                        Interpretation            0       1,652      ACCEPTABLE_INTERESTING                   !!!!            1      46,460,657              ACCEPTABLE                        ok            4       4,571,072              ACCEPTABLE                     ok</code></pre><p>可以看到，出现结果为 0 的情况有 638 次，虽然次数相对很少，但毕竟是出现了。</p><h3 id="3-2-解决方法"><a href="#3-2-解决方法" class="headerlink" title="3.2 解决方法"></a>3.2 解决方法</h3><p><code>volatile</code> 修饰的变量，可以禁用指令重排</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@JCStressTest</span> <span class="token annotation punctuation">@Outcome</span><span class="token punctuation">(</span>id <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token string">"4"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> expect <span class="token operator">=</span> Expect<span class="token punctuation">.</span>ACCEPTABLE<span class="token punctuation">,</span> desc <span class="token operator">=</span> <span class="token string">"ok"</span><span class="token punctuation">)</span> <span class="token annotation punctuation">@Outcome</span><span class="token punctuation">(</span>id <span class="token operator">=</span> <span class="token string">"0"</span><span class="token punctuation">,</span> expect <span class="token operator">=</span> Expect<span class="token punctuation">.</span>ACCEPTABLE_INTERESTING<span class="token punctuation">,</span> desc <span class="token operator">=</span> <span class="token string">"!!!!"</span><span class="token punctuation">)</span> <span class="token annotation punctuation">@State</span> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcurrencyTest</span> <span class="token punctuation">{</span>  <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>   <span class="token keyword">volatile</span> <span class="token keyword">boolean</span> ready <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>   <span class="token annotation punctuation">@Actor</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">actor1</span><span class="token punctuation">(</span>I_Result r<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">if</span><span class="token punctuation">(</span>ready<span class="token punctuation">)</span> <span class="token punctuation">{</span>           r<span class="token punctuation">.</span>r1 <span class="token operator">=</span> num <span class="token operator">+</span> num<span class="token punctuation">;</span>       <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>          r<span class="token punctuation">.</span>r1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Actor</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">actor2</span><span class="token punctuation">(</span>I_Result r<span class="token punctuation">)</span> <span class="token punctuation">{</span>      num <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>      ready <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>结果为：</p><pre><code>*** INTERESTING tests     Some interesting behaviors observed. This is for the plain curiosity.    0 matching test results.</code></pre><h3 id="3-3-有序性理解"><a href="#3-3-有序性理解" class="headerlink" title="3.3 有序性理解"></a>3.3 有序性理解</h3><p>JVM 会在不影响正确性的前提下，可以调整语句的执行顺序，思考下面一段代码</p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">int</span> i<span class="token punctuation">;</span> <span class="token keyword">static</span> <span class="token keyword">int</span> j<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 在某个线程内执行如下赋值操作 </span>i <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 较为耗时的操作 </span>j <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span></code></pre><p>可以看到，至于是先执行 i 还是 先执行 j ，对最终的结果不会产生影响。所以，上面代码真正执行时， 既可以是</p><pre class=" language-java"><code class="language-java">i <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 较为耗时的操作 </span>j <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span></code></pre><p>也可以是</p><pre class=" language-java"><code class="language-java">j <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span> i <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 较为耗时的操作</span></code></pre><p>这种特性称之为『指令重排』，多线程下『指令重排』会影响正确性，例如著名的 double-checked locking 模式实现单例</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>     <span class="token keyword">private</span> <span class="token keyword">static</span> Singleton INSTANCE <span class="token operator">=</span> null<span class="token punctuation">;</span>     <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 实例没创建，才会进入内部的 synchronized代码块</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>INSTANCE <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>Singleton<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>             <span class="token comment" spellcheck="true">// 也许有其它线程已经创建实例，所以再判断一次 </span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>INSTANCE <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                   INSTANCE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token punctuation">}</span>             <span class="token punctuation">}</span>          <span class="token punctuation">}</span>         <span class="token keyword">return</span> INSTANCE<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>以上的实现特点是：</p><ul><li><p>懒惰实例化 </p></li><li><p>首次使用 getInstance() 才使用 synchronized 加锁，后续使用时无需加锁</p></li></ul><p>但在多线程环境下，上面的代码是有问题的， <code>INSTANCE = new Singleton()</code> 对应的字节码为：</p><pre><code>0: new             #2                   // class cn/itcast/jvm/t4/Singleton3: dup 4: invokespecial #3    // Method &quot;&lt;init&gt;&quot;:()V 7: putstatic #4              // Field INSTANCE:Lcn/itcast/jvm/t4/Singleton;</code></pre><p>其中 4 7 两步的顺序不是固定的，也许 jvm 会优化为：先将引用地址赋值给 INSTANCE 变量后，再执行 构造方法，如果两个线程 t1，t2 按如下时间序列执行：</p><pre><code>时间1 t1 线程执行到 INSTANCE = new Singleton(); 时间2 t1 线程分配空间，为Singleton对象生成了引用地址（0 处） 时间3 t1 线程将引用地址赋值给 INSTANCE，这时 INSTANCE != null（7 处） 时间4 t2 线程进入getInstance() 方法，发现 INSTANCE != null（synchronized块外），直接 返回 INSTANCE 时间5 t1 线程执行Singleton的构造方法（4 处）</code></pre><p>这时 t1 还未完全将构造方法执行完毕，如果在构造方法中要执行很多初始化操作，那么 t2 拿到的是将 是一个未初始化完毕的单例</p><p>对 <code>INSTANCE</code> 使用 <code>volatile</code> 修饰即可，可以禁用指令重排，但要注意在 JDK 5 以上的版本的 <code>volatile</code> 才 会真正有效</p><h3 id="3-4-happens-before"><a href="#3-4-happens-before" class="headerlink" title="3.4 happens-before"></a>3.4 happens-before</h3><p>happens-before 规定了哪些写操作对其它线程的读操作可见，它是可见性与有序性的一套规则总结， 抛开以下 happens-before 规则，JMM 并不能保证一个线程对共享变量的写，对于其它线程对该共享变 量的读可见</p><ul><li>线程解锁m 之前对变量的写，对于接下来对 m 加锁的其它线程对该变量的读可见</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">int</span> x<span class="token punctuation">;</span> <span class="token keyword">static</span> Object m <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span> <span class="token keyword">synchronized</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span> <span class="token punctuation">{</span> x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token string">"t1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span> <span class="token keyword">synchronized</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span> <span class="token punctuation">{</span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token string">"t2"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>线程对 <span class="token keyword">volatile</span> 变量的写，对接下来其它线程对该变量的读可见<span class="token keyword">volatile</span> <span class="token keyword">static</span> <span class="token keyword">int</span> x<span class="token punctuation">;</span><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span> x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token string">"t1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token string">"t2"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 线程 start 前对变量的写，对该线程开始后对该变量的读可见<span class="token keyword">static</span> <span class="token keyword">int</span> x<span class="token punctuation">;</span>x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token string">"t2"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>线程结束前对变量的写，对其它线程得知它结束后的读可见（比如其它线程调用 t1.isAlive() 或</p><p>t1.join()等待它结束）</p><p>static int x;</p><p>Thread t1 = new Thread(()-&gt;{ x = 10; },”t1”); t1.start();</p><p>t1.join(); System.out.println(x);</p><p>线程 t1 打断 t2（interrupt）前对变量的写，对于其他线程得知 t2 被打断后对变量的读可见（通</p><p>过t2.interrupted 或 t2.isInterrupted）</p><p>static int x;</p><p>public static void main(String[] args) {</p><p>Thread t2 = new Thread(()-&gt;{ while(true) { if(Thread.currentThread().isInterrupted()) { System.out.println(x); break;</p><p>}</p><p>} },”t2”); t2.start();</p><p>new Thread(()-&gt;{ try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } x = 10; t2.interrupt(); },”t1”).start();</p><p>while(!t2.isInterrupted()) { Thread.yield(); } System.out.println(x); }</p><p>对变量默认值（0，false，null）的写，对其它线程对该变量的读可见 具有传递性，如果 x hb-&gt; y 并且 y hb-&gt; z 那么有 x hb-&gt; z 变量都是指成员变量或静态成员变量 参考： 第17页</p><h2 id="4-CAS-与-原子类"><a href="#4-CAS-与-原子类" class="headerlink" title="4.CAS 与 原子类"></a>4.CAS 与 原子类</h2><h3 id="4-1-CAS"><a href="#4-1-CAS" class="headerlink" title="4.1 CAS"></a>4.1 CAS</h3><p>CAS 即 <code>Compare and Swap</code> 行 +1 操作：</p><p>，它体现的一种乐观锁的思想，比如多个线程要对一个共享的整型变量执</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 需要不断尝试 </span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> 旧值 <span class="token operator">=</span> 共享变量 <span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 比如拿到了当前值 0 </span>  <span class="token keyword">int</span> 结果 <span class="token operator">=</span> 旧值 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 在旧值 0 的基础上增加 1 ，正确结果是 1</span><span class="token comment" spellcheck="true">/*    compareAndSwap在把结果写入共享变量之前会将旧值和共享变量当前的值做比较    这时候如果别的线程把共享变量改成了 5，本线程的正确结果 1 就作废了，这时候     compareAndSwap 返回 false，重新尝试，直到：     compareAndSwap 返回 true，表示我本线程做修改的同时，别的线程没有干扰 */</span>   <span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token function">compareAndSwap</span> <span class="token punctuation">(</span> 旧值<span class="token punctuation">,</span> 结果 <span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">// 成功，退出循环 }</span><span class="token punctuation">}</span></code></pre><p>获取共享变量时，为了保证该变量的可见性，需要使用 volatile 修饰。结合 CAS 和 volatile 可以实现无 锁并发，适用于竞争不激烈、多核 CPU 的场景下。</p><ul><li><p>因为没有使用 synchronized，所以线程不会陷入阻塞，没有线程上下文切换这是效率提升的因素之一</p></li><li><p>但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响 </p></li></ul><p>CAS 底层依赖于一个 Unsafe 类来直接调用操作系统底层的 CAS 指令，下面是直接使用 Unsafe 对象进 行线程安全保护的一个例子</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span>Unsafe<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>Field<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestCAS</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        DataContainer dc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DataContainer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>        Thread t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> count<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                dc<span class="token punctuation">.</span><span class="token function">increase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>dc<span class="token punctuation">.</span><span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">DataContainer</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> data<span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> Unsafe unsafe<span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> DATA_OFFSET<span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// Unsafe 对象不能直接调用，只能通过反射获得 </span>            Field theUnsafe <span class="token operator">=</span> Unsafe<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"theUnsafe"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            theUnsafe<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            unsafe <span class="token operator">=</span> <span class="token punctuation">(</span>Unsafe<span class="token punctuation">)</span> theUnsafe<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">NoSuchFieldException</span> <span class="token operator">|</span> IllegalAccessException e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// data 属性在 DataContainer 对象中的偏移量，用于 Unsafe 直接访问该属性 </span>            DATA_OFFSET <span class="token operator">=</span> unsafe<span class="token punctuation">.</span><span class="token function">objectFieldOffset</span><span class="token punctuation">(</span>DataContainer<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"data"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">NoSuchFieldException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">increase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> oldValue<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 获取共享变量旧值，可以在这一行加入断点，修改 data 调试来加深理解 </span>            oldValue <span class="token operator">=</span> data<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// cas 尝试修改 data 为 旧值 + 1，如果期间旧值被别的线程改了，返回 false </span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> DATA_OFFSET<span class="token punctuation">,</span> oldValue<span class="token punctuation">,</span> oldValue <span class="token operator">+</span>                    <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">decrease</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> oldValue<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            oldValue <span class="token operator">=</span> data<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> DATA_OFFSET<span class="token punctuation">,</span> oldValue<span class="token punctuation">,</span> oldValue <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> data<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="4-2-乐观锁与悲观锁"><a href="#4-2-乐观锁与悲观锁" class="headerlink" title="4.2 乐观锁与悲观锁"></a>4.2 乐观锁与悲观锁</h3><ul><li>CAS 是基于乐观锁的思想：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系， 我吃亏点再重试呗。 </li><li>synchronized 是基于悲观锁的思想：最悲观的估计，得防着其它线程来修改共享变量，我上了锁 你们都别想改，我改完了解开锁，你们才有机会。</li></ul><h3 id="4-3-原子操作类"><a href="#4-3-原子操作类" class="headerlink" title="4.3 原子操作类"></a>4.3 原子操作类</h3><p><code>juc（java.util.concurrent）</code>中提供了原子操作类，可以提供线程安全的操作，例如：<code>AtomicInteger</code>、 <code>AtomicBoolean</code>等，它们底层就是采用 <code>CAS</code> 技术 + <code>volatile</code> 来实现的。</p><p>可以使用 <code>AtomicInteger</code> 改写之前的例子：</p><pre class=" language-java"><code class="language-java"> <span class="token comment" spellcheck="true">// 创建原子整数对象</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> AtomicInteger i <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        Thread t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">5000</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                i<span class="token punctuation">.</span><span class="token function">getAndIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 获取并且自增 i++</span>                <span class="token comment" spellcheck="true">// i.incrementAndGet(); // 自增并且获取 ++i</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread t2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">5000</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                i<span class="token punctuation">.</span><span class="token function">getAndDecrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 获取并且自减 i--</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h2 id="5-synchronized-优化"><a href="#5-synchronized-优化" class="headerlink" title="5.synchronized 优化"></a>5.synchronized 优化</h2><p>Java HotSpot 虚拟机中，每个对象都有对象头（包括 class 指针和 Mark Word）。</p><p>Mark Word 平时存储这个对象的 哈希码 、 分代年龄 ，当加锁时，这些信息就根据情况被替换为 标记位 、 针 、 重量级锁指针 、 线程ID 等内容</p><p>线程锁记录指 </p><h3 id="5-1-轻量级锁"><a href="#5-1-轻量级锁" class="headerlink" title="5.1 轻量级锁"></a>5.1 轻量级锁</h3><p>如果一个对象虽然有多线程访问，但多线程访问的时间是错开的（也就是没有竞争），那么可以使用轻 量级锁来优化。这就好比： 学生（线程 A）用课本占座，上了半节课，出门了（CPU时间到），回来一看，发现课本没变，说明没 有竞争，继续上他的课。 如果这期间有其它学生（线程 B）来了，会告知（线程A）有并发访问，线程 A 随即升级为重量级锁，进入重量级锁的流程。 而重量级锁就不是那么用课本占座那么简单了，可以想象线程 A 走之前，把座位用一个铁栅栏围起来 假设有两个方法同步块，利用同一个对象加锁</p><p>static Object obj = new Object(); public static void method1() { synchronized( obj ) { // 同步块 A method2(); } } public static void method2() { synchronized( obj ) { // 同步块 B } }</p><p>每个线程都的栈帧都会包含一个锁记录的结构，内部可以存储锁定对象的 Mark Word 线程 1</p><p>对象 Mark Word</p><p>线程 2</p><p>访问同步块 A，把 Mark 复制到 线程 1 的锁记录</p><p>01（无锁）</p><p>-</p><p>CAS 修改 Mark 为线程 1 锁记录</p><p>地址</p><p>01（无锁）</p><p>-</p><p>成功（加锁）</p><p>00（轻量锁）线程 1</p><p>锁记录地址</p><p>-</p><p>执行同步块 A</p><p>00（轻量锁）线程 1</p><p>锁记录地址</p><p>-</p><p>访问同步块 B，把 Mark 复制到 线程 1 的锁记录</p><p>00（轻量锁）线程 1</p><p>锁记录地址</p><p>-</p><p>CAS 修改 Mark 为线程 1 锁记录</p><p>地址</p><p>00（轻量锁）线程 1</p><p>锁记录地址</p><p>-</p><p>失败（发现是自己的锁）</p><p>00（轻量锁）线程 1</p><p>锁记录地址</p><p>-</p><p>锁重入</p><p>00（轻量锁）线程 1</p><p>锁记录地址</p><p>-</p><p>执行同步块 B</p><p>00（轻量锁）线程 1</p><p>锁记录地址</p><p>-</p><p>同步块 B 执行完毕</p><p>00（轻量锁）线程 1</p><p>锁记录地址</p><p>-</p><p>同步块 A 执行完毕</p><p>00（轻量锁）线程 1</p><p>锁记录地址</p><p>-</p><p>成功（解锁）</p><p>01（无锁）</p><p>-</p><p>-</p><p>01（无锁）</p><p>访问同步块 A，把 Mark 复制到 线程 2 的锁记录</p><p>-</p><p>01（无锁）</p><p>CAS 修改 Mark 为线程 2 锁记录</p><p>地址</p><p>-</p><p>00（轻量锁）线程 2</p><p>锁记录地址</p><p>成功（加锁）</p><p>-</p><p>…</p><p>…</p><h3 id="5-2-锁膨胀"><a href="#5-2-锁膨胀" class="headerlink" title="5.2 锁膨胀"></a>5.2 锁膨胀</h3><p>如果在尝试加轻量级锁的过程中，CAS 操作无法成功，这时一种情况就是有其它线程为此对象加上了轻 量级锁（有竞争），这时需要进行锁膨胀，将轻量级锁变为重量级锁。 static Object obj = new Object(); public static void method1() {</p><p>synchronized( obj ) {</p><p>// 同步块</p><p>} }</p><p>线程 1</p><p>访问同步块，把 Mark 复制到线程 1 的锁记录</p><p>CAS 修改 Mark 为线程 1 锁记录地 址</p><p>成功（加锁）</p><p>执行同步块</p><p>执行同步块</p><p>执行同步块</p><p>执行同步块</p><p>执行同步块</p><p>执行同步块</p><p>执行完毕</p><p>失败（解锁）</p><p>释放重量锁，唤起阻塞线程竞争</p><p>-</p><p>-</p><p>-</p><p>对象 Mark</p><p>01（无锁）</p><p>01（无锁）</p><p>00（轻量锁）线程 1 锁 记录地址 00（轻量锁）线程 1 锁 记录地址 00（轻量锁）线程 1 锁 记录地址 00（轻量锁）线程 1 锁 记录地址 00（轻量锁）线程 1 锁 记录地址 00（轻量锁）线程 1 锁 记录地址 10（重量锁）重量锁指 针 10（重量锁）重量锁指 针 10（重量锁）重量锁指 针 01（无锁） 10（重量锁） 10（重量锁） …</p><p>线程 2</p><p>-</p><p>90</p><p>-</p><p>-</p><p>-</p><p>访问同步块，把 Mark 复制 到线程 2</p><p>CAS 修改 Mark 为线程 2 锁 记录地址</p><p>失败（发现别人已经占了 锁）</p><p>CAS 修改 Mark 为重量锁</p><p>阻塞中</p><p>阻塞中</p><p>阻塞中</p><p>阻塞中</p><p>竞争重量锁</p><p>成功（加锁）</p><p>…</p><h3 id="5-3-重量锁"><a href="#5-3-重量锁" class="headerlink" title="5.3 重量锁"></a>5.3 重量锁</h3><p>重量级锁竞争的时候，还可以使用自旋来进行优化，如果当前线程自旋成功（即这时候持锁线程已经退 出了同步块，释放了锁），这时当前线程就可以避免阻塞。</p><p>在 Java 6 之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能 性会高，就多自旋几次；反之，就少自旋甚至不自旋，总之，比较智能。 自旋会占用 CPU 时间，单核 CPU 自旋就是浪费，多核 CPU 自旋才能发挥优势。 好比等红灯时汽车是不是熄火，不熄火相当于自旋（等待时间短了划算），熄火了相当于阻塞（等 待时间长了划算） Java 7 之后不能控制是否开启自旋功能 自旋重试成功的情况</p><p>线程 1 （cpu 1 上）</p><p>访问同步块，获取 monitor 成功（加锁） 执行同步块 执行同步块 执行同步块 执行完毕 成功（解锁）</p><p>-</p><p>-</p><p>-</p><p>对象 Mark</p><p>10（重量锁） 10（重量锁）重量锁指针 10（重量锁）重量锁指针 10（重量锁）重量锁指针 10（重量锁）重量锁指针 10（重量锁）重量锁指针 10（重量锁）重量锁指针 01（无锁） 10（重量锁）重量锁指针 10（重量锁）重量锁指针 …</p><p>对象 Mark</p><p>10（重量锁） 10（重量锁）重量锁指针 10（重量锁）重量锁指针 10（重量锁）重量锁指针 10（重量锁）重量锁指针 10（重量锁）重量锁指针 10（重量锁）重量锁指针 10（重量锁）重量锁指针 10（重量锁）重量锁指针 …</p><p>线程 2 （cpu 2 上）</p><p>-</p><p>-</p><p>-</p><p>访问同步块，获取 monitor 自旋重试 自旋重试 自旋重试 成功（加锁） 执行同步块 …</p><p>自旋重试失败的情况</p><p>线程 1（cpu 1 上）</p><p>访问同步块，获取 monitor 成功（加锁） 执行同步块 执行同步块 执行同步块 执行同步块 执行同步块 执行同步块</p><p>-</p><p>线程 2（cpu 2 上）</p><p>-</p><p>-</p><p>-</p><p>访问同步块，获取 monitor 自旋重试 自旋重试 自旋重试 阻塞 …</p><h3 id="5-4-偏向锁-轻量级锁在没有竞争时（就自己这个线程），每次重入仍然需要执行-CAS-操作。Java-6-中引入了偏向锁-来做进一步优化：只有第一次使用-CAS-将线程-ID-设置到对象的-Mark-Word-头，之后发现这个线程-ID-是自己的就表示没有竞争，不用重新-CAS"><a href="#5-4-偏向锁-轻量级锁在没有竞争时（就自己这个线程），每次重入仍然需要执行-CAS-操作。Java-6-中引入了偏向锁-来做进一步优化：只有第一次使用-CAS-将线程-ID-设置到对象的-Mark-Word-头，之后发现这个线程-ID-是自己的就表示没有竞争，不用重新-CAS" class="headerlink" title="5.4 偏向锁 轻量级锁在没有竞争时（就自己这个线程），每次重入仍然需要执行 CAS 操作。Java 6 中引入了偏向锁 来做进一步优化：只有第一次使用 CAS 将线程 ID 设置到对象的 Mark Word 头，之后发现这个线程 ID 是自己的就表示没有竞争，不用重新 CAS."></a>5.4 偏向锁 轻量级锁在没有竞争时（就自己这个线程），每次重入仍然需要执行 CAS 操作。Java 6 中引入了偏向锁 来做进一步优化：只有第一次使用 CAS 将线程 ID 设置到对象的 Mark Word 头，之后发现这个线程 ID 是自己的就表示没有竞争，不用重新 CAS.</h3><p>撤销偏向需要将持锁线程升级为轻量级锁，这个过程中所有线程需要暂停（STW） 访问对象的 hashCode 也会撤销偏向锁 如果对象虽然被多个线程访问，但没有竞争，这时偏向了线程 T1 的对象仍有机会重新偏向 T2， 重偏向会重置对象的 Thread ID 撤销偏向和重偏向都是批量进行的，以类为单位 如果撤销偏向到达某个阈值，整个类的所有对象都会变为不可偏向的 可以主动使用 -XX:-UseBiasedLocking 禁用偏向锁</p><p>层 公楼一 燕龙办 西路金 建材城 昌平区 北京市</p><p>可以参考这篇论文： <a href="https://www.oracle.com/technetwork/java/biasedlocking-oopsla2006-wp149958.pdf" target="_blank" rel="noopener">https://www.oracle.com/technetwork/java/biasedlocking-oopsla2006-wp149958.pdf</a> 假设有两个方法同步块，利用同一个对象加锁</p><p>static Object obj = new Object(); public static void method1() { synchronized( obj ) { // 同步块 A method2(); } } public static void method2() { synchronized( obj ) { // 同步块 B } }</p><p>线程 1</p><p>访问同步块 A，检查 Mark 中是否有线程 ID</p><p>尝试加偏向锁</p><p>成功</p><p>执行同步块 A</p><p>访问同步块 B，检查 Mark 中是否有线程 ID</p><p>是自己的线程 ID，锁是自己的，无需做更多操作</p><p>执行同步块 B</p><p>执行完毕</p><p>对象 Mark</p><p>101（无锁可偏向） 101（无锁可偏向）对象 hashCode 101（无锁可偏向）线程ID 101（无锁可偏向）线程ID 101（无锁可偏向）线程ID 101（无锁可偏向）线程ID 101（无锁可偏向）线程ID 101（无锁可偏向）对象 hashCode</p><h3 id="5-5-其它优化"><a href="#5-5-其它优化" class="headerlink" title="5.5 其它优化"></a>5.5 其它优化</h3><ol><li>减少上锁时间</li></ol><p>同步代码块中尽量短</p><ol start="2"><li>减少锁的粒度</li></ol><p>将一个锁拆分为多个锁提高并发度，例如： ConcurrentHashMap LongAdder 分为 base 和 cells 两部分。没有并发争用的时候或者是 cells 数组正在初始化的时 候，会使用 CAS 来累加值到 base，有并发争用，会初始化 cells 数组，数组有多少个 cell，就允 许有多少线程并行修改，最后将数组中每个 cell 累加，再加上 base 就是最终的值 LinkedBlockingQueue 入队和出队使用不同的锁，相对于LinkedBlockingArray只有一个锁效率要 高</p><ol start="3"><li>锁粗化</li></ol><p>多次循环进入同步块不如同步块内多次循环 另外 JVM 可能会做如下优化，把多次 append 的加锁操作 粗化为一次（因为都是对同一个对象加锁，没必要重入多次）</p><p>new StringBuffer().append(“a”).append(“b”).append(“c”);</p><ol start="4"><li>锁消除</li></ol><p>JVM 会进行代码的逃逸分析，例如某个加锁对象是方法内局部变量，不会被其它线程所访问到，这时候 就会被即时编译器忽略掉所有同步操作。</p><ol start="5"><li>读写分离</li></ol><p>CopyOnWriteArrayList ConyOnWriteSet 参考： <a href="https://wiki.openjdk.java.net/display/HotSpot/Synchronization" target="_blank" rel="noopener">https://wiki.openjdk.java.net/display/HotSpot/Synchronization</a> <a href="http://luojinping.com/2015/07/09/java锁优化/" target="_blank" rel="noopener">http://luojinping.com/2015/07/09/java锁优化/</a> <a href="https://www.infoq.cn/article/java-se-16-synchronized" target="_blank" rel="noopener">https://www.infoq.cn/article/java-se-16-synchronized</a> <a href="https://www.jianshu.com/p/9932047a89be" target="_blank" rel="noopener">https://www.jianshu.com/p/9932047a89be</a> <a href="https://www.cnblogs.com/sheeva/p/6366782.html" target="_blank" rel="noopener">https://www.cnblogs.com/sheeva/p/6366782.html</a> <a href="https://stackoverﬂow.com/questions/46312817/does-java-ever-rebias-an-individual-lock" target="_blank" rel="noopener">https://stackoverﬂow.com/questions/46312817/does-java-ever-rebias-an-individual-lock</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/Java虚拟机/三、类文件结构</title>
      <link href="blog/510968677.html"/>
      <url>blog/510968677.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-类文件结构"><a href="#1-类文件结构" class="headerlink" title="1.类文件结构"></a>1.类文件结构</h2><h3 id="1-1魔数"><a href="#1-1魔数" class="headerlink" title="1.1魔数"></a>1.1魔数</h3><h3 id="1-2版本"><a href="#1-2版本" class="headerlink" title="1.2版本"></a>1.2版本</h3><h3 id="1-3常量池"><a href="#1-3常量池" class="headerlink" title="1.3常量池"></a>1.3常量池</h3><p>1.常量池是一张表，容量计数(只有这个是)从1开始，第0项表示不引用任何一个常量池项目。</p><p>eg:<img src=".三、类文件结构_images/image-20200627124535551.png" alt="image-20200627124535551" style="zoom:50%;" /></p><p>2.常量池主要存放两大类常量：字面量(Literal)和符号引用.</p><p>​    字面量：Java中的字符串，final修饰的常量值，</p><p>​    符号引用：①类和接口的全限定名；②字段的名称和描述符③方法的名称和描述符</p><p>3.常量池中的每一项也是一个表，主要有<strong>14种常量类型</strong>(表结构见numbers图)，该表中第一个字段(占1个字节)表示类型</p><img src=".三、类文件结构_images/image-20200627124019251.png" alt="image-20200627124019251" style="zoom:50%;" /><h3 id="1-4访问标志与继承信息"><a href="#1-4访问标志与继承信息" class="headerlink" title="1.4访问标志与继承信息"></a>1.4访问标志与继承信息</h3><h3 id="1-5字段表-方法表-属性表"><a href="#1-5字段表-方法表-属性表" class="headerlink" title="1.5字段表 方法表 属性表"></a>1.5字段表 方法表 属性表</h3><h2 id="4-类加载阶段"><a href="#4-类加载阶段" class="headerlink" title="4.类加载阶段"></a>4.类加载阶段</h2><h3 id="4-1-加载"><a href="#4-1-加载" class="headerlink" title="4.1 加载"></a>4.1 加载</h3><ul><li>将类的字节码载入方法区中，内部采用 C++ 的 instanceKlass 描述 java 类，它的重要 ﬁeld 有：<ul><li>_java_mirror 即 java 的类镜像，例如对 String 来说，就是 String.class，作用是把 klass 暴 露给 java 使用 </li><li>_super 即父类 </li><li>_ﬁelds 即成员变量 </li><li>_methods 即方法 </li><li>_constants 即常量池 </li><li>_class_loader 即类加载器 </li><li>_vtable 虚方法表 </li><li>_itable 接口方法表 </li></ul></li><li>如果这个类还有父类没有加载，先加载父类 </li><li>加载和链接可能是交替运行的</li></ul><blockquote><p>注意</p><ul><li>instanceKlass 这样的【元数据】是存储在方法区（1.8 后的元空间内），但 _java_mirror 是存储在堆中  </li><li>可以通过前面介绍的 HSDB 工具查看<br><img src=".%E4%B8%89%E3%80%81%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84_images/aff35c1f.png" alt=""></li></ul></blockquote><h3 id="4-2-链接"><a href="#4-2-链接" class="headerlink" title="4.2 链接"></a>4.2 链接</h3><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>验证类是否符合 JVM规范，安全性检查</p><p>用 UE 等支持二进制的编辑器修改 HelloWorld.class 的魔数，在控制台运行</p><pre><code>E:\git\jvm\out\production\jvm&gt;java cn.itcast.jvm.t5.HelloWorld Error: A JNI error has occurred, please check your installation and try again Exception in thread &quot;main&quot; java.lang.ClassFormatError: Incompatible magic value 3405691578 in class file cn/itcast/jvm/t5/HelloWorld       at java.lang.ClassLoader.defineClass1(Native Method)       at java.lang.ClassLoader.defineClass(ClassLoader.java:763)       at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142)       at java.net.URLClassLoader.defineClass(URLClassLoader.java:467)       at java.net.URLClassLoader.access$100(URLClassLoader.java:73)       at java.net.URLClassLoader$1.run(URLClassLoader.java:368)       at java.net.URLClassLoader$1.run(URLClassLoader.java:362)       at java.security.AccessController.doPrivileged(Native Method)       at java.net.URLClassLoader.findClass(URLClassLoader.java:361)       at java.lang.ClassLoader.loadClass(ClassLoader.java:424)       at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:331)       at java.lang.ClassLoader.loadClass(ClassLoader.java:357)       at sun.launcher.LauncherHelper.checkAndLoadMain(LauncherHelper.java:495)</code></pre><p>1.文件格式验证：①是否以魔数开头②③</p><p>2.元数据验证：①这个类是否有父类(除了Object都有父类)②③    </p><p>3.字节码验证：对类的方法体校验①②保证跳转指令不会跳转到方法体以外的字节码指令上③</p><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>为 static 变量分配空间，设置默认值</p><ul><li>static 变量在 JDK 7 之前存储于 instanceKlass 末尾，从 JDK 7 开始，存储于 _java_mirror 末尾 </li><li>static 变量分配空间和赋值是两个步骤，分配空间在准备阶段完成，赋值在初始化阶段完成 </li><li>如果 static 变量是 ﬁnal 的基本类型，以及字符串常量，那么编译阶段值就确定了，赋值在准备阶 段完成 </li><li>如果 static 变量是 ﬁnal 的，但属于引用类型，那么赋值也会在初始化阶段完成 </li></ul><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>将常量池中的符号引用解析为直接引用。</p><p>解析动作主要针对：类或接口(CONSTANT_Class_info)、字段(CONSTANT_Fieldref_info)、类方法(CONSTANT_Methodref_info)、接口方法、方法类型等7类符号引用进行。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> cn<span class="token punctuation">.</span>itcast<span class="token punctuation">.</span>jvm<span class="token punctuation">.</span>t3<span class="token punctuation">.</span>load<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/**  * 解析的含义  */</span> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Load2</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> ClassNotFoundException<span class="token punctuation">,</span> IOException <span class="token punctuation">{</span>      ClassLoader classloader <span class="token operator">=</span> Load2<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// loadClass 方法不会导致类的解析和初始化</span>      Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> c <span class="token operator">=</span> classloader<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token string">"cn.itcast.jvm.t3.load.C"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// new C(); </span>        System<span class="token punctuation">.</span>in<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">C</span> <span class="token punctuation">{</span>   D d <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">D</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">D</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><p>符号引用：在Class文件中它以CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等类型的常量出现</p><p>直接引用：可以是直接指向目标的指针、相对偏移量或是一个能定位到目标的句柄。</p><p>1.类或接口的解析：    假设当前所处的类为D</p><p>如果要把一个未解析过的符号引用N解析为一个类或接口C的直接引用，如果C是一个类，那么虚拟机将会把代表N的全限定名传递给D的类加载器去加载;如果过程成功，那么C在虚拟机中就成为一个有效的类或接口了。</p><h3 id="4-3-初始化"><a href="#4-3-初始化" class="headerlink" title="4.3 初始化"></a>4.3 初始化</h3><p><code>&lt;cinit&gt;()V</code> 方法</p><p>初始化即调用 <code>&lt;cinit&gt;()V</code> ，虚拟机会保证这个类的『构造方法』的线程安全</p><p>发生的时机</p><p>概括得说，类初始化是【懒惰的】</p><ul><li>main 方法所在的类，总会被首先初始化 </li><li>首次访问这个类的静态变量或静态方法时 </li><li>子类初始化，如果父类还没初始化，会引发 </li><li>子类访问父类的静态变量，只会触发父类的初始化</li><li>Class.forName </li><li>new 会导致初始化</li></ul><p>不会导致类初始化的情况</p><ul><li>访问类的 static ﬁnal 静态常量（基本类型和字符串）不会触发初始化</li><li>类对象.class 不会触发初始化 </li><li>创建该类的数组不会触发初始化 </li><li>类加载器的 loadClass 方法 </li><li>Class.forName 的参数 2 为 false 时</li></ul><p>实验</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>     <span class="token keyword">static</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token keyword">static</span> <span class="token punctuation">{</span>       System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"a init"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token keyword">extends</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token keyword">double</span> b <span class="token operator">=</span> <span class="token number">5.0</span><span class="token punctuation">;</span>     <span class="token keyword">static</span> <span class="token keyword">boolean</span> c <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>     <span class="token keyword">static</span> <span class="token punctuation">{</span>       System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"b init"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>验证（实验时请先全部注释，每次只执行其中一个）</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Load3</span> <span class="token punctuation">{</span>        <span class="token keyword">static</span> <span class="token punctuation">{</span>       System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"main init"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> ClassNotFoundException <span class="token punctuation">{</span>           <span class="token comment" spellcheck="true">// 1. 静态常量（基本类型和字符串）不会触发初始化 </span>          System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>B<span class="token punctuation">.</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// 2. 类对象.class 不会触发初始化 </span>          System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>B<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// 3. 创建该类的数组不会触发初始化 </span>          System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">B</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// 4. 不会初始化类 B，但会加载 B、A </span>          ClassLoader cl <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getContextClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                                 cl<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token string">"cn.itcast.jvm.t3.B"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// 5. 不会初始化类 B，但会加载 B、A </span>          ClassLoader c2 <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getContextClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"cn.itcast.jvm.t3.B"</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> c2<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 1. 首次访问这个类的静态变量或静态方法时 </span>          System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>A<span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// 2. 子类初始化，如果父类还没初始化，会引发 </span>          System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>B<span class="token punctuation">.</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// 3. 子类访问父类静态变量，只触发父类初始化 </span>          System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>B<span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// 4. 会初始化类 B，并先初始化类 A </span>          Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"cn.itcast.jvm.t3.B"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><p>​    关于类的卸载，在<a href="http://blog.csdn.net/zhengzhb/article/details/7331354" target="_blank" rel="noopener"><strong>单例模式讨论篇：单例模式与垃圾回收</strong></a>一文中有过描述，在类使用完之后，如果满足下面的情况，类就会被卸载：</p><ul><li>该类所有的实例都已经被回收，也就是java堆中不存在该类的任何实例。</li><li>加载该类的ClassLoader已经被回收。</li><li>该类对应的java.lang.Class对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul><p>​    如果以上三个条件全部满足，jvm就会在方法区垃圾回收的时候对类进行卸载，类的卸载过程其实就是在方法区中清空类信息，java类的整个生命周期就结束了。</p><blockquote><p> 做java的朋友对于对象的生命周期可能都比较熟悉，对象基本上都是在jvm的堆区中创建，在创建对象之前，会触发类加载（加载、连接、初始化），当类初始化完成后，根据类信息在堆区中实例化类对象，初始化非静态变量、非静态代码以及默认构造方法，当对象使用完之后会在合适的时候被jvm垃圾收集器回收。读完本文后我们知道，对象的生命周期只是类的生命周期中使用阶段的主动引用的一种情况（即实例化类对象）。而类的整个生命周期则要比对象的生命周期长的多。</p></blockquote><h3 id="4-4-练习"><a href="#4-4-练习" class="headerlink" title="4.4 练习"></a>4.4 练习</h3><p>从字节码分析，使用 a，b，c 这三个常量是否会导致 E 初始化 </p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Load4</span> <span class="token punctuation">{</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>       System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>E<span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>       System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>E<span class="token punctuation">.</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>       System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>E<span class="token punctuation">.</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">E</span> <span class="token punctuation">{</span>     <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>     <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String b <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>     <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Integer c <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><p>典型应用 - 完成懒惰初始化单例模式</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>        <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 内部类中保存单例 </span>      <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">LazyHolder</span> <span class="token punctuation">{</span>                <span class="token keyword">static</span> <span class="token keyword">final</span> Singleton INSTANCE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>   <span class="token comment" spellcheck="true">// 第一次调用 getInstance 方法，才会导致内部类加载和初始化其静态成员 </span>      <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> LazyHolder<span class="token punctuation">.</span>INSTANCE<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>以上的实现特点是：</p><ul><li>懒惰实例化 </li><li>初始化时的线程安全是有保障的</li></ul><h2 id="5-类加载器"><a href="#5-类加载器" class="headerlink" title="5.类加载器"></a>5.类加载器</h2><p>以 JDK 8 为例： </p><table><thead><tr><th>名称</th><th>加载哪的类</th><th>说明</th></tr></thead><tbody><tr><td>Bootstrap ClassLoader</td><td>JAVA_HOME/jre/lib</td><td>无法直接访问</td></tr><tr><td>Extension ClassLoader</td><td>JAVA_HOME/jre/lib/ext</td><td>上级为 Bootstrap，显示为 null</td></tr><tr><td>Application ClassLoader</td><td>classpath</td><td>上级为 Extension</td></tr><tr><td>自定义类加载器</td><td>自定义</td><td>上级为 Application</td></tr></tbody></table><h3 id="5-1-启动类加载器"><a href="#5-1-启动类加载器" class="headerlink" title="5.1 启动类加载器"></a>5.1 启动类加载器</h3><p>用 Bootstrap 类加载器加载类：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> cn<span class="token punctuation">.</span>itcast<span class="token punctuation">.</span>jvm<span class="token punctuation">.</span>t3<span class="token punctuation">.</span>load<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">F</span> <span class="token punctuation">{</span>     <span class="token keyword">static</span> <span class="token punctuation">{</span>       System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"bootstrap F init"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre><p>执行</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> cn<span class="token punctuation">.</span>itcast<span class="token punctuation">.</span>jvm<span class="token punctuation">.</span>t3<span class="token punctuation">.</span>load<span class="token punctuation">;</span> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Load5_1</span> <span class="token punctuation">{</span>     <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> ClassNotFoundException <span class="token punctuation">{</span>       Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> aClass <span class="token operator">=</span> Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"cn.itcast.jvm.t3.load.F"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>aClass<span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre><p>输出</p><pre><code>E:\git\jvm\out\production\jvm&gt;java -Xbootclasspath/a:. cn.itcast.jvm.t3.load.Load5 bootstrap F init null</code></pre><ul><li>-Xbootclasspath 表示设置 bootclasspath </li><li>其中 /a:. 表示将当前目录追加至 bootclasspath 之后 </li><li>可以用这个办法替换核心类<ul><li>java -Xbootclasspath:<new bootclasspath> </li><li>java -Xbootclasspath/a:&lt;追加路径&gt; //后面追加</li><li>java -Xbootclasspath/p:&lt;追加路径&gt;//前面追加</li></ul></li></ul><h3 id="5-2-扩展类加载器"><a href="#5-2-扩展类加载器" class="headerlink" title="5.2 扩展类加载器"></a>5.2 扩展类加载器</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> cn<span class="token punctuation">.</span>itcast<span class="token punctuation">.</span>jvm<span class="token punctuation">.</span>t3<span class="token punctuation">.</span>load<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">G</span> <span class="token punctuation">{</span>   <span class="token keyword">static</span> <span class="token punctuation">{</span>     System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"classpath G init"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre><p>执行</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Load5_2</span> <span class="token punctuation">{</span>     <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> ClassNotFoundException <span class="token punctuation">{</span>       Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> aClass <span class="token operator">=</span> Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"cn.itcast.jvm.t3.load.G"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>aClass<span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre><p>输出</p><pre><code>classpath G init sun.misc.Launcher$AppClassLoader@18b4aac2</code></pre><p>写一个同名的类</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> cn<span class="token punctuation">.</span>itcast<span class="token punctuation">.</span>jvm<span class="token punctuation">.</span>t3<span class="token punctuation">.</span>load<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">G</span> <span class="token punctuation">{</span>         <span class="token keyword">static</span> <span class="token punctuation">{</span>       System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ext G init"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre><p>打个 jar 包</p><pre><code>E:\git\jvm\out\production\jvm&gt;jar -cvf my.jar cn/itcast/jvm/t3/load/G.class 已添加清单 正在添加: cn/itcast/jvm/t3/load/G.class(输入 = 481) (输出 = 322)(压缩了 33%)</code></pre><p>将 jar 包拷贝到 JAVA_HOME/jre/lib/ext </p><p>重新执行 Load5_2 </p><p>输出</p><pre><code>ext G init sun.misc.Launcher$ExtClassLoader@29453f44</code></pre><h3 id="5-3-双亲委派模式"><a href="#5-3-双亲委派模式" class="headerlink" title="5.3 双亲委派模式"></a>5.3 双亲委派模式</h3><p>所谓的双亲委派，就是指调用类加载器的 loadClass 方法时，查找类的规则 </p><blockquote><p>注意 :这里的双亲，翻译为上级似乎更为合适，因为它们并没有继承关系</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">loadClass</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> <span class="token keyword">boolean</span> resolve<span class="token punctuation">)</span> <span class="token keyword">throws</span> ClassNotFoundException <span class="token punctuation">{</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token function">getClassLoadingLock</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 1. 检查该类是否已经加载</span>            Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> c <span class="token operator">=</span> <span class="token function">findLoadedClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">long</span> t0 <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token comment" spellcheck="true">// 2. 有上级的话，委派上级</span>                        loadClass c <span class="token operator">=</span> parent<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                        <span class="token comment" spellcheck="true">// 3. 如果没有上级了（ExtClassLoader），则委派</span>                        BootstrapClassLoader c <span class="token operator">=</span> <span class="token function">findBootstrapClassOrNull</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">long</span> t1 <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 4. 每一层找不到，调用 findClass 方法（每个类加载器自己扩展）来加载</span>                    c <span class="token operator">=</span> <span class="token function">findClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 5. 记录耗时</span>                    sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span>PerfCounter<span class="token punctuation">.</span><span class="token function">getParentDelegationTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addTime</span><span class="token punctuation">(</span>t1 <span class="token operator">-</span> t0<span class="token punctuation">)</span><span class="token punctuation">;</span>                    sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span>PerfCounter<span class="token punctuation">.</span><span class="token function">getFindClassTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addElapsedTimeFrom</span><span class="token punctuation">(</span>t1<span class="token punctuation">)</span><span class="token punctuation">;</span>                    sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span>PerfCounter<span class="token punctuation">.</span><span class="token function">getFindClasses</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">resolveClass</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> c<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p>例如：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Load5_3</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> ClassNotFoundException <span class="token punctuation">{</span>        Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> aClass <span class="token operator">=</span> Load5_3<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token string">"cn.itcast.jvm.t3.load.H"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>aClass<span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>执行流程为：</p><ol><li><p><code>sun.misc.Launcher$AppClassLoader</code> //1 处， 开始查看已加载的类，结果没有</p></li><li><p><code>sun.misc.Launcher$AppClassLoader</code>  // 2 处，委派上级 <code>sun.misc.Launcher$ExtClassLoader.loadClass()</code></p></li><li><p><code>sun.misc.Launcher$ExtClassLoader</code> // 1 处，查看已加载的类，结果没有 </p></li><li><p><code>sun.misc.Launcher$ExtClassLoader</code> // 3 处，没有上级了，则委派 <code>BootstrapClassLoader</code>查找</p></li><li><p><code>BootstrapClassLoader</code> 是在 JAVA_HOME/jre/lib 下找 H 这个类，显然没有</p></li><li><p><code>sun.misc.Launcher$ExtClassLoader</code> // 4 处，调用自己的 ﬁndClass 方法，是在<code>JAVA_HOME/jre/lib/ext</code> 下找 H 这个类，显然没有，回到 <code>sun.misc.Launcher$AppClassLoader</code> 的 // 2 处 </p></li><li><p>继续执行到 <code>sun.misc.Launcher$AppClassLoader</code> // 4 处，调用它自己的 ﬁndClass 方法，在classpath 下查找，找到了</p></li></ol><h3 id="5-4-线程上下文类加载器"><a href="#5-4-线程上下文类加载器" class="headerlink" title="5.4 线程上下文类加载器"></a>5.4 线程上下文类加载器</h3><p>我们在使用 JDBC 时，都需要加载 Driver 驱动，不知道你注意到没有，不写</p><pre class=" language-JAVA"><code class="language-JAVA">Class.forName("com.mysql.jdbc.Driver")</code></pre><p>也是可以让 <code>com.mysql.jdbc.Driver</code> 正确加载的，你知道是怎么做的吗？</p><p>让我们追踪一下源码：</p><pre class=" language-JAVA"><code class="language-JAVA">public class DriverManager {    // 注册驱动的集合     private final static CopyOnWriteArrayList<DriverInfo> registeredDrivers = new CopyOnWriteArrayList<>();    // 初始化驱动     static {        loadInitialDrivers();        println("JDBC DriverManager initialized");    }}</code></pre><p>先不看别的，看看 <code>DriverManager</code> 的类加载器：</p><pre class=" language-JAVA"><code class="language-JAVA">System.out.println(DriverManager.class.getClassLoader());</code></pre><p>打印 <code>null</code>，表示它的类加载器是 <code>Bootstrap ClassLoader</code>，会到 <code>JAVA_HOME/jre/lib</code> 下搜索类，但 JAVA_HOME/jre/lib 下显然没有 <code>mysql-connector-java-5.1.47.jar</code> 包，这样问题来了，在 <code>DriverManager</code> 的静态代码块中，怎么能正确加载 <code>com.mysql.jdbc.Driver</code> 呢？</p><p>继续看 <code>loadInitialDrivers()</code> 方法：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">loadInitialDrivers</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        String drivers<span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            drivers <span class="token operator">=</span> AccessController<span class="token punctuation">.</span><span class="token function">doPrivileged</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">PrivilegedAction</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">public</span> String <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">return</span> System<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"jdbc.drivers"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>            drivers <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 1）使用 ServiceLoader 机制加载驱动，即 SPI </span>        AccessController<span class="token punctuation">.</span><span class="token function">doPrivileged</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">PrivilegedAction</span><span class="token operator">&lt;</span>Void<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">public</span> Void <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                ServiceLoader<span class="token operator">&lt;</span>Driver<span class="token operator">></span> loadedDrivers <span class="token operator">=</span> ServiceLoader<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>Driver<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                Iterator<span class="token operator">&lt;</span>Driver<span class="token operator">></span> driversIterator <span class="token operator">=</span> loadedDrivers<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    <span class="token keyword">while</span> <span class="token punctuation">(</span>driversIterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        driversIterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// Do nothing </span>                <span class="token punctuation">}</span>                <span class="token keyword">return</span> null<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"DriverManager.initialize: jdbc.drivers = "</span> <span class="token operator">+</span> drivers<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 2）使用 jdbc.drivers 定义的驱动名加载驱动 </span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>drivers <span class="token operator">==</span> null <span class="token operator">||</span> drivers<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        String<span class="token punctuation">[</span><span class="token punctuation">]</span> driversList <span class="token operator">=</span> drivers<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">":"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"number of Drivers:"</span> <span class="token operator">+</span> driversList<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>String aDriver <span class="token operator">:</span> driversList<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"DriverManager.Initialize: loading "</span> <span class="token operator">+</span> aDriver<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 这里的 ClassLoader.getSystemClassLoader() 就是应用程序类加载器 </span>                Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>aDriver<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> ClassLoader<span class="token punctuation">.</span><span class="token function">getSystemClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"DriverManager.Initialize: load failed: "</span> <span class="token operator">+</span> ex<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p>先看 2）发现它最后是使用 Class.forName 完成类的加载和初始化，关联的是应用程序类加载器，因此 可以顺利完成类加载 </p><p>再看 1）它就是大名鼎鼎的 Service Provider Interface （SPI） </p><p>约定如下，在 jar 包的 META-INF/services 包下，以接口全限定名名为文件，文件内容是实现类名称 </p><p><img src=".%E4%B8%89%E3%80%81%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84_images/755077f7.png" alt=""><br>这样就可以使用</p><pre class=" language-java"><code class="language-java">ServiceLoader<span class="token operator">&lt;</span>接口类型<span class="token operator">></span> allImpls <span class="token operator">=</span> ServiceLoader<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>接口类型<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span> Iterator<span class="token operator">&lt;</span>接口类型<span class="token operator">></span> iter <span class="token operator">=</span> allImpls<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">while</span><span class="token punctuation">(</span>iter<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   iter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>来得到实现类，体现的是【面向接口编程 +解耦】的思想，在下面一些框架中都运用了此思想：</p><ul><li>JDBC</li><li>Servlet 初始化器 </li><li>Spring 容器 </li><li>Dubbo（对 SPI 进行了扩展）</li></ul><p>接着看 <code>ServiceLoader.load</code> 方法：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>S<span class="token operator">></span> ServiceLoader<span class="token operator">&lt;</span>S<span class="token operator">></span> <span class="token function">load</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span>S<span class="token operator">></span> service<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">// 获取线程上下文类加载器 </span>  ClassLoader cl <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getContextClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> ServiceLoader<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>service<span class="token punctuation">,</span> cl<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><p>线程上下文类加载器是当前线程使用的类加载器，默认就是应用程序类加载器，它内部又是由 Class.forName 调用了线程上下文类加载器完成类加载，具体代码在 <code>ServiceLoader</code> 的内部类 <code>LazyIterator</code> 中：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> S <span class="token function">nextService</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">hasNextService</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NoSuchElementException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String cn <span class="token operator">=</span> nextName<span class="token punctuation">;</span>        nextName <span class="token operator">=</span> null<span class="token punctuation">;</span>        Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> c <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            c <span class="token operator">=</span> Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>cn<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> loader<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">fail</span><span class="token punctuation">(</span>service<span class="token punctuation">,</span><span class="token string">"Provider "</span> <span class="token operator">+</span> cn <span class="token operator">+</span> <span class="token string">" not found"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>service<span class="token punctuation">.</span><span class="token function">isAssignableFrom</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token function">fail</span><span class="token punctuation">(</span>service<span class="token punctuation">,</span> <span class="token string">"Provider "</span> <span class="token operator">+</span> cn <span class="token operator">+</span> <span class="token string">" not a subtype"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            S p <span class="token operator">=</span> service<span class="token punctuation">.</span><span class="token function">cast</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            providers<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>cn<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> p<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">fail</span><span class="token punctuation">(</span>service<span class="token punctuation">,</span> <span class="token string">"Provider "</span> <span class="token operator">+</span> cn <span class="token operator">+</span> <span class="token string">" could not be instantiated"</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// This cannot happen</span>    <span class="token punctuation">}</span></code></pre><h3 id="5-5-自定义类加载器"><a href="#5-5-自定义类加载器" class="headerlink" title="5.5 自定义类加载器"></a>5.5 自定义类加载器</h3><p>问问自己，什么时候需要自定义类加载器</p><ul><li>1）想加载非 classpath 随意路径中的类文件 </li><li>2）都是通过接口来使用实现，希望解耦时，常用在框架设计 </li><li>3）这些类希望予以隔离，不同应用的同名类都可以加载，不冲突，常见于 tomcat 容器</li></ul><p>步骤：</p><ol><li>继承 ClassLoader 父类</li><li>要遵从双亲委派机制，重写 ﬁndClass 方法 注意不是重写 loadClass 方法，否则不会走双亲委派机制</li><li>读取类文件的字节码</li><li>调用父类的 deﬁneClass 方法来加载类</li><li>使用者调用该类加载器的 loadClass 方法 示例： 准备好两个类文件放入 E:\myclasspath，它实现了 java.util.Map 接口，可以先反编译看一下：</li></ol><h2 id="6-运行期优化"><a href="#6-运行期优化" class="headerlink" title="6.运行期优化"></a>6.运行期优化</h2><h3 id="6-1-即时编译"><a href="#6-1-即时编译" class="headerlink" title="6.1 即时编译"></a>6.1 即时编译</h3><h4 id="分层编译"><a href="#分层编译" class="headerlink" title="分层编译"></a>分层编译</h4><p>（TieredCompilation） 先来个例子</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JIT1</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">200</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">long</span> start <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">long</span> end <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\t%d\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre><code>0    1199751    671362    756953    589784    673135    608766    563827    619518    600869    5472110    6821711    6312512    6225213    5910714    6217915    6296716    6075917    5817418    5905119    6275220    7124821    5523622    5834223    6194024    6200825    6477626    6149627    7574828    6598329    12739830    6644431    6465132    6923833    6613134    6418735    6360736    6558437    6417438    5785539    5722440    5823741    7663642    4333143    6172644    5868245    6025246    6208347    4289948    3970449    5931350    9448651    6748152    6129153    6386854    6335455    6703756    6030457    6224558    6526159    6209360    12218161    6595862    8391163    2890364    2391365    2577166    2174567    2387068    2176769    2524570    9494471    1904172    2033273    2184174    2178075    1980276    2087877    30463978    2930379    2376680    2191381    2563382    2353983    2252784    2443585    2861686    2083887    2045088    2394589    2418490    2395991    2339692    2211593    2742094    2755695    2311496    2684097    3018198    3116099    24057100    26253101    157559102    151652103    23938104    30776105    26687106    19810107    25983108    24691109    25251110    33804111    22614112    18195113    22940114    24277115    23970116    21482117    24731118    120710119    31968120    634121    489122    558123    528124    501125    542126    578127    473128    646129    528130    534131    572132    606133    568134    561135    575136    469137    538138    732139    482140    572141    466142    658143    549144    613145    575146    726147    572148    556149    506150    614151    565152    639153    621154    677155    583156    617157    460158    599159    444160    517161    471162    508163    701164    624165    563166    695167    689168    643169    572170    418171    643172    489173    530174    635175    569176    606177    489178    861179    618180    608181    553182    491183    589184    603185    733186    455187    425188    513189    700190    769191    615192    595193    496194    529195    561196    529197    423198    554199    500</code></pre><p>原因是什么呢？</p><p>JVM 将执行状态分成了 5 个层次：</p><ul><li>0 层，解释执行（Interpreter） </li><li>1 层，使用 C1 即时编译器编译执行（不带 proﬁling） </li><li>2 层，使用 C1 即时编译器编译执行（带基本的 proﬁling） </li><li>3 层，使用 C1 即时编译器编译执行（带完全的 proﬁling） </li><li>4 层，使用 C2 即时编译器编译执行</li></ul><blockquote><p>proﬁling 是指在运行过程中收集一些程序执行状态的数据，例如【方法的调用次数】，【循环的 回边次数】等</p></blockquote><p>即时编译器（JIT）与解释器的区别</p><ul><li>解释器是将字节码解释为机器码，下次即使遇到相同的字节码，仍会执行重复的解释</li><li>JIT 是将一些字节码编译为机器码，并存入 Code Cache，下次遇到相同的代码，直接执行，无需 再编译 解释器是将字节码解释为针对所有平台都通用的机器码 JIT 会根据平台类型，生成平台特定的机器码</li></ul><p>对于占据大部分的不常用的代码，我们无需耗费时间将其编译成机器码，而是采取解释执行的方式运 行；另一方面，对于仅占据小部分的热点代码，我们则可以将其编译成机器码，以达到理想的运行速 度。 执行效率上简单比较一下 Interpreter &lt; C1 &lt; C2，总的目标是发现热点代码（hotspot名称的由 来），优化之</p><p>刚才的一种优化手段称之为【逃逸分析】，发现新建的对象是否逃逸。可以使用 -XX:DoEscapeAnalysis 关闭逃逸分析，再运行刚才的示例观察结果</p><p>参考资料： <a href="https://docs.oracle.com/en/java/javase/12/vm/java-hotspot-virtual-machineperformance-enhancements.html#GUID-D2E3DC58-D18B-4A6C-8167-4A1DFB4888E4" target="_blank" rel="noopener">https://docs.oracle.com/en/java/javase/12/vm/java-hotspot-virtual-machineperformance-enhancements.html#GUID-D2E3DC58-D18B-4A6C-8167-4A1DFB4888E4</a></p><h4 id="方法内联"><a href="#方法内联" class="headerlink" title="方法内联"></a>方法内联</h4><p>（Inlining）</p><pre class=" language-JAVA"><code class="language-JAVA">private static int square(final int i) {   return i * i; }System.out.println(square(9));</code></pre><p>如果发现 square 是热点方法，并且长度不太长时，会进行内联，所谓的内联就是把方法内代码拷贝、 粘贴到调用者的位置：</p><pre class=" language-java"><code class="language-java">System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token number">9</span> <span class="token operator">*</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>还能够进行常量折叠（constant folding）的优化 </p><pre><code>System.out.println(81);</code></pre><p>实验：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JIT2</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">// -XX:+UnlockDiagnosticVMOptions -XX:+PrintInlining （解锁隐藏参数）打印 inlining 信息 </span>    <span class="token comment" spellcheck="true">// -XX:CompileCommand=dontinline,*JIT2.square 禁止某个方法 inlining </span>    <span class="token comment" spellcheck="true">// -XX:+PrintCompilation 打印编译信息</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">500</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">long</span> start <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                x <span class="token operator">=</span> <span class="token function">square</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">long</span> end <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\t%d\t%d\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> x<span class="token punctuation">,</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">square</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> i <span class="token operator">*</span> i<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="字段优化"><a href="#字段优化" class="headerlink" title="字段优化"></a>字段优化</h4><p>JMH 基准测试请参考：<a href="http://openjdk.java.net/projects/code-tools/jmh/" target="_blank" rel="noopener">http://openjdk.java.net/projects/code-tools/jmh/</a></p><p>创建 maven 工程，添加依赖如下</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.openjdk.jmh<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>jmh-core<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>${jmh.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.openjdk.jmh<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>jmh-generator-annprocess<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>${jmh.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>provided<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><p>编写基准测试代码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> test<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>openjdk<span class="token punctuation">.</span>jmh<span class="token punctuation">.</span>annotations<span class="token punctuation">.</span>*<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>openjdk<span class="token punctuation">.</span>jmh<span class="token punctuation">.</span>runner<span class="token punctuation">.</span>Runner<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>openjdk<span class="token punctuation">.</span>jmh<span class="token punctuation">.</span>runner<span class="token punctuation">.</span>RunnerException<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>openjdk<span class="token punctuation">.</span>jmh<span class="token punctuation">.</span>runner<span class="token punctuation">.</span>options<span class="token punctuation">.</span>Options<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>openjdk<span class="token punctuation">.</span>jmh<span class="token punctuation">.</span>runner<span class="token punctuation">.</span>options<span class="token punctuation">.</span>OptionsBuilder<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Random<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>ThreadLocalRandom<span class="token punctuation">;</span><span class="token annotation punctuation">@Warmup</span><span class="token punctuation">(</span>iterations <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> time <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Measurement</span><span class="token punctuation">(</span>iterations <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">,</span> time <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token annotation punctuation">@State</span><span class="token punctuation">(</span>Scope<span class="token punctuation">.</span>Benchmark<span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Benchmark1</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> elements <span class="token operator">=</span> <span class="token function">randomInts</span><span class="token punctuation">(</span>1_000<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">randomInts</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Random random <span class="token operator">=</span> ThreadLocalRandom<span class="token punctuation">.</span><span class="token function">current</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> values <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>size<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            values<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> random<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> values<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Benchmark</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> elements<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">doSum</span><span class="token punctuation">(</span>elements<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Benchmark</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> local <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>elements<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> local<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">doSum</span><span class="token punctuation">(</span>local<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Benchmark</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> element <span class="token operator">:</span> elements<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">doSum</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@CompilerControl</span><span class="token punctuation">(</span>CompilerControl<span class="token punctuation">.</span>Mode<span class="token punctuation">.</span>INLINE<span class="token punctuation">)</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">doSum</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        sum <span class="token operator">+=</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> RunnerException <span class="token punctuation">{</span>        Options opt <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">OptionsBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">include</span><span class="token punctuation">(</span>Benchmark1<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getSimpleName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forks</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Runner</span><span class="token punctuation">(</span>opt<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>首先启用 doSum 的方法内联，测试结果如下（每秒吞吐量，分数越高的更好）：</p><pre><code>Benchmark                         Mode     Samples      Score      Score error   Unitst.Benchmark1.test1    thrpt      5       2420286.539    390747.467    ops/st.Benchmark1.test2    thrpt             5       2544313.594    91304.136     ops/st.Benchmark1.test3    thrpt             5       2469176.697    450570.647    ops/s </code></pre><p>接下来禁用 doSum 方法内联</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@CompilerControl</span><span class="token punctuation">(</span>CompilerControl<span class="token punctuation">.</span>Mode<span class="token punctuation">.</span>DONT_INLINE<span class="token punctuation">)</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">doSum</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>       sum <span class="token operator">+=</span> x<span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><p>测试结果如下：</p><pre><code>Benchmark                         Mode     Samples      Score      Score error    Unitst.Benchmark1.test1    thrpt      5          296141.478     63649.220         ops/st.Benchmark1.test2    thrpt             5          371262.351     83890.984         ops/st.Benchmark1.test3    thrpt             5          368960.847     60163.391         ops/s </code></pre><p>分析： 在刚才的示例中，doSum 方法是否内联会影响 elements 成员变量读取的优化： 如果 doSum 方法内联了，刚才的 test1 方法会被优化成下面的样子（伪代码）：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Benchmark</span> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">// elements.length 首次读取会缓存起来 -> int[] local </span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> elements<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">// 后续 999 次 求长度 &lt;- local </span>    sum <span class="token operator">+=</span> elements<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 1000 次取下标 i 的元素 &lt;- local </span>  <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre><p>可以节省 1999 次 Field 读取操作 但如果 doSum 方法没有内联，则不会进行上面的优化</p><p>练习：在内联情况下将 elements 添加 volatile 修饰符，观察测试结果 </p><h3 id="6-2-反射优化"><a href="#6-2-反射优化" class="headerlink" title="6.2 反射优化"></a>6.2 反射优化</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> cn<span class="token punctuation">.</span>itcast<span class="token punctuation">.</span>jvm<span class="token punctuation">.</span>t3<span class="token punctuation">.</span>reflect<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>IOException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>InvocationTargetException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>Method<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Reflect1</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"foo..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        Method foo <span class="token operator">=</span> Reflect1<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">"foo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">16</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\t"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>            foo<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>in<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><code>foo.invoke</code> 前面 0 ~ 15 次调用使用的是 <code>MethodAccessor</code> 的 <code>NativeMethodAccessorImpl</code> 实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> sun<span class="token punctuation">.</span>reflect<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>InvocationTargetException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>Method<span class="token punctuation">;</span><span class="token keyword">import</span> sun<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>misc<span class="token punctuation">.</span>ReflectUtil<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">NativeMethodAccessorImpl</span> <span class="token keyword">extends</span> <span class="token class-name">MethodAccessorImpl</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> Method method<span class="token punctuation">;</span>    <span class="token keyword">private</span> DelegatingMethodAccessorImpl parent<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> numInvocations<span class="token punctuation">;</span>    <span class="token function">NativeMethodAccessorImpl</span><span class="token punctuation">(</span>Method method<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>method <span class="token operator">=</span> method<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> Object <span class="token function">invoke</span><span class="token punctuation">(</span>Object target<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IllegalArgumentException<span class="token punctuation">,</span> InvocationTargetException <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// inflationThreshold 膨胀阈值，默认 15 </span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span><span class="token keyword">this</span><span class="token punctuation">.</span>numInvocations <span class="token operator">></span> ReflectionFactory<span class="token punctuation">.</span><span class="token function">inflationThreshold</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>ReflectUtil<span class="token punctuation">.</span><span class="token function">isVMAnonymousClass</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>method<span class="token punctuation">.</span><span class="token function">getDeclaringClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 使用 ASM 动态生成的新实现代替本地实现，速度较本地实现快 20 倍左右</span>            MethodAccessorImpl generatedMethodAccessor <span class="token operator">=</span>                     <span class="token punctuation">(</span>MethodAccessorImpl<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MethodAccessorGenerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                            <span class="token punctuation">.</span><span class="token function">generateMethod</span><span class="token punctuation">(</span>                                    <span class="token keyword">this</span><span class="token punctuation">.</span>method<span class="token punctuation">.</span><span class="token function">getDeclaringClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                     <span class="token keyword">this</span><span class="token punctuation">.</span>method<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                     <span class="token keyword">this</span><span class="token punctuation">.</span>method<span class="token punctuation">.</span><span class="token function">getParameterTypes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                    <span class="token keyword">this</span><span class="token punctuation">.</span>method<span class="token punctuation">.</span><span class="token function">getReturnType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                     <span class="token keyword">this</span><span class="token punctuation">.</span>method<span class="token punctuation">.</span><span class="token function">getExceptionTypes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                     <span class="token keyword">this</span><span class="token punctuation">.</span>method<span class="token punctuation">.</span><span class="token function">getModifiers</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                            <span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>parent<span class="token punctuation">.</span><span class="token function">setDelegate</span><span class="token punctuation">(</span>generatedMethodAccessor<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>             <span class="token comment" spellcheck="true">// 调用本地实现 </span>         <span class="token keyword">return</span> <span class="token function">invoke0</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>method<span class="token punctuation">,</span> target<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">setParent</span><span class="token punctuation">(</span>DelegatingMethodAccessorImpl parent<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>parent <span class="token operator">=</span> parent<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">native</span> Object <span class="token function">invoke0</span><span class="token punctuation">(</span>Method method<span class="token punctuation">,</span> Object target<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>当调用到第 16 次（从0开始算）时，会采用运行时生成的类代替掉最初的实现，可以通过 debug 得到 类名为 sun.reﬂect.GeneratedMethodAccessor1</p><p>可以使用阿里的 arthas 工具：</p><pre><code>java -jar arthas-boot.jar [INFO] arthas-boot version: 3.1.1 [INFO] Found existing java process, please choose one and hit RETURN.* [1]: 13065 cn.itcast.jvm.t3.reflect.Reflect1</code></pre><p>选择 1 回车表示分析该进程 </p><pre><code>1 [INFO] arthas home: /root/.arthas/lib/3.1.1/arthas [INFO] Try to attach process 13065 [INFO] Attach process 13065 success.[INFO] arthas-client connect 127.0.0.1 3658 ,---. ,------. ,--------.,--. ,--. ,---. ,---. / O \ | .--. &#39;&#39;--. .--&#39;| &#39;--&#39; | / O \ &#39; .-&#39; | .-. || &#39;--&#39;.&#39; | | | .--. || .-. |`. `-. | | | || |\ \ | | | | | || | | |.-&#39; `--&#39; `--&#39;`--&#39; &#39;--&#39; `--&#39; `--&#39; `--&#39;`--&#39; `--&#39;`-----&#39;|wiki https://alibaba.github.io/arthas tutorials https://alibaba.github.io/arthas/arthas-tutorials version 3.1.1 pid 13065 time 2019-06-10 12:23:54</code></pre><p>再输入【jad + 类名】来进行反编译</p><pre class=" language-java"><code class="language-java">$ jad sun<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>GeneratedMethodAccessor1ClassLoader<span class="token operator">:</span><span class="token operator">+</span><span class="token operator">-</span>sun<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>DelegatingClassLoader<span class="token annotation punctuation">@15db9742</span>    <span class="token operator">+</span><span class="token operator">-</span>sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span>Launcher$AppClassLoader<span class="token annotation punctuation">@4e0e2f2a</span>        <span class="token operator">+</span><span class="token operator">-</span>sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span>Launcher$ExtClassLoader<span class="token annotation punctuation">@2fdb006e</span>Location<span class="token operator">:</span><span class="token comment" spellcheck="true">/* * Decompiled with CFR 0_132.* * Could not load the following classes: * cn.itcast.jvm.t3.reflect.Reflect1 */</span> <span class="token keyword">package</span> sun<span class="token punctuation">.</span>reflect<span class="token punctuation">;</span><span class="token keyword">import</span> cn<span class="token punctuation">.</span>itcast<span class="token punctuation">.</span>jvm<span class="token punctuation">.</span>t3<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>Reflect1<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>InvocationTargetException<span class="token punctuation">;</span><span class="token keyword">import</span> sun<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>MethodAccessorImpl<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GeneratedMethodAccessor1</span> <span class="token keyword">extends</span> <span class="token class-name">MethodAccessorImpl</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/*     * Loose catch block * Enabled aggressive block sorting     * Enabled unnecessary exception pruning     * Enabled aggressive exception aggregation     * Lifted jumps to return sites     */</span>    <span class="token keyword">public</span> Object <span class="token function">invoke</span><span class="token punctuation">(</span>Object object<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> arrobject<span class="token punctuation">)</span> <span class="token keyword">throws</span> InvocationTargetException <span class="token punctuation">{</span>         <span class="token comment" spellcheck="true">// 比较奇葩的做法，如果有参数，那么抛非法参数异常 </span>         block4 <span class="token operator">:</span> <span class="token punctuation">{</span>              <span class="token keyword">if</span> <span class="token punctuation">(</span>arrobject <span class="token operator">==</span> null <span class="token operator">||</span> arrobject<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">break</span> block4<span class="token punctuation">;</span>              <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span> <span class="token keyword">try</span> <span class="token punctuation">{</span>              <span class="token comment" spellcheck="true">// 可以看到，已经是直接调用了    </span>             Reflect1<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// 因为没有返回值 </span>             <span class="token keyword">return</span> null<span class="token punctuation">;</span>          <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> throwable<span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InvocationTargetException</span><span class="token punctuation">(</span>throwable<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassCastException</span> <span class="token operator">|</span> NullPointerException runtimeException<span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>    <span class="token function">Affect</span><span class="token punctuation">(</span>row<span class="token operator">-</span>cnt<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">)</span> cost in 1540ms<span class="token punctuation">.</span></code></pre><blockquote><p>注意</p><p>通过查看 ReflectionFactory源码可知</p><ul><li>sun.reﬂect.noInﬂation 可以用来禁用膨胀（直接生成 GeneratedMethodAccessor1，但首 次生成比较耗时，如果仅反射调用一次，不划算） </li><li>sun.reﬂect.inﬂationThreshold 可以修改膨胀阈值 </li></ul></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/Android/UI/ImageView</title>
      <link href="blog/3089470578.html"/>
      <url>blog/3089470578.html</url>
      
        <content type="html"><![CDATA[<h1 id="ImageView"><a href="#ImageView" class="headerlink" title="ImageView"></a>ImageView</h1><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><ol><li>contentDescription: 盲人点击的时候会系统会读出来.</li></ol><p>scaletype</p><ul><li>fitcenter: 小图片放到大imageview中，放大居中,会模糊</li><li></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/Android/UI/ConstraintLayout</title>
      <link href="blog/1812463686.html"/>
      <url>blog/1812463686.html</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="ConstraintLayout-用法"><a href="#ConstraintLayout-用法" class="headerlink" title="ConstraintLayout 用法"></a>ConstraintLayout 用法</h1><p>现在AndroidStudio新建的工程默认布局就是ConstrainsLayout,之所以这样是因为Google推荐我们这么做。ConstrainsLayout是RelativeLayout改良后的一个版本，尤其适合在GUI中设计App界面。  </p><h2 id="1-constraint"><a href="#1-constraint" class="headerlink" title="1. constraint"></a>1. constraint</h2><p>一个控件(View)所在的位置由它的4个方向上的约束所确定，<strong>至少得有水平和垂直方向各1个约束</strong>。</p><ul><li>如果没有给加一个view加约束，它运行时的位置将在(0,0)处，并且该控件会有<code>！</code>提示<br><img src=".ConstraintLayout_images/c3e2148f.png" alt=""><br>在<code>Design</code>界面，<code>TextView</code>在中间<br><img src=".ConstraintLayout_images/b44bd739.png" alt=""><br>但是运行时，它实际位置在屏幕左上角。    </li><li>每拖入一个控件，都要连4个约束，太麻烦，怎么办？用魔法棒<br><img src=".ConstraintLayout_images/Apr-01-2020%2018-03-48.gif" alt=""><br>魔法棒智能的添加约束，尽可能的保持原有的位置</li></ul><ul><li>删除约束<br><img src=".ConstraintLayout_images/48eabeb7.png" alt=""><br><img src=".ConstraintLayout_images/8472cd25.png" alt="">  </li></ul><h2 id="2-pack"><a href="#2-pack" class="headerlink" title="2. pack"></a>2. pack</h2><p><img src=".ConstraintLayout_images/9f737270.png" alt=""><br><code>pack Vertically</code>:可将多个控件/view 紧凑的在垂直方向上聚拢到一起<br><code>pack Horizontally</code>:水平方向上同理<br><code>expand Horizontally</code>:将1个或多个控件在水平方向扩展直至占满父布局<br><code>expand Vertically</code>:垂直方向上同理<br> <img src=".ConstraintLayout_images/Apr-02-2020%2015-28-43.gif" alt="">    </p><h2 id="3-align（各种对齐方式-可对多个控件使用）"><a href="#3-align（各种对齐方式-可对多个控件使用）" class="headerlink" title="3. align（各种对齐方式,可对多个控件使用）"></a>3. align（各种对齐方式,可对多个控件使用）</h2><ul><li>align<br><img src=".ConstraintLayout_images/fa1d7cab.png" alt=""><br><img src=".ConstraintLayout_images/Apr-02-2020%2015-40-17.gif" alt="">    </li><li>还有一种对齐<br><img src=".ConstraintLayout_images/Apr-02-2020%2015-45-38.gif" alt="">    </li><li>两控件文字基线对齐（有这种对齐方式，但是我的studio 3.2.1按钮右键没有showbaseline,3.4有）<h2 id="4-Guidelines-辅助线"><a href="#4-Guidelines-辅助线" class="headerlink" title="4. Guidelines(辅助线)"></a>4. Guidelines(辅助线)</h2></li></ul><p><img src=".ConstraintLayout_images/76738a7c.png" alt="">  </p><blockquote><p>重点为guideline何barrier，能使我们的界面设计得更加精准</p></blockquote><ol><li>Guildline(重点)</li></ol><ul><li>只是设计阶段能看到，运行时看不到</li><li>加了之后，控件会多了可以连接的地方,可以添加多个    </li><li>移动辅助线时，所有跟他关联的控件都会同时移动<br><img src=".ConstraintLayout_images/Apr-02-2020%2016-02-09.gif" alt="">    </li><li>辅助线有个重要的好处是点击Cycle Guideline(鼠标放到guildline上)修改它的模式<ul><li>水平guideline:<ul><li>距离上边的绝对距离</li><li>距离下边的绝对距离</li><li><strong>距离上边的百分比（非常有用,实现屏幕适配）</strong>    </li></ul></li><li>垂直guideline:同理  </li></ul></li></ul><ol start="2"><li>Barrier  </li></ol><ul><li>给多个控件添加一条边界，<br><img src=".ConstraintLayout_images/Apr-02-2020%2016-25-16.gif" alt="">   </li></ul><ol start="3"><li>Group  <ul><li>可以把多个控件添加到一个group,然后操作group,比如设置group为invisiable，则在group内多个控件都将不可见</li></ul></li></ol><p>   最后，实现如下图的一个demo，在不同分辨率的屏幕下整体效果都基本一样。</p><p>   <img src=".ConstraintLayout_images/4e3c69a4.png" alt="">  </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/Java虚拟机/二、垃圾回收</title>
      <link href="blog/2728185685.html"/>
      <url>blog/2728185685.html</url>
      
        <content type="html"><![CDATA[<h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><h2 id="1-如何判断对象可以回收-是垃圾"><a href="#1-如何判断对象可以回收-是垃圾" class="headerlink" title="1. 如何判断对象可以回收/是垃圾"></a>1. 如何判断对象可以回收/是垃圾</h2><h3 id="1-1-引用计数法"><a href="#1-1-引用计数法" class="headerlink" title="1.1 引用计数法"></a>1.1 引用计数法</h3><ul><li>早期python虚拟机使用这种方法</li><li>存在2个互相引用，进而不能释放的问题</li><li>Java虚拟机没有采用这种方法<h3 id="1-2-可达性分析算法"><a href="#1-2-可达性分析算法" class="headerlink" title="1.2 可达性分析算法"></a>1.2 可达性分析算法</h3></li><li>Java 虚拟机中的垃圾回收器采用可达性分析来探索所有存活的对象</li><li>扫描堆中的对象，看是否能够沿着 GC Root对象 为起点的引用链找到该对象，找不到，表示可以 回收 </li><li>哪些对象可以作为 GC Root(是一系列对象) ?  </li></ul><p><strong>Memory Analyzer(MAT)</strong> - eclipse提供的著名的专业的Java heap 分析工具<br><img src=".%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_images/15347dc6.png" alt=""></p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 演示GC Roots,通过看list1没值和有值前后对比，看到底哪些对象可以作为根对象 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo2_2</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException<span class="token punctuation">,</span> IOException <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>Object<span class="token operator">></span> list1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        list1<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        list1<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>in<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//暂停</span>        list1 <span class="token operator">=</span> null<span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>in<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//暂停</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"end..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ol><li>使用<code>MAT</code>先用<code>jps</code>看进程id  </li><li>分别用<code>jmap</code> 在list1有值和null时抓取内存快照: <code>jmap -dump:format=b,live，file=1.bin 21384</code><ul><li>live参数表示只抓存活的，并且抓取之前会进行一次GC</li><li>format=b 表示格式为二进制</li><li>file=1.bin表示将抓取的数据存在当前文件夹下1.bin文件中</li><li>21384 是进程ID  </li></ul></li><li>用MAT打开上面的2个快照文件  </li><li>查看当前快照的GC Roots对象有哪些<br><img src=".%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_images/a5bbd703.png" alt=""><br><img src=".%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_images/65059335.png" alt="">  </li></ol><ul><li>GC Roots对象是堆中的对象，不是栈帧中的局部变量引用</li><li>Busy Monitor:被加锁的对象  </li><li>System Class:系统类对象  </li><li>Thread:活动线程栈帧内使用的对象，比如下图中list1引用的对象就是，方法参数引用的也是<br><img src=".%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_images/f65d450b.png" alt=""></li></ul><h3 id="1-3-四种引用"><a href="#1-3-四种引用" class="headerlink" title="1.3 四种引用"></a>1.3 四种引用</h3><ol><li><p><strong>强引用 (<code>StrongReference</code>)</strong> :只有所有 <code>GC Roots</code> 对象都不通过【强引用】引用该对象，该对象才能被垃圾回收</p><ol start="2"><li><strong>软引用（<code>SoftReference</code>）</strong>: <ul><li>仅有软引用引用该对象时，在垃圾回收后，内存仍不足时会再次出发垃圾回收，回收软引用 对象 </li><li>可以配合引用队列来释放软引用自身<br><img src=".%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_images/3e407324.png" alt=""></li></ul></li><li><strong>弱引用（<code>WeakReference</code>）</strong>: <ul><li>仅有弱引用引用该对象时，在垃圾回收时，无论内存是否充足，都会回收弱引用对象 </li><li>可以配合引用队列来释放弱引用自身</li></ul></li><li><strong>虚引用（<code>PhantomReference</code>）</strong>: 必须配合引用队列使用，主要配合 <code>ByteBuﬀer</code> 使用，被引用对象回收时，会将虚引用入队， 由 <code>Reference Handler</code> 线程调用虚引用相关方法释放直接内存</li><li><strong>终结器引用（<code>FinalReference</code>）</strong>: 无需手动编码，但其内部配合引用队列使用，在垃圾回收时，终结器引用入队（被引用对象 暂时没有被回收），再由 <code>Finalizer</code> 线程通过终结器引用找到被引用对象并调用它的 ﬁnalize 方法，第二次 GC 时才能回收被引用对象  </li></ol><p><strong>例：软引用</strong></p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//加上虚拟机参数 -Xmx20m -XX:+PrintGCDetails -verbose:gc  再执行下面代码terminal中观察内存使用情况</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo2_3</span> <span class="token punctuation">{</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> _4MB <span class="token operator">=</span> <span class="token number">4</span> <span class="token operator">*</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">;</span> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/*List&lt;byte[]> list = new ArrayList&lt;>();    for (int i = 0; i &lt; 5; i++) {        list.add(new byte[_4MB]);    }    System.in.read();*/</span>    <span class="token function">soft</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">soft</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// list --> SoftReference --> byte[]</span>    List<span class="token operator">&lt;</span>SoftReference<span class="token operator">&lt;</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">>></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        SoftReference<span class="token operator">&lt;</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> ref <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SoftReference</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span>_4MB<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>ref<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>ref<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"循环结束："</span> <span class="token operator">+</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>SoftReference<span class="token operator">&lt;</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> ref <span class="token operator">:</span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>ref<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>soft方法上面的代码会发生呢次溢出异常，而soft方法不会</li><li>一些不重要的资源用SoftReference引用它，当空间紧张时，GC就可以把它回收掉  <h2 id="2-垃圾回收算法"><a href="#2-垃圾回收算法" class="headerlink" title="2. 垃圾回收算法"></a>2. 垃圾回收算法</h2></li></ul></li></ol><h3 id="2-1-标记清除"><a href="#2-1-标记清除" class="headerlink" title="2.1 标记清除"></a>2.1 标记清除</h3><p>定义： Mark Sweep </p><ul><li>速度较快 会造成内存碎片<br><img src=".%E4%BA%8C%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_images/51f34827.png" alt=""></li></ul><h3 id="2-2-标记整理"><a href="#2-2-标记整理" class="headerlink" title="2.2 标记整理"></a>2.2 标记整理</h3><p>定义：Mark Compact  </p><ul><li>速度慢 没有内存碎片<br><img src=".%E4%BA%8C%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_images/6aff524c.png" alt=""></li></ul><h3 id="2-3-复制"><a href="#2-3-复制" class="headerlink" title="2.3 复制"></a>2.3 复制</h3><p>定义：Copy  </p><ul><li>不会有内存碎片 </li><li>需要占用双倍内存空间<br><img src=".%E4%BA%8C%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_images/8de79ded.png" alt=""></li></ul><h2 id="3-分代垃圾回收"><a href="#3-分代垃圾回收" class="headerlink" title="3. 分代垃圾回收"></a>3. 分代垃圾回收</h2><p><img src=".%E4%BA%8C%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_images/d8e08357.png" alt="">  </p><ul><li>对象首先分配在伊甸园区域 </li><li>新生代空间不足时，触发 minor gc，伊甸园和 from 存活的对象使用 copy 复制到 to 中，存活的 对象年龄加 1并且交换 from to </li><li>minor gc 会引发 stop the world（STW），暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行</li><li>当对象寿命超过阈值时，会晋升至老年代，最大寿命是15（4bit） </li><li>当老年代空间不足，会先尝试触发 minor gc，如果之后空间仍不足，那么触发 full gc，STW的时 间更长</li></ul><h3 id="3-1-相关-VM-参数"><a href="#3-1-相关-VM-参数" class="headerlink" title="3.1 相关 VM 参数"></a>3.1 相关 VM 参数</h3><p>​                含义     参数</p><ul><li><p>堆初始大小    -Xms</p></li><li><p>堆最大大小    -Xmx 或 -XX:MaxHeapSize=size</p></li><li><p>新生代大小    -Xmn 或 (-XX:NewSize=size + -XX:MaxNewSize=size )</p><ul><li>括号中分别为新生代初始大小和最大大小</li></ul></li><li><p>幸存区比例（动态）    -XX:InitialSurvivorRatio=ratio 和 -XX:+UseAdaptiveSizePolicy</p></li><li><p>幸存区比例    -XX:SurvivorRatio=ratio</p><ul><li>eg:ratio为8，新生代为10MB,则伊甸园为8M,from  to 各1M</li></ul></li><li><p>晋升阈值    -XX:MaxTenuringThreshold=threshold</p><ul><li>新生代晋升到老年代的阈值</li></ul></li><li><p>晋升详情    -XX:+PrintTenuringDistribution</p></li><li><p>GC详情    -XX:+PrintGCDetails -verbose:gc</p></li><li><p>FullGC 前 MinorGC    -XX:+ScavengeBeforeFullGC</p></li></ul><h3 id="3-2-示例"><a href="#3-2-示例" class="headerlink" title="3.2 示例"></a>3.2 示例</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** *  演示内存的分配策略 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo2_1</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> _512KB <span class="token operator">=</span> <span class="token number">512</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> _1MB <span class="token operator">=</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> _6MB <span class="token operator">=</span> <span class="token number">6</span> <span class="token operator">*</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> _7MB <span class="token operator">=</span> <span class="token number">7</span> <span class="token operator">*</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> _8MB <span class="token operator">=</span> <span class="token number">8</span> <span class="token operator">*</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc -XX:-ScavengeBeforeFullGC</span>  <span class="token comment" spellcheck="true">//堆初始大小和最大大小都为20M,新生代10M(输出的新生代大小为9M,包含伊甸园和from区域)</span>  <span class="token comment" spellcheck="true">//UseSerialGC表示用这个垃圾回收器，JDK1.8默认不是这个</span>  <span class="token comment" spellcheck="true">//ScavengeBeforeFullGC：表示FullGC前进行一次GC，默认也是开启的</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>初始main函数为空，输出如下<br><img src=".%E4%BA%8C%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_images/1fb8b430.png" alt=""></p><ul><li>对于大对象，新生代放不下，老年代能放下，会直接放入老年代，不会触发GC  </li></ul><p>对面上面的类，若main函数如下  </p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>           list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span>_8MB<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>输出<br><img src=".%E4%BA%8C%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_images/74830f6e.png" alt=""></p><ul><li>如果新生代和老年代都放不下，会触发OOM</li><li>一个线程OOM不会导致整个进程终止 </li></ul><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            ArrayList<span class="token operator">&lt;</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span>_8MB<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span>_8MB<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"sleep...."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>1000L<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>   </code></pre><p><img src=".%E4%BA%8C%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_images/dceadba3.png" alt=""></p><h2 id="4-垃圾回收器"><a href="#4-垃圾回收器" class="headerlink" title="4. 垃圾回收器"></a>4. 垃圾回收器</h2><h3 id="4-1-串行"><a href="#4-1-串行" class="headerlink" title="4.1. 串行"></a>4.1. 串行</h3><ul><li>单线程 </li><li>堆内存较小，适合个人电脑 </li></ul><h3 id="4-2-吞吐量优先"><a href="#4-2-吞吐量优先" class="headerlink" title="4.2. 吞吐量优先"></a>4.2. 吞吐量优先</h3><ul><li>多线程 </li><li>堆内存较大，多核 cpu </li><li>让单位时间内，STW 的时间最短(比如1H内发生2次，共 0.2S 0.2S = 0.4S)，垃圾回收时间占比最低，这样就称吞吐量高 </li></ul><h3 id="4-3-响应时间优先"><a href="#4-3-响应时间优先" class="headerlink" title="4.3 响应时间优先"></a>4.3 响应时间优先</h3><ul><li>多线程 </li><li>堆内存较大，多核 cpu 尽可能让单次 STW 的时间最短比如(1h内发生了5次gc,共 0.1 0.1 0.1 0.1 0.1 = 0.5s)</li></ul><h2 id="5-垃圾回收调优"><a href="#5-垃圾回收调优" class="headerlink" title="5. 垃圾回收调优"></a>5. 垃圾回收调优</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/Java虚拟机/一、内存结构</title>
      <link href="blog/1643669774.html"/>
      <url>blog/1643669774.html</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p><img src=".%E4%B8%80%E3%80%81%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84_images/image-20200429092949049.png" alt="image-20200429092949049"></p><p><img src=".%E4%B8%80%E3%80%81%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84_images/2564394b.png" alt=""></p><h1 id="1-程序计数器"><a href="#1-程序计数器" class="headerlink" title="1. 程序计数器"></a>1. 程序计数器</h1><pre><code>1. 定义: program counter register 程序计数器(寄存器)    2. 作用: 保存下一条字节码指令的地址  </code></pre><h1 id="2-虚拟机栈"><a href="#2-虚拟机栈" class="headerlink" title="2. 虚拟机栈"></a>2. 虚拟机栈</h1><h3 id="2-1定义"><a href="#2-1定义" class="headerlink" title="2.1定义"></a>2.1定义</h3><ul><li><p>定义：每个线程运行需要的空间  </p></li><li><p>组成：由多个栈帧组成</p></li><li><p>栈帧：是方法需要的内存.   </p><ol><li>存放方法参数，局部变量，返回地址</li><li>1个方法的调用对应1个栈帧的入栈和出栈</li><li>每个线程只能由1个活动栈帧，对应着当前正在执行的方法</li><li>idea中的frames即为栈帧<br><img src=".%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84_images/6b95ca33.png" alt="">  </li></ol></li><li><p>几个问题  </p><ol><li>垃圾回收是否涉及栈内存？答：不涉及</li><li>栈内存分配越大越好吗？  <ul><li>线程栈的大小设置，一般用系统默认的就可以<br><img src=".%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84_images/073afff6.png" alt=""><br><img src=".%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84_images/a1f52447.png" alt=""></li><li>栈内存的size越大，能够支持更多次的递归调用，然而支持并发的线程数就越小  </li></ul></li><li>方法内的局部变量是否线程安全？看1个变量是否是多个线程共享的  <ul><li>每个线程有自己的栈帧，局部变量存在栈帧中，如果不作为返回值，则是线程安全的。</li><li>如果局部变量引用了对象，并逃离方法的作用范围，需要考虑线程安全<br><img src=".%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84_images/c035a9be.png" alt=""><h3 id="2-2-栈内存溢出StackOverflowError"><a href="#2-2-栈内存溢出StackOverflowError" class="headerlink" title="2.2. 栈内存溢出StackOverflowError"></a>2.2. 栈内存溢出StackOverflowError</h3></li></ul></li><li>栈帧过多导致(递归,json转化时由于2个类的循环引用导致)</li><li>单个栈帧太大(jsp中)<h3 id="2-3-线程运行诊断"><a href="#2-3-线程运行诊断" class="headerlink" title="2.3. 线程运行诊断"></a>2.3. 线程运行诊断</h3></li></ol></li><li><p>nohup命令：nohup java cn.ustc.jvm.Demo1_16 &amp;   (让Java代码在后台运行)</p></li><li><p>top命令：监测进程对CPU,内存的占用情况，定位不到线程</p></li><li><p>ps命令：可以查看线程对cpu的占用情况  </p></li></ul><p><strong>案例1： 定位cpu 占用过多-空循环</strong>  </p><ul><li><p>用top定位哪个进程对cpu的占用过高  </p></li><li><p>ps H -eo pid,tid,%cpu | grep 进程id （用ps命令进一步定位是哪个线程引起的cpu占用过高） </p></li><li><p>jstack(JDK提供) 进程id</p><ul><li><p>会列出所有线程，可以根据线程id 找到有问题的线程(nid)，进一步定位到问题代码的源码行号<br><img src=".%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84_images/46302b21.png" alt="">   </p><pre><code>public static void main(String[] args) {  new Thread(null, () -&gt; {      System.out.println(&quot;1...&quot;);      while(true) {      }  }, &quot;thread1&quot;).start();</code></pre></li></ul></li></ul><p><strong>案例2：Jstack排查死锁问题</strong>  </p><ul><li>先用nohup运行，后直接用jstack得出下图<br><img src=".%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84_images/b7dcd81d.png" alt=""><br><img src=".%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84_images/44d8f8be.png" alt=""><h1 id="3-本地方法栈Native-Method-Stacks"><a href="#3-本地方法栈Native-Method-Stacks" class="headerlink" title="3. 本地方法栈Native Method Stacks"></a>3. 本地方法栈Native Method Stacks</h1><img src=".%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84_images/b6060bf4.png" alt=""></li><li>什么叫本地方法？  <ul><li>Java语言有限制，有些操作系统底层的功能得通过c/c++的方法去调用.</li><li>本地方法很多，本地方法运行需要的内存叫本地方法栈  <h1 id="4-堆Heap"><a href="#4-堆Heap" class="headerlink" title="4. 堆Heap"></a>4. 堆Heap</h1><h3 id="4-1-定义"><a href="#4-1-定义" class="headerlink" title="4.1 定义"></a>4.1 定义</h3></li></ul></li><li>通过 new 关键字，创建对象都会使用堆内存</li><li>它是线程共享的，堆中对象都需要考虑线程安全的问题</li><li>有垃圾回收机制<h3 id="4-2-堆内存溢出-java-lang-OutOfMemoryError-Java-heap-space"><a href="#4-2-堆内存溢出-java-lang-OutOfMemoryError-Java-heap-space" class="headerlink" title="4.2 堆内存溢出 java.lang.OutOfMemoryError:Java heap space"></a>4.2 堆内存溢出 java.lang.OutOfMemoryError:Java heap space</h3>例：<br><img src=".%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84_images/c9a6ad85.png" alt="">  <ul><li>虚拟机参数:-Xmx8m 设置堆空间大小为8MB ,默认是4GB？</li><li>排查堆内存溢出的问题可以将堆空间大小设置小些，尽早暴露出问题  <h3 id="4-2-堆内存诊断"><a href="#4-2-堆内存诊断" class="headerlink" title="4.2 堆内存诊断"></a>4.2 堆内存诊断</h3></li></ul></li></ul><ol><li>jps 工具：查看当前系统中有哪些 java 进程  </li><li>jmap 工具： 查看某一时刻堆内存占用情况 jmap -heap 进程id</li><li>jconsole工具：图形界面的，多功能的监测工具，可以连续监测不仅堆内存的情况  </li></ol><p><strong>jmap例：演示堆内存</strong>-分别看Eden Space这个区域used情况  </p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo1_4</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"1..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">30000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//用来在new 对象前敲jmap命令</span>        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 10 Mb</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"2..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">20000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        array <span class="token operator">=</span> null<span class="token punctuation">;</span>        System<span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//显示垃圾回收</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"3..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>1000000L<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><img src=".%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84_images/fd7b8b4c.png" alt=""><br><strong>jconsole例：演示堆内存</strong></p><ul><li>仍然用上面的main方法</li><li>命令行输入jconsole-&gt;选择进程-&gt;可看到堆内存的动态变化情况<br><img src=".%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84_images/cf35614f.png" alt="">  </li></ul><p><strong>例：垃圾回收后，内存占用仍然很高，怎么用工具来排查？</strong></p><ul><li><p>jmap 查看进程的新生代和老年代内存使用情况  </p></li><li><p>用jconsole 对进程执行GC，观察出内存使用从250MB，只降到了200多MB</p></li><li><p>再用jmap 查看发现新生代使用的减少到了6MB，但是老年代仍然使用了200多MB</p></li><li><p>jvisualvm命令-可视化虚拟机</p><ul><li>用堆Dump这个功能抓取堆的当前快照<br><img src=".%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84_images/3a062849.png" alt=""></li><li>查找占用内存最大的前20个对象<br><img src=".%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84_images/bb69012b.png" alt="">  </li><li>发现arraylist大小200，每个元素占1MB<br><img src=".%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84_images/038ce66d.png" alt=""> </li><li>分析代码 <pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//演示查看对象个数 堆转储 dump</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo1_13</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>      List<span class="token operator">&lt;</span>Student<span class="token operator">></span> students <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">200</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          students<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//            Student student = new Student();</span>      <span class="token punctuation">}</span>      Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>1000000000L<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token punctuation">{</span>  <span class="token keyword">private</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> big <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">1024</span><span class="token operator">*</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h1 id="5-方法区"><a href="#5-方法区" class="headerlink" title="5. 方法区"></a>5. 方法区</h1><h3 id="5-1-定义"><a href="#5-1-定义" class="headerlink" title="5.1 定义"></a>5.1 定义</h3></li></ul></li><li><p>逻辑上是堆的一个组成部分，具体实现不同厂商可能不一样，甚至上实现上不是</p><ul><li>Hotspot虚拟机在1.8以前用的堆中的永久代区域实现的方法区</li><li>1.8用的不是堆的内存，叫元空间，用的本地内存， 是操作系统的内存</li></ul></li><li><p>存储每个类的结构/信息，如field,(运行时)常量池，构造器和成员方法，类方法的代码</p></li><li><p>是所有线程共享的，和堆一样</p></li><li><p>在虚拟机启动时创建</p></li><li><p>会发生OutOfMemoryError<br><img src=".%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84_images/53210605.png" alt="">  </p></li></ul><h3 id="5-2溢出java-lang-OutOfMemoryError"><a href="#5-2溢出java-lang-OutOfMemoryError" class="headerlink" title="5.2溢出java.lang.OutOfMemoryError"></a>5.2溢出java.lang.OutOfMemoryError</h3><ul><li><p>元空间溢出<br><img src=".%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84_images/87f6c480.png" alt=""></p></li><li><p>永久代空间溢出<br><img src=".%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84_images/333a37de.png" alt=""></p><pre class=" language-java"><code class="language-java">  <span class="token comment" spellcheck="true">/**   * 演示元空间内存溢出 java.lang.OutOfMemoryError: Metaspace   * -XX:MaxMetaspaceSize=8m   * 1.8用的元空间实现，默认没有大小限制，为了演示OutOfMemoryError，得修改上面的虚拟机参数   */</span>  <span class="token comment" spellcheck="true">/**   * 演示1.6 永久代内存溢出  java.lang.OutOfMemoryError: PermGen space   * -XX:MaxPermSize=8m   */</span>  <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo1_8</span> <span class="token keyword">extends</span> <span class="token class-name">ClassLoader</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 可以用来加载类的二进制字节码</span>      <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>          <span class="token keyword">try</span> <span class="token punctuation">{</span>              Demo1_8 test <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Demo1_8</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">,</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                  <span class="token comment" spellcheck="true">// ClassWriter 作用是生成类的二进制字节码</span>                  ClassWriter cw <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassWriter</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token comment" spellcheck="true">//参数： 版本号， public， 类名, 包名, 父类， 接口</span>                  cw<span class="token punctuation">.</span><span class="token function">visit</span><span class="token punctuation">(</span>Opcodes<span class="token punctuation">.</span>V1_8<span class="token punctuation">,</span> Opcodes<span class="token punctuation">.</span>ACC_PUBLIC<span class="token punctuation">,</span> <span class="token string">"Class"</span> <span class="token operator">+</span> i<span class="token punctuation">,</span> null<span class="token punctuation">,</span> <span class="token string">"java/lang/Object"</span><span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token comment" spellcheck="true">// 返回 byte[]</span>                  <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> code <span class="token operator">=</span> cw<span class="token punctuation">.</span><span class="token function">toByteArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token comment" spellcheck="true">// 只执行了类的加载（没有初始化等其他过程）</span>                  test<span class="token punctuation">.</span><span class="token function">defineClass</span><span class="token punctuation">(</span><span class="token string">"Class"</span> <span class="token operator">+</span> i<span class="token punctuation">,</span> code<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> code<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Class 对象</span>              <span class="token punctuation">}</span>          <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>              System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span></code></pre></li><li><p>实际场景中spring,mabatis大量使用了运行中加载、生成类-动态生成字节码技术，使用不当可能会导致方法区内存溢出</p><h3 id="5-3-运行时常量池"><a href="#5-3-运行时常量池" class="headerlink" title="5.3 运行时常量池"></a>5.3 运行时常量池</h3><p>什么是常量池？  </p></li><li><p>class文件结构中的常量池，class文件还包括类的基本信息，类方法(虚拟机指令)</p></li><li><p>常量池，就是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量(字符串，基本类型常量) 等信息</p></li></ul><p>什么是运行时常量池？</p><ul><li>运行时常量池，常量池是 *.class 文件中的，当该类被加载，它的常量池信息就会放入运行时常量 池，并把里面的符号地址变为真实地址      </li></ul><p>总结：</p><ul><li><strong>方法区：</strong>在java的虚拟机中有一块专门用来存放已经加载的类信息、常量、静态变量以及方法代码的内存区域，叫做方法区。</li><li><strong>常量池：</strong>常量池是方法区的一部分，主要用来存放常量和类中的符号引用等信息。</li><li><strong>堆区：</strong>用于存放类的对象实例。</li><li><strong>栈区：</strong>也叫java虚拟机栈，是由一个一个的栈帧组成的后进先出的栈式结构，栈桢中存放方法运行时产生的局部变量、方法出口等信息。当调用一个方法时，虚拟机栈中就会创建一个栈帧存放这些数据，当方法调用完成时，栈帧消失，如果方法中调用了其他方法，则继续在栈顶创建新的栈桢。</li></ul><p>jvm中的运行时内存区域还包括<strong>本地方法栈</strong>和<strong>程序计数</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/Java虚拟机/图解方法执行流程</title>
      <link href="blog/2107526682.html"/>
      <url>blog/2107526682.html</url>
      
        <content type="html"><![CDATA[<p><img src=".%E5%9B%BE%E8%A7%A3%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B_images/65e44a7e.png" alt="">  </p><ul><li>Short.MAX_VALUE存在哪?<blockquote><p>int a = 10 比较小的数(short范围内)跟字节码指令存在一起<br>int b = Short.MAX_VALUE + 1  比short最大值还大的数存在常量池中    </p></blockquote></li><li>这样一段Java代码被虚拟机执行时，发生了什么？<ul><li>类加载器将main方法所在的类的字节码读入内存  </li><li>.class中常量池被放入运行时常量(方法区的一个部分)池这个区域<br><img src=".%E5%9B%BE%E8%A7%A3%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B_images/a04d8f51.png" alt=""><br><img src=".%E5%9B%BE%E8%A7%A3%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B_images/cf3c8c1a.png" alt=""><br><img src=".%E5%9B%BE%E8%A7%A3%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B_images/60d57295.png" alt=""><br><img src=".%E5%9B%BE%E8%A7%A3%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B_images/c4ac00aa.png" alt=""><br><img src=".%E5%9B%BE%E8%A7%A3%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B_images/f8d93735.png" alt=""><br><img src=".%E5%9B%BE%E8%A7%A3%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B_images/6532e195.png" alt=""><br><img src=".%E5%9B%BE%E8%A7%A3%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B_images/b3467f03.png" alt=""><br><img src=".%E5%9B%BE%E8%A7%A3%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B_images/1d6368ac.png" alt="">  <blockquote><p>栈帧中绿色的为局部变量表(stack为操作数栈的最大深度)，蓝色的为操作数栈</p></blockquote></li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/面经/备战指南</title>
      <link href="blog/1176870268.html"/>
      <url>blog/1176870268.html</url>
      
        <content type="html"><![CDATA[<ol><li>简历准备  </li></ol><p>基本外观：首先是格式，一定要pdf，每个人的电脑系统不同，pdf可以保证你的简历不会乱码，不会排版错乱。其次是页数，个人认为对于实习或者校招生来说一页已经足够了，排版再规划一下，简洁清晰即可。<br>内容：个人信息，项目经历（学校里做的或实习项目），获奖情况，掌握的技术栈，自我评价。可以根据个人情况增加或删减。</p><p>对于一般实习或校招生，项目可能比较少。关键要把项目的重点，难点，是如何做的，怎么解决的，学到了什么说清楚。项目中用到的技术栈好好准备，面试的时候一定要讲清楚，如果能在底层深挖一下会更好。</p><ol start="2"><li>基础知识准备</li></ol><p>对于实习或校招生来说，项目经验可能不是很多，但是基础知识一定要熟悉。包括数据结构，算法，数据库，计算机网络，操作系统等等，基础知识不掌握会让面试官觉得你学习能力有问题。基础知识可以在牛客网上看看相关面经，了解一下面试时的提问方式，可以为复习提供方向。<br>此外不同岗位的侧重点也会不一样，比如对于Java后台来说，基础知识可能偏向Java基础，JVM，数据库，计算机网络等。确定好自己的求职方向后针对性的复习即可。</p><ol start="3"><li>笔试</li></ol><p>对于笔试来说就一句话，坚持刷题。网上有很多资源，剑指offer，LeetCode（可以按tag刷）</p><ol start="4"><li>面试</li></ol><p>一般分成四个阶段</p><ol><li>自我介绍：时间不要太久，控制在3分钟以内，整体上一定要保持信心。</li><li>基础知识考察：前面提到，根据自己的面试岗位与求职方向进行针对性复习。</li><li>针对项目的考察：主要是基于简历中或者一些常规的技术问题进行回答。切忌切忌流水账式讲述，讲项目可按照star模型来讲述，主要是为了考察背后你的能力，比如说：思考力、学习能力、学习态度、总结能力等等。在说的过程中，先介绍宏观，再落到具体，非常清楚的讲明白为什么做，怎么做，以此要解决什么样的业务问题。这样你的表达能力&amp;沟通能力，就能得到体现。如果你只是流水账式讲出来，就达不到效果了。</li><li>笔试：我参加过的校招面试几乎每一场都会有笔试，为了考察你的算法，数据结构，编码能力，逻辑思维。所以说刷题很重要</li></ol><p>最后给大家推荐个复习资源：<a href="https://github.com/CyC2018/CS-Notes" target="_blank" rel="noopener">https://github.com/CyC2018/CS-Notes</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="blog/1243066710.html"/>
      <url>blog/1243066710.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> Hellox </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/java/安装JDK</title>
      <link href="blog/3891037058.html"/>
      <url>blog/3891037058.html</url>
      
        <content type="html"><![CDATA[<p>####/usr/bin/java</p><ul><li>指向/System/Library/Frameworks/JavaVM.framework/Versions/A/Commands/java<h4 id="System-Library-Frameworks-JavaVM-framework-是啥？"><a href="#System-Library-Frameworks-JavaVM-framework-是啥？" class="headerlink" title="/System/Library/Frameworks/JavaVM.framework/是啥？"></a>/System/Library/Frameworks/JavaVM.framework/是啥？</h4></li><li>macos 自带的JDK目录 还是 安装java后会在里面生成一个版本<h4 id="Library-Java-JavaVirtualMachines"><a href="#Library-Java-JavaVirtualMachines" class="headerlink" title="/Library/Java/JavaVirtualMachines"></a>/Library/Java/JavaVirtualMachines</h4></li><li>Oracle JDK安装目录<br><img src=".%E5%AE%89%E8%A3%85JDK_images/6855cc94.png" alt=""><h4 id="Library-Internet-Plug-Ins-JavaAppletPlugin-plugin-Contents-Home-bin-java"><a href="#Library-Internet-Plug-Ins-JavaAppletPlugin-plugin-Contents-Home-bin-java" class="headerlink" title="/Library/Internet\ Plug-Ins/JavaAppletPlugin.plugin/Contents/Home/bin/java"></a>/Library/Internet\ Plug-Ins/JavaAppletPlugin.plugin/Contents/Home/bin/java</h4></li><li>这是什么？</li></ul><h3 id="java-home"><a href="#java-home" class="headerlink" title="java_home"></a>java_home</h3><ul><li>/usr/libexec/java_home<br><img src=".%E5%AE%89%E8%A3%85JDK_images/c2582110.png" alt="">  </li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/面经/其他</title>
      <link href="blog/4268862004.html"/>
      <url>blog/4268862004.html</url>
      
        <content type="html"><![CDATA[<ol><li>平时怎么学习Android的？有没有关注最新版本Android的新特性  </li><li>平常使用模式开发，为什么</li><li>人工智能的了解  </li><li>unicode字符？</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/面经/算法题</title>
      <link href="blog/3878850257.html"/>
      <url>blog/3878850257.html</url>
      
        <content type="html"><![CDATA[<ol><li>很长的字符串里有字母和数字，怎么快速去除数字：stringbuilter，正则，这两个哪个快  </li><li>判断链表中是否有环</li><li>旋转数组的查找</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/操作系统/操作系统</title>
      <link href="blog/2483025269.html"/>
      <url>blog/2483025269.html</url>
      
        <content type="html"><![CDATA[<h1 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h2><p>操作系统的定义：进程是程序的一次执行过程，是操作系统资源分配的基本单位。</p><p>进程控制块 (Process Control Block, PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。</p><p>线程：为了让计算机在同一时间内能执行更多任务，在进程内部又划分了许多线程。线程是计算机中独立运行的最小单位，运行时占用很少的系统资源，可以把线程看成操作系统分配CPU时间的基本单位。它与同属于一个进程的其他线程共享进程拥有的全部资源。一个线程可以创建撤销另一个线程，同一个进程中的多个线程可以并行执行。</p><h2 id="2-区别"><a href="#2-区别" class="headerlink" title="2.区别"></a>2.区别</h2><p>Ⅰ 拥有资源 进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。 </p><p>Ⅱ 调度 线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程 中的线程时，会引起进程切换。 </p><p>Ⅲ 系统开销 由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销 线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而 线程切换时只需保存和设置少量寄存器内容，开销很小。</p><p>Ⅳ 通信方面</p><p>线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。</p><h2 id="3-进程状态的切换"><a href="#3-进程状态的切换" class="headerlink" title="3.进程状态的切换"></a>3.进程状态的切换</h2><p><img src=".%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_images/image-20200718212910316.png" alt="image-20200718212910316"></p><h2 id="4-进程管理"><a href="#4-进程管理" class="headerlink" title="4.进程管理"></a>4.进程管理</h2><p>进程控制、进程同步、进程通信、死锁处理、处理机调度等。</p><h3 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h3><ol start="2"><li>同步与互斥</li></ol><p>同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。 互斥：多个进程在同一时刻只有一个进程能进入临界区。</p><h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><h4 id="1-管道"><a href="#1-管道" class="headerlink" title="1.管道"></a>1.管道</h4><p>是一种2个进程进行单向通信的机制。 是通过调用 pipe 函数创建的，fd[0] 用于读，fd[1] 用于写。</p><p>通过管道通信的2个进程，1个进程向管道写数据，另外1个进程从管道的另一端读数据。写入的数据每次都添加在管道缓冲区的末尾，读数据的时候都是从缓冲区的头部读出数据.</p><p>管道是1个特殊的文件，这个文件只存在于内存中。创建管道时，系统为管道分配一个页面作为数据缓冲区。</p><pre><code>#include &lt;unistd.h&gt; int pipe(int fd[2]);/调用成功返回0，并且数组中将包含2个新的文件描述符,有错误发生返回-1</code></pre><p>它具有以下限制：</p><p>只支持半双工通信（单向交替传输）； 只能在父子进程或者兄弟进程中使用。</p><p>管道的一种常见用法：在父进程创建子进程后向子进程传递参数,</p><h4 id="2-消息队列"><a href="#2-消息队列" class="headerlink" title="2.消息队列"></a>2.消息队列</h4><p>1.基本概念</p><p>消息队列是存放在内核中的消息链表，每个消息队列由消息队列标识。只有OS重启或者显示的删除1个消息队列时，该消息队列才会被真正删除.</p><h4 id="3-信号量"><a href="#3-信号量" class="headerlink" title="3.信号量"></a>3.信号量</h4><p>信号量是一个计数器，常用于处理进程或线程的同步问题，特别是对临界资源的访问。信号量的值大于或等于0时表示可供并发进程使用的资源实体数；小于0时代表正在等待使用临界资源的进程数。</p><h4 id="4-共享内存"><a href="#4-共享内存" class="headerlink" title="4.共享内存"></a>4.共享内存</h4><p>就是分配一块能被其他进程访问的内存。每个共享内存段在内核中维护着一个内部结构shmid_ds(和消息队列，信号量一样)</p><p>允许多个进程共享一个给定的存储区。因为数据不需要在进程之间复制，所以这是最快的一种 IPC。</p><p>需要使用信号量用来同步对共享存储的访问。</p><p>多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存。另外 XSI 共享内存不是使用文件，而是使用内 存的匿名段。</p><h4 id="5-socket"><a href="#5-socket" class="headerlink" title="5.socket"></a>5.socket</h4><p>与其它通信机制不同的是，它可用于不同机器间的进程通信。</p><h4 id="为什么要使用Binder？"><a href="#为什么要使用Binder？" class="headerlink" title="为什么要使用Binder？"></a>为什么要使用Binder？</h4><ol><li><strong>管道：</strong>在创建时分配一个page大小的内存，缓存区大小比较有限；</li><li><strong>消息队列</strong>：信息复制两次，额外的CPU消耗；不合适频繁或信息量大的通信；</li><li><strong>共享内存</strong>：无须复制，共享缓冲区直接付附加到进程虚拟地址空间，速度快；但进程间的同步问题操作系统无法实现，必须各进程利用同步工具解决；</li><li><strong>套接字</strong>：作为更通用的接口，传输效率低，主要用于不通机器或跨网络的通信；</li></ol><p><strong>性能方面</strong></p><p>Binder数据拷贝只需要一次，而管道、消息队列、Socket都需要2次，共享内存方式一次内存拷贝都不需要，但实现方式又比较复杂。</p><h3 id="死锁处理"><a href="#死锁处理" class="headerlink" title="死锁处理"></a>死锁处理</h3><p><img src=".%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_images/image-20200718215059175.png" alt="image-20200718215059175"></p><h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p><img src=".%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_images/image-20200719165854347.png" alt="image-20200719165854347"></p><h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><h3 id="UDP-和-TCP-的特点"><a href="#UDP-和-TCP-的特点" class="headerlink" title="UDP 和 TCP 的特点"></a>UDP 和 TCP 的特点</h3><ul><li>用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文 （对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多 的交互通信。 </li><li>传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控 制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据 块），每一条 TCP 连接只能是点对点的（一对一）。</li></ul><h3 id="TCP-的三次握手"><a href="#TCP-的三次握手" class="headerlink" title="TCP 的三次握手"></a>TCP 的三次握手</h3><p>假设 A 为客户端，B 为服务器端。</p><p>首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。 A 向 B 发送连接请求报文段，同步位SYN=1，ACK=0，选择一个初始的序号 x。</p><p> B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时 也选择一个初始的序号 y。</p><p> A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。 B 收到 A 的确认后，连接建立。</p><p><img src=".%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_images/image-20200718215854020.png" alt="image-20200718215854020"></p><p><strong>三次握手的原因</strong></p><p>第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。</p><p>客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待 一个超时重传时间之后，就会重新请求连接。</p><p>但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握 手，那么只要服务器发出确认，新的连接就建立了，就会打开两个连接。</p><p>由于现在A并没发出连接请求，因此不会理B的确认，但B却以为新的传输连接已经建立，在等A发来数据。B的许多资源就这样白白浪费了。</p><p>如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，因此就不会再次建立连接。</p><h3 id="TCP-的四次挥手"><a href="#TCP-的四次挥手" class="headerlink" title="TCP 的四次挥手"></a>TCP 的四次挥手</h3><p><img src=".%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_images/image-20200718215911636.png" alt="image-20200718215911636"></p><p>以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都 为 1。</p><p>A 发送连接释放报文，FIN=1。 B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。 当 B 不再需要连接时，发送连接释放报文，FIN=1。 A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。 B 收到 A 的确认后释放连接。</p><p><strong>四次挥手的原因</strong></p><p>客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服 务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。</p><p><strong>TIME_WAIT</strong></p><p>客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器 设置的时间 2MSL。这么做有两个理由：</p><p>确保A发送的最后一个确认报文能够到达B。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文， A 等待一段时间就是为了处理这种情况的发生。 等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧 的连接请求报文。</p><h3 id="TCP-可靠传输"><a href="#TCP-可靠传输" class="headerlink" title="TCP 可靠传输"></a>TCP 可靠传输</h3><h3 id="TCP-滑动窗口"><a href="#TCP-滑动窗口" class="headerlink" title="TCP 滑动窗口"></a>TCP 滑动窗口</h3><h3 id="TCP-流量控制"><a href="#TCP-流量控制" class="headerlink" title="TCP 流量控制"></a>TCP 流量控制</h3><h3 id="TCP-拥塞控制"><a href="#TCP-拥塞控制" class="headerlink" title="TCP 拥塞控制"></a>TCP 拥塞控制</h3><h2 id="Http"><a href="#Http" class="headerlink" title="Http"></a>Http</h2><h3 id="一、"><a href="#一、" class="headerlink" title="一、"></a>一、</h3><p><strong>请求和响应报文</strong></p><p><img src=".%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_images/image-20200719092433701.png" alt="image-20200719092433701"></p><h3 id="二、HTTP-方法"><a href="#二、HTTP-方法" class="headerlink" title="二、HTTP 方法"></a>二、HTTP 方法</h3><p>POST 主要用来传输数据，而 GET 主要用来获取资源。</p><p><strong>PUT</strong></p><p>上传文件 由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法</p><p><strong>HEAD</strong></p><p>获取报文首部 和 GET 方法类似，但是不返回报文实体主体部分。 主要用于确认 URL 的有效性以及资源更新的日期时间等。</p><h3 id="三、具体应用"><a href="#三、具体应用" class="headerlink" title="三、具体应用"></a>三、具体应用</h3><h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a><strong>Cookie</strong></h4><p>HTTP 协议是无状态的，主要是为了让 HTTP 协议尽可能简单，使得它能够处理大量事务。HTTP/1.1 引入 Cookie 来 保存状态信息。</p><p> Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器之后向同一服务器再次发起请求时被 携带上，用于告知服务端两个请求是否来自同一浏览器。由于之后每次请求都会需要携带 Cookie 数据，因此会带来 额外的性能开销（尤其是在移动环境下）。</p><p>Cookie 曾一度用于客户端数据的存储，因为当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现 代浏览器开始支持各种各样的存储方式，Cookie 渐渐被淘汰。新的浏览器 API 已经允许开发者直接将数据存储到本 地，如使用 Web storage API（本地存储和会话存储）或 IndexedDB。</p><ol><li>用途</li></ol><p>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息） 个性化设置（如用户自定义设置、主题等） 浏览器行为跟踪（如跟踪分析用户行为等）</p><h4 id="Session"><a href="#Session" class="headerlink" title="Session"></a><strong>Session</strong></h4><p>除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 Session 存储在服务器端，存储在服务器端的信 息更加安全。</p><p>Session 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在 Redis 这种内存型数据库中，效 率会更高。</p><p>使用 Session 维护用户登录状态的过程如下：</p><p>用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中； 服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID； 服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中； 客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取 出用户信息，继续之前的业务操作。</p><p>应该注意 Session ID 的安全性问题，不能让它被恶意攻击者轻易获取，那么就不能产生一个容易被猜到的 Session ID 值。此外，还需要经常重新生成 Session ID。在对安全性要求极高的场景下，例如转账等操作，除了使用 Session 管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式。</p><h3 id="九、GET-和-POST-比较"><a href="#九、GET-和-POST-比较" class="headerlink" title="九、GET 和 POST 比较"></a>九、GET 和 POST 比较</h3><p><strong>作用</strong></p><p>GET 用于获取资源，而 POST 用于传输实体主体。</p><p><strong>参数</strong></p><p> GET 的参数是以查询字符串出现在 URL 中，而 POST 的参数存储在 实体主体中。不能因为 POST 参数存储在实体主体中就认为它的安全性更高，因为照样可以通过一些抓包工具 （Fiddler）查看。</p><p> 因为 URL 只支持 ASCII 码，因此 GET 的参数中如果存在中文等字符就需要先进行编码。例如 中文 会转换为 %E4%B8%AD%E6%96%87 ，而空格会转换为 %20 。POST 参数支持标准字符集。</p><p><strong>安全</strong></p><p>安全的 HTTP 方法不会改变服务器状态，也就是说它只是可读的。 GET 方法是安全的，而 POST 却不是，因为 POST 的目的是传送实体主体内容，这个内容可能是用户上传的表单数 据，上传成功之后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。</p><p><strong>幂等性</strong> </p><p>幂等的 HTTP 方法，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。</p><p>GET /pageX HTTP/1.1 是幂等的，连续调用多次，客户端接收到的结果都是一样的：</p><p>POST /add_row HTTP/1.1 不是幂等的，如果调用多次，就会增加多行记录：</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/面经/linux</title>
      <link href="blog/1663652498.html"/>
      <url>blog/1663652498.html</url>
      
        <content type="html"><![CDATA[<ol><li>平时用linux吗，有哪些常见命令 </li><li>Linux中进程的通信方式</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/面经/数据结构</title>
      <link href="blog/823268851.html"/>
      <url>blog/823268851.html</url>
      
        <content type="html"><![CDATA[<p>####链表</p><ol><li>如何删除链表节点  </li><li>删除倒数k个元素</li><li></li><li>数组和链表的区别</li></ol><p>####排序</p><ol><li>知道哪些排序算法，冒泡和归并的时间复杂度。</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/面经/Android</title>
      <link href="blog/71967024.html"/>
      <url>blog/71967024.html</url>
      
        <content type="html"><![CDATA[<ol><li><p>Android的四大组件,四大组件项目里怎么用的、生命周期  </p></li><li><p>1Android生命周期，pause()和stop()的区别  </p></li><li><p>为什么service看不见界面,Service的开启方式，两种开启方法的区别 </p></li><li><p>广播创建的方法  </p></li><li><p>1 Broatcast的种类</p></li><li><p>四种启动方式;Android不同启动模式并举例使用场景  </p></li><li><p>1 启动方式，singleTask 可以在在多个栈中吗，singleInstance 的使用场景</p></li><li></li><li><p>intent的作用</p></li><li></li><li><p>Android内存泄露</p></li><li><p>Android中多进程的使用方法</p></li><li><p>Android中多进程的使用方法，Android进程的通信方式，Linux中进程的通信方式，binder机制是用管道实现的吗？</p></li><li><p>Activity的启动周期，Activity之间切换和按home键时的生命周期变化 </p></li><li><p>Android中如何使用多线程，怎么关闭线程  </p></li><li><p>如何完成线程A完成后同时线程B开始，线程B完成之后线程C开始 </p></li><li><p>如何完成线程A和线程B都完成后，再通知线程C开始  </p></li><li><p>假如需要关闭Activity，保证下载线程继续执行。</p></li><li><p>如果Service使用startService()启动，如何再进行Activity和Service之间的通讯。</p></li><li><p>说一下IntentService的原理 </p></li><li><p>广播的两种类型，为什么本地广播只能在本进程中接收到  </p></li><li><p>知道动态权限吗？</p></li><li><p>handleThread</p></li><li><p>Android中的JNI  </p></li><li></li></ol><p>自定义View</p><ol><li>自定义view中onMeasure()和onLayout()在viewgroup和子view的调用顺序</li><li>自定义view，里面的方法,每个过程的具体作用 </li><li>自定义view中onMeasure中的MeasureSpec有哪些</li></ol><p>Fragment</p><ol><li>Fragment使用场景，Fragment和Activity之间的数据传输</li><li>fragment生命周期、作用  </li></ol><p>Handler</p><ol><li>handle原理，handle可以在子线程创建吗  </li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/面经/Java</title>
      <link href="blog/870307389.html"/>
      <url>blog/870307389.html</url>
      
        <content type="html"><![CDATA[<ol><li></li><li>抽象类和接口,说自己的理解。[***]</li><li>泛型   </li><li>知道哪些Java中的容器，HashMap和HashTable的区别,和ConCurrentHashMap的区别，是否线程安全。[***]  </li><li>HashMap的原理，ConCurrentHashMap中的锁是怎样的</li><li>ArrayList 与 LinkedList 区别，是否线程安全</li><li>int 和 Integer 用==来比较的不同情况  </li><li>sychronized 的使用方法，修饰代码块时多个进程执行的情况（这个问题好像是这样，当时没有听懂他的意思）。</li><li>分别解释Java 面向对象的三个特性——封装、继承、多态</li><li>重写和重载的区别</li><li>访问控制符的种类和异同  </li><li>final的使用方法及不同修饰情况下的区别 </li><li>static的使用方法</li><li>finally的使用方法，try里return了finaly的代码块还会不会继续执行</li><li>Java注解</li><li>Java反射</li><li>threadLocal 原理  </li><li>一般Object哈希值怎么确定 </li><li>内存回收机制、GC的四种算法、四种引用、GC Roots包含哪些对象</li><li>json、xml传递信息</li></ol><p>####多线程   </p><ol><li>线程池的原理和种类</li><li>线程、线程池  </li><li>多线程中sleep()和wait()的区别</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/简历</title>
      <link href="blog/4286269691.html"/>
      <url>blog/4286269691.html</url>
      
        <content type="html"><![CDATA[<ul><li>简历，最重要的信息：姓名，联系方式（手机号码+邮件），还有意向岗位！  我发现有些同学意向岗位居然没写上去！！内推哪个岗位，只能我自己根据实习经历猜了😥  </li><li>教育经历，描述要简洁。有些同学把教育经历写成了小作文，我<strong>年在</strong>读了**，这是反例。  </li><li>实习经历，描述尽量简洁明了，多用谓宾结构，负责了<strong>，实现了</strong>，达到了**效果之类的。 尽量用量化的数据<br>有些同学的简历两页，第二页只有一个小尾巴，自我评价啥的。像这种情况，可以直接去掉了。感观体验不是很好。（自我评价这种东西，说实话，当一页简历不够充实时，只好加点自我评价了😂）</li><li>简历一定要突出重点，突出你的能力，让人一目了然。举个例子，面试官在找一只猫，那你的简历就要告诉他，你就是他要找的那只猫！如果你在简历里把你自己描述成了狗。。那就尴尬了。再说具体一些：比如，你成绩好，年级排名一定要亮出来；大型比赛拿了名次，要说明比赛的难度；实习经历丰富，一定要好好提炼实习项目，在实习中具备哪些能力。总之，拿数据说话。还有同学说，研究生老板都不让实习，都在搞课题，简历没什么写的，怎么办？那既然你在学校好好做研究，那科研成果肯定很好撒。课题亮出来，文章，会议晒出来，虽然它跟你面试的岗位可能没关系，但是它能突出你的科研能力，学习能力和逻辑能力，那也是加分项。</li><li>如果你还是觉得没有东西可写，我这里有一个小建议：回想你从大学入学至今，做过了一些事情，无论巨细，把它写在纸上，罗列，挨个思考，这个事情，有没有体现你某方面能力，继续记录，先发散，再聚合，这样你肯定能找到自己可以show的能力。<br><code>https://www.nowcoder.com/discuss/376419?type=0&amp;order=0&amp;pos=22&amp;page=0</code>  </li></ul><p><img src=".%E7%AE%80%E5%8E%86_images/7e85bb28.png" alt=""></p><h3 id="项目经历："><a href="#项目经历：" class="headerlink" title="项目经历："></a>项目经历：</h3><ul><li>以结果为导向，拿数据说话</li><li>控制在3个以内有代表性的<ul><li>项目描述</li><li>个人职责</li><li>使用的技术栈</li></ul></li><li></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/java/float的内存存储</title>
      <link href="blog/2255226197.html"/>
      <url>blog/2255226197.html</url>
      
        <content type="html"><![CDATA[<p>###浮点数<br><code>Float.floatToIntBits(float value)</code>     返回value的二进制表示的10进制数<br><code>Integer.toBinaryString（int i）</code> 返回i的二进制，前面的全0省略<br><code>Integer.toHexString(int i)</code> 返回i的十六制，前面的全0省略  </p><ul><li>浮点型常量默认为double型，float型要在小数后加f，double型后的d可不加</li><li>float和double变量保存了8和16个精确位</li><li>Java中的浮点型内存存储为IEEE 754格式<br>###类型转换</li></ul><hr><p>两个不同类型操作数的二元运算，小范围的会自动转为大范围的：  </p><ul><li>比如 3 * 4.5 实际上是 3.0 * 4.5</li></ul><p>拓宽类型：小范围类型的变量-&gt;大范围类型的变量<br>缩窄类型：大范围类型的变量-&gt;小范围类型的变量<br><strong>Java将自动拓宽一个类型，缩窄必须显示完成(强制类型转换).</strong><br>注：</p><ul><li>double转int时，小数部分被截去</li><li>整型常量默认为int型</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/招聘信息</title>
      <link href="blog/722947164.html"/>
      <url>blog/722947164.html</url>
      
        <content type="html"><![CDATA[<p><img src=".%E6%8B%9B%E8%81%98%E4%BF%A1%E6%81%AF_images/9a8408fa.png" alt=""><br><img src=".%E6%8B%9B%E8%81%98%E4%BF%A1%E6%81%AF_images/07860206.png" alt=""><br><img src=".%E6%8B%9B%E8%81%98%E4%BF%A1%E6%81%AF_images/4acf9a03.png" alt=""></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/dairy</title>
      <link href="blog/415915814.html"/>
      <url>blog/415915814.html</url>
      
        <content type="html"><![CDATA[<p>####2020-03-06 18:20:04<br><code>开始整理面经</code><br>####2020-03-13 22:13:01</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/面经</title>
      <link href="blog/4053934612.html"/>
      <url>blog/4053934612.html</url>
      
        <content type="html"><![CDATA[<p>2020-03-18 腾讯技术厂分享<br><img src=".%E9%9D%A2%E7%BB%8F_images/f7ddcfce.png" alt=""><br><img src=".%E9%9D%A2%E7%BB%8F_images/9f6d4908.png" alt=""><br><img src=".%E9%9D%A2%E7%BB%8F_images/c0b7c25a.png" alt=""><br><img src=".%E9%9D%A2%E7%BB%8F_images/96e5102c.png" alt=""><br><img src=".%E9%9D%A2%E7%BB%8F_images/e8da5938.png" alt=""><br><img src=".%E9%9D%A2%E7%BB%8F_images/c9f15eb4.png" alt=""></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/C++</title>
      <link href="blog/3580537540.html"/>
      <url>blog/3580537540.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/网络/Network</title>
      <link href="blog/2020447380.html"/>
      <url>blog/2020447380.html</url>
      
        <content type="html"><![CDATA[<p>10.输入url到渲染的过程</p><p>11.http的head</p><p>12.http和https的区别</p><p>13.有抓包过https吗，怎么抓包的  </p><p>浏览器输入网址balabala，HTTP</p><p>解析域名（DNS）</p><p>TCP建立连接</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/数据库/Database</title>
      <link href="blog/1010108968.html"/>
      <url>blog/1010108968.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/java/Java</title>
      <link href="blog/1957497594.html"/>
      <url>blog/1957497594.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-0-gt-gt-1-和0-gt-gt-gt-1"><a href="#1-0-gt-gt-1-和0-gt-gt-gt-1" class="headerlink" title="1. 0  &gt;&gt; 1 和0 &gt;&gt;&gt; 1"></a>1. 0  &gt;&gt; 1 和0 &gt;&gt;&gt; 1</h3><p><img src=".Java_images/324a0cd4.png" alt="">  </p><pre><code>这俩结果不一样System.out.println(2 + (2 - 2) &gt;&gt;&gt; 1);System.out.println(2 + ((2 - 2) &gt;&gt;&gt; 1));</code></pre><h3 id="2-List和int-转化"><a href="#2-List和int-转化" class="headerlink" title="2. List和int[]转化"></a>2. List和int[]转化</h3><h3 id="3-break-和continue的区别"><a href="#3-break-和continue的区别" class="headerlink" title="3. break 和continue的区别"></a>3. break 和continue的区别</h3><ul><li><p>break跳出当前循环；但是如果是嵌套循环，则只能跳出当前的这一层循环  </p></li><li><p>continue:终止当前循环，但是不跳出循环继</p></li></ul><h3 id="4-int和double比较"><a href="#4-int和double比较" class="headerlink" title="4. int和double比较"></a>4. int和double比较</h3><h3 id="5-transient关键字"><a href="#5-transient关键字" class="headerlink" title="5. transient关键字"></a>5. transient关键字</h3><blockquote><p>当一个对象被序列化的时候，transient型变量的值不包括在序列化的表示中，然而非transient型的变量是被包括进去的</p></blockquote><h3 id="6-final关键字"><a href="#6-final关键字" class="headerlink" title="6. final关键字"></a>6. final关键字</h3><blockquote><p>73</p></blockquote><h3 id="7-初始化顺序"><a href="#7-初始化顺序" class="headerlink" title="7. 初始化顺序"></a>7. 初始化顺序</h3><p><strong>1.</strong> <strong>初始化父类中的静态成员变量和静态代码块</strong> <strong>；</strong> </p><p><strong>2.</strong> <strong>初始化子类中的静态成员变量和静态代码块</strong> <strong>；</strong> </p><p><strong>3.初始化父类的普通成员变量和代码块，再执行父类的构造方法；</strong></p><p><strong>4.初始化子类的普通成员变量和代码块，再执行子类的构造方法；</strong> </p><h3 id="8-访问修饰符-分为类内部，同一个包，子类，外部包"><a href="#8-访问修饰符-分为类内部，同一个包，子类，外部包" class="headerlink" title="8. 访问修饰符(分为类内部，同一个包，子类，外部包)"></a>8. 访问修饰符(分为类内部，同一个包，子类，外部包)</h3><ol><li><p>public</p></li><li><p>private</p></li><li><p>不加</p></li><li><p>protected 也有包访问权限</p><table><thead><tr><th></th><th>类内部</th><th>同一个包</th><th>不同包的子类</th><th>不同包的非子类</th></tr></thead><tbody><tr><td>public</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>protected</td><td>√</td><td>√</td><td>√</td><td></td></tr><tr><td>不加</td><td>√</td><td>√</td><td></td><td></td></tr><tr><td>private</td><td>√</td><td></td><td></td><td></td></tr></tbody></table><p>类可以以两种方式使用：创建实例；扩展创建它的子类。</p><p>如果不想从类的外部使用的类的成员，就把成员声明成private;</p><p>如果想让该类的用户都能使用该类的成员，就把成员声明成public;</p><p>如果想让该类的扩展者使用该类的成员，而不想让该类的用户使用，就把成员声明为protected.</p><p>一个没有修饰符中的类是不能被其他包中的类访问。</p></li></ol><ul><li><p>静态方法只能访问静态成员(变量和静态方法)。</p></li><li><p>实例方法可以访问实例方法和实例成员，也可以访问静态成员。</p></li></ul><h3 id="9-内存溢出和内存泄漏的区别"><a href="#9-内存溢出和内存泄漏的区别" class="headerlink" title="9. 内存溢出和内存泄漏的区别"></a>9. 内存溢出和内存泄漏的区别</h3><ol><li><p>内存溢出：（Out Of Memory—OOM）</p><p>系统已经不能再分配出你所需要的空间，比如你需要100M的空间，系统只剩90M了，这就叫内存溢出</p></li><li><p>内存泄漏： (Memory Leak)—-》强引用所指向的对象不会被回收，可能导致内存泄漏，虚拟机宁愿抛出OOM也不会去回收他指向的对象</p><p>内存泄漏的根本原因是长生命周期的对象持有短生命周期对象的引用，尽管短生命周期的对象已经不再需要，但由于长生命周期对象持有它的引用而导致不能被回收。</p></li></ol><p>意思就是你用资源的时候为他开辟了一段空间，当你用完时忘记释放资源了，这时内存还被占用着，一次没关系，但是内存泄漏次数多了就会导致内存溢出</p><p>例子：你向系统申请分配内存进行使用(new)，可是使用完了以后却不归还(delete)，结果你申请到的那块内存你自己也不能再访问（也许你把它的地址给弄丢了），而系统也不能再次将它分配给需要的程序。就相当于你租了个带钥匙的柜子，你存完东西之后把柜子锁上之后，把钥匙丢了或者没有将钥匙还回去，那么结果就是这个柜子将无法供给任何人使用，也无法被垃圾回收器回收，因为找不到他的任何信息。</p><p>一般我们所说的内存泄漏指的是堆内存的泄露，堆内存是指程序从堆中分配的，大小随机的用完后必须显示释放的内存，C++/C中有free函数可以释放内存，java中有垃圾回收机制不用程序员自己手动调用释放</p><p>如果这块内存不释放，就不能再用了，这就叫这块内存泄漏了</p><h3 id="10-throw-和-throws的区别"><a href="#10-throw-和-throws的区别" class="headerlink" title="10. throw 和 throws的区别"></a>10. throw 和 throws的区别</h3><h3 id="11-instanceof运算符"><a href="#11-instanceof运算符" class="headerlink" title="11. instanceof运算符"></a>11. instanceof运算符</h3><p><strong>用来判断1个对象是否为右边类（接口，抽象类，父类）的实例</strong></p><h3 id="12-线程局部存储TLS-thread-local-storage"><a href="#12-线程局部存储TLS-thread-local-storage" class="headerlink" title="12. 线程局部存储TLS(thread local storage)"></a>12. 线程局部存储TLS(thread local storage)</h3><h3 id="13-递归（自己调用自己）"><a href="#13-递归（自己调用自己）" class="headerlink" title="13. 递归（自己调用自己）"></a>13. 递归（自己调用自己）</h3><ul><li>设计递归函数的重点在于给下级安排工作</li><li>一定要有终止条件(一定要有1个最小的集合)</li></ul><h3 id="14-equals和-有什么区别？"><a href="#14-equals和-有什么区别？" class="headerlink" title="14.equals和==有什么区别？"></a>14.equals和==有什么区别？</h3><p>1）对于==，比较的是值是否相等</p><pre><code>        如果作用于基本数据类型的变量，则直接比较其存储的 “值”是否相等；</code></pre><p>　　　　如果作用于引用类型的变量，则比较的是所指向的对象的地址</p><p>　　2）对于equals方法，注意：equals方法不能作用于基本数据类型的变量，equals继承Object类，比较的是是否是同一个对象</p><p>　　　　如果没有对equals方法进行重写，则比较的是引用类型的变量所指向的对象的地址；</p><p>　　　　诸如String、Date等类对equals方法进行了重写的话，比较的是所指向的对象的内容。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For Offer/Android/Android</title>
      <link href="blog/2475333922.html"/>
      <url>blog/2475333922.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、Android基础"><a href="#一、Android基础" class="headerlink" title="一、Android基础"></a>一、Android基础</h1><ol><li>⭐️⭐️⭐️⭐️⭐️四大组件</li></ol><ol start="2"><li><p>⭐️⭐️⭐️⭐️⭐️UI及VIew绘制和事件分发</p></li><li><p>⭐️⭐️⭐️⭐️⭐️Handler消息机制</p></li><li><p>序列化</p></li><li><p>⭐️⭐️⭐️⭐️图片相关bitmap,drawable,mipmap</p></li><li><p>⭐️⭐️动画</p></li><li><p>⭐️⭐️⭐️⭐️⭐️android中的进程和线程</p></li><li><p>android中的资源dimen,color,attrs,styles(dp,sp,px)</p></li><li><p>⭐️⭐️⭐️持久化存储sqlite等</p></li><li><p>架构设计MVP等</p></li><li><p>Android 10 的新特性</p></li></ol><h1 id="二、Android高级"><a href="#二、Android高级" class="headerlink" title="二、Android高级"></a>二、Android高级</h1><ol><li>⭐️⭐️⭐️⭐️性能优化</li><li>⭐️⭐️⭐️⭐️网络框架okhttp</li><li>⭐️⭐️⭐️⭐️图片处理框架picasso,glide</li><li>⭐️⭐️⭐️⭐️NDK jni</li><li>⭐️kotlin</li><li>音视频</li><li>⭐React Native</li><li>⭐RxJava</li><li>⭐️EventBus</li><li>⭐️热修复插件化</li><li>读过哪些(Framework)源码</li><li>Gradle</li></ol>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
