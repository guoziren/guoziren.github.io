<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
    <meta name="keywords" content="For Offer/面试题精编, Guoziren`s World">
    <meta name="description" content="">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>For Offer/面试题精编 | Guoziren`s World</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 4.2.0"><link rel="stylesheet" href="/css/prism-duotone-light.css" type="text/css"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>


<body>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">Guoziren`s World</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">Guoziren`s World</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    
<script src="/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = '';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('请输入访问本文章的密码')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/11.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">For Offer/面试题精编</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        height: calc(100vh - 250px);
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                          <div class="article-tag">
                            <span class="chip bg-color">无标签</span>
                          </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2020-05-06
                </div>
                

                

                

                

                
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="第一章：Android-基础"><a href="#第一章：Android-基础" class="headerlink" title="第一章：Android 基础"></a>第一章：Android 基础</h1><h2 id="一、-Activity-更新-2019-5-5"><a href="#一、-Activity-更新-2019-5-5" class="headerlink" title="一、 Activity(更新 2019.5.5)"></a>一、 Activity(更新 2019.5.5)</h2><h3 id="1、什么是-Activity以及Activity的生命周期"><a href="#1、什么是-Activity以及Activity的生命周期" class="headerlink" title="1、什么是 Activity以及Activity的生命周期?"></a>1、什么是 Activity以及Activity的生命周期?</h3><p>四大组件之一,一般的,一个用户交互界面对应一个 activity setContentView() ,// 要显示的布局 button.setOnclickLinstener{ }, activity 是 Context 的子类,同时实现了 window.callback 和 keyevent.callback, 可以处理与窗体用户交互的事件. </p>
<ul>
<li><h3 id="onCreate"><a href="#onCreate" class="headerlink" title="onCreate()"></a>onCreate()</h3></li>
</ul>
<p>系统第一次创建该Activity实例时会回调该方法。该方法一般承担着一些初始化工作，比如调用setContentView去加载界面布局，初始化Activity所需的数据并绑定到对应的View上。</p>
<ul>
<li><h3 id="onRestart"><a href="#onRestart" class="headerlink" title="onRestart()"></a>onRestart()</h3></li>
</ul>
<p>Activity从onStop状态，将要重新进入前台（由不可见到可见）。</p>
<ul>
<li><h3 id="onStart"><a href="#onStart" class="headerlink" title="onStart()"></a>onStart()</h3></li>
</ul>
<p>Activity正在启动，已经时可见的了，但还没到前台，无法和用户交互。</p>
<ul>
<li><h3 id="onResume"><a href="#onResume" class="headerlink" title="onResume()"></a>onResume()</h3></li>
</ul>
<p>Activity获得焦点或者即将获得焦点.。</p>
<ul>
<li><h3 id="onPause"><a href="#onPause" class="headerlink" title="onPause()"></a>onPause()</h3></li>
</ul>
<p>Activity离开前台，不能与用户交互。这也是Activity接收到用户要离开该Activity指令时所回调的第一个方法。比如：</p>
<ol>
<li>有电话打进来</li>
<li>手机息屏</li>
<li>进入其他的Activity</li>
<li>打开一个新的半透明的Activity</li>
<li>在Android 7.0之后的multi-window模式下，失去焦点的Activity会调用onPause</li>
</ol>
<p>onPause适合做轻量级的回收工作，比如停止动画等，而不适合进行太耗时的操作，因为旧的onPause执行完后，新的Activity的onResume才会执行。</p>
<p>执行完onPause后并不意味着activity就离开了Paused 状态了，因为此时旧的activity仍然可见且新的activity还未进入resume状态。如果activity变得完全不可见了，回调onStop。</p>
<ul>
<li><h3 id="onStop"><a href="#onStop" class="headerlink" title="onStop()"></a>onStop()</h3></li>
</ul>
<p>Activity即将停止，不再可见。</p>
<p>onStop适合做稍微重量级的回收工作，比如释放导致内存泄漏的资源，保存数据到数据库中。</p>
<p>有时候由于高优先级的应用需要内存，系统不足以分配，就把拥有该Activity的进程杀死来释放内存，这样就不会调用onDestory。(It is possible for the system to kill the process hosting your activity without calling the activity’s final <code>onDestroy()</code> callback.)</p>
<ul>
<li><h3 id="onDestroy"><a href="#onDestroy" class="headerlink" title="onDestroy()"></a>onDestroy()</h3></li>
</ul>
<p>Activity即将被销毁，Activity生命周期中最后一个回调，适合做最终的资源释放与回收工作。</p>
<p>有两种情况下，系统回调此方法。一是Activity的finish()被调用，二是系统为了节约内存而把activity所在的进程杀死(the system is temporarily destroying the process containing the activity to save space)。这两种方式可以用 <code>isFinishing()</code> 来区分，前者 <code>isFinishing()</code> 返回true。</p>
<p><strong>小结</strong></p>
<p>onCreate与onDestroy是一对回调，标志一个Activity的诞生与消亡；</p>
<p>onStart与onStop是一对回调，标志一个Activity是否可见；</p>
<p>onResume与onPause是一对回调，标志一个Activity是否能与用户交互，是位于前台还是后台。</p>
<h3 id="4、如何保存-Activity-的状态或者-Activiy-重启怎么保存数据？）"><a href="#4、如何保存-Activity-的状态或者-Activiy-重启怎么保存数据？）" class="headerlink" title="4、如何保存 Activity 的状态或者(Activiy 重启怎么保存数据？）"></a>4、如何保存 Activity 的状态或者(Activiy 重启怎么保存数据？）</h3><ol>
<li>配置变更：横竖屏切换或者切换到多窗口模式(系统默认会销毁Activity并重建。)。用户期望界面状态在配置变更时保持不变。</li>
</ol>
<ul>
<li><p>异常情况下发生配置变更或者内存不够时而销毁Activity</p>
<p>实际的 <a href="https://developer.android.google.cn/reference/android/app/Activity" target="_blank" rel="noopener"><code>Activity</code></a> 实例已消失，但系统会记住它曾经存在过。如果用户尝试回退到该 Activity，则系统将使用之前通过bundle对象中的键值对保存的 Activity 销毁时的状态来新建该 Activity 的实例。但是，可能需要保存更多的状态信息，比如成员变量系统不会帮你保存，系统会帮你保存有id的控件的状态，保存edittext中的内容.</p>
</li>
<li><p>正常情况下（按了返回键）</p>
<p>  系统会销毁Activity,也是用户期望的，不需要有额外的工作</p>
</li>
</ul>
<ol start="2">
<li><p>使用 <code>onSaveInstanceState()</code> 保存<strong>简单轻量的界面状态</strong></p>
<ul>
<li><code>onSaveInstanceState()</code> 不一定会调用，正常退出或者显示调用finish()时不会调用</li>
<li>异常情况下，onSaveInstanceState() 会在onPause()后调用</li>
<li>适合保存activity的成员变量,listview的滚动位置，edittext中的文本</li>
</ul>
</li>
<li><p><a href="https://developer.android.google.cn/reference/android/app/Activity#onRestoreInstanceState(android.os.Bundle)" target="_blank" rel="noopener"><code>onRestoreInstanceState()</code></a> 会在onStart()后调用</p>
</li>
<li><p>onCreate中的Bundle参数</p>
<ul>
<li>如果activity是新建的则他为Null,所以要进行非空判断</li>
</ul>
</li>
<li><p>持久化数据(sp或数据库),应在activity处于前台时或者onStop方法保存.</p>
</li>
</ol>
<h3 id="5、-两个-Activity-之间跳转时必然会执行的是哪几个方-法？"><a href="#5、-两个-Activity-之间跳转时必然会执行的是哪几个方-法？" class="headerlink" title="5、 两个 Activity 之间跳转时必然会执行的是哪几个方 法？"></a>5、 两个 Activity 之间跳转时必然会执行的是哪几个方 法？</h3><p>一般情况下比如说有两个activity,分别叫A,B,当在A里面激活B 组件的时候, A 会调用 onPause()方法,然后 B 调用 onCreate() ,onStart(), onResume()。</p>
<p>这个时候 B 覆盖了窗体, A 会调用 onStop()方法. 如果 B 是个透明的,或者 是对话框的样式, 就不会调用 A 的 onStop()方法。</p>
<h3 id="6、-横竖屏切换时-Activity-的生命周期（★★★★）"><a href="#6、-横竖屏切换时-Activity-的生命周期（★★★★）" class="headerlink" title="6、 横竖屏切换时 Activity 的生命周期（★★★★）"></a>6、 横竖屏切换时 Activity 的生命周期（★★★★）</h3><p>此时的生命周期跟清单文件里的配置有关系。 </p>
<ol>
<li><p>不设置 Activity 的 android:configChanges 时，切屏会重新调用各个生 命周期默认首先销毁当前 activity,然后重新加载。 </p>
</li>
<li><p>设置 Activity android:configChanges=”orientation|keyboardHidden|screenSize”时，切屏不会重新调用各个生命周期，而是会执行 onConfigurationChanged 方法。 </p>
</li>
<li><p>设置android:screenOrientation=“portrait”强制竖屏，此时旋转不会切换</p>
</li>
</ol>
<h3 id="7、-如何将一个-Activity-设置成窗口（对话框）的样式"><a href="#7、-如何将一个-Activity-设置成窗口（对话框）的样式" class="headerlink" title="7、 如何将一个 Activity 设置成窗口（对话框）的样式"></a>7、 如何将一个 Activity 设置成窗口（对话框）的样式</h3><p>只需要给我们的 Activity 配置如下属性即可。 android:theme=”@android:style/Theme.Dialog”</p>
<h3 id="8、-如何退-出-Activity？-如何-安-全退-出-已调-用-多个-Activity-的-Application？（★★★★）"><a href="#8、-如何退-出-Activity？-如何-安-全退-出-已调-用-多个-Activity-的-Application？（★★★★）" class="headerlink" title="8、 如何退 出 Activity？ 如何 安 全退 出 已调 用 多个 Activity 的 Application？（★★★★）"></a>8、 如何退 出 Activity？ 如何 安 全退 出 已调 用 多个 Activity 的 Application？（★★★★）</h3><ol>
<li><p>通常情况用户退出一个 Activity 只需按返回键，我们写代码想退出 activity 直接调用 finish()方法就行。 </p>
</li>
<li><p>记录打开的 Activity： 每打开一个 Activity，就记录下来。在需要退出时，关闭每一个 Activity 即可。</p>
</li>
</ol>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//伪代码 </span>
List<span class="token operator">&lt;</span>Activity<span class="token operator">></span> lists <span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// 在 application 全局的变量里面 </span>
lists <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Activity<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
lists<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token keyword">for</span><span class="token punctuation">(</span>Activity activity<span class="token operator">:</span> lists<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    activity<span class="token punctuation">.</span><span class="token function">finish</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span> 
lists<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<ol start="3">
<li>发送特定广播： 在需要结束应用时，发送一个特定的广播，每个 Activity 收到广播后，关闭 即可。</li>
</ol>
<pre class=" language-java"><code class="language-java"> <span class="token comment" spellcheck="true">//给某个 activity 注册接受接受广播的意图</span>
<span class="token function">registerReceiver</span><span class="token punctuation">(</span>receiver<span class="token punctuation">,</span> filter<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//如果过接受到的是 关闭 activity 的广播 activity finish()掉</span></code></pre>
<p> 4、递归退出</p>
<p>就调用 finish()方法 把当前的</p>
<p>在打开新的 Activity 时使用 startActivityForResult，然后自己加标志，在 onActivityResult 中处理，递归关闭。 5、其实 也可以通过 intent 的 flag 来实现 intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP)激活一个新的 activity。 此时如果该任务栈中已经有该 Activity，那么系统会把这个 Activity 上面的所有 Activity 干掉。其实相当于给 Activity 配置的启动模式为 SingleTop。</p>
<h3 id="9、-Activity-的-四-种-启-动-模-式-，-singleTop-和-singletask-区别是什么？一般书签的使用模式是-singleTop，那为什么不使用-singleTask"><a href="#9、-Activity-的-四-种-启-动-模-式-，-singleTop-和-singletask-区别是什么？一般书签的使用模式是-singleTop，那为什么不使用-singleTask" class="headerlink" title="9、 Activity 的 四 种 启 动 模 式 ， singleTop 和 singletask 区别是什么？一般书签的使用模式是 singleTop，那为什么不使用 singleTask?"></a>9、 Activity 的 四 种 启 动 模 式 ， singleTop 和 singletask 区别是什么？一般书签的使用模式是 singleTop，那为什么不使用 singleTask?</h3><p>任务是用户在执行某项工作时与之互动的一系列 Activity 的集合。这些 Activity 按照每个 Activity 打开的顺序排列在一个返回堆栈中。</p>
<ul>
<li><p>singleInsance:这种模式的activity会新开并独占一个task,  由该 Activity 启动的任何 Activity 都会在其他的任务中打开. 呼叫来电界面</p>
</li>
<li><p>singleTop:栈顶只能有1个，但栈内可以有多个。比如搜索activity，二维码扫描</p>
<ul>
<li>栈中已有该Activity的实例并且该实例位于栈顶时<strong>,启动他时，会复用，并将Intent对象传入，回调onNewIntent()方法；</strong></li>
<li>2、新闻详情页面。<br>假设主界面为 MainActivity，显示新闻的界面是 DetailActivity，显然显示任何一条新闻都会使用 DetailActivity，即把新闻内容通过 Intent 传给 DetailActivity 就可以了。 假设你正在看新闻1(即在 DetailActivity)，此时手机收到服务器的推送：收到一条通知(新闻2)，点击通知就会跳转到 DetailActivity 并显示新闻2，当你点击通知时，因为目前栈顶的 Activity 就是 DetailActivity，因此这里就是使用 SingleTop 的地方，即点击通知后以 SingleTop 加载模式打开 DetailActivity 并显示新闻2，因此新闻1的 DetailActivity 就被覆盖掉了。 此后你点击返回键会回到主界面。</li>
</ul>
</li>
<li><p>singleTask:</p>
<ul>
<li><p>task中只能有1个，启动他时，他上面的activity会全部清除。</p>
</li>
<li><p>设置了<code>singleTask</code>启动模式的<code>Activity</code>，它在启动的时候，会先在系统中查找属性值<code>affinity</code>等于它的属性值<code>taskAffinity</code>的任务存在；如果存在这样的任务，它就会在这个任务中启动，否则就会在新任务中启动。因此，如果我们想要设置了<code>singleTask</code>启动模式的<code>Activity</code>在新的任务中启动，就要为它设置一个独立的<code>taskAffinity</code>属性值。如果设置了<code>singleTask</code>启动模式的Activity不是在新的任务中启动时，它会在已有的任务中查看是否已经存在相应的<code>Activity</code>实例，如果存在，就会把位于这个<code>Activity</code>实例上面的Activity全部结束掉，即最终这个Activity实例会位于任务的堆栈顶端中。</p>
</li>
</ul>
</li>
</ul>
<pre><code>但是，如果另外的任务中已存在该 Activity 的实例，则系统会通过调用其 `onNewIntent()` 方法将 intent 转送到该现有实例，而不是创建新实例。Activity 一次只能有一个实例存在。比如应用的主界面</code></pre><ul>
<li>比如浏览器应用，览器 Activity 应始终在它自己的任务中打开。这意味着，如果您的应用发出打开 Android 浏览器的 intent，系统不会将其 Activity 置于您的应用所在的任务中，而是会为浏览器启动一个新任务，如果浏览器已经有任务在后台运行，则会将该任务转到前台来处理新 intent。</li>
</ul>
<ul>
<li>standard:调用startActivity都会创建实例</li>
</ul>
<p>默认情况下，新 Activity 会启动到调用 <code>startActivity()</code> 的 Activity 的任务中。它会被推送到调用方 Activity 所在的返回堆栈中。</p>
<h6 id="taskAffinity-属性-默认不设置为应用的报名，设置了非本应用的包名后，且是singleTask的情况下，会添加到该名称的task"><a href="#taskAffinity-属性-默认不设置为应用的报名，设置了非本应用的包名后，且是singleTask的情况下，会添加到该名称的task" class="headerlink" title="taskAffinity 属性 : 默认不设置为应用的报名，设置了非本应用的包名后，且是singleTask的情况下，会添加到该名称的task"></a>taskAffinity 属性 : 默认不设置为应用的报名，设置了非本应用的包名后，且是singleTask的情况下，会添加到该名称的task</h6><h3 id="10、Android-中的-Context-Activity，Appliction-有-什么区别？（★★）"><a href="#10、Android-中的-Context-Activity，Appliction-有-什么区别？（★★）" class="headerlink" title="10、Android 中的 Context, Activity，Appliction 有 什么区别？（★★）"></a>10、Android 中的 Context, Activity，Appliction 有 什么区别？（★★）</h3><ul>
<li><p>相同：Activity 和 Application 都是 Context 的子类。 Context 从字面上理解就是上下文的意思，在实际应用中它也确实是起到了管理 上下文环境中各个参数和变量的作用，方便我们可以简单的访问到各种资源。 </p>
</li>
<li><p>不同：维护的生命周期不同。 Context 维护的是当前的 Activity 的生命周期， Application 维护的是整个应用的生命周期。 使用 context 的时候，小心内存泄露，防止内存泄露，注意一下几个方面：</p>
</li>
</ul>
<ol>
<li><p>不要让生命周期长的对象引用 activity context，即保证引用 activity 的对象 要与 activity 本身生命周期是一样的。</p>
</li>
<li><p>对于生命周期长的对象，可以使用 application，context。</p>
</li>
<li><p>避免非静态的内部类，尽量使用静态类，避免生命周期问题，注意内部类对 外部对象引用导致的生命周期变化。</p>
</li>
</ol>
<h3 id="11、两个-Activity-之间传递数据，除了-intent，广播接-收者，content-provider-还有啥？"><a href="#11、两个-Activity-之间传递数据，除了-intent，广播接-收者，content-provider-还有啥？" class="headerlink" title="11、两个 Activity 之间传递数据，除了 intent，广播接 收者，content provider 还有啥？"></a>11、两个 Activity 之间传递数据，除了 intent，广播接 收者，content provider 还有啥？</h3><p>​    1）利用 static 静态数据，public static 成员变量 </p>
<p>​    2）利用外部存储的传输， 例如 File 文件存储</p>
<p>​    3)   SharedPreferences 首选项 Sqlite 数据库</p>
<h3 id="12、Context-是-什-么-？-一-个-应-用-有-多-少-个-Context-2019-5-5）（★★）"><a href="#12、Context-是-什-么-？-一-个-应-用-有-多-少-个-Context-2019-5-5）（★★）" class="headerlink" title="12、Context 是 什 么 ？ 一 个 应 用 有 多 少 个 Context(2019.5.5）（★★）"></a>12、Context 是 什 么 ？ 一 个 应 用 有 多 少 个 Context(2019.5.5）（★★）</h3><p>1、它描述的是一个应用程序环境的信息，即上下文。 </p>
<p>2、该类是一个抽象(abstract class)类，Android 提供了该抽象类的具体实 现类（ContextIml）。 </p>
<p>3、通过它我们可以获取应用程序的资源和类，也包括一些应用级别操作， 例如：启动一个 Activity，发送广播，接受 Intent，信息，等。</p>
<p> 4、一个应用 Context 数量 = Activity 个数+service 个数+1 个</p>
<h3 id="13-activity-之间还有-activity-和-service-之间如何传值，可以传图片吗？-2019-5-5）（上海）"><a href="#13-activity-之间还有-activity-和-service-之间如何传值，可以传图片吗？-2019-5-5）（上海）" class="headerlink" title="13.activity 之间还有 activity 和 service 之间如何传值，可以传图片吗？ (2019.5.5）（上海）"></a>13.activity 之间还有 activity 和 service 之间如何传值，可以传图片吗？ (2019.5.5）（上海）</h3><h4 id="Activity-之间的传值："><a href="#Activity-之间的传值：" class="headerlink" title="Activity 之间的传值："></a>Activity 之间的传值：</h4><p>​    startActivity，通过 Intent 对象的各种 putExtra 方法来 进行传递。在第二个 Activity 对象中，可以通过 getIntent() 方法来得到跳转 到这个 Activity 的 Intent 对象，然后通过 Intent 对象的各种 getXXExtra 方 法来得到我们的传过来的值。 </p>
<h4 id="Activity-和-Service-之间传值："><a href="#Activity-和-Service-之间传值：" class="headerlink" title="Activity 和 Service 之间传值："></a>Activity 和 Service 之间传值：</h4><p>​    1、service 可以从 <code>public int onStartCommand(Intent intent, int flags, int startId)</code>中取出从 activity 中传过来的值。intent.getExtra()获得 bundle 对象， 可从中取值。 </p>
<p>​    2、activity 也可以用 <code>bindService(intent, conn,BIND_AUTO_CREATE)</code>传 值，把要传的值绑定在 intent 里，在 service 的 <code>public IBinder onBind(Intent intent)</code> 方法里取得 intent。 </p>
<p>​    3、同时也可以在 reseiver 里面注册一个广播，在 activity 里 <code>sendbroadcast(intent)</code>传值。 可以传递图片，用 Intent 把图片的地址或者把图片对象用 Intent 传过去， 用 bitmap 对象。</p>
<h3 id="14-startActivityForResult-和-onActivityResult"><a href="#14-startActivityForResult-和-onActivityResult" class="headerlink" title="14. startActivityForResult() 和 onActivityResult()"></a>14. startActivityForResult() 和 onActivityResult()</h3><p>​    用于activity之间回传值</p>
<pre class=" language-java"><code class="language-java"><span class="token function">onActivityResult</span><span class="token punctuation">(</span><span class="token keyword">int</span> requestCode<span class="token punctuation">,</span> <span class="token keyword">int</span> resultCode<span class="token punctuation">,</span> Intent data<span class="token punctuation">)</span>
    resultCode<span class="token operator">:</span>用于判断是否成功
    requestCode<span class="token operator">:</span>用于判断是哪个activity</code></pre>
<h2 id="二、-Service"><a href="#二、-Service" class="headerlink" title="二、 Service"></a>二、 Service</h2><h3 id="0-什么是服务？"><a href="#0-什么是服务？" class="headerlink" title="0.什么是服务？"></a>0.什么是服务？</h3><p><code>Service</code> 是一种可在后台执行长时间运行操作而不提供界面的应用组件。服务可由其他应用组件启动，而且即使用户切换到其他应用，服务仍将在后台继续运行。此外，组件可通过绑定到服务与之进行交互，甚至是执行进程间通信 (IPC)。例如，服务可在后台处理网络事务、播放音乐，执行文件 I/O 或与内容提供程序进行交互。</p>
<h3 id="1-Service-是否在-main-thread-中执行-service-里面是否能执-行耗时的操作-（★★）"><a href="#1-Service-是否在-main-thread-中执行-service-里面是否能执-行耗时的操作-（★★）" class="headerlink" title="1.Service 是否在 main thread 中执行, service 里面是否能执 行耗时的操作?（★★）"></a>1.Service 是否在 main thread 中执行, service 里面是否能执 行耗时的操作?（★★）</h3><p>服务在其托管进程的主线程中运行，它既<strong>不</strong>创建自己的线程，也<strong>不</strong>在单独的进程中运行（除非另行指定）。如果服务将执行任何 CPU 密集型工作或阻止性/耗时操作（例如 MP3 播放或联网），则应通过在服务内创建新线程来完成这项工作。通过使用单独的线程，您可以降低发生“应用无响应”(ANR) 错误的风险，而应用的主线程仍可继续专注于运行用户与 Activity 之间的交互。</p>
<pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>service</span> <span class="token attr-name"><span class="token namespace">android:</span>name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.baidu.location.f<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">android:</span>enabled</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> 
         <span class="token attr-name"><span class="token namespace">android:</span>process</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>:player<span class="token punctuation">"</span></span> <span class="token punctuation">></span></span> 
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>service</span><span class="token punctuation">></span></span></code></pre>
<h3 id="2-Activity-怎么和-Service-绑定，怎么在-Activity-中启动自己-对应的-Service？"><a href="#2-Activity-怎么和-Service-绑定，怎么在-Activity-中启动自己-对应的-Service？" class="headerlink" title="2.Activity 怎么和 Service 绑定，怎么在 Activity 中启动自己 对应的 Service？"></a>2.Activity 怎么和 Service 绑定，怎么在 Activity 中启动自己 对应的 Service？</h3><p>Activity 通过 <code>bindService(Intent service, ServiceConnection conn, int flags)</code>跟 Service 进行绑定，当绑定成功的时候 Service 会将代理对象通过回调的形式传给 conn，这样我们就拿到了 Service 提供的服务代理对象。</p>
<p>在 Activity 中可以通过 startService 和 bindService 方法启动 Service。一 般情况下如果想获取 Service 的服务对象那么肯定需要通过 bindService（）方 法，比如音乐播放器，第三方支付等。如果仅仅只是为了开启一个后台任务那么 可以使用 startService（）方法。</p>
<h3 id="3-请描述一下-Service-的生命周期（★★★）"><a href="#3-请描述一下-Service-的生命周期（★★★）" class="headerlink" title="3.请描述一下 Service 的生命周期（★★★）"></a>3.请描述一下 Service 的生命周期（★★★）</h3><p>Service 有绑定模式和非绑定模式，以及这两种模式的混合使用方式。不同 的使用方法生命周期方法也不同。</p>
<p>非 绑 定 模 式 ： 当 第 一 次 调 用 startService 的 时 候 执 行 的 方 法 依 次 为 onCreate()、</p>
<p>​                            onStartCommand()，当 Service 关闭的时候调用 onDestory 方 法。</p>
<p>绑定模式：第一次 bindService（）的时候， 执行的方法为 onCreate()、 onBind(）;</p>
<p>​                    解除绑定的时候会执行 onUnbind()、onDestory()。</p>
<p>上面的两种生命周期是在相对单纯的模式下的情形。注意如果当前要启动的 Service 已经存在了那么就不会再次创建该 Service 当然也不会调用 onCreate（）方法。 一个 Service 可以被多个客户进行绑定， 只有所有的绑定对象都执行了 unBind（）方法后该 Service 才会销毁，不过如果有一个客户执行了 onStart() 方法，那么这个时候如果所有的 bind 客户都执行了 unBind()该 Service 也不会 销毁。</p>
<p>Service 的生命周期图如下所示，帮助大家记忆。</p>
<p><img src=".%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B2%BE%E7%BC%96_images/image-20200508144319768.png" alt="image-20200508144319768"></p>
<h3 id="4-什么是-IntentService？有何优点？（★★★）"><a href="#4-什么是-IntentService？有何优点？（★★★）" class="headerlink" title="4.什么是 IntentService？有何优点？（★★★）"></a>4.什么是 IntentService？有何优点？（★★★）</h3><p>我们通常只会使用 Service。那么看了下面的介绍相信你就不再陌生了。如果你还是不了解那么在 面试的时候你就坦诚说没用过或者不了解等。并不是所有的问题都需要回答上来 的。 </p>
<p>一、IntentService 简介</p>
<p>​         IntentService 是 Service 的子类，比普通的 Service 增加了额外的功能。 先看 Service 本身存在两个问题： Service 不会专门启动一条单独的进程，Service 与它所在应用位于同一个进 程中； </p>
<p>Service 也不是专门一条新线程，因此不应该在 Service 中直接处理耗时的 任务； </p>
<p>二、IntentService 特征 </p>
<ul>
<li><p>会创建独立的 worker 线程来处理所有的 Intent 请求；</p>
</li>
<li><p>会创建独立的 worker 线程来处理 onHandleIntent()方法实现的代码，无需 处理多线程问题； </p>
</li>
<li><p>所有请求处理完成后，IntentService 会自动停止，无需调用 stopSelf()方法 停止 Service； </p>
</li>
<li><p>为 Service 的 onBind()提供默认实现，返回 null；</p>
</li>
<li><p>为 Service 的 onStartCommand 提供默认实现，将请求 Intent 添加到队列 中；</p>
</li>
</ul>
<p>使用 IntentService</p>
<p>​         一 个 IntentService 的 使 用 例 子 供 参 考 。 该 例 子 中 一 个 MainActivity 一个 MyIntentService，这两个类都是四大组件当然需要在清单 文件中注册。这里只给出核心代码：</p>
<pre class=" language-java"><code class="language-java">MainActivity<span class="token punctuation">.</span>java<span class="token operator">:</span>

<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">click</span><span class="token punctuation">(</span>View view<span class="token punctuation">)</span><span class="token punctuation">{</span> 
  Intent intent <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Intent</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> MyIntentService<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
  intent<span class="token punctuation">.</span><span class="token function">putExtra</span><span class="token punctuation">(</span><span class="token string">"start"</span><span class="token punctuation">,</span> <span class="token string">"MyIntentService"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
  <span class="token function">startService</span><span class="token punctuation">(</span>intent<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>

MyIntentService<span class="token punctuation">.</span>java

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyIntentService</span> <span class="token keyword">extends</span> <span class="token class-name">IntentService</span> <span class="token punctuation">{</span> 
  <span class="token keyword">private</span> String ex <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span> 
  <span class="token keyword">private</span> Handler mHandler <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleMessage</span><span class="token punctuation">(</span>android<span class="token punctuation">.</span>os<span class="token punctuation">.</span>Message msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>                                                         Toast<span class="token punctuation">.</span><span class="token function">makeText</span><span class="token punctuation">(</span>MyIntentService<span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token string">"-e "</span> <span class="token operator">+</span> ex<span class="token punctuation">,</span> Toast<span class="token punctuation">.</span>LENGTH_LONG<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token punctuation">}</span> 
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token function">MyIntentService</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token string">"MyIntentService"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span> 
  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">onStartCommand</span><span class="token punctuation">(</span>Intent intent<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span> <span class="token keyword">int</span> startId<span class="token punctuation">)</span> <span class="token punctuation">{</span>

            ex <span class="token operator">=</span> intent<span class="token punctuation">.</span><span class="token function">getStringExtra</span><span class="token punctuation">(</span><span class="token string">"start"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onStartCommand</span><span class="token punctuation">(</span>intent<span class="token punctuation">,</span> flags<span class="token punctuation">,</span> startId<span class="token punctuation">)</span><span class="token punctuation">;</span> 
  <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span> 
  <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">onHandleIntent</span><span class="token punctuation">(</span>Intent intent<span class="token punctuation">)</span> <span class="token punctuation">{</span>

        <span class="token comment" spellcheck="true">/** * 模拟执行耗时任务 * 该方法是在子线程中执行的，因此需要用到 handler 跟主线程进行通信 */</span> 
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
                Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token punctuation">}</span> 
    mHandler<span class="token punctuation">.</span><span class="token function">sendEmptyMessage</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
                Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span></code></pre>
<p>运行后效果如下：</p>
<h3 id="5-说说-Activity、Intent、Service-是什么关系"><a href="#5-说说-Activity、Intent、Service-是什么关系" class="headerlink" title="5.说说 Activity、Intent、Service 是什么关系"></a>5.说说 Activity、Intent、Service 是什么关系</h3><p>他们都是 Android 开发中使用频率最高的类。其中 Activity 和 Service 都是 Android 四大组件之一。他俩都是 Context 类的子类 ContextWrapper 的子类， Activity 负责用户界面的显示和交互，Service 负责后台任务的处理。Activity 和 Service 之间可 以通过 Intent 传递数据，因此可以把 Intent 看作是通信使者。</p>
<h3 id="6-Service-和-Activity-在同一个线程吗，服务和线程的区别（★）"><a href="#6-Service-和-Activity-在同一个线程吗，服务和线程的区别（★）" class="headerlink" title="6.Service 和 Activity 在同一个线程吗，服务和线程的区别（★）"></a>6.Service 和 Activity 在同一个线程吗，服务和线程的区别（★）</h3><p>对于同一 app 来说默认情况下是在同一个线程中的， main Thread （UIThread）。</p>
<ul>
<li><p>服务是一种即使用户未与应用交互也可在后台运行的组件，因此，只有在需要服务时才应创建服务</p>
<p>比如微信中的播放的音乐，退出微信了，也在播放中。</p>
</li>
<li><p>如果您必须在主线程之外执行操作，但只在用户与您的应用交互时执行此操作，则应创建新线程。例如，如果您只是想在 Activity 运行的同时播放一些音乐，则可在 <code>onCreate()</code> 中创建线程，在 <code>onStart()</code> 中启动线程运行，然后在 <code>onStop()</code> 中停止线程。</p>
</li>
</ul>
<h3 id="7-Service-里面可以弹吐司么（★）"><a href="#7-Service-里面可以弹吐司么（★）" class="headerlink" title="7.Service 里面可以弹吐司么（★）"></a>7.Service 里面可以弹吐司么（★）</h3><p>可以的。弹吐司有个条件就是得有一个 Context 上下文，而 Service 本身就是 Context 的子类， 因此在 Service 里面弹吐司是完全可以的。 比如我们在Service 中完成下载任务后可以弹一个吐司通知用户。</p>
<h3 id="8-什么是-Service-以及描述下它的生命周期。Service-有哪些启动方"><a href="#8-什么是-Service-以及描述下它的生命周期。Service-有哪些启动方" class="headerlink" title="8.什么是 Service 以及描述下它的生命周期。Service 有哪些启动方"></a>8.什么是 Service 以及描述下它的生命周期。Service 有哪些启动方</h3><p>法，有什么区别，怎样停用 Service？（★★★）</p>
<p>1． 通过 startService</p>
<p>Service 会经历 onCreate 到 onStart，然后处于运行状态，stopService 的时候调用 onDestroy 方法。</p>
<p>如果是调用者自己直接退出而没有调用 stopService 的话，Service 会一直 在后台运行。</p>
<p>2． 通过 bindService</p>
<p>Service会运行onCreate，然后是调用onBind，这个时候调用者和Service 绑定在一起。调用者退出了，Srevice 就会调用 onUnbind-&gt;onDestroyed 方 法。</p>
<p>所谓绑定在一起就共存亡了。调用者也可以通过调用 unbindService 方法来</p>
<p>停止服务，这时候 Srevice 就会调用 onUnbind-&gt;onDestroyed 方法。 需要注意的是如果这几个方法交织在一起的话，会出现什么情况呢？ 一个原则是 Service 的 onCreate 的方法只会被调用一次，就是你无论多少次的 startService 又 bindService，Service 只被创建一次。</p>
<p>如果先是 bind 了，那么 start 的时候就直接运行 Service 的 onStart 方法， 如果先是 start，那么 bind 的时候就直接运行 onBind 方法。 如果 service 运行期间调用了 bindService，这时候再调用 stopService 的话， service 是不会调用 onDestroy 方法的，service 就 stop 不掉了，只能调用 UnbindService, service 就会被销毁</p>
<p>如果一个 service 通过 startService 被 start 之后，多次调用 startService 的话，service 会多次调用 onStart 方法。多次调用 stopService 的话，service 只会调用一次 onDestroyed 方法。</p>
<p>如果一个 service 通过 bindService 被 start 之后，多次调用 bindService 的话，service 只会调用一次 onBind 方法。 多次调用 unbindService 的话会抛出异常。</p>
<h2 id="三、Broadcast-Receiver"><a href="#三、Broadcast-Receiver" class="headerlink" title="三、Broadcast Receiver"></a>三、Broadcast Receiver</h2><h3 id="1-请描述一下-BroadcastReceiver（★★）"><a href="#1-请描述一下-BroadcastReceiver（★★）" class="headerlink" title="1.请描述一下 BroadcastReceiver（★★）"></a>1.请描述一下 BroadcastReceiver（★★）</h3><ul>
<li><p>BroadCastReceiver 是 Android 四大组件之一，主要用于接收系统或者 app 发送的广播通知，比如开机启动、sd 挂载、 低电量、外播电话、锁屏。如果我们做的是播放器，那么监听到用户锁屏后我们应该将我们的播放之暂停 等。</p>
</li>
<li><p>广播分两种：有序广播和无序广播。 </p>
</li>
</ul>
<p><strong>无序广播</strong>：完全异步，逻辑上可以被任何广播接收者接收到。优点是效率较高。 缺点是一个接收者不能将处理结果传递给下一个接收者，并无法终止广播 intent 的传播。 </p>
<p><strong>有序广播</strong>：按照被接收者的优先级顺序，在被接收者中依次传播。比如有三个广 播接收者 A，B，C，优先级是 A &gt; B &gt; C。那这个消息先传给 A，再传给 B，最 后传给 C。每个接收者有权终止广播，比如 B 终止广播，C 就无法接收到。此外 A 接收到广播后可以对结果对象进行操作，当广播传给 B 时，B 可以从结果对象 中取得 A 存入的数据。 </p>
<pre class=" language-java"><code class="language-java">Context<span class="token punctuation">.</span><span class="token function">sendOrderedBroadcast</span><span class="token punctuation">(</span>intent<span class="token punctuation">,</span> receiverPermission<span class="token punctuation">,</span> resultReceiver<span class="token punctuation">,</span> scheduler<span class="token punctuation">,</span> initialCode<span class="token punctuation">,</span> initialData<span class="token punctuation">,</span> initialExtras<span class="token punctuation">)</span></code></pre>
<p>我们可以 指定 resultReceiver 广播接收者，这个接收者我们可以认为是最终接收者，通 常情况下如果比他优先级更高的接收者如果没有终止广播，那么他的 onReceive 会被执行两次，第一次是正常的按照优先级顺序执行，<strong>第二次</strong>是作为最终接收者 接收。如果比他优先级高的接收者终止了广播，那么他<strong>依然能接收</strong>到广播。 </p>
<ul>
<li>内部通信实现机制：通过 Android 系统的 Binder 机制实现通信。 </li>
</ul>
<h3 id="2-在-manifest-和代码中如何注册和使用-BroadcastReceiver"><a href="#2-在-manifest-和代码中如何注册和使用-BroadcastReceiver" class="headerlink" title="2.在 manifest 和代码中如何注册和使用 BroadcastReceiver"></a>2.在 manifest 和代码中如何注册和使用 BroadcastReceiver</h3><p>在清单文件中注册广播接收者称为静态注册，在代码中注册称为动态注册。</p>
<p>静态注册的广播接收者只要 app 在系统中运行,则一直可以接收到广播消息，动</p>
<p>态注册的广播接收者当注册的 Activity 或者 Service 销毁了那么就接收不到广播</p>
<p>了。</p>
<p>静态注册：在清单文件中进行如下配置</p>
<pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>receiver</span> <span class="token attr-name"><span class="token namespace">android:</span>name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>.BroadcastReceiver1<span class="token punctuation">"</span></span> <span class="token punctuation">></span></span> 
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>intent-filter</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>action</span> <span class="token attr-name"><span class="token namespace">android:</span>name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>android.intent.action.CALL<span class="token punctuation">"</span></span> <span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>action</span><span class="token punctuation">></span></span> 
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>intent-filter</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>receiver</span><span class="token punctuation">></span></span></code></pre>
<p>动态注册：在代码中进行如下注册</p>
<pre class=" language-java"><code class="language-java">receiver <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BroadcastReceiver</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
IntentFilter intentFilter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IntentFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
intentFilter<span class="token punctuation">.</span><span class="token function">addAction</span><span class="token punctuation">(</span>CALL_ACTION<span class="token punctuation">)</span><span class="token punctuation">;</span> 
context<span class="token punctuation">.</span><span class="token function">registerReceiver</span><span class="token punctuation">(</span>receiver<span class="token punctuation">,</span> intentFilter<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<h3 id="3-BroadCastReceiver-的生命周期"><a href="#3-BroadCastReceiver-的生命周期" class="headerlink" title="3.BroadCastReceiver 的生命周期"></a>3.BroadCastReceiver 的生命周期</h3><p>a. 广播接收者的生命周期非常短暂的， 在接收到广播的时候创建， onReceive()方法结束之后销毁；</p>
<p>b. 广播接收者中不要做一些耗时的工作， 否则会弹出 Application No Response 错误对话框；</p>
<p>c. 最好也不要在广播接收者中创建子线程做耗时的工作，因为广播接收者被 销毁后进程就成为了空进程，很容易被系统杀掉?；</p>
<p>d. 耗时的较长的工作最好放在服务中完成；</p>
<h3 id="4、Android-引入广播机制的用意"><a href="#4、Android-引入广播机制的用意" class="headerlink" title="4、Android 引入广播机制的用意"></a>4、Android 引入广播机制的用意</h3><p>a. 从 MVC 的角度考虑(应用程序内) 其实回答这个问题的时候还可以这样问， android 为什么要有那 4 大组件，现在的移动开发模型基本上也是照搬的 web 那一套 MVC 架构，只不过是改了点嫁妆而已。android 的四大组件本 质上就是为了实现移动或者说嵌入式设备上的 MVC 架构，它们之间有时候 是一种相互依存的关系，有时候又是一种补充关系，引入广播机制可以方便 几大组件的信息和数据交互。</p>
<p>b.程序间互通消息(例如在自己的应用程序内监听系统来电) </p>
<p>c. 效率上(参考 UDP 的广播协议在局域网的方便性) </p>
<p>d.设计模式上(反转控制的一种应用，类似监听者模式)</p>
<h2 id="四、-ContentProvider（更新-2019-6-14）"><a href="#四、-ContentProvider（更新-2019-6-14）" class="headerlink" title="四、 ContentProvider（更新 2019.6.14）"></a>四、 ContentProvider（更新 2019.6.14）</h2><h3 id="1-请介绍下-ContentProvider-是如何实现数据共享的（★★★）"><a href="#1-请介绍下-ContentProvider-是如何实现数据共享的（★★★）" class="headerlink" title="1.请介绍下 ContentProvider 是如何实现数据共享的（★★★）"></a>1.请介绍下 ContentProvider 是如何实现数据共享的（★★★）</h3><p>在 Android 中如果想将自己应用的数据（一般多为数据库中的数据）提供</p>
<p>给第三发应用，那么我们只能通过 ContentProvider 来实现了。</p>
<p>ContentProvider 是应用程序之间共享数据的接口。使用的时候首先自定义</p>
<p>一个类继承 ContentProvider，然后覆写 query、insert、update、delete 等</p>
<p>方法。因为其是四大组件之一因此必须在 AndroidManifest 文件中进行注册。</p>
<p>把自己的数据通过 uri 的形式共享出去，android</p>
<p>系统下 不同程序 数据默认</p>
<p>是不能共享访问，需要去实现一个类去继承 ContentProvider</p>
<p>public class PersonContentProvider extends ContentProvider{ public boolean onCreate(){</p>
<p>} query(Uri, String[], String, String[], String)</p>
<p>insert(Uri, ContentValues) update(Uri, ContentValues, String, String[]) delete(Uri, String, String[])</p>
<p>}</p>
<p>&lt;provider android:exported=”true” android:name=”com.itheima.contenProvider.provider.PersonContentPro vider”android:authorities=”com.itheima.person” /&gt;</p>
<p>第三方可以通过 ContentResolver 来访问该 Provider。</p>
<h3 id="2-为什么要用-ContentProvider？它和-sql-的实现上有什么差"><a href="#2-为什么要用-ContentProvider？它和-sql-的实现上有什么差" class="headerlink" title="2.为什么要用 ContentProvider？它和 sql 的实现上有什么差"></a>2.为什么要用 ContentProvider？它和 sql 的实现上有什么差</h3><p>别？（★★★）</p>
<p>ContentProvider 屏蔽了数据存储的细节,内部实现对用户完全透明,用户只 需要关心操作数据的 uri 就可以了，ContentProvider 可以实现不同 app 之间 共享。</p>
<p>Sql 也有增删改查的方法， 但是 sql 只能查询本应用下的数据库。 而 ContentProvider 还可以去增删改查本地文件. xml 文件的读取等。</p>
<h3 id="3-说说-ContentProvider、ContentResolver、ContentObserver"><a href="#3-说说-ContentProvider、ContentResolver、ContentObserver" class="headerlink" title="3.说说 ContentProvider、ContentResolver、ContentObserver"></a>3.说说 ContentProvider、ContentResolver、ContentObserver</h3><p>之间的关系（★★★★）</p>
<p>a. ContentProvider 内容提供者，用于对外提供数据</p>
<p>b. ContentResolver.notifyChange(uri)发出消息</p>
<p>c. ContentResolver 内容解析者，用于获取内容提供者提供的数据</p>
<p>d. ContentObserver 内容监听器，可以监听数据的改变状态</p>
<p>e. ContentResolver.registerContentObserver()监听消息。</p>
<h3 id="4-使用-contentProvider-获取本地所有的音频文件-上海）-更-新-2019-5-5-（★★★）"><a href="#4-使用-contentProvider-获取本地所有的音频文件-上海）-更-新-2019-5-5-（★★★）" class="headerlink" title="4.使用 contentProvider 获取本地所有的音频文件(上海） (更 新 2019.5.5)（★★★）"></a>4.使用 contentProvider 获取本地所有的音频文件(上海） (更 新 2019.5.5)（★★★）</h3><p>Android 中，系统为多媒体类型的文件（比如图片、音频、视频等）建立了 数据库(sqlite 数据库)，将文件的名称、大小等信息存储起来，从而完成多媒体 数据的维护工作；所以我们需要实现建立一个实体类。</p>
<p>可以根据 ContentResover 获取到一个 Cursor，然后根据这个游标，遍历所 有的歌曲的信息，设置给实体类，得到你想要的音频文件。因为是从本地读取数 据，所以需要添加权限</p>
<p>&lt;uses-permission</p>
<p>android:name=”android.permission.READ_EXTERNAL_STORAGE”/&gt;</p>
<h2 id="五、-ListView"><a href="#五、-ListView" class="headerlink" title="五、 ListView"></a>五、 ListView</h2><h3 id="1-ListView-如何提高其效率？（★★）"><a href="#1-ListView-如何提高其效率？（★★）" class="headerlink" title="1.ListView 如何提高其效率？（★★）"></a>1.ListView 如何提高其效率？（★★）</h3><p>当 convertView 为空时， 用 setTag()方法为每个 View 绑定一个存放控件的 ViewHolder 对象。当 convertView 不为空，重复利用已经创建的 view 的时候，使用 getTag()方法获取绑定的 ViewHolder 对象，这样就避免了 findViewById 对控件的层层查询，而是快速定位到控件。</p>
<p>① 复用 ConvertView，使用历史的 view，提升效率 200% </p>
<p>② 自定义静态类 ViewHolder，减少 findViewById 的次数。提 升效率 50% </p>
<p>③ 异步加载数据，分页加载数据。 </p>
<p>④ 使用 WeakRefrence 引用 ImageView 对象</p>
<h3 id="2-当-ListView-数据集改变后，如何更新-ListView"><a href="#2-当-ListView-数据集改变后，如何更新-ListView" class="headerlink" title="2.当 ListView 数据集改变后，如何更新 ListView"></a>2.当 ListView 数据集改变后，如何更新 ListView</h3><p>使用该 ListView 的 adapter 的 notifyDataSetChanged()方法。 该方法会 使 ListView 重新绘制。</p>
<h3 id="3-ListView-如何实现分页加载（★★★★★）"><a href="#3-ListView-如何实现分页加载（★★★★★）" class="headerlink" title="3.ListView 如何实现分页加载（★★★★★）"></a>3.ListView 如何实现分页加载（★★★★★）</h3><p>① 设 置 ListView 的 滚 动 监 听 器 ： setOnScrollListener(new OnScrollListener{….}) 在监听器中有两个方法： 滚动状态发生变化的方法(onScrollStateChanged)和 listView 被滚动时调用的方法(onScroll)</p>
<p>② 在滚动状态发生改变的方法中，有三种状态： 手指按下移动的状态：SCROLL_STATE_TOUCH_SCROLL: // 触摸滑动 惯性滚动（滑翔（flgin）状态）：SCROLL_STATE_FLING: // 滑翔</p>
<p>静止状态： SCROLL_STATE_IDLE: // 静止 对不同的状态进行处理： 分批加载数据，只关心静止状态：关心最后一个可见的条目，如果最后一个 可见条目就是数据适配器（集合）里的最后一个，此时可加载更多的数据。在每 次加载的时候，计算出滚动的数量，当滚动的数量大于等于总数量的时候，可以 提示用户无更多数据了。</p>
<h3 id="4-ListView-可以显示多种类型的条目吗（★★）"><a href="#4-ListView-可以显示多种类型的条目吗（★★）" class="headerlink" title="4.ListView 可以显示多种类型的条目吗（★★）"></a>4.ListView 可以显示多种类型的条目吗（★★）</h3><p>这个当然可以的， ListView 显示的每个条目都是通过 baseAdapter 的 getView(int position, View convertView, ViewGroup parent)来展示的， 理 论上我们完全可以让每个条目都是不同类型的 view。</p>
<p>比如：从服务器拿回一个标识为 id=1,那么当 id=1 的时候，我们就加载类 型一的条目，当 id=2 的时候，加载类型二的条目。常见布局在资讯类客户端中 可以经常看到。</p>
<p>除 此 之 外 adapter 还 提 供 了 getViewTypeCount （ ） 和 getItemViewType(int position)两个方法。在 getView 方法中我们可以根据不 同的 viewtype 加载不同的布局文件。</p>
<h3 id="5-ListView-如何定位到指定位置"><a href="#5-ListView-如何定位到指定位置" class="headerlink" title="5.ListView 如何定位到指定位置"></a>5.ListView 如何定位到指定位置</h3><p>可以通过 ListView 提供的 lv.setSelection(listView.getPosition());方法。</p>
<h3 id="6-如何在-ScrollView-中如何嵌入-ListView（★★★★）"><a href="#6-如何在-ScrollView-中如何嵌入-ListView（★★★★）" class="headerlink" title="6.如何在 ScrollView 中如何嵌入 ListView（★★★★）"></a>6.如何在 ScrollView 中如何嵌入 ListView（★★★★）</h3><p>通常情况下我们不会在 ScrollView 中嵌套 ListView，但是如果面试官非让 我嵌套的话也是可以的。</p>
<p>在 ScrollView 添加一个 ListView 会导致 listview 控件显示不全，通常只会 显示一条，这是因为两个控件的滚动事件冲突导致。所以需要通过 listview 中的 item 数量去计算 listview 的显示高度，从而使其完整展示，如下提供一个方法 供大家参考。</p>
<p>lv = (ListView) findViewById(R.id.lv); adapter = new MyAdapter(); lv.setAdapter(adapter); setListViewHeightBasedOnChildren(lv); —————————————————public void setListViewHeightBasedOnChildren(ListView listView) { ListAdapter listAdapter = listView.getAdapter(); if (listAdapter == null) { return; } int totalHeight = 0; for (int i = 0; i &lt; listAdapter.getCount(); i++) { View listItem = listAdapter.getView(i, null, listView); listItem.measure(0, 0); totalHeight += listItem.getMeasuredHeight();</p>
<p>} ViewGroup.LayoutParams params = listView.getLayoutParams(); params.height = totalHeight + (listView.getDividerHeight() * (listAdapter.getCount() - 1)); params.height += 5;// if without this statement,the listview will be // little short listView.setLayoutParams(params); }</p>
<p>现阶段最好的处理的方式是： 自定义 ListView，重载 onMeasure()方法，设置 全部显示。</p>
<p>package com.meiya.ui;</p>
<p>import android.widget.ListView;</p>
<p>/** * * @Description: scrollview 中内嵌 listview 的简单实现 * * @File: ScrollViewWithListView.java * * * @Version */ public class ScrollViewWithListView extends ListView {</p>
<p>public ScrollViewWithListView(android.content.Context context, android.util.AttributeSet attrs) { super(context, attrs); }</p>
<p>/** * Integer.MAX_VALUE &gt;&gt; 2,如果不设置，系统默认设置是显示两条 */ public void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { int expandSpec = MeasureSpec.makeMeasureSpec(Integer.MAX_VALUE &gt;&gt; 2, MeasureSpec.AT_MOST); super.onMeasure(widthMeasureSpec, expandSpec);</p>
<p>}</p>
<p>}</p>
<h3 id="7-ListView-中如何优化图片（★★）"><a href="#7-ListView-中如何优化图片（★★）" class="headerlink" title="7.ListView 中如何优化图片（★★）"></a>7.ListView 中如何优化图片（★★）</h3><p>图片的优化策略比较多。</p>
<p>1、处理图片的方式： 如果 ListView 中自定义的 Item 中有涉及到大量图片的，一定要对图片进行 细心的处理，因为图片占的内存是 ListView 项中最头疼的，处理图片的方法大 致有以下几种： ①、不要直接拿路径就去循环 BitmapFactory.decodeFile;使用 Options 保 存图片大小、不要加载图片到内存去。 ②、对图片一定要经过边界压缩尤其是比较大的图片，如果你的图片是后台 服务器处理好的那就不需要了 ③、在 ListView 中取图片时也不要直接拿个路径去取图片， 而是以 WeakReference （ 使 用 WeakReference 代 替 强 引 用 。 比 如 可 以 使 用 WeakReference mContextRef）、SoftReference、WeakHashMap 等的来存 储图片信息。 ④、在 getView 中做图片转换时，产生的中间变量一定及时释放 2、异步加载图片基本思想： 1）、 先从内存缓存中获取图片显示（内存缓冲） 2）、获取不到的话从 SD 卡里获取（SD 卡缓冲） 3）、都获取不到的话从网络下载图片并保存到 SD 卡同时加入内存并显示 （视情况看是否要显示） 原理： 优化一：先从内存中加载，没有则开启线程从 SD 卡或网络中获取，这里注</p>
<p>意从 SD 卡获取图片是放在子线程里执行的，否则快速滑屏的话会不够流畅。 优化二：于此同时，在 adapter 里有个 busy 变量，表示 listview 是否处于 滑动状态，如果是滑动状态则仅从内存中获取图片，没有的话无需再开启线程去 外存或网络获取图片。</p>
<p>优化三：ImageLoader 里的线程使用了线程池，从而避免了过多线程频繁 创建和销毁，如果每次总是 new 一个线程去执行这是非常不可取的，好一点的 用的 AsyncTask 类，其实内部也是用到了线程池。在从网络获取图片时，先是 将其保存到 sd 卡，然后再加载到内存，这么做的好处是在加载到内存时可以做 个压缩处理，以减少图片所占内存。</p>
<h3 id="8-ListView-中图片错位的问题是如何产生的（★★★）"><a href="#8-ListView-中图片错位的问题是如何产生的（★★★）" class="headerlink" title="8.ListView 中图片错位的问题是如何产生的（★★★）"></a>8.ListView 中图片错位的问题是如何产生的（★★★）</h3><p>图片错位问题的本质源于我们的 listview 使用了缓存 convertView，假设一 种场景，一个 listview 一屏显示九个 item，那么在拉出第十个 item 的时候，事 实上该 item 是重复使用了第一个 item，也就是说在第一个 item 从网络中下载 图片并最终要显示的时候，其实该 item 已经不在当前显示区域内了，此时显示 的后果将可能在第十个 item 上输出图像，这就导致了图片错位的问题。所以解 决之道在于可见则显示，不可见则不显示。</p>
<h3 id="10-如何刷新-ListView-中单个-item-的数据，-不刷新整个-ListView-的数据？"><a href="#10-如何刷新-ListView-中单个-item-的数据，-不刷新整个-ListView-的数据？" class="headerlink" title="10.如何刷新 ListView 中单个 item 的数据， 不刷新整个 ListView 的数据？"></a>10.如何刷新 ListView 中单个 item 的数据， 不刷新整个 ListView 的数据？</h3><p>修改单个 Item 的数据,然后调用适配器的 notifyDataSetChanged()方法</p>
<h2 id="六、Intent"><a href="#六、Intent" class="headerlink" title="六、Intent"></a>六、Intent</h2><h3 id="1-Intent-传递数据时，可以传递哪些类型数据？"><a href="#1-Intent-传递数据时，可以传递哪些类型数据？" class="headerlink" title="1.Intent 传递数据时，可以传递哪些类型数据？"></a>1.Intent 传递数据时，可以传递哪些类型数据？</h3><p>Intent 可以传递，java 的基本数据类型和 String 以 及他 们的 数组 形 式 都可 以 ， 除 此 之外还 可 以 传 递 实现 了 Serializable 和 Parcelable 接口的对象。通过 intent 发送数据时，应小心地将数据大小限制为几 KB。发送过多数据会导致系统抛出 <code>TransactionTooLargeException</code> 异常</p>
<h3 id="2-Serializable-和-Parcelable-的区别（★★★）"><a href="#2-Serializable-和-Parcelable-的区别（★★★）" class="headerlink" title="2.Serializable 和 Parcelable 的区别（★★★）"></a>2.Serializable 和 Parcelable 的区别（★★★）</h3><p>在使用内存的时候， Parcelable 类比 Serializable 性能高， 所以推荐使用 Parcelable 类。</p>
<p>1．Serializable 在序列化的时候会产生大量的临时变量，从而引起频繁的 GC。</p>
<p>2．Parcelable 不能使用在要将数据存储在磁盘上的情况。尽管 Serializable 效率低点，但在这种情况下，还是建议你用 Serializable 。</p>
<p>实现：</p>
<p>1．Serializable 的实现，只需要继承 Serializable 即可。这只是给对象打了一个标记，系统会自动将其序列化。 2．Parcelabel 的实现，需要在类中添加一个静态成员变量 CREATOR，这 个变量需要继承 Parcelable.Creator 接口。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyParcelable</span> <span class="token keyword">implements</span> <span class="token class-name">Parcelable</span> <span class="token punctuation">{</span> 
  <span class="token keyword">private</span> <span class="token keyword">int</span> mData<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">describeContents</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">writeToParcel</span><span class="token punctuation">(</span>Parcel out<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
      out<span class="token punctuation">.</span><span class="token function">writeInt</span><span class="token punctuation">(</span>mData<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Parcelable<span class="token punctuation">.</span>Creator<span class="token operator">&lt;</span>MyParcelable<span class="token operator">></span> CREATOR <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parcelable<span class="token punctuation">.</span>Creator</span><span class="token operator">&lt;</span>MyParcelable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
  <span class="token keyword">public</span> MyParcelable <span class="token function">createFromParcel</span><span class="token punctuation">(</span>Parcel in<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">MyParcelable</span><span class="token punctuation">(</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

    <span class="token keyword">public</span> MyParcelable<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">newArray</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
      <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">MyParcelable</span><span class="token punctuation">[</span>size<span class="token punctuation">]</span><span class="token punctuation">;</span> 
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token function">MyParcelable</span><span class="token punctuation">(</span>Parcel in<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
      mData <span class="token operator">=</span> in<span class="token punctuation">.</span><span class="token function">readInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<blockquote>
<p>注意：<code>Parcel</code> 不是通用序列化机制，您绝不能将任何 <code>Parcel</code> 数据存储在磁盘上或通过网络发送。</p>
</blockquote>
<h3 id="3-请描述一下-Intent-和-IntentFilter（★★★）"><a href="#3-请描述一下-Intent-和-IntentFilter（★★★）" class="headerlink" title="3.请描述一下 Intent 和 IntentFilter（★★★）"></a>3.请描述一下 Intent 和 IntentFilter（★★★）</h3><p><code>Intent</code> 是一个消息传递对象，您可以用来从其他<a href="https://developer.android.google.cn/guide/components/fundamentals#Components" target="_blank" rel="noopener">应用组件</a>请求操作</p>
<p>​        Android 中通过 Intent 对象来表示一条消息，一个 Intent 对象不仅包含有这个消息的目的地，还可以包含消息的内容，这好比一封 Email，其中不仅应 该包含收件地址，还可以包含具体的内容。对于一个 Intent 对象，消息“目的 地”是必须的，而内容则是可选项。 通过 Intent 可以实现各种系统组件的调用与激活.</p>
<p>​        IntentFilter: 可以理解为邮局或者是一个信笺的分拣系统… 这个分拣系统通过 3 个参数来识别 </p>
<p><code>Action</code>: 动作 view </p>
<p><code>Data</code>: 数据 uri uri </p>
<p><code>Category</code> : 额外的附加信息 </p>
<h5 id="Action-匹配"><a href="#Action-匹配" class="headerlink" title="Action 匹配"></a>Action 匹配</h5><p>​        Action 是一个用户定义的字符串，用于描述一个 Android 应用程序组件， 一 个 <code>IntentFilter</code> 可 以 包 含 多 个 Action 。 在 <code>AndroidManifest.xml</code> 的 <code>Activity</code> 定义时可以在其 <intent-filter>节点指定一个 Action 列表用于标 示 Activity 所能接受的“动作”，例如： </p>
<pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>intent-filter</span> <span class="token punctuation">></span></span> 
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>action</span> <span class="token attr-name"><span class="token namespace">android:</span>name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>android.intent.action.MAIN<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span> 
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>action</span> <span class="token attr-name"><span class="token namespace">android:</span>name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>cn.itheima.action<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>
  ……
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>intent-filter</span><span class="token punctuation">></span></span> </code></pre>
<p>如果我们在启动一个 Activity 时使用这样的 Intent 对象：</p>
<pre><code>Intent intent =new Intent();
intent.setAction(&quot;cn.itheima.action&quot;); </code></pre><p>那么所有的 Action 列表中包含了“cn.itheima”的 Activity 都将会匹配 成功。 Android 预定义了一系列的 Action 分别表示特定的系统动作。 这些 Action 通过常量的方式定义在 <code>android.content. Intent</code> 中，以“ACTION_” 开头。我们可以在 Android 提供的文档中找到它们的详细说明。 </p>
<h5 id="URI-数据匹配"><a href="#URI-数据匹配" class="headerlink" title="URI 数据匹配"></a>URI 数据匹配</h5><p>一个 Intent 可以通过 URI 携带外部数据给目标组件。在 <intent-filter > 节点中，通过 <data/>节点匹配外部数据。 mimeType 属性指定携带外部数据的数据类型，scheme 指定协议，host、 port、path 指定数据的位置、端口、和路径。如下： </p>
<pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>data</span> <span class="token attr-name"><span class="token namespace">android:</span>mimeType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mimeType<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">android:</span>scheme</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>scheme<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">android:</span>host</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>host<span class="token punctuation">"</span></span>       
      <span class="token attr-name"><span class="token namespace">android:</span>port</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>port<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">android:</span>path</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>path<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span></code></pre>
<p> 电话的 uri tel: 12345 </p>
<p><a href="http://www.baidu.com" target="_blank" rel="noopener">http://www.baidu.com</a> </p>
<p>自己定义的 uri itcast://cn.itcast/person/10 </p>
<p>如果在 Intent Filter 中指定了这些属性，那么只有所有的属性都匹配成功 时 URI 数据匹配才会成功。</p>
<h5 id="Category-类别匹配"><a href="#Category-类别匹配" class="headerlink" title="Category 类别匹配"></a>Category 类别匹配</h5><p>​        <intent-filter>节点中可以为组件定义一个 <code>Category</code> 类别列表， 当 Intent 中包含这个列表的所有项目时 <code>Category</code> 类别匹配才会成功。</p>
<h3 id="4-intent-的意义"><a href="#4-intent-的意义" class="headerlink" title="4.intent 的意义"></a>4.intent 的意义</h3><p>保证了组件之间的通信，在组件之间传递了数据。</p>
<h2 id="七、Fragment"><a href="#七、Fragment" class="headerlink" title="七、Fragment"></a>七、Fragment</h2><h3 id="1-Fragment-跟-Activity-之间是如何传值的"><a href="#1-Fragment-跟-Activity-之间是如何传值的" class="headerlink" title="1.Fragment 跟 Activity 之间是如何传值的"></a>1.Fragment 跟 Activity 之间是如何传值的</h3><p>当 Fragment 跟 Activity 绑 定 之 后 ， 在 Fragment 中 可 以 直 接 通 过 getActivity（）方法获取到其绑定的 Activity 对象， 这样就可以调用 Activity 的方法了。在 Activity 中可以通过如下方法获取到 Fragment 实例</p>
<p>FragmentManager fragmentManager = getFragmentManager(); Fragment fragment = fragmentManager.findFragmentByTag(tag); Fragment fragment = fragmentManager.findFragmentById(id);</p>
<p>获取到 Fragment 之后就可以调用 Fragment 的方法。也就实现了通信功能。</p>
<h3 id="2-描述一下-Fragment-的生命周期"><a href="#2-描述一下-Fragment-的生命周期" class="headerlink" title="2.描述一下 Fragment 的生命周期"></a>2.描述一下 Fragment 的生命周期</h3><h3 id="3-Fragment-的-replace-和-add-方法的区别"><a href="#3-Fragment-的-replace-和-add-方法的区别" class="headerlink" title="3.Fragment 的 replace 和 add 方法的区别"></a>3.Fragment 的 replace 和 add 方法的区别</h3><p>Fragment 本 身 并 没 有 replace 和 add 方 法 ， 这 里 的 理 解 应 该 为 使 用</p>
<p>FragmentManager 的 replace 和 add 两种方法切换 Fragment 时有什么不同。 我 们 经 常 使 用 的 一 个 架 构 就 是 通 过 RadioGroup 切 换 Fragment ， 每 个 Fragment 就是一个功能模块。</p>
<p>case R.id.rb_1:</p>
<p>//</p>
<p>//</p>
<p>//</p>
<p>rb_1.setBackgroundColor(Color.RED); transaction.show(fragment1); transaction.replace(R.id.fl, fragment1, “Fragment1”); break; case R.id.rb_2:</p>
<p>rb_2.setBackgroundColor(Color.YELLOW); transaction.replace(R.id.fl, fragment2, “Fragment2”); transaction.show(fragment2); break; case R.id.rb_3:</p>
<p>rb_3.setBackgroundColor(Color.BLUE); transaction.replace(R.id.fl, fragment3, “Fragment3”); transaction.show(fragment3); break;</p>
<p>实现这个功能可以通过 replace 和 add 两种方法。 Fragment 的容器一个 FrameLayout，add 的时候是把所有的 Fragment 一层 一层的叠加到了 FrameLayout 上了， 而 replace 的话首先将该容器中的其他 Fragment 去除掉然后将当前 Fragment 添加到容器中。 一个 Fragment 容器中只能添加一个 Fragment 种类，如果多次添加则会报异 常，导致程序终止，而 replace 则无所谓，随便切换。 因为通过 add 的方法添加的 Fragment，每个 Fragment 只能添加一次，因此 如果要想达到切换效果需要通过 Fragment 的的hide 和 show 方法结合者使用。 将要显示的 show 出来，将其他 hide 起来。这个过程 Fragment 的生命周期没</p>
<p>有变化。 通 过 replace 切 换 Fragment ， 每 次 都 会 执 行 上 一 个 Fragment 的 onDestroyView，新 Fragment 的 onCreateView、onStart、onResume 方法。 基于以上不同的特点我们在使用的使用一定要结合着生命周期操作我们的视图 和数据。</p>
<h3 id="4-Fragment-如何实现类似-Activity-栈的压栈和出栈效果的？"><a href="#4-Fragment-如何实现类似-Activity-栈的压栈和出栈效果的？" class="headerlink" title="4.Fragment 如何实现类似 Activity 栈的压栈和出栈效果的？"></a>4.Fragment 如何实现类似 Activity 栈的压栈和出栈效果的？</h3><p>Fragment 的事物管理器内部维持了一个双向链表结构，该结构可以记录我 们每次 add 的 Fragment 和 replace 的 Fragment，然后当我们点击 back 按钮 的时候会自动帮我们实现退栈操作。</p>
<p>Add this transaction to the back stack. This means that the transaction will be remembered after it is com and will reverse its operation when later popped off the stack.</p>
<p>Parameters:</p>
<p>name An optional name for this back stack state, or null.</p>
<p>transaction.addToBackStack(“name”);</p>
<p>//实现源码 在 BackStackRecord 中 public FragmentTransaction addToBackStack(String name) {</p>
<p>if (!mAllowAddToBackStack) { throw new IllegalStateException( “This FragmentTransaction is not allowed to be added to th stack.”);</p>
<p>}</p>
<p>mAddToBackStack = true;</p>
<p>mName = name;</p>
<p>return this;</p>
<p>} //上面的源码仅仅做了一个标记</p>
<p>除此之外因为我们要使用 FragmentManger 用的是 FragmentActivity，因 此 FragmentActivity 的 onBackPress 方法必定重新覆写了。打开看一下，发现 确实如此。</p>
<p>/**</p>
<ul>
<li>Take care of popping the fragment back stack or finishing the activit * as appropriate.</li>
</ul>
<p>*/ public void onBackPressed() { if (!mFragments.popBackStackImmediate()) { finish(); } } //mFragments 的原型是 FragmentManagerImpl，看看这个方法都干嘛了</p>
<p>@Override</p>
<p>public boolean popBackStackImmediate() { checkStateLoss(); executePendingTransactions(); return popBackStackState(mActivity.mHandler, null, -1, 0); }</p>
<p>//看看 popBackStackState 方法都干了啥，其实通过名称也能大概了解 只给几个片段吧，代 了</p>
<p>while (index &gt;= 0) { //从后退栈中取出当前记录对象 BackStackRecord bss = mBackStack.get(index); if (name != null &amp;&amp; name.equals(bss.getName())) { break; } if (id &gt;= 0 &amp;&amp; id == bss.mIndex) { break; } index–;</p>
<p>}</p>
<h3 id="5-Fragment-在你们项目中的使用"><a href="#5-Fragment-在你们项目中的使用" class="headerlink" title="5.Fragment 在你们项目中的使用"></a>5.Fragment 在你们项目中的使用</h3><p>Fragment 是 android3.0 以后引入的的概念，做局部内容更新更方便，原</p>
<p>来为了到达这一点要把多个布局放到一个 activity 里面， 现在可以用多 Fragment 来代替，只有在需要的时候才加载 Fragment，提高性能。 Fragment 的好处： </p>
<p>（1）Fragment 可以使你能够将 activity 分离成多个可重用的组件，每个都有 它自己的生命周期和 UI。 （2）Fragment 可以轻松得创建动态灵活的 UI 设计，可以适应于不同的屏幕尺 寸。从手机到平板电脑。 </p>
<p>（3）Fragment 是一个独立的模块,紧紧地与 activity 绑定在一起。可以运行中 动态地移除、加入、交换等。 （4）Fragment 提供一个新的方式让你在不同的安卓设备上统一你的 UI。 （5）Fragment 解决 Activity 间的切换不流畅，轻量切换。 （6）Fragment 替代 TabActivity 做导航，性能更好。 （7）Fragment 在 4.2.版本中新增嵌套 fragment 使用方法，能够生成更好的 界面效果。</p>
<h3 id="6-如何切换-fragement-不重新实例化"><a href="#6-如何切换-fragement-不重新实例化" class="headerlink" title="6.如何切换 fragement,不重新实例化"></a>6.如何切换 fragement,不重新实例化</h3><p>翻看了 Android 官方 Doc，和一些组件的源代码，发现 replace()这个方法只是 在上一个 Fragment 不再需要时采用的简便方法.</p>
<p>正确的切换方式是 add()，切换时 hide()，add()另一个 Fragment；再次切换时， 只需 hide()当前，show()另一个。</p>
<p>这样就能做到多个 Fragment 切换不重新实例化：</p>
<p>public void switchContent(Fragment from, Fragment to) {</p>
<p>if (mContent != to) {</p>
<p>mContent = to;</p>
<p>FragmentTransaction transaction =mFragmentMan.beginTransaction().setCustomAnimations(android.R.anim.fad e_in, R.anim.slide_out);</p>
<p>if (!to.isAdded()) { // 先判断是否被 add 过 transaction.hide(from).add(R.id.content_frame, to).commit(); // 隐藏 当前的 fragment，add 下一个到 Activity 中</p>
<p>} else { transaction.hide(from).show(to).commit(); // 隐藏当前的 fragment，显示下一个 }</p>
<p>}</p>
<h2 id="UI"><a href="#UI" class="headerlink" title="UI"></a>UI</h2><p>setContentView的内部过程(字节跳动)</p>
<h3 id="一、View绘制及自定义View"><a href="#一、View绘制及自定义View" class="headerlink" title="一、View绘制及自定义View"></a>一、View绘制及自定义View</h3><h4 id="1-View的总体绘制过程："><a href="#1-View的总体绘制过程：" class="headerlink" title="1. View的总体绘制过程："></a><strong>1. View</strong>的总体绘制过程：</h4><p>①当Activity对象被创建完成，会将DecorView添加到Window中（显示），同时创建ViewRoot的实现对象ViewRootImpl与之关联。ViewRootImpl会调用performTraversals来进行View的绘制过程。</p>
<p>②经过测量measure,布局layout,绘制draw三个主要阶段才能完成一个View的绘制过程，分别是用于测量宽、高；确定在父容器中的位置；绘制在屏幕上三个过程。而measure方法会调用onMeasure函数，这其中又会调用子元素的measure函数，如此反复就能完成整个View树的遍历过程。其他两个流程也同样如此。</p>
<h5 id="1-1测量阶段"><a href="#1-1测量阶段" class="headerlink" title="1.1测量阶段"></a>1.1测量阶段</h5><p>在 View 的测量阶段会执行两个方法，measure() 和onMeasure()。</p>
<p><strong>measure()</strong> ： 调度方法，主要做一些前置和优化工作，并最终会调用 onMeasure() 方法执行实际的测量工作；</p>
<p><strong>onMeasure()</strong> ： 实际执行测量任务的方法，主要用与测量 View 尺寸和位置(宽高和左右上下)。在自定义 View 的 onMeasure() 方法中，View 根据自己的特性和父 View 给的参考的测量规格算出自己的期望尺寸(测量尺寸)，并通过 setMeasuredDimension() 方法告知父 View 自己的期望(想要的)尺寸。</p>
<blockquote>
<p><strong>注意：</strong><br> 多数情况下，这里的期望尺寸就是 View 的最终尺寸。不过最终 View 的期望尺寸和实际尺寸是不是一样还要看它的父 View 会不会同意。View 的父 View 最终会通过调用 View 的 layout() 方法告知 View 的实际尺寸，并且在 layout() 方法中 View 需要将这个实际尺寸保存下来，以便绘制阶段和触摸反馈阶段使用，</p>
</blockquote>
<h5 id="1-2布局阶段"><a href="#1-2布局阶段" class="headerlink" title="1.2布局阶段"></a>1.2布局阶段</h5><p>在 View 的布局阶段确定视图的位置，会执行两个方法layout()和onLayout().</p>
<ul>
<li><p><strong>layout(int l, int t, int r, int b)</strong> ： 四个参数，分别代表着左、上、右、下的坐标，当然这个坐标是相对于当前视图的父视图而言的。保存 View 的实际尺寸（测量出的高度和宽度）。调用 setFrame() 方法保存 View 的实际尺寸，调用 onSizeChanged() 通知开发者 View 的尺寸更改了，并最终会调用 onLayout() 方法让子 View 布局（如果有子 View 的话。因为自定义 View 中没有子 View，所以自定义 View 的 onLayout() 方法是一个空实现）；</p>
</li>
<li><p><strong>onLayout(boolean changed, int l, int t, int r, int b)</strong> ： View的这个方法是1个空方法，因为它没有子 View。ViewGroup中的onLayout()是一个抽象方法。如果是 ViewGroup 的话，在 onLayout() 方法中需要调用子 View 的 layout() 方法，将子 View 的实际尺寸传给它们，让子 View 保存自己的实际尺寸。因此，在自定义 View 中，不需重写此方法，在自定义 ViewGroup 中，需重写此方法。完成之后可以根据getTop,getBottom,getLeft,getRight来获得4个属性值，完成之后可以调用getWidth和getHeight来获取View实际的宽和高；</p>
</li>
</ul>
<h5 id="1-3绘制阶段"><a href="#1-3绘制阶段" class="headerlink" title="1.3绘制阶段"></a>1.3绘制阶段</h5><p>在 View 的绘制阶段就决定了View的显示，完成draw才能真正显示出来，会执行一个方法——draw()。</p>
<p>draw() 是绘制阶段的总调度方法，在其中会调用绘制背景的方法 drawBackground()、绘制主体的方法 onDraw()、绘制子 View 的方法 dispatchDraw() 和 绘制前景的方法 onDrawForeground()：</p>
<ul>
<li>draw()</li>
</ul>
<p><strong>draw()</strong> ： 绘制阶段的总调度方法，在其中会调用绘制背景的方法 drawBackground()、绘制主体的方法 onDraw()、绘制子 View 的方法 dispatchDraw() 和 绘制前景的方法 onDrawForeground()；</p>
<p><strong>drawBackground()</strong> ： 绘制背景的方法，不能重写，只能通过 xml 布局文件或者 setBackground() 来设置或修改背景；</p>
<p><strong>onDraw()</strong> ： 绘制 View 主体内容的方法，通常情况下，在自定义 View 的时候，只用实现该方法即可；</p>
<p><strong>dispatchDraw()</strong> ： 绘制子 View 的方法。同 onLayout() 方法一样，在自定义 View 中它是空实现，什么也不做。但在自定义 ViewGroup 中，它会调用 ViewGroup.drawChild() 方法，在 ViewGroup.drawChild() 方法中又会调用每一个子 View 的 View.draw() 让子 View 进行自我绘制；</p>
<p><strong>onDrawForeground()</strong> ： 绘制 View 前景的方法，也就是说，想要在主体内容之上绘制东西的时候就可以在该方法中实现。</p>
<blockquote>
<p><a href="https://juejin.im/post/5d6c8f7cf265da03d42fbe58#heading-15" target="_blank" rel="noopener">https://juejin.im/post/5d6c8f7cf265da03d42fbe58#heading-15</a></p>
</blockquote>
<h6 id="getMeasureWidth-和getWidth-的区别？"><a href="#getMeasureWidth-和getWidth-的区别？" class="headerlink" title="getMeasureWidth()和getWidth()的区别？"></a>getMeasureWidth()和getWidth()的区别？</h6><pre><code>- 首先getMeasureWidth()方法在measure()过程结束后就可以获取到了，而getWidth()方法要在layout()过程结束后才能获取到。</code></pre><ul>
<li>另外，getMeasureWidth()方法中的值是通过setMeasuredDimension()方法来进行设置的，而getWidth()方法中的值则是通过视图右边的坐标减去左边的坐标计算出来的。</li>
</ul>
<h4 id="2-自定义-View-步骤"><a href="#2-自定义-View-步骤" class="headerlink" title="2. 自定义 View 步骤"></a>2. 自定义 View 步骤</h4><ol>
<li>自定义属性的声明与获取；</li>
<li>重写测量阶段相关方法（onMeasure()）；</li>
<li>重写布局阶段相关方法（onLayout()（仅 ViewGroup 需要重写））；</li>
<li>重写绘制阶段相关方法（onDraw() 绘制主体、dispatchDraw() 绘制子 View 和 onDrawForeground() 绘制前景）；</li>
<li>onTouchEvent()；</li>
<li>onInterceptTouchEvent()（仅 ViewGroup 有此方法）；</li>
</ol>
<h4 id="3-View的刷新机制"><a href="#3-View的刷新机制" class="headerlink" title="3. View的刷新机制"></a>3. View的刷新机制</h4><h3 id="二、事件分发以及滑动冲突的解决"><a href="#二、事件分发以及滑动冲突的解决" class="headerlink" title="二、事件分发以及滑动冲突的解决"></a>二、事件分发以及滑动冲突的解决</h3><p>1、View<strong>的事件分发机制</strong></p>
<p>事件分发机制传递的就是MotionEvent，也就是点击事件，这个传递过程就是分发的过程。</p>
<p>（1）点击事件的传递规则</p>
<p>三大函数：</p>
<p><strong>public boolean dispatchTouchEvent(MotionEvent ev)</strong></p>
<p>这个函数用于进行事件的分发，如果这个时间能够传递给当前的View，那么这个方法一定会调用，返回的结果表示是否消耗当前事件，返回的结果受onInterceptTouchEvent和下级View的影响。</p>
<p><strong>public boolean onInterceptTouchEvent(MotionEvent ev)</strong></p>
<p>这个函数内部调用，用于判断是否拦截某个事件，如果当前View拦截了某个事件，那么同一事件序列中，此方法不会被再次调用。</p>
<p><strong>public boolean onTouchEvent(MotionEvent ev)</strong></p>
<p>在<strong>dispatchTouchEvent</strong>中调用，用于处理点击事件，其返回结果表示是否消耗当前事件，如果不消耗，那么同一事件序列中，当前View无法再接收到事件。</p>
<p> 伪代码：</p>
<p>public boolean dispatchTouchEvent(MotionEvent ev){</p>
<p>​    boolean consume = false;</p>
<p>​    if(<strong>onInterceptTouchEvent(ev)</strong>){</p>
<p>​       consume = <strong>onTouchEvent</strong>(ev);</p>
<p>} else {</p>
<p>​    consume = child. <strong>dispatchTouchEvent(ev);</strong></p>
<p>}</p>
<p>return consume;</p>
<p>}</p>
<p>通过上述伪代码，我们可以大致得出传递的规则：</p>
<p>（1）对于一个根ViewGroup来说，点击事件产生后，首先会传递给它自己，如果它的<strong>onInterceptTouchEvent</strong>返回true，那么就表示它要拦截当前事件，那么它的<strong>onTouchEvent</strong>函数就会被调用；如果返回false，那么就传递给子元素，直到事件被处理。</p>
<p>（2）当一个View需要进行事件处理时，如果它设置了OnTouchListener，那么它的onTouch方法就会被调用，<strong>这时事件如何处理还要看**</strong>onTouch<strong><strong>的返回值，如果返回false</strong></strong>，那么当前View<strong><strong>的onTouchEvent</strong></strong>就会被调用；如果返回true<strong><strong>，那么onTouchEvent</strong></strong>方法将不会调用！！！！！！。**由此可见，OnTouchListener的优先级高于onTouchEvent。在onTouchEvent方法中，如果当前设置有OnClickListener，那么它的onClick会被调用，其优先级最低，处于调用的末端。</p>
<p>（3）如果一个事件传递到View，如果此View的onTouchEvent返回false，就是不消耗事件，那么此View的父容器的onTouchEvent就会被调用，也就是说如果事件最终没有View处理，那么处理的人就是Activity，也就是责任链模式。</p>
<p> 一些结论：</p>
<p>（1）同一个事件序列指的是从手指接触屏幕开始，到手指离开屏幕的过程，也就是DOWN—MOVE…MOVE—UP，这是一个事件序列。</p>
<p>（2）同一个事件序列只能被同一个View所消耗，因为一旦一个View拦截了某个事件，那么同一序列内的所有事件都会直接交给他处理。但是要注意，如果事件在之前又被别人拦截，根本不交给它处理的情况也会发生——事件拦截。</p>
<p>（3）某个View一旦开始处理事件，如果它不消耗ACTION_DOWN事件（onTouchEvent返回了false），那么同一事件序列中的其他事件都不会再交给他处理，即父元素的onTouchEvent会被调用，交给父元素来处理（责任链模式）。</p>
<p>如果某个View不处理除了ACTION_DOWN之外的其他事件，那么这个点击事件就会消失，并且当前View可以持续接收到后续事件（无论你选择不选择处理），最终消失的会被Activity处理。</p>
<p>（4）ViewGroup的onInterceptTouchEvent方法默认返回false，即不拦截任何事件，而View没有onInterceptTouchEvent函数，即不能选择是否拦截，必须拦截，但可以不处理。</p>
<p>（5）View的onTouchEvent默认都会消耗事件，返回true，除非它是不可点击的。</p>
<p>（6）对于onTouch和onClick的总结</p>
<p><strong>规律（总结）：</strong></p>
<p>（1）首先没有设置OnClickListener的情况下，onTouch的返回值表示的就是View对点击事件是否消耗，如果在DOWN事件传递过来时返回false，那么剩下的MOVE直到UP的事件都不会被onTouch接收到；如果在DOWN事件返回true，那么剩下的直到UP的事件都会接受到，无论你之后的返回值。<br> （2）在同时设置了OnTouchListener与OnClickListener之后，情况就有些复杂了：<br> <strong>情况1**</strong>：<strong>如果onTouch在DOWN时返回了true，那么onTouch就和（1）一样收到剩下的所有事件，但onClick就不会被执行；<br> <strong>情况2</strong></strong>：**如果onTouch在DOWN时返回了false，与（1）不同的是，onTouch尽管在DOWN时返回了false，但之后的所有事件仍能接受到，并且onClick会在之后被调用。</p>
<p>public boolean dispatchTouchEvent(MotionEvent event){ </p>
<p>  … … </p>
<p>  if(onFilterTouchEventForSecurity(event)){ </p>
<p>​    ListenerInfo li = mListenerInfo; </p>
<p>​    if(li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED </p>
<p>​      &amp;&amp; li.mOnTouchListener.onTouch(this, event)) { //（1）onTouch调用</p>
<p>​      return true; </p>
<p>​    } </p>
<p>​    if(onTouchEvent(event)){ //（2）onTouchEvent调用</p>
<p>​      return true; </p>
<p>​    } </p>
<p>  } </p>
<p>  … … </p>
<p>  return false; </p>
<p>} </p>
<p>分析：</p>
<p>（1）如果没有设置OnClickListener，只设置了OnTouchListener，那么在代码（1）处就会调用onTouch，如果DOWN事件时返回了true，那么剩下的事件都会交由此View进行处理；如果返回了false，那么就会执行代码（2）处的onTouchEvent函数，如果设置了OnClickListener，就会在其中进行调用，如果没有设置，dispatchTouchEvent就会返回false，那么剩下的事件都不会交由此View进行处理；<br> （2）如果同时设置了OnTouchListener与OnClickListener，那么我们再按上面的两种情况进行分析：<br> <strong>情况1**</strong>：<strong>onTouch在DOWN时返回了true，那么代码（1）处就得到了真的结果，直接就返回了true，可以知道后面代码（2）处的onTouchEvent函数不会被执行，那么自然你的OnClickListener就不起作用了，onClick就不会被执行； **<br>** <strong>情况2</strong></strong>：**onTouch在DOWN时返回了false，那么当DOWN事件传递来的时候，代码（1）处就不会得到真的结果，也就是说onTouch中你表示自己不会处理这个事件序列了，后面代码（2）处的onTouchEvent函数就会得到执行，而如果你设置了OnClickListener，View就会处于CLICKABLE状态，那么onTouchEvent函数就会返回true，又表示你可以处理这个点击事件序列了，dispatchTouchEvent就会返回true，那么这时后面的事件由于DOWN时返回true，就会统统交由此View进行处理，自然你的onTouch中也能够监听到后面的所有事件！这样上面的情况就能够得到解释了。</p>
<p><strong>二、滑动冲突的解决方法</strong></p>
<p>（1）滑动冲突的类型</p>
<p>滑动冲突分为三种类型，第一类是外部和内部滑动方向不一致，第二类是外部和内部滑动方向一致，第三类是前两种嵌套的模式。</p>
<p>处理这三种类型的规则分为两类，对于第一种类型，我们可以根据滑动方向来处理，符合处理方向的分配给对应的控件；对于2、3种类型，必须根据业务上的区别来处理，某种状态的处理时间分发给对应的控件来处理。</p>
<p>（2）滑动冲突的解决方式</p>
<p><strong>解决方式一：外部拦截法</strong></p>
<p>外部拦截法指点击事件首先都会经过父容器的拦截处理，父容器如果需要此事件就进行拦截，如果不需要此事件就不进行拦截，这样就可以解决滑动冲突问题。外部拦截法主要就是重写父容器的onInterceptTouchEvent方法，但是要注意，父容器拦截不能在ACTION_DOWN中返回true，否则之后的所有事件序列都会交给它处理，无论返回什么，因为不会再调用它的onInterceptTouchEvent函数了。所以父控件应该在ACTION_MOVE中选择是否拦截。但是这种拦截的问题是，如果拦截了，那么子控件的onClick事件将无法再出发了。</p>
<p>伪代码如下：</p>
<p>public boolean onInterceptTouchEvent(MotionEvent ev) {<br>   boolean intercepted = false;<br>   switch (ev.getAction()){<br>     case MotionEvent.<em>ACTION_DOWN</em>:<br>       intercepted = false;<br>       break;<br>     case MotionEvent.<em>ACTION_MOVE</em>:<br>       if(父控件需要处理){<br>         intercepted = true;<br>       } else{<br>         intercepted = false;<br>       }<br>       break;<br>     case MotionEvent.<em>ACTION_UP</em>:<br>       intercepted = false;<br>       break;<br>   }</p>
<p>   return intercepted;<br> }</p>
<p><strong>解决方法二：内部拦截法</strong></p>
<p>​    内部拦截法指的是父容器不拦截任何事件，所有事件全部传递给子元素，如果子元素需要就进行消耗，否则交由父容器进行处理。这种方式需要配合ViewGroup的FLAG_DISALLOW_INTERCEPT标志位来使用。设置此标志为可以通过requestDisallowIntercept TouchEvent函数来设置，如果设置了此标志位，那么ViewGroup就无法拦截除了ACTION_DOWN之外的任何事件。这样首先我们保证ViewGroup的onInterceptTouchEvent方法除了DOWN其他都返回true，DOWN返回false，这样保证了不会拦截DOWN事件，交给它的子View进行处理；重写View的dispatchTouchEvent函数，在DOWN中设置parent.requestDisallowInterceptTouchEvent(true)，这样父控件在默认的情况下DOWN之后的所有事件它都拦截不到，交由子View来处理，View在MOVE中判断父控件需要时，调用parent.requestDisallow InterceptTouchEvent(false)，这样父控件的拦截又起作用了，相应的事件交给了父控件进行处理。伪代码如下：</p>
<p><strong>父控件中：</strong></p>
<p>@Override<br> public boolean onInterceptTouchEvent(MotionEvent ev) {<br>   int action = ev.getAction();<br>   if(action == MotionEvent.<em>ACTION_DOWN</em>){<br>     return false;<br>   } else {<br>     return true;<br>   }<br> }</p>
<p><strong>子View**</strong>中：**</p>
<p>@Override<br> public boolean dispatchTouchEvent(MotionEvent ev) {</p>
<p>   switch (ev.getAction()){<br>     case MotionEvent.<em>ACTION_DOWN</em>:<br>       getParent().requestDisallowInterceptTouchEvent(true);<br>       break;<br>     case MotionEvent.<em>ACTION_MOVE</em>:<br>       if(父控件需要此点击事件){<br>         getParent().requestDisallowInterceptTouchEvent(false);<br>       }<br>       break;<br>     case MotionEvent.<em>ACTION_UP</em>:<br>       break;<br>   }<br> }</p>
<p><strong>滑动冲突处理案例：下拉刷新实现原理。</strong></p>
<h1 id="第二章-高频"><a href="#第二章-高频" class="headerlink" title="第二章 高频"></a>第二章 高频</h1><ul>
<li>handler</li>
<li>图片处理</li>
<li>网络httpclient okhttp  httpurlconnection</li>
<li>性能优化</li>
<li>内存泄露原因LeakCanary</li>
<li>四种引用</li>
<li>自定义View, 滑动冲突解决</li>
</ul>
<h2 id="Binder"><a href="#Binder" class="headerlink" title="Binder"></a>Binder</h2><p>1.Binder原理</p>
<p><img src=".%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B2%BE%E7%BC%96_images/image-20200513151345495.png" alt="image-20200513151345495"></p>
<p><img src=".%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B2%BE%E7%BC%96_images/image-20200513150605562.png" alt="image-20200513150605562"></p>
<ul>
<li>Binder通信采用C/S架构</li>
<li>service引用</li>
</ul>
<h5 id="为什么要使用Binder？"><a href="#为什么要使用Binder？" class="headerlink" title="为什么要使用Binder？"></a>为什么要使用Binder？</h5><ol>
<li><strong>管道：</strong>在创建时分配一个page大小的内存，缓存区大小比较有限；</li>
<li><strong>消息队列</strong>：信息复制两次，额外的CPU消耗；不合适频繁或信息量大的通信；</li>
<li><strong>共享内存</strong>：无须复制，共享缓冲区直接付附加到进程虚拟地址空间，速度快；但进程间的同步问题操作系统无法实现，必须各进程利用同步工具解决；</li>
<li><strong>套接字</strong>：作为更通用的接口，传输效率低，主要用于不通机器或跨网络的通信；</li>
</ol>
<p><strong>性能方面</strong></p>
<p>Binder数据拷贝只需要一次，而管道、消息队列、Socket都需要2次，共享内存方式一次内存拷贝都不需要，但实现方式又比较复杂。</p>
<p><strong>安全方面</strong></p>
<p>传统的进程通信方式对于通信双方的身份并没有做出严格的验证，</p>
<p>传统Linux IPC的接收方无法获得对方进程可靠的UID/PID，从而无法鉴别对方身份；而Android作为一个开放的开源体系，拥有非常多的开发平台，App来源甚广，因此手机的安全显得额外重要；对于普通用户，绝不希望从App商店下载偷窥隐射数据、后台造成手机耗电等等问题，传统Linux IPC无任何保护措施，完全由上层协议来确保。</p>
<p>而Binder机制从协议本身就支持对通信双方做身份校检，因而大大提升了安全性。</p>
<p>、</p>
<p>作者：Ruheng<br>链接：<a href="https://www.jianshu.com/p/4920c7781afe" target="_blank" rel="noopener">https://www.jianshu.com/p/4920c7781afe</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h2 id="图片处理"><a href="#图片处理" class="headerlink" title="图片处理"></a>图片处理</h2><h3 id="加载图片"><a href="#加载图片" class="headerlink" title="加载图片"></a>加载图片</h3><h4 id="1-如何加载一张图片"><a href="#1-如何加载一张图片" class="headerlink" title="1.如何加载一张图片"></a>1.如何加载一张图片</h4><p>BitmapFactory类提供了4类方法：<code>decodeFile</code>，<code>decodeResouce</code>，<code>decodeStream</code>，和<code>decodeByteArray</code>，分别用于支持从文件系统，资源，输入流以及字节数组中加载出一个<code>Bitmap</code>对象    ，其中<code>decodeFile</code>和<code>decodeResource</code>又间接调用了<code>decodeStream</code>方法，这四类方法最终是在<code>Android</code>底层实现的，对应<code>BitmapFactory</code>类的几个native方法</p>
<h4 id="2-ImageVIew是如何加载图片的"><a href="#2-ImageVIew是如何加载图片的" class="headerlink" title="2.ImageVIew是如何加载图片的"></a>2.ImageVIew是如何加载图片的</h4><ul>
<li><p>通过<code>BitmapFactory</code>的<code>decodeStream</code>生成Bitmap对象</p>
</li>
<li><p>再构造<code>BitmapDrawable</code>对象</p>
</li>
<li><p>再把这个<code>Drawable</code>设置给<code>ImageView</code></p>
</li>
<li><p>后续就是<code>ImageView</code>自己对Drawable进行缩放，绘制的逻辑，继而变成了一张显示在手机上的图片</p>
</li>
</ul>
<p>缩放比例：</p>
<p>图片所在文件夹：drawable（160dpi）、drawable-xhdpi（320dpi）、drawable-xxhdpi（480dpi）、drawable-xxxhdpi（720dpi）</p>
<p>你手机是480dpi的，图片放在drawable文件夹下，则比例 = 480/ 160 会放大3倍</p>
<h4 id="3-如何高效加载一张图片-压缩图片"><a href="#3-如何高效加载一张图片-压缩图片" class="headerlink" title="3.如何高效加载一张图片(压缩图片)"></a>3.如何高效加载一张图片(压缩图片)</h4><p>通过<code>BitmapFactory.Options</code>对图片进行采样缩放，主要用到了它的inSampleSize参数,及采样率。</p>
<ul>
<li>inSampleSize为&lt;=1，采用后的图片为原始大小</li>
<li>inSampleSize为4,缩小为原来的1/16</li>
<li>inSampleSize不为2的指数，系统会向下取整选择一个最接近的的指数来代替，比如3，系统会选择2，但并非所有Android版本都成立</li>
</ul>
<p>如何获取采用率?</p>
<p>(1)将<code>BitmapFactory.Options</code>的inJustDecodeBounds参数设置为true并加载图片</p>
<p>(2)从<code>BitmapFactory.Options</code>中取出图片的原始宽高信息，它们对应于outWidth和outHeight参数</p>
<p>(3)根据采样率的规则并结合目标View的所需大小计算出采样率inSampleSize</p>
<p>(4)将<code>BitmapFactory.Options</code>的inJustDecodeBounds参数设为false,然后重新加载图片</p>
<h3 id="4-利用矩阵放大Bitmap"><a href="#4-利用矩阵放大Bitmap" class="headerlink" title="4.利用矩阵放大Bitmap"></a>4.利用矩阵放大Bitmap</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> Bitmap <span class="token function">bitMapScale</span><span class="token punctuation">(</span>Bitmap bitmap<span class="token punctuation">,</span><span class="token keyword">float</span> scale<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Matrix matrix <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Matrix</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        matrix<span class="token punctuation">.</span><span class="token function">postScale</span><span class="token punctuation">(</span>scale<span class="token punctuation">,</span>scale<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//长和宽放大缩小的比例</span>
        Bitmap resizeBmp <span class="token operator">=</span> Bitmap<span class="token punctuation">.</span><span class="token function">createBitmap</span><span class="token punctuation">(</span>bitmap<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>bitmap<span class="token punctuation">.</span><span class="token function">getWidth</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>bitmap<span class="token punctuation">.</span><span class="token function">getHeight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>matrix<span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> resizeBmp<span class="token punctuation">;</span>
    <span class="token punctuation">}</span></code></pre>

            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">Bailitusu</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="http://blts.asia/blog/1027335175.html">http://blts.asia/blog/1027335175.html</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">Bailitusu</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            <span class="chip bg-color">无标签</span>
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="https://gzr-blog.oss-cn-shanghai.aliyuncs.com/uPic/1600304779621_2020-09-20_20:57:52.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="https://gzr-blog.oss-cn-shanghai.aliyuncs.com/uPic/mm_reward_qrcode_1600606512599_2020-09-20_20:56:56.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/blog/3424522753.html">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/4.jpg" class="responsive-img" alt="For Offer/Android/Android基础/Fragment">
                        
                        <span class="card-title">For Offer/Android/Android基础/Fragment</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2020-05-08
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            Bailitusu
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/blog/3431503302.html">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/0.jpg" class="responsive-img" alt="For Offer/Android/Untitled 1">
                        
                        <span class="card-title">For Offer/Android/Untitled 1</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2020-05-05
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            Bailitusu
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


<!-- 代码块折行 -->

<style type="text/css">
code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }
</style>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>

    
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            <span id="year">2020</span>
            <a href="/about" target="_blank">Bailitusu</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/234917515" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:234917515@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=234917515" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 234917515" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/search.xml", 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
    

</body>

</html>
